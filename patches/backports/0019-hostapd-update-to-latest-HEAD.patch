From 6e3370a4c785c2c245b77832960f1dbed2736192 Mon Sep 17 00:00:00 2001
From: John Crispin <john@phrozen.org>
Date: Sat, 4 Sep 2021 05:48:27 +0200
Subject: [PATCH 01/70] hostapd: update to latest HEAD

Signed-off-by: John Crispin <john@phrozen.org>
---
 package/network/services/hostapd/Makefile     |  15 +-
 .../hostapd/files/hostapd-basic.config        |   2 +-
 .../hostapd/files/hostapd-full.config         |   4 +-
 .../network/services/hostapd/files/hostapd.sh | 188 +++++++++---
 ...-fix-frequency-setup-with-HE-enabled.patch | 196 -------------
 ...> 001-wolfssl-init-RNG-with-ECC-key.patch} |  11 +-
 ...-init-order-disable-pri-sec-channel-.patch | 126 --------
 ...andle-HT40-and-mode-downgrade-in-AP-.patch | 102 -------
 ...ix-frequency-config-for-non-p2p-vht-.patch |  63 ----
 ...nable-vht-and-he-in-default-config-p.patch |  25 --
 ...er-debug-messages-for-some-error-cas.patch |  83 ------
 ...lper-functions-for-vht-he-parameters.patch |  27 --
 ...ompletion-callback-to-complete-mesh-.patch | 108 -------
 ...-frequency-as-pri-sec-channel-switch.patch |  26 --
 ...hannels-to-be-selected-if-dfs-is-ena.patch |  10 +-
 ...offchanok-on-DFS-channels-in-non-ETS.patch |  53 ----
 ...rministic-channel-on-channel-switch.patch} |   2 +-
 ...-fix-channel-switch-error-during-CAC.patch |  66 -----
 ...rnel-driver-DFS-handler-in-userspace.patch |  48 ---
 .../014-mesh-fixes-for-mesh-init-deinit.patch | 158 ----------
 .../015-mesh-fix-DFS-deinit-init.patch        | 262 -----------------
 ...sts-DFS-test-for-wpa_supplicant-mesh.patch |  94 ------
 .../patches/017-mesh-fix-mesh_oom-test.patch  |  24 --
 ...ve-mesh-freq-setting-to-own-function.patch |  93 ------
 ...020-ignore-4addr-mode-enabling-error.patch |  78 -----
 ...0-mesh-make-forwarding-configurable.patch} |  28 +-
 ...ix-sta-add-after-previous-connection.patch |  26 ++
 ...use-of-uninitialized-stack-variables.patch |  25 ++
 ...-dl_list_del-before-freeing-ipv6-add.patch |  19 ++
 ...ewrite-neigh-code-to-not-depend-on-l.patch | 275 ++++++++++++++++++
 ...-case-in-peer-addition-based-on-PD-R.patch |  45 ---
 .../patches/110-notify-mgmt-frames.patch      | 116 --------
 .../patches/110-wolfssl-compile-fix.patch     |  10 -
 .../120-reconfigure-wps-credentials.patch     | 178 ------------
 .../hostapd/patches/200-multicall.patch       |  80 ++---
 .../services/hostapd/patches/300-noscan.patch |   6 +-
 .../hostapd/patches/301-mesh-noscan.patch     |  10 +-
 .../patches/310-rescan_immediately.patch      |   2 +-
 .../hostapd/patches/320-optional_rfkill.patch |   8 +-
 .../patches/330-nl80211_fix_set_freq.patch    |   2 +-
 .../patches/340-reload_freq_change.patch      |   6 +-
 .../341-mesh-ctrl-iface-channel-switch.patch  |   2 +-
 .../patches/350-nl80211_del_beacon_bss.patch  |  12 +-
 .../patches/360-ctrl_iface_reload.patch       |  10 +-
 .../hostapd/patches/370-ap_sta_support.patch  |  67 ++---
 .../patches/380-disable_ctrl_iface_mib.patch  |  34 +--
 .../patches/390-wpa_ie_cap_workaround.patch   |   4 +-
 .../patches/420-indicate-features.patch       |   4 +-
 .../patches/430-hostapd_cli_ifdef.patch       |   4 +-
 ...dd-new-config-params-to-be-used-with.patch |   8 +-
 ...-use-new-parameters-during-ibss-join.patch |   4 +-
 .../patches/463-add-mcast_rate-to-11s.patch   |  10 +-
 .../patches/464-fix-mesh-obss-check.patch     |   2 +-
 .../patches/470-survey_data_fallback.patch    |   2 +-
 .../patches/500-lto-jobserver-support.patch   |  19 +-
 .../hostapd/patches/600-ubus_support.patch    | 166 ++++++++---
 .../hostapd/patches/700-wifi-reload.patch     |  51 ++--
 .../hostapd/patches/710-vlan_no_bridge.patch  |  41 +++
 .../patches/711-wds_bridge_force.patch        |  26 ++
 .../720-ACS-fix-channel-100-frequency.patch   |  30 ++
 .../patches/720-iface_max_num_sta.patch       |  82 ++++++
 .../hostapd/patches/730-ft_iface.patch        |  38 +++
 .../hostapd/patches/740-snoop_iface.patch     |  72 +++++
 ...ate-if-no-available-channel-is-found.patch |  37 ---
 ...of-secondary-device-types-for-P2P-gr.patch |  33 ---
 .../services/hostapd/src/src/ap/ubus.c        | 214 +++++++++++++-
 .../services/hostapd/src/src/ap/ubus.h        |  16 +
 .../hostapd/src/src/utils/build_features.h    |   2 -
 68 files changed, 1343 insertions(+), 2347 deletions(-)
 delete mode 100644 package/network/services/hostapd/patches/001-HE-VHT-fix-frequency-setup-with-HE-enabled.patch
 rename package/network/services/hostapd/patches/{802-wolfssl-init-RNG-with-ECC-key.patch => 001-wolfssl-init-RNG-with-ECC-key.patch} (76%)
 delete mode 100644 package/network/services/hostapd/patches/002-mesh-fix-channel-init-order-disable-pri-sec-channel-.patch
 delete mode 100644 package/network/services/hostapd/patches/003-wpa_supplicant-handle-HT40-and-mode-downgrade-in-AP-.patch
 delete mode 100644 package/network/services/hostapd/patches/004-wpa_supplicant-fix-frequency-config-for-non-p2p-vht-.patch
 delete mode 100644 package/network/services/hostapd/patches/005-wpa_supplicant-enable-vht-and-he-in-default-config-p.patch
 delete mode 100644 package/network/services/hostapd/patches/006-hw_features-better-debug-messages-for-some-error-cas.patch
 delete mode 100644 package/network/services/hostapd/patches/007-dfs-use-helper-functions-for-vht-he-parameters.patch
 delete mode 100644 package/network/services/hostapd/patches/008-mesh-use-setup-completion-callback-to-complete-mesh-.patch
 delete mode 100644 package/network/services/hostapd/patches/009-mesh-update-ssid-frequency-as-pri-sec-channel-switch.patch
 delete mode 100644 package/network/services/hostapd/patches/011-mesh-do-not-set-offchanok-on-DFS-channels-in-non-ETS.patch
 rename package/network/services/hostapd/patches/{019-mesh-use-deterministic-channel-on-channel-switch.patch => 011-mesh-use-deterministic-channel-on-channel-switch.patch} (97%)
 delete mode 100644 package/network/services/hostapd/patches/012-mesh-fix-channel-switch-error-during-CAC.patch
 delete mode 100644 package/network/services/hostapd/patches/013-mesh-inform-kernel-driver-DFS-handler-in-userspace.patch
 delete mode 100644 package/network/services/hostapd/patches/014-mesh-fixes-for-mesh-init-deinit.patch
 delete mode 100644 package/network/services/hostapd/patches/015-mesh-fix-DFS-deinit-init.patch
 delete mode 100644 package/network/services/hostapd/patches/016-tests-DFS-test-for-wpa_supplicant-mesh.patch
 delete mode 100644 package/network/services/hostapd/patches/017-mesh-fix-mesh_oom-test.patch
 delete mode 100644 package/network/services/hostapd/patches/018-mesh-move-mesh-freq-setting-to-own-function.patch
 delete mode 100644 package/network/services/hostapd/patches/020-ignore-4addr-mode-enabling-error.patch
 rename package/network/services/hostapd/patches/{050-mesh-make-forwarding-configurable.patch => 020-mesh-make-forwarding-configurable.patch} (89%)
 create mode 100644 package/network/services/hostapd/patches/021-fix-sta-add-after-previous-connection.patch
 create mode 100644 package/network/services/hostapd/patches/022-hostapd-fix-use-of-uninitialized-stack-variables.patch
 create mode 100644 package/network/services/hostapd/patches/023-ndisc_snoop-call-dl_list_del-before-freeing-ipv6-add.patch
 create mode 100644 package/network/services/hostapd/patches/030-driver_nl80211-rewrite-neigh-code-to-not-depend-on-l.patch
 delete mode 100644 package/network/services/hostapd/patches/060-P2P-Fix-a-corner-case-in-peer-addition-based-on-PD-R.patch
 delete mode 100644 package/network/services/hostapd/patches/110-notify-mgmt-frames.patch
 delete mode 100644 package/network/services/hostapd/patches/110-wolfssl-compile-fix.patch
 delete mode 100644 package/network/services/hostapd/patches/120-reconfigure-wps-credentials.patch
 create mode 100644 package/network/services/hostapd/patches/710-vlan_no_bridge.patch
 create mode 100644 package/network/services/hostapd/patches/711-wds_bridge_force.patch
 create mode 100644 package/network/services/hostapd/patches/720-ACS-fix-channel-100-frequency.patch
 create mode 100644 package/network/services/hostapd/patches/720-iface_max_num_sta.patch
 create mode 100644 package/network/services/hostapd/patches/730-ft_iface.patch
 create mode 100644 package/network/services/hostapd/patches/740-snoop_iface.patch
 delete mode 100644 package/network/services/hostapd/patches/800-dfs-enter-DFS-state-if-no-available-channel-is-found.patch
 delete mode 100644 package/network/services/hostapd/patches/801-P2P-Fix-copying-of-secondary-device-types-for-P2P-gr.patch

diff --git a/package/network/services/hostapd/Makefile b/package/network/services/hostapd/Makefile
index 67ea89c339..fee6889b40 100644
--- a/package/network/services/hostapd/Makefile
+++ b/package/network/services/hostapd/Makefile
@@ -1,19 +1,17 @@
-# Copyright (C) 2006-2014 OpenWrt.org
-#
-# This is free software, licensed under the GNU General Public License v2.
-# See /LICENSE for more information.
+# SPDX-License-Identifier: GPL-2.0-only
 #
+# Copyright (C) 2006-2021 OpenWrt.org
 
 include $(TOPDIR)/rules.mk
 
 PKG_NAME:=hostapd
-PKG_RELEASE:=35
+PKG_RELEASE:=$(AUTORELEASE)
 
 PKG_SOURCE_URL:=http://w1.fi/hostap.git
 PKG_SOURCE_PROTO:=git
-PKG_SOURCE_DATE:=2020-06-08
-PKG_SOURCE_VERSION:=5a8b366233f5585e68a4ffbb604fbb4a848eb325
-PKG_MIRROR_HASH:=1b2a4947034142587a3f81eac2ea27dd64650e77f8943d973623b47533be2393
+PKG_SOURCE_DATE:=2021-05-22
+PKG_SOURCE_VERSION:=b102f19bcc53c7f7db3951424d4d46709b4f1986
+PKG_MIRROR_HASH:=cb3cb968883042fc582752be1607586696c18e6ecf9808c9a8ac50e204584367
 
 PKG_MAINTAINER:=Felix Fietkau <nbd@nbd.name>
 PKG_LICENSE:=BSD-3-Clause
@@ -524,6 +522,7 @@ define Build/RunMake
 		LIBS_c="$(TARGET_LDFLAGS_C)" \
 		AR="$(TARGET_CROSS)gcc-ar" \
 		BCHECK= \
+		$(if $(findstring s,$(OPENWRT_VERBOSE)),V=1) \
 		$(2)
 endef
 
diff --git a/package/network/services/hostapd/files/hostapd-basic.config b/package/network/services/hostapd/files/hostapd-basic.config
index 947e2fa200..33c38192b1 100644
--- a/package/network/services/hostapd/files/hostapd-basic.config
+++ b/package/network/services/hostapd/files/hostapd-basic.config
@@ -384,7 +384,7 @@ CONFIG_TLS=internal
 #CONFIG_OWE=y
 
 # Airtime policy support
-#CONFIG_AIRTIME_POLICY=y
+CONFIG_AIRTIME_POLICY=y
 
 # Override default value for the wpa_disable_eapol_key_retries configuration
 # parameter. See that parameter in hostapd.conf for more details.
diff --git a/package/network/services/hostapd/files/hostapd-full.config b/package/network/services/hostapd/files/hostapd-full.config
index df272e443a..61b6daf861 100644
--- a/package/network/services/hostapd/files/hostapd-full.config
+++ b/package/network/services/hostapd/files/hostapd-full.config
@@ -94,10 +94,10 @@ CONFIG_EAP_TTLS=y
 #CONFIG_EAP_PAX=y
 
 # EAP-PSK for the integrated EAP server (this is _not_ needed for WPA-PSK)
-#CONFIG_EAP_PSK=y
+CONFIG_EAP_PSK=y
 
 # EAP-pwd for the integrated EAP server (secure authentication with a password)
-#CONFIG_EAP_PWD=y
+CONFIG_EAP_PWD=y
 
 # EAP-SAKE for the integrated EAP server
 #CONFIG_EAP_SAKE=y
diff --git a/package/network/services/hostapd/files/hostapd.sh b/package/network/services/hostapd/files/hostapd.sh
index aa72e09eba..fe6af98f4d 100644
--- a/package/network/services/hostapd/files/hostapd.sh
+++ b/package/network/services/hostapd/files/hostapd.sh
@@ -48,13 +48,17 @@ hostapd_append_wpa_key_mgmt() {
 		;;
 		eap192)
 			append wpa_key_mgmt "WPA-EAP-SUITE-B-192"
+			append wpa_key_mgmt "WPA-EAP-SHA256"
 			[ "${ieee80211r:-0}" -gt 0 ] && append wpa_key_mgmt "FT-EAP"
 		;;
-		eap-eap192)
-			append wpa_key_mgmt "WPA-EAP-SUITE-B-192"
+		eap-eap256)
 			append wpa_key_mgmt "WPA-EAP"
+			append wpa_key_mgmt "WPA-EAP-SHA256"
+			[ "${ieee80211r:-0}" -gt 0 ] && append wpa_key_mgmt "FT-EAP"
+		;;
+		eap256)
+			append wpa_key_mgmt "WPA-EAP-SHA256"
 			[ "${ieee80211r:-0}" -gt 0 ] && append wpa_key_mgmt "FT-EAP"
-			[ "${ieee80211w:-0}" -gt 0 ] && append wpa_key_mgmt "WPA-EAP-SHA256"
 		;;
 		sae)
 			append wpa_key_mgmt "SAE"
@@ -91,6 +95,7 @@ hostapd_add_log_config() {
 hostapd_common_add_device_config() {
 	config_add_array basic_rate
 	config_add_array supported_rates
+	config_add_string beacon_rate
 
 	config_add_string country country3
 	config_add_boolean country_ie doth
@@ -99,6 +104,10 @@ hostapd_common_add_device_config() {
 	config_add_string require_mode
 	config_add_boolean legacy_rates
 	config_add_int cell_density
+	config_add_int rts_threshold
+	config_add_int rssi_reject_assoc_rssi
+	config_add_int rssi_ignore_probe_request
+	config_add_int maxassoc
 
 	config_add_string acs_chan_bias
 	config_add_array hostapd_options
@@ -115,7 +124,8 @@ hostapd_prepare_device_config() {
 	local base_cfg=
 
 	json_get_vars country country3 country_ie beacon_int:100 dtim_period:2 doth require_mode legacy_rates \
-		acs_chan_bias local_pwr_constraint spectrum_mgmt_required airtime_mode cell_density
+		acs_chan_bias local_pwr_constraint spectrum_mgmt_required airtime_mode cell_density \
+		rts_threshold beacon_rate rssi_reject_assoc_rssi rssi_ignore_probe_request maxassoc
 
 	hostapd_set_log_options base_cfg
 
@@ -207,11 +217,16 @@ hostapd_prepare_device_config() {
 		hostapd_add_rate brlist "$br"
 	done
 
+	[ -n "$rssi_reject_assoc_rssi" ] && append base_cfg "rssi_reject_assoc_rssi=$rssi_reject_assoc_rssi" "$N"
+	[ -n "$rssi_ignore_probe_request" ] && append base_cfg "rssi_ignore_probe_request=$rssi_ignore_probe_request" "$N"
+	[ -n "$beacon_rate" ] && append base_cfg "beacon_rate=$beacon_rate" "$N"
 	[ -n "$rlist" ] && append base_cfg "supported_rates=$rlist" "$N"
 	[ -n "$brlist" ] && append base_cfg "basic_rates=$brlist" "$N"
 	append base_cfg "beacon_int=$beacon_int" "$N"
+	[ -n "$rts_threshold" ] && append base_cfg "rts_threshold=$rts_threshold" "$N"
 	append base_cfg "dtim_period=$dtim_period" "$N"
 	[ "$airtime_mode" -gt 0 ] && append base_cfg "airtime_mode=$airtime_mode" "$N"
+	[ -n "$maxassoc" ] && append base_cfg "iface_max_num_sta=$maxassoc" "$N"
 
 	json_get_values opts hostapd_options
 	for val in $opts; do
@@ -269,7 +284,7 @@ hostapd_common_add_bss_config() {
 	config_add_array domain_match domain_match2 domain_suffix_match domain_suffix_match2
 	config_add_string ieee80211w_mgmt_cipher
 
-	config_add_int dynamic_vlan vlan_naming
+	config_add_int dynamic_vlan vlan_naming vlan_no_bridge
 	config_add_string vlan_tagged_interface vlan_bridge
 	config_add_string vlan_file
 
@@ -287,6 +302,7 @@ hostapd_common_add_bss_config() {
 	config_add_boolean wnm_sleep_mode wnm_sleep_mode_no_keys bss_transition
 	config_add_int time_advertisement
 	config_add_string time_zone
+	config_add_string vendor_elements
 
 	config_add_boolean ieee80211k rrm_neighbor_report rrm_beacon_report
 
@@ -311,6 +327,7 @@ hostapd_common_add_bss_config() {
 	config_add_array supported_rates
 
 	config_add_boolean sae_require_mfp
+	config_add_int sae_pwe
 
 	config_add_string 'owe_transition_bssid:macaddr' 'owe_transition_ssid:string'
 
@@ -319,23 +336,35 @@ hostapd_common_add_bss_config() {
 	config_add_int iw_ipaddr_type_availability iw_gas_address3
 	config_add_string iw_hessid iw_network_auth_type iw_qos_map_set
 	config_add_array iw_roaming_consortium iw_domain_name iw_anqp_3gpp_cell_net iw_nai_realm
-	config_add_array iw_anqp_elem
+	config_add_array iw_anqp_elem iw_venue_name iw_venue_url
 
 	config_add_boolean hs20 disable_dgaf osen
 	config_add_int anqp_domain_id
-	config_add_int hs20_deauth_req_timeout
+	config_add_int hs20_deauth_req_timeout hs20_release
 	config_add_array hs20_oper_friendly_name
 	config_add_array osu_provider
 	config_add_array operator_icon
 	config_add_array hs20_conn_capab
 	config_add_string osu_ssid hs20_wan_metrics hs20_operating_class hs20_t_c_filename hs20_t_c_timestamp
 
+	config_add_string hs20_t_c_server_url
+
 	config_add_array airtime_sta_weight
 	config_add_int airtime_bss_weight airtime_bss_limit
 
-	config_add_boolean multicast_to_unicast per_sta_vif
+	config_add_boolean multicast_to_unicast proxy_arp per_sta_vif
 
 	config_add_array hostapd_bss_options
+	config_add_boolean default_disabled
+
+	config_add_boolean request_cui
+	config_add_array radius_auth_req_attr
+	config_add_array radius_acct_req_attr
+
+	config_add_int eap_server
+	config_add_string eap_user_file ca_cert server_cert private_key private_key_passwd server_id
+	
+	config_add_boolean ratelimit
 }
 
 hostapd_set_vlan_file() {
@@ -387,7 +416,7 @@ append_iw_anqp_3gpp_cell_net() {
 	if [ -z "$iw_anqp_3gpp_cell_net_conf" ]; then
 		iw_anqp_3gpp_cell_net_conf="$1"
 	else
-		iw_anqp_3gpp_cell_net_conf="$iw_anqp_3gpp_cell_net_conf:$1"
+		iw_anqp_3gpp_cell_net_conf="$iw_anqp_3gpp_cell_net_conf;$1"
 	fi
 }
 
@@ -399,10 +428,22 @@ append_iw_nai_realm() {
 	[ -n "$1" ] && append bss_conf "nai_realm=$1" "$N"
 }
 
+append_iw_venue_name() {
+	append bss_conf "venue_name=$1" "$N"
+}
+
+append_iw_venue_url() {
+	append bss_conf "venue_url=$1" "$N"
+}
+
 append_hs20_oper_friendly_name() {
 	append bss_conf "hs20_oper_friendly_name=$1" "$N"
 }
 
+append_osu_provider_friendly_name() {
+	append bss_conf "osu_friendly_name=$1" "$N"
+}
+
 append_osu_provider_service_desc() {
 	append bss_conf "osu_service_desc=$1" "$N"
 }
@@ -450,6 +491,7 @@ append_osu_provider() {
 	append bss_conf "osu_method_list=$osu_method_list" "$N"
 
 	config_list_foreach "$1" osu_service_desc append_osu_provider_service_desc
+	config_list_foreach "$1" osu_friendly_name append_osu_friendly_name
 	config_list_foreach "$1" osu_icon append_osu_icon
 
 	append bss_conf "$N"
@@ -459,6 +501,14 @@ append_hs20_conn_capab() {
 	[ -n "$1" ] && append bss_conf "hs20_conn_capab=$1" "$N"
 }
 
+append_radius_acct_req_attr() {
+	[ -n "$1" ] && append bss_conf "radius_acct_req_attr=$1" "$N"
+}
+
+append_radius_auth_req_attr() {
+	[ -n "$1" ] && append bss_conf "radius_auth_req_attr=$1" "$N"
+}
+
 append_airtime_sta_weight() {
 	[ -n "$1" ] && append bss_conf "airtime_sta_weight=$1" "$N"
 }
@@ -482,10 +532,12 @@ hostapd_set_bss_options() {
 		macfilter ssid utf8_ssid wmm uapsd hidden short_preamble rsn_preauth \
 		iapp_interface eapol_version dynamic_vlan ieee80211w nasid \
 		acct_server acct_secret acct_port acct_interval \
-		bss_load_update_period chan_util_avg_period sae_require_mfp \
+		bss_load_update_period chan_util_avg_period sae_require_mfp sae_pwe \
 		multi_ap multi_ap_backhaul_ssid multi_ap_backhaul_key skip_inactivity_poll \
 		airtime_bss_weight airtime_bss_limit airtime_sta_weight \
-		multicast_to_unicast per_sta_vif
+		multicast_to_unicast proxy_arp per_sta_vif \
+		eap_server eap_user_file ca_cert server_cert private_key private_key_passwd server_id \
+		vendor_elements
 
 	set_default isolate 0
 	set_default maxassoc 0
@@ -506,6 +558,7 @@ hostapd_set_bss_options() {
 	set_default multi_ap 0
 	set_default airtime_bss_weight 0
 	set_default airtime_bss_limit 0
+	set_default eap_server 0
 
 	append bss_conf "ctrl_interface=/var/run/hostapd"
 	if [ "$isolate" -gt 0 ]; then
@@ -532,6 +585,7 @@ hostapd_set_bss_options() {
 	append bss_conf "uapsd_advertisement_enabled=$uapsd" "$N"
 	append bss_conf "utf8_ssid=$utf8_ssid" "$N"
 	append bss_conf "multi_ap=$multi_ap" "$N"
+	[ -n "$vendor_elements" ] && append bss_conf "vendor_elements=$vendor_elements" "$N"
 
 	[ "$tdls_prohibit" -gt 0 ] && append bss_conf "tdls_prohibit=$tdls_prohibit" "$N"
 
@@ -550,19 +604,21 @@ hostapd_set_bss_options() {
 			append bss_conf "acct_server_shared_secret=$acct_secret" "$N"
 		[ -n "$acct_interval" ] && \
 			append bss_conf "radius_acct_interim_interval=$acct_interval" "$N"
+		json_for_each_item append_radius_acct_req_attr radius_acct_req_attr
 	}
 
 	case "$auth_type" in
-		sae|owe|eap192|eap-eap192)
+		sae|owe|eap192|eap256)
 			set_default ieee80211w 2
 			set_default sae_require_mfp 1
 		;;
-		psk-sae)
+		psk-sae|eap-eap256)
 			set_default ieee80211w 1
 			set_default sae_require_mfp 1
 		;;
 	esac
 	[ -n "$sae_require_mfp" ] && append bss_conf "sae_require_mfp=$sae_require_mfp" "$N"
+	[ -n "$sae_pwe" ] && append bss_conf "sae_pwe=$sae_pwe" "$N"
 
 	local vlan_possible=""
 
@@ -599,12 +655,12 @@ hostapd_set_bss_options() {
 			vlan_possible=1
 			wps_possible=1
 		;;
-		eap|eap192|eap-eap192)
+		eap|eap192|eap-eap256|eap256)
 			json_get_vars \
 				auth_server auth_secret auth_port \
 				dae_client dae_secret dae_port \
 				ownip radius_client_addr \
-				eap_reauth_period
+				eap_reauth_period request_cui
 
 			# radius can provide VLAN ID for clients
 			vlan_possible=1
@@ -616,18 +672,22 @@ hostapd_set_bss_options() {
 
 			set_default auth_port 1812
 			set_default dae_port 3799
+			set_default request_cui 0
 
+			[ "$eap_server" -eq 0 ] && {
+				append bss_conf "auth_server_addr=$auth_server" "$N"
+				append bss_conf "auth_server_port=$auth_port" "$N"
+				append bss_conf "auth_server_shared_secret=$auth_secret" "$N"
+			}
 
-			append bss_conf "auth_server_addr=$auth_server" "$N"
-			append bss_conf "auth_server_port=$auth_port" "$N"
-			append bss_conf "auth_server_shared_secret=$auth_secret" "$N"
-
+			[ "$request_cui" -gt 0 ] && append bss_conf "radius_request_cui=$request_cui" "$N"
 			[ -n "$eap_reauth_period" ] && append bss_conf "eap_reauth_period=$eap_reauth_period" "$N"
 
 			[ -n "$dae_client" -a -n "$dae_secret" ] && {
 				append bss_conf "radius_das_port=$dae_port" "$N"
 				append bss_conf "radius_das_client=$dae_client $dae_secret" "$N"
 			}
+			json_for_each_item append_radius_auth_req_attr radius_auth_req_attr
 
 			[ -n "$ownip" ] && append bss_conf "own_ip_addr=$ownip" "$N"
 			[ -n "$radius_client_addr" ] && append bss_conf "radius_client_addr=$radius_client_addr" "$N"
@@ -699,7 +759,8 @@ hostapd_set_bss_options() {
 	}
 
 	append bss_conf "ssid=$ssid" "$N"
-	[ -n "$network_bridge" ] && append bss_conf "bridge=$network_bridge" "$N"
+	[ -n "$network_bridge" ] && append bss_conf "bridge=$network_bridge${N}wds_bridge=" "$N"
+	[ -n "$network_ifname" ] && append bss_conf "snoop_iface=$network_ifname" "$N"
 	[ -n "$iapp_interface" ] && {
 		local ifname
 		network_get_device ifname "$iapp_interface" || ifname="$iapp_interface"
@@ -740,7 +801,7 @@ hostapd_set_bss_options() {
 			append bss_conf "ftm_responder=1" "$N"
 			[ "$stationary_ap" -eq "1" ] && append bss_conf "stationary_ap=1" "$N"
 			[ -n "$lci" ] && append bss_conf "lci=$lci" "$N"
-			[ -n "$civic" ] && append bss_conf "lci=$civic" "$N"
+			[ -n "$civic" ] && append bss_conf "civic=$civic" "$N"
 		}
 	fi
 
@@ -764,6 +825,7 @@ hostapd_set_bss_options() {
 				;;
 			esac
 
+			[ -n "$network_ifname" ] && append bss_conf "ft_iface=$network_ifname" "$N"
 			append bss_conf "mobility_domain=$mobility_domain" "$N"
 			append bss_conf "ft_psk_generate_local=$ft_psk_generate_local" "$N"
 			append bss_conf "ft_over_ds=$ft_over_ds" "$N"
@@ -778,6 +840,13 @@ hostapd_set_bss_options() {
 				set_default r0_key_lifetime 10000
 				set_default pmk_r1_push 0
 
+				[ -n "$r0kh" -a -n "$r1kh" ] || {
+					key=`echo -n "$mobility_domain/$auth_secret" | md5sum | awk '{print $1}'`
+
+					set_default r0kh "ff:ff:ff:ff:ff:ff,*,$key"
+					set_default r1kh "00:00:00:00:00:00,00:00:00:00:00:00,$key"
+				}
+
 				[ -n "$r1_key_holder" ] && append bss_conf "r1_key_holder=$r1_key_holder" "$N"
 				append bss_conf "r0_key_lifetime=$r0_key_lifetime" "$N"
 				append bss_conf "pmk_r1_push=$pmk_r1_push" "$N"
@@ -822,7 +891,16 @@ hostapd_set_bss_options() {
 				json_get_vars ieee80211w_mgmt_cipher ieee80211w_max_timeout ieee80211w_retry_timeout
 				append bss_conf "ieee80211w=$ieee80211w" "$N"
 				[ "$ieee80211w" -gt "0" ] && {
-					append bss_conf "group_mgmt_cipher=${ieee80211w_mgmt_cipher:-AES-128-CMAC}" "$N"
+					case "$auth_type" in
+					eap192)
+						append bss_conf "group_mgmt_cipher=BIP-GMAC-256" "$N"
+						append bss_conf "group_cipher=GCMP-256" "$N"
+						;;
+					*)
+						append bss_conf "group_mgmt_cipher=${ieee80211w_mgmt_cipher:-AES-128-CMAC}" "$N"
+						;;
+					esac
+
 					[ -n "$ieee80211w_max_timeout" ] && \
 						append bss_conf "assoc_sa_query_max_timeout=$ieee80211w_max_timeout" "$N"
 					[ -n "$ieee80211w_retry_timeout" ] && \
@@ -863,13 +941,17 @@ hostapd_set_bss_options() {
 	}
 
 	[ -n "$vlan_possible" -a -n "$dynamic_vlan" ] && {
-		json_get_vars vlan_naming vlan_tagged_interface vlan_bridge vlan_file
+		json_get_vars vlan_naming vlan_tagged_interface vlan_bridge vlan_file vlan_no_bridge
 		set_default vlan_naming 1
 		[ -z "$vlan_file" ] && set_default vlan_file /var/run/hostapd-$ifname.vlan
 		append bss_conf "dynamic_vlan=$dynamic_vlan" "$N"
 		append bss_conf "vlan_naming=$vlan_naming" "$N"
-		[ -n "$vlan_bridge" ] && \
+		if [ -n "$vlan_bridge" ]; then
 			append bss_conf "vlan_bridge=$vlan_bridge" "$N"
+		else
+			set_default vlan_no_bridge 1
+		fi
+		append bss_conf "vlan_no_bridge=$vlan_no_bridge" "$N"
 		[ -n "$vlan_tagged_interface" ] && \
 			append bss_conf "vlan_tagged_interface=$vlan_tagged_interface" "$N"
 		[ -n "$vlan_file" ] && {
@@ -882,6 +964,7 @@ hostapd_set_bss_options() {
 	json_get_vars iw_hessid iw_venue_group iw_venue_type iw_network_auth_type
 	json_get_vars iw_roaming_consortium iw_domain_name iw_anqp_3gpp_cell_net iw_nai_realm
 	json_get_vars iw_anqp_elem iw_qos_map_set iw_ipaddr_type_availability iw_gas_address3
+	json_get_vars iw_venue_name iw_venue_url
 
 	set_default iw_enabled 0
 	if [ "$iw_enabled" = "1" ]; then
@@ -905,11 +988,12 @@ hostapd_set_bss_options() {
 		[ -n "$iw_network_auth_type" ] && \
 			append bss_conf "network_auth_type=$iw_network_auth_type" "$N"
 		[ -n "$iw_gas_address3" ] && append bss_conf "gas_address3=$iw_gas_address3" "$N"
-		[ -n "$iw_qos_map_set" ] && append bss_conf "qos_map_set=$iw_qos_map_set" "$N"
 
 		json_for_each_item append_iw_roaming_consortium iw_roaming_consortium
 		json_for_each_item append_iw_anqp_elem iw_anqp_elem
 		json_for_each_item append_iw_nai_realm iw_nai_realm
+		json_for_each_item append_iw_venue_name iw_venue_name
+		json_for_each_item append_iw_venue_url iw_venue_url
 
 		iw_domain_name_conf=
 		json_for_each_item append_iw_domain_name iw_domain_name
@@ -922,13 +1006,22 @@ hostapd_set_bss_options() {
 			append bss_conf "anqp_3gpp_cell_net=$iw_anqp_3gpp_cell_net_conf" "$N"
 	fi
 
+	set_default iw_qos_map_set 0,0,2,16,1,1,255,255,18,22,24,38,40,40,44,46,48,56
+	case "$iw_qos_map_set" in
+		*,*);;
+		*) iw_qos_map_set="";;
+	esac
+	[ -n "$iw_qos_map_set" ] && append bss_conf "qos_map_set=$iw_qos_map_set" "$N"
 
 	local hs20 disable_dgaf osen anqp_domain_id hs20_deauth_req_timeout \
-		osu_ssid hs20_wan_metrics hs20_operating_class hs20_t_c_filename hs20_t_c_timestamp
+		osu_ssid hs20_wan_metrics hs20_operating_class hs20_t_c_filename hs20_t_c_timestamp \
+		hs20_t_c_server_url hs20_release
 	json_get_vars hs20 disable_dgaf osen anqp_domain_id hs20_deauth_req_timeout \
-		osu_ssid hs20_wan_metrics hs20_operating_class hs20_t_c_filename hs20_t_c_timestamp
+		osu_ssid hs20_wan_metrics hs20_operating_class hs20_t_c_filename hs20_t_c_timestamp \
+		hs20_t_c_server_url hs20_release
 
 	set_default hs20 0
+	set_default hs20_release  1
 	set_default disable_dgaf $hs20
 	set_default osen 0
 	set_default anqp_domain_id 0
@@ -936,6 +1029,7 @@ hostapd_set_bss_options() {
 	if [ "$hs20" = "1" ]; then
 		append bss_conf "hs20=1" "$N"
 		append_hs20_icons
+		append bss_conf "hs20_release=$hs20_release" "$N"
 		append bss_conf "disable_dgaf=$disable_dgaf" "$N"
 		append bss_conf "osen=$osen" "$N"
 		append bss_conf "anqp_domain_id=$anqp_domain_id" "$N"
@@ -945,16 +1039,31 @@ hostapd_set_bss_options() {
 		[ -n "$hs20_operating_class" ] && append bss_conf "hs20_operating_class=$hs20_operating_class" "$N"
 		[ -n "$hs20_t_c_filename" ] && append bss_conf "hs20_t_c_filename=$hs20_t_c_filename" "$N"
 		[ -n "$hs20_t_c_timestamp" ] && append bss_conf "hs20_t_c_timestamp=$hs20_t_c_timestamp" "$N"
-		json_for_each_item append_hs20_conn_capab hs20_conn_capab
+		[ -n "$hs20_t_c_server_url" ] && append bss_conf "hs20_t_c_server_url=$hs20_t_c_server_url" "$N"
 		json_for_each_item append_hs20_oper_friendly_name hs20_oper_friendly_name
+		json_for_each_item append_hs20_conn_capab hs20_conn_capab
 		json_for_each_item append_osu_provider osu_provider
 		json_for_each_item append_operator_icon operator_icon
 	fi
 
+	if [ "$eap_server" = "1" ]; then
+		append bss_conf "eap_server=1" "$N"
+		[ -n "$eap_user_file" ] && append bss_conf "eap_user_file=$eap_user_file" "$N"
+		[ -n "$ca_cert" ] && append bss_conf "ca_cert=$ca_cert" "$N"
+		[ -n "$server_cert" ] && append bss_conf "server_cert=$server_cert" "$N"
+		[ -n "$private_key" ] && append bss_conf "private_key=$private_key" "$N"
+		[ -n "$private_key_passwd" ] && append bss_conf "private_key_passwd=$private_key_passwd" "$N"
+		[ -n "$server_id" ] && append bss_conf "server_id=$server_id" "$N"
+	fi
+
 	set_default multicast_to_unicast 0
 	if [ "$multicast_to_unicast" -gt 0 ]; then
 		append bss_conf "multicast_to_unicast=$multicast_to_unicast" "$N"
 	fi
+	set_default proxy_arp 0
+	if [ "$proxy_arp" -gt 0 ]; then
+		append bss_conf "proxy_arp=$proxy_arp" "$N"
+	fi
 
 	set_default per_sta_vif 0
 	if [ "$per_sta_vif" -gt 0 ]; then
@@ -1079,16 +1188,16 @@ wpa_supplicant_set_fixed_freq() {
 	append network_data "frequency=$freq" "$N$T"
 	case "$htmode" in
 		NOHT) append network_data "disable_ht=1" "$N$T";;
-		HT20|VHT20) append network_data "disable_ht40=1" "$N$T";;
+		HT20|VHT20|HE20) append network_data "disable_ht40=1" "$N$T";;
 		HT40*|VHT40*|VHT80*|VHT160*) append network_data "ht40=1" "$N$T";;
 	esac
 	case "$htmode" in
 		VHT*) append network_data "vht=1" "$N$T";;
 	esac
 	case "$htmode" in
-		VHT80) append network_data "max_oper_chwidth=1" "$N$T";;
-		VHT160) append network_data "max_oper_chwidth=2" "$N$T";;
-		VHT20|VHT40) append network_data "max_oper_chwidth=0" "$N$T";;
+		HE80|VHT80) append network_data "max_oper_chwidth=1" "$N$T";;
+		HE160|VHT160) append network_data "max_oper_chwidth=2" "$N$T";;
+		HE20|HE40|VHT20|VHT40) append network_data "max_oper_chwidth=0" "$N$T";;
 		*) append network_data "disable_vht=1" "$N$T";;
 	esac
 }
@@ -1106,19 +1215,21 @@ wpa_supplicant_add_network() {
 		ssid bssid key \
 		basic_rate mcast_rate \
 		ieee80211w ieee80211r \
-		multi_ap
+		multi_ap \
+		default_disabled
 
 	case "$auth_type" in
-		sae|owe|eap192|eap-eap192)
+		sae|owe|eap-eap256)
 			set_default ieee80211w 2
 		;;
-		psk-sae)
+		psk-sae|eap192|eap256)
 			set_default ieee80211w 1
 		;;
 	esac
 
 	set_default ieee80211r 0
 	set_default multi_ap 0
+	set_default default_disabled 0
 
 	local key_mgmt='NONE'
 	local network_data=
@@ -1150,7 +1261,10 @@ wpa_supplicant_add_network() {
 		scan_ssid=""
 	}
 
-	[ "$multi_ap" = 1 -a "$_w_mode" = "sta" ] && append network_data "multi_ap_backhaul_sta=1" "$N$T"
+	[ "$_w_mode" = "sta" ] && {
+		[ "$multi_ap" = 1 ] && append network_data "multi_ap_backhaul_sta=1" "$N$T"
+		[ "$default_disabled" = 1 ] && append network_data "disabled=1" "$N$T"
+	}
 
 	case "$auth_type" in
 		none) ;;
@@ -1186,7 +1300,7 @@ wpa_supplicant_add_network() {
 			fi
 			append network_data "$passphrase" "$N$T"
 		;;
-		eap|eap192|eap-eap192)
+		eap|eap192|eap-eap256|eap256)
 			hostapd_append_wpa_key_mgmt
 			key_mgmt="$wpa_key_mgmt"
 
diff --git a/package/network/services/hostapd/patches/001-HE-VHT-fix-frequency-setup-with-HE-enabled.patch b/package/network/services/hostapd/patches/001-HE-VHT-fix-frequency-setup-with-HE-enabled.patch
deleted file mode 100644
index 37c17c50af..0000000000
--- a/package/network/services/hostapd/patches/001-HE-VHT-fix-frequency-setup-with-HE-enabled.patch
+++ /dev/null
@@ -1,196 +0,0 @@
-From 91976250359b263a44861aebe553b20627fe487e Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 13:53:17 +0200
-Subject: [PATCH 01/19] HE/VHT: fix frequency setup with HE enabled
-
-Some places in the code base were not using the
-wrappers like hostapd_set_oper_centr_freq_seg0_idx
-and friends. This could lead to errors, for example when
-joining 80 MHz mesh networks. Fix this, by enforcing
-usage of these wrappers.
-
-wpa_supplicant_conf_ap_ht now checks for HE capability
-before dealing with VHT in order for these wrappers to work,
-as they first check HE support in the config.
-
-While doing these changes, I've noticed that the extra
-channel setup code for mesh networks in wpa_supplicant/mesh.c
-should not be necessary anymore and dropped it.
-wpa_supplicant_conf_ap_ht should handle this setup already.
-
-Acked-by: John Crispin <john@phrozen.org>
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- src/ap/dfs.c          |  8 ++++----
- wpa_supplicant/ap.c   | 40 +++++++++++++++++++++++-----------------
- wpa_supplicant/mesh.c | 24 ------------------------
- 3 files changed, 27 insertions(+), 45 deletions(-)
-
---- a/src/ap/dfs.c
-+++ b/src/ap/dfs.c
-@@ -1028,7 +1028,7 @@ static int hostapd_dfs_start_channel_swi
- 	unsigned int i;
- 	int err = 1;
- 	struct hostapd_hw_modes *cmode = iface->current_mode;
--	u8 current_vht_oper_chwidth = iface->conf->vht_oper_chwidth;
-+	u8 current_vht_oper_chwidth = hostapd_get_oper_chwidth(iface->conf);
- 
- 	wpa_printf(MSG_DEBUG, "%s called (CAC active: %s, CSA active: %s)",
- 		   __func__, iface->cac_started ? "yes" : "no",
-@@ -1089,8 +1089,8 @@ static int hostapd_dfs_start_channel_swi
- 		"freq=%d chan=%d sec_chan=%d", channel->freq,
- 		channel->chan, secondary_channel);
- 
--	new_vht_oper_chwidth = iface->conf->vht_oper_chwidth;
--	iface->conf->vht_oper_chwidth = current_vht_oper_chwidth;
-+	new_vht_oper_chwidth = hostapd_get_oper_chwidth(iface->conf);
-+	hostapd_set_oper_chwidth(iface->conf, current_vht_oper_chwidth);
- 
- 	/* Setup CSA request */
- 	os_memset(&csa_settings, 0, sizeof(csa_settings));
-@@ -1130,7 +1130,7 @@ static int hostapd_dfs_start_channel_swi
- 		iface->freq = channel->freq;
- 		iface->conf->channel = channel->chan;
- 		iface->conf->secondary_channel = secondary_channel;
--		iface->conf->vht_oper_chwidth = new_vht_oper_chwidth;
-+		hostapd_set_oper_chwidth(iface->conf, new_vht_oper_chwidth);
- 		hostapd_set_oper_centr_freq_seg0_idx(iface->conf,
- 						     oper_centr_freq_seg0_idx);
- 		hostapd_set_oper_centr_freq_seg1_idx(iface->conf,
---- a/wpa_supplicant/ap.c
-+++ b/wpa_supplicant/ap.c
-@@ -52,6 +52,7 @@ static void wpas_conf_ap_vht(struct wpa_
- #ifdef CONFIG_P2P
- 	u8 center_chan = 0;
- 	u8 channel = conf->channel;
-+	u8 freq_seg_idx;
- #endif /* CONFIG_P2P */
- 
- 	if (!conf->secondary_channel)
-@@ -59,19 +60,21 @@ static void wpas_conf_ap_vht(struct wpa_
- 
- 	/* Use the maximum oper channel width if it's given. */
- 	if (ssid->max_oper_chwidth)
--		conf->vht_oper_chwidth = ssid->max_oper_chwidth;
-+		hostapd_set_oper_chwidth(conf, ssid->max_oper_chwidth);
- 
- 	ieee80211_freq_to_chan(ssid->vht_center_freq2,
--			       &conf->vht_oper_centr_freq_seg1_idx);
-+			       &freq_seg_idx);
-+	hostapd_set_oper_centr_freq_seg1_idx(conf, freq_seg_idx);
- 
- 	if (!ssid->p2p_group) {
- 		if (!ssid->vht_center_freq1 ||
--		    conf->vht_oper_chwidth == CHANWIDTH_USE_HT)
-+		    hostapd_get_oper_chwidth(conf) == CHANWIDTH_USE_HT)
- 			goto no_vht;
- 		ieee80211_freq_to_chan(ssid->vht_center_freq1,
--				       &conf->vht_oper_centr_freq_seg0_idx);
-+				       &freq_seg_idx);
-+		hostapd_set_oper_centr_freq_seg0_idx(conf, freq_seg_idx);
- 		wpa_printf(MSG_DEBUG, "VHT seg0 index %d for AP",
--			   conf->vht_oper_centr_freq_seg0_idx);
-+			   hostapd_get_oper_centr_freq_seg0_idx(conf));
- 		return;
- 	}
- 
-@@ -96,14 +99,14 @@ static void wpas_conf_ap_vht(struct wpa_
- 		 * try oper_cwidth 160 MHz first then VHT 80 MHz, if 160 MHz is
- 		 * not supported.
- 		 */
--		conf->vht_oper_chwidth = CHANWIDTH_160MHZ;
-+		hostapd_set_oper_chwidth(conf, CHANWIDTH_160MHZ);
- 		center_chan = wpas_p2p_get_vht160_center(wpa_s, mode, channel);
- 		if (center_chan) {
- 			wpa_printf(MSG_DEBUG,
- 				   "VHT center channel %u for auto-selected 160 MHz bandwidth",
- 				   center_chan);
- 		} else {
--			conf->vht_oper_chwidth = CHANWIDTH_80MHZ;
-+			hostapd_set_oper_chwidth(conf, CHANWIDTH_80MHZ);
- 			center_chan = wpas_p2p_get_vht80_center(wpa_s, mode,
- 								channel);
- 			wpa_printf(MSG_DEBUG,
-@@ -115,9 +118,9 @@ static void wpas_conf_ap_vht(struct wpa_
- 	if (!center_chan)
- 		goto no_vht;
- 
--	conf->vht_oper_centr_freq_seg0_idx = center_chan;
-+	hostapd_set_oper_centr_freq_seg0_idx(conf, center_chan);
- 	wpa_printf(MSG_DEBUG, "VHT seg0 index %d for P2P GO",
--		   conf->vht_oper_centr_freq_seg0_idx);
-+		   hostapd_get_oper_centr_freq_seg0_idx(conf));
- 	return;
- #endif /* CONFIG_P2P */
- 
-@@ -125,9 +128,9 @@ no_vht:
- 	wpa_printf(MSG_DEBUG,
- 		   "No VHT higher bandwidth support for the selected channel %d",
- 		   conf->channel);
--	conf->vht_oper_centr_freq_seg0_idx =
--		conf->channel + conf->secondary_channel * 2;
--	conf->vht_oper_chwidth = CHANWIDTH_USE_HT;
-+	hostapd_set_oper_centr_freq_seg0_idx(conf,
-+					     conf->channel + conf->secondary_channel * 2);
-+	hostapd_set_oper_chwidth(conf, CHANWIDTH_USE_HT);
- }
- 
- 
-@@ -231,16 +234,19 @@ int wpa_supplicant_conf_ap_ht(struct wpa
- 				 HT_CAP_INFO_TX_STBC |
- 				 HT_CAP_INFO_MAX_AMSDU_SIZE);
- 
-+			/* check this before VHT, because setting oper chan
-+			 * width and friends is the same call for HE and VHT
-+			 * and checks if conf->ieee8021ax == 1 */
-+			if (mode->he_capab[wpas_mode_to_ieee80211_mode(
-+					    ssid->mode)].he_supported &&
-+			    ssid->he)
-+				conf->ieee80211ax = 1;
-+
- 			if (mode->vht_capab && ssid->vht) {
- 				conf->ieee80211ac = 1;
- 				conf->vht_capab |= mode->vht_capab;
- 				wpas_conf_ap_vht(wpa_s, ssid, conf, mode);
- 			}
--
--			if (mode->he_capab[wpas_mode_to_ieee80211_mode(
--					    ssid->mode)].he_supported &&
--			    ssid->he)
--				conf->ieee80211ax = 1;
- 		}
- 	}
- 
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -333,30 +333,6 @@ static int wpa_supplicant_mesh_init(stru
- 			   frequency);
- 		goto out_free;
- 	}
--	if (ssid->ht40)
--		conf->secondary_channel = ssid->ht40;
--	if (conf->hw_mode == HOSTAPD_MODE_IEEE80211A && ssid->vht) {
--		if (ssid->max_oper_chwidth != DEFAULT_MAX_OPER_CHWIDTH)
--			conf->vht_oper_chwidth = ssid->max_oper_chwidth;
--		switch (conf->vht_oper_chwidth) {
--		case CHANWIDTH_80MHZ:
--		case CHANWIDTH_80P80MHZ:
--			ieee80211_freq_to_chan(
--				frequency,
--				&conf->vht_oper_centr_freq_seg0_idx);
--			conf->vht_oper_centr_freq_seg0_idx += ssid->ht40 * 2;
--			break;
--		case CHANWIDTH_160MHZ:
--			ieee80211_freq_to_chan(
--				frequency,
--				&conf->vht_oper_centr_freq_seg0_idx);
--			conf->vht_oper_centr_freq_seg0_idx += ssid->ht40 * 2;
--			conf->vht_oper_centr_freq_seg0_idx += 40 / 5;
--			break;
--		}
--		ieee80211_freq_to_chan(ssid->vht_center_freq2,
--				       &conf->vht_oper_centr_freq_seg1_idx);
--	}
- 
- 	if (ssid->mesh_basic_rates == NULL) {
- 		/*
diff --git a/package/network/services/hostapd/patches/802-wolfssl-init-RNG-with-ECC-key.patch b/package/network/services/hostapd/patches/001-wolfssl-init-RNG-with-ECC-key.patch
similarity index 76%
rename from package/network/services/hostapd/patches/802-wolfssl-init-RNG-with-ECC-key.patch
rename to package/network/services/hostapd/patches/001-wolfssl-init-RNG-with-ECC-key.patch
index 89d111e991..84fc1c9351 100644
--- a/package/network/services/hostapd/patches/802-wolfssl-init-RNG-with-ECC-key.patch
+++ b/package/network/services/hostapd/patches/001-wolfssl-init-RNG-with-ECC-key.patch
@@ -14,11 +14,9 @@ Signed-off-by: David Bauer <mail@david-bauer.net>
  src/crypto/crypto_wolfssl.c | 4 ++++
  1 file changed, 4 insertions(+)
 
-diff --git a/src/crypto/crypto_wolfssl.c b/src/crypto/crypto_wolfssl.c
-index 2e4bf8962..ed2528159 100644
 --- a/src/crypto/crypto_wolfssl.c
 +++ b/src/crypto/crypto_wolfssl.c
-@@ -1303,6 +1303,7 @@ int ecc_projective_add_point(ecc_point *P, ecc_point *Q, ecc_point *R,
+@@ -1303,6 +1303,7 @@ int ecc_projective_add_point(ecc_point *
  
  struct crypto_ec {
  	ecc_key key;
@@ -26,7 +24,7 @@ index 2e4bf8962..ed2528159 100644
  	mp_int a;
  	mp_int prime;
  	mp_int order;
-@@ -1357,6 +1358,8 @@ struct crypto_ec * crypto_ec_init(int group)
+@@ -1357,6 +1358,8 @@ struct crypto_ec * crypto_ec_init(int gr
  		return NULL;
  
  	if (wc_ecc_init(&e->key) != 0 ||
@@ -35,7 +33,7 @@ index 2e4bf8962..ed2528159 100644
  	    wc_ecc_set_curve(&e->key, 0, curve_id) != 0 ||
  	    mp_init(&e->a) != MP_OKAY ||
  	    mp_init(&e->prime) != MP_OKAY ||
-@@ -1388,6 +1391,7 @@ void crypto_ec_deinit(struct crypto_ec* e)
+@@ -1388,6 +1391,7 @@ void crypto_ec_deinit(struct crypto_ec*
  	mp_clear(&e->order);
  	mp_clear(&e->prime);
  	mp_clear(&e->a);
@@ -43,6 +41,3 @@ index 2e4bf8962..ed2528159 100644
  	wc_ecc_free(&e->key);
  	os_free(e);
  }
--- 
-2.31.1
-
diff --git a/package/network/services/hostapd/patches/002-mesh-fix-channel-init-order-disable-pri-sec-channel-.patch b/package/network/services/hostapd/patches/002-mesh-fix-channel-init-order-disable-pri-sec-channel-.patch
deleted file mode 100644
index c7101b1dbc..0000000000
--- a/package/network/services/hostapd/patches/002-mesh-fix-channel-init-order-disable-pri-sec-channel-.patch
+++ /dev/null
@@ -1,126 +0,0 @@
-From d869c753b79a1423c2bd9b0afdfa0d89d55a930c Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 13:53:18 +0200
-Subject: [PATCH 02/19] mesh: fix channel init order, disable pri/sec channel
- switch
-
-wpa_supplicant_conf_ap_ht has to happen before hostapd_setup_interface
-in order for its configuration settings to have effect on interface
-configuration.
-
-Disable primary and secondary channel switch because of missing tie
-breaking rule/frames in mesh networks. A rather long comment about
-this issue is placed in mesh.c in the corresponding place.
-
-In consequence, remove mesh coex test, which contradicts this change.
-
-I was not able to reproduce the memory corruption during
-mesh_secure_ocv_mix_legacy, which lead to a revert of a similar patch
-in the past.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- tests/hwsim/test_wpas_mesh.py | 50 -----------------------------------
- wpa_supplicant/mesh.c         | 25 ++++++++++++++++--
- 2 files changed, 23 insertions(+), 52 deletions(-)
-
---- a/tests/hwsim/test_wpas_mesh.py
-+++ b/tests/hwsim/test_wpas_mesh.py
-@@ -933,56 +933,6 @@ def _test_wpas_mesh_open_5ghz(dev, apdev
-     dev[0].dump_monitor()
-     dev[1].dump_monitor()
- 
--def test_wpas_mesh_open_5ghz_coex(dev, apdev):
--    """Mesh network on 5 GHz band and 20/40 coex change"""
--    try:
--        _test_wpas_mesh_open_5ghz_coex(dev, apdev)
--    finally:
--        dev[0].request("MESH_GROUP_REMOVE " + dev[0].ifname)
--        dev[1].request("MESH_GROUP_REMOVE " + dev[1].ifname)
--        set_world_reg(apdev0=apdev[0], dev0=dev[0])
--        dev[0].flush_scan_cache()
--        dev[1].flush_scan_cache()
--
--def _test_wpas_mesh_open_5ghz_coex(dev, apdev):
--    check_mesh_support(dev[0])
--    subprocess.call(['iw', 'reg', 'set', 'US'])
--
--    # Start a 20 MHz BSS on channel 40 that would be the secondary channel of
--    # HT40+ mesh on channel 36.
--    params = {"ssid": "test-ht40",
--              "hw_mode": "a",
--              "channel": "40",
--              "country_code": "US"}
--    hapd = hostapd.add_ap(apdev[0], params)
--    bssid = hapd.own_addr()
--
--    for i in range(2):
--        for j in range(5):
--            ev = dev[i].wait_event(["CTRL-EVENT-REGDOM-CHANGE"], timeout=5)
--            if ev is None:
--                raise Exception("No regdom change event")
--            if "alpha2=US" in ev:
--                break
--        dev[i].scan_for_bss(bssid, freq=5200)
--        add_open_mesh_network(dev[i], freq="5180")
--
--    check_mesh_joined_connected(dev)
--
--    freq = dev[0].get_status_field("freq")
--    if freq != "5200":
--        raise Exception("Unexpected STATUS freq=" + freq)
--    sig = dev[0].request("SIGNAL_POLL").splitlines()
--    if "FREQUENCY=5200" not in sig:
--        raise Exception("Unexpected SIGNAL_POLL output: " + str(sig))
--
--    hapd.disable()
--    dev[0].mesh_group_remove()
--    dev[1].mesh_group_remove()
--    check_mesh_group_removed(dev[0])
--    check_mesh_group_removed(dev[1])
--    dev[0].dump_monitor()
--    dev[1].dump_monitor()
- 
- def test_wpas_mesh_open_ht40(dev, apdev):
-     """Mesh and HT40 support difference"""
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -363,6 +363,29 @@ static int wpa_supplicant_mesh_init(stru
- 		conf->basic_rates[rate_len] = -1;
- 	}
- 
-+	/* While it can enhance performance to switch the primary channel, which
-+	 * is also the secondary channel of another network at the same time),
-+	 * to the other primary channel, problems exist with this in mesh networks.
-+	 *
-+	 * Example with problems:
-+	 *     - 3 mesh nodes M1-M3, freq (5200, 5180)
-+	 *     - other node O1, e.g. AP mode, freq (5180, 5200),
-+	 * Locations: O1 M1      M2      M3
-+	 *
-+	 * M3 can only send frames to M1 over M2, no direct connection is possible
-+	 * Start O1, M1 and M3 first, M1 or O1 will switch channels to align with
-+	 * each other. M3 does not swap, because M1 or O1 cannot be reached.
-+	 * M2 is started afterwards and can either connect to M3 or M1 because of
-+	 * this primary secondary channel switch.
-+	 *
-+	 * Solutions: (1) central coordination -> not always possible
-+	 *            (2) disable pri/sec channel switch in mesh networks
-+	 *
-+	 * In AP mode, when all nodes can work independently, this poses of course
-+	 * no problem, therefore disable it only in mesh mode.`*/
-+	conf->no_pri_sec_switch = 1;
-+	wpa_supplicant_conf_ap_ht(wpa_s, ssid, conf);
-+
- 	if (wpa_drv_init_mesh(wpa_s)) {
- 		wpa_msg(wpa_s, MSG_ERROR, "Failed to init mesh in driver");
- 		return -1;
-@@ -374,8 +397,6 @@ static int wpa_supplicant_mesh_init(stru
- 		return -1;
- 	}
- 
--	wpa_supplicant_conf_ap_ht(wpa_s, ssid, conf);
--
- 	return 0;
- out_free:
- 	wpa_supplicant_mesh_deinit(wpa_s);
diff --git a/package/network/services/hostapd/patches/003-wpa_supplicant-handle-HT40-and-mode-downgrade-in-AP-.patch b/package/network/services/hostapd/patches/003-wpa_supplicant-handle-HT40-and-mode-downgrade-in-AP-.patch
deleted file mode 100644
index f42620042d..0000000000
--- a/package/network/services/hostapd/patches/003-wpa_supplicant-handle-HT40-and-mode-downgrade-in-AP-.patch
+++ /dev/null
@@ -1,102 +0,0 @@
-From 978a59514ccde994b5c06e1cbb49cc8cebe6381c Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 13:53:19 +0200
-Subject: [PATCH 03/19] wpa_supplicant: handle HT40 and mode downgrade in AP
- mode
-
-This patch adds some missing pieces to the interface configuration
-of AP/mesh mode in wpa_supplicant.
- - check for secondary channel and HT40 capability
- - try to downgrade to 11b if 11g is not available
-Especially with the HT40 check, this code now performs all settings,
-which the deleted/duplicated mesh code did.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- wpa_supplicant/ap.c | 49 ++++++++++++++++++++++++++++++++++++---------
- 1 file changed, 40 insertions(+), 9 deletions(-)
-
---- a/wpa_supplicant/ap.c
-+++ b/wpa_supplicant/ap.c
-@@ -134,6 +134,23 @@ no_vht:
- }
- 
- 
-+static struct hostapd_hw_modes *wpa_supplicant_find_hw_mode(struct wpa_supplicant *wpa_s,
-+							    enum hostapd_hw_mode hw_mode)
-+{
-+	struct hostapd_hw_modes *mode = NULL;
-+	int i;
-+
-+	for (i = 0; i < wpa_s->hw.num_modes; i++) {
-+		if (wpa_s->hw.modes[i].mode == hw_mode) {
-+			mode = &wpa_s->hw.modes[i];
-+			break;
-+		}
-+	}
-+
-+	return mode;
-+}
-+
-+
- int wpa_supplicant_conf_ap_ht(struct wpa_supplicant *wpa_s,
- 			      struct wpa_ssid *ssid,
- 			      struct hostapd_config *conf)
-@@ -147,9 +164,6 @@ int wpa_supplicant_conf_ap_ht(struct wpa
- 		return -1;
- 	}
- 
--	/* TODO: enable HT40 if driver supports it;
--	 * drop to 11b if driver does not support 11g */
--
- 	/*
- 	 * Enable HT20 if the driver supports it, by setting conf->ieee80211n
- 	 * and a mask of allowed capabilities within conf->ht_capab.
-@@ -158,17 +172,27 @@ int wpa_supplicant_conf_ap_ht(struct wpa
- 	 */
- 	if (wpa_s->hw.modes) {
- 		struct hostapd_hw_modes *mode = NULL;
--		int i, no_ht = 0;
-+		int no_ht = 0;
- 
- 		wpa_printf(MSG_DEBUG,
- 			   "Determining HT/VHT options based on driver capabilities (freq=%u chan=%u)",
- 			   ssid->frequency, conf->channel);
- 
--		for (i = 0; i < wpa_s->hw.num_modes; i++) {
--			if (wpa_s->hw.modes[i].mode == conf->hw_mode) {
--				mode = &wpa_s->hw.modes[i];
--				break;
--			}
-+		mode = wpa_supplicant_find_hw_mode(wpa_s, conf->hw_mode);
-+
-+		/* may drop drop to 11b if driver does not support 11g */
-+		if (!mode && conf->hw_mode == HOSTAPD_MODE_IEEE80211G) {
-+			conf->hw_mode = HOSTAPD_MODE_IEEE80211B;
-+			wpa_printf(MSG_INFO,
-+			   "Try downgrade to IEEE 802.11b as 802.11g is not "
-+			   "supported by the current hardware");
-+			mode = wpa_supplicant_find_hw_mode(wpa_s, conf->hw_mode);
-+		}
-+
-+		if (!mode) {
-+			wpa_printf(MSG_ERROR,
-+			   "No match between requested and supported hw modes found");
-+			return -1;
- 		}
- 
- #ifdef CONFIG_HT_OVERRIDES
-@@ -193,6 +217,13 @@ int wpa_supplicant_conf_ap_ht(struct wpa
- 				      HT_CAP_INFO_SUPP_CHANNEL_WIDTH_SET),
- 				   ssid->ht40);
- 			conf->ieee80211n = 1;
-+
-+			if (ssid->ht40 &&
-+			    mode->ht_capab & HT_CAP_INFO_SUPP_CHANNEL_WIDTH_SET)
-+				conf->secondary_channel = ssid->ht40;
-+			else
-+				conf->secondary_channel = 0;
-+
- #ifdef CONFIG_P2P
- 			if (ssid->p2p_group &&
- 			    conf->hw_mode == HOSTAPD_MODE_IEEE80211A &&
diff --git a/package/network/services/hostapd/patches/004-wpa_supplicant-fix-frequency-config-for-non-p2p-vht-.patch b/package/network/services/hostapd/patches/004-wpa_supplicant-fix-frequency-config-for-non-p2p-vht-.patch
deleted file mode 100644
index e8682af644..0000000000
--- a/package/network/services/hostapd/patches/004-wpa_supplicant-fix-frequency-config-for-non-p2p-vht-.patch
+++ /dev/null
@@ -1,63 +0,0 @@
-From 7f7325dae1d03a3964d4e91940d8369f3fed7b43 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 13:53:20 +0200
-Subject: [PATCH 04/19] wpa_supplicant: fix frequency config for non p2p vht/he
- cases
-
-Fix compile without CONFIG_P2P and only set secondary channel seg idx
-if we use a mode supporting a sec channel for vht/he.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- wpa_supplicant/ap.c | 23 +++++++++++++----------
- 1 file changed, 13 insertions(+), 10 deletions(-)
-
---- a/wpa_supplicant/ap.c
-+++ b/wpa_supplicant/ap.c
-@@ -52,8 +52,8 @@ static void wpas_conf_ap_vht(struct wpa_
- #ifdef CONFIG_P2P
- 	u8 center_chan = 0;
- 	u8 channel = conf->channel;
--	u8 freq_seg_idx;
- #endif /* CONFIG_P2P */
-+	u8 freq_seg_idx;
- 
- 	if (!conf->secondary_channel)
- 		goto no_vht;
-@@ -62,24 +62,27 @@ static void wpas_conf_ap_vht(struct wpa_
- 	if (ssid->max_oper_chwidth)
- 		hostapd_set_oper_chwidth(conf, ssid->max_oper_chwidth);
- 
--	ieee80211_freq_to_chan(ssid->vht_center_freq2,
--			       &freq_seg_idx);
--	hostapd_set_oper_centr_freq_seg1_idx(conf, freq_seg_idx);
--
- 	if (!ssid->p2p_group) {
--		if (!ssid->vht_center_freq1 ||
--		    hostapd_get_oper_chwidth(conf) == CHANWIDTH_USE_HT)
-+		if (!ssid->vht_center_freq1)
- 			goto no_vht;
- 		ieee80211_freq_to_chan(ssid->vht_center_freq1,
- 				       &freq_seg_idx);
- 		hostapd_set_oper_centr_freq_seg0_idx(conf, freq_seg_idx);
--		wpa_printf(MSG_DEBUG, "VHT seg0 index %d for AP",
--			   hostapd_get_oper_centr_freq_seg0_idx(conf));
-+
-+		if (hostapd_get_oper_chwidth(conf) == CHANWIDTH_80P80MHZ) {
-+			ieee80211_freq_to_chan(ssid->vht_center_freq2,
-+					       &freq_seg_idx);
-+			hostapd_set_oper_centr_freq_seg1_idx(conf, freq_seg_idx);
-+		}
-+
-+		wpa_printf(MSG_DEBUG, "VHT seg0 index %d and seg1 index %d for AP",
-+			   hostapd_get_oper_centr_freq_seg0_idx(conf),
-+			   hostapd_get_oper_centr_freq_seg1_idx(conf));
- 		return;
- 	}
- 
- #ifdef CONFIG_P2P
--	switch (conf->vht_oper_chwidth) {
-+	switch (hostapd_get_oper_chwidth(conf)) {
- 	case CHANWIDTH_80MHZ:
- 	case CHANWIDTH_80P80MHZ:
- 		center_chan = wpas_p2p_get_vht80_center(wpa_s, mode, channel);
diff --git a/package/network/services/hostapd/patches/005-wpa_supplicant-enable-vht-and-he-in-default-config-p.patch b/package/network/services/hostapd/patches/005-wpa_supplicant-enable-vht-and-he-in-default-config-p.patch
deleted file mode 100644
index 25d74252cd..0000000000
--- a/package/network/services/hostapd/patches/005-wpa_supplicant-enable-vht-and-he-in-default-config-p.patch
+++ /dev/null
@@ -1,25 +0,0 @@
-From ff7fb3fa0831c8521327d777c5607a3b7d8736b8 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 13:53:21 +0200
-Subject: [PATCH 05/19] wpa_supplicant: enable vht and he in default config
- parameters
-
-Enable VHT and HE as default config parameters in order for
-wpa_supplicant AP mode to use it, if hw support is given.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- wpa_supplicant/config.c | 2 ++
- 1 file changed, 2 insertions(+)
-
---- a/wpa_supplicant/config.c
-+++ b/wpa_supplicant/config.c
-@@ -3036,6 +3036,8 @@ void wpa_config_set_network_defaults(str
- 	ssid->wpa_deny_ptk0_rekey = PTK0_REKEY_ALLOW_ALWAYS;
- 	ssid->bg_scan_period = DEFAULT_BG_SCAN_PERIOD;
- 	ssid->ht = 1;
-+	ssid->vht = 1;
-+	ssid->he = 1;
- #ifdef IEEE8021X_EAPOL
- 	ssid->eapol_flags = DEFAULT_EAPOL_FLAGS;
- 	ssid->eap_workaround = DEFAULT_EAP_WORKAROUND;
diff --git a/package/network/services/hostapd/patches/006-hw_features-better-debug-messages-for-some-error-cas.patch b/package/network/services/hostapd/patches/006-hw_features-better-debug-messages-for-some-error-cas.patch
deleted file mode 100644
index 31b1ac0d38..0000000000
--- a/package/network/services/hostapd/patches/006-hw_features-better-debug-messages-for-some-error-cas.patch
+++ /dev/null
@@ -1,83 +0,0 @@
-From 6522dcbbcf71abcb80cce84b93b4a9a5cfcd4fca Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 13:53:22 +0200
-Subject: [PATCH 06/19] hw_features: better debug messages for some error cases
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- src/common/hw_features_common.c | 29 ++++++++++++++++++++++-------
- 1 file changed, 22 insertions(+), 7 deletions(-)
-
---- a/src/common/hw_features_common.c
-+++ b/src/common/hw_features_common.c
-@@ -540,13 +540,18 @@ int hostapd_set_freq_params(struct hosta
- 		if (center_segment1 ||
- 		    (center_segment0 != 0 &&
- 		     5000 + center_segment0 * 5 != data->center_freq1 &&
--		     2407 + center_segment0 * 5 != data->center_freq1))
-+		     2407 + center_segment0 * 5 != data->center_freq1)) {
-+			wpa_printf(MSG_ERROR, "20/40 MHz: center segment 0 (=%i) and center freq 1 (=%i) not in sync",
-+				   center_segment0, data->center_freq1);
- 			return -1;
-+		}
- 		break;
- 	case CHANWIDTH_80P80MHZ:
- 		if (center_segment1 == center_segment0 + 4 ||
--		    center_segment1 == center_segment0 - 4)
-+		    center_segment1 == center_segment0 - 4) {
-+			wpa_printf(MSG_ERROR, "80+80 MHz: center segment 1 only 20 MHz apart");
- 			return -1;
-+		}
- 		data->center_freq2 = 5000 + center_segment1 * 5;
- 		/* fall through */
- 	case CHANWIDTH_80MHZ:
-@@ -555,8 +560,10 @@ int hostapd_set_freq_params(struct hosta
- 		     center_segment1) ||
- 		    (oper_chwidth == CHANWIDTH_80P80MHZ &&
- 		     !center_segment1) ||
--		    !sec_channel_offset)
-+		    !sec_channel_offset) {
-+			wpa_printf(MSG_ERROR, "80/80+80 MHz: center segment 1 wrong or no second channel offset");
- 			return -1;
-+		}
- 		if (!center_segment0) {
- 			if (channel <= 48)
- 				center_segment0 = 42;
-@@ -582,16 +589,22 @@ int hostapd_set_freq_params(struct hosta
- 			    center_segment0 == channel - 2 ||
- 			    center_segment0 == channel - 6)
- 				data->center_freq1 = 5000 + center_segment0 * 5;
--			else
-+			else {
-+				wpa_printf(MSG_ERROR, "Wrong coupling between HT and VHT/HE channel setting");
- 				return -1;
-+			}
- 		}
- 		break;
- 	case CHANWIDTH_160MHZ:
- 		data->bandwidth = 160;
--		if (center_segment1)
-+		if (center_segment1) {
-+			wpa_printf(MSG_ERROR, "160 MHz: center segment 1 should not be set");
- 			return -1;
--		if (!sec_channel_offset)
-+		}
-+		if (!sec_channel_offset) {
-+			wpa_printf(MSG_ERROR, "160 MHz: second channel offset not set");
- 			return -1;
-+		}
- 		/*
- 		 * Note: HT/VHT config and params are coupled. Check if
- 		 * HT40 channel band is in VHT160 channel band configuration.
-@@ -605,8 +618,10 @@ int hostapd_set_freq_params(struct hosta
- 		    center_segment0 == channel - 10 ||
- 		    center_segment0 == channel - 14)
- 			data->center_freq1 = 5000 + center_segment0 * 5;
--		else
-+		else {
-+			wpa_printf(MSG_ERROR, "160 MHz: HT40 channel band is not in 160 MHz band");
- 			return -1;
-+		}
- 		break;
- 	}
- 
diff --git a/package/network/services/hostapd/patches/007-dfs-use-helper-functions-for-vht-he-parameters.patch b/package/network/services/hostapd/patches/007-dfs-use-helper-functions-for-vht-he-parameters.patch
deleted file mode 100644
index 3481c52eef..0000000000
--- a/package/network/services/hostapd/patches/007-dfs-use-helper-functions-for-vht-he-parameters.patch
+++ /dev/null
@@ -1,27 +0,0 @@
-From 6eacc14904b6f09a1490e697c01adf5dc56c4905 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 13:53:23 +0200
-Subject: [PATCH 07/19] dfs: use helper functions for vht/he parameters
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- src/ap/dfs.c | 6 ++++--
- 1 file changed, 4 insertions(+), 2 deletions(-)
-
---- a/src/ap/dfs.c
-+++ b/src/ap/dfs.c
-@@ -955,10 +955,12 @@ dfs_downgrade_bandwidth(struct hostapd_i
- 		if (*skip_radar) {
- 			*skip_radar = 0;
- 		} else {
--			if (iface->conf->vht_oper_chwidth == CHANWIDTH_USE_HT)
-+			int oper_chwidth = hostapd_get_oper_chwidth(iface->conf);
-+
-+			if (oper_chwidth == CHANWIDTH_USE_HT)
- 				break;
- 			*skip_radar = 1;
--			iface->conf->vht_oper_chwidth--;
-+			hostapd_set_oper_chwidth(iface->conf, oper_chwidth - 1);
- 		}
- 	}
- 
diff --git a/package/network/services/hostapd/patches/008-mesh-use-setup-completion-callback-to-complete-mesh-.patch b/package/network/services/hostapd/patches/008-mesh-use-setup-completion-callback-to-complete-mesh-.patch
deleted file mode 100644
index 28c283d035..0000000000
--- a/package/network/services/hostapd/patches/008-mesh-use-setup-completion-callback-to-complete-mesh-.patch
+++ /dev/null
@@ -1,108 +0,0 @@
-From 11e5bbe58eebdb10793eec374b6c8ccc7daf7ec8 Mon Sep 17 00:00:00 2001
-From: Peter Oh <peter.oh@bowerswilkins.com>
-Date: Tue, 30 Jun 2020 14:18:56 +0200
-Subject: [PATCH 08/19] mesh: use setup completion callback to complete mesh
- join
-
-mesh join function is the last function to be called during
-mesh join process, but it's been called a bit earlier than
-it's supposed to be, so that some mesh parameter values
-such as VHT capabilities not applied correct when mesh join
-is in process.
-Moreover current design of mesh join that is called directly
-after mesh initialization isn't suitable for DFS channels to use,
-since mesh join process should be paused until DFS CAC is
-done and resumed after it's done.
-The callback will be called by hostapd_setup_interface_complete_sync.
-There is possiblity that completing mesh init fails, so add error
-handle codes.
-
-Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
----
- src/ap/hostapd.c      | 11 ++++++++++-
- wpa_supplicant/mesh.c | 12 ++++++++++--
- 2 files changed, 20 insertions(+), 3 deletions(-)
-
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -434,6 +434,8 @@ static void hostapd_free_hapd_data(struc
- #ifdef CONFIG_MESH
- 	wpabuf_free(hapd->mesh_pending_auth);
- 	hapd->mesh_pending_auth = NULL;
-+	/* handling setup failure is already done */
-+	hapd->setup_complete_cb = NULL;
- #endif /* CONFIG_MESH */
- 
- 	hostapd_clean_rrm(hapd);
-@@ -2156,6 +2158,13 @@ dfs_offload:
- 	if (hapd->setup_complete_cb)
- 		hapd->setup_complete_cb(hapd->setup_complete_cb_ctx);
- 
-+#ifdef CONFIG_MESH
-+	if (delay_apply_cfg && iface->mconf == NULL) {
-+		wpa_printf(MSG_ERROR, "Error while completing mesh init");
-+		goto fail;
-+	}
-+#endif /* CONFIG_MESH */
-+
- 	wpa_printf(MSG_DEBUG, "%s: Setup of interface done.",
- 		   iface->bss[0]->conf->iface);
- 	if (iface->interfaces && iface->interfaces->terminate_on_error > 0)
-@@ -2299,7 +2308,7 @@ int hostapd_setup_interface(struct hosta
- 	ret = setup_interface(iface);
- 	if (ret) {
- 		wpa_printf(MSG_ERROR, "%s: Unable to setup interface.",
--			   iface->bss[0]->conf->iface);
-+			iface->conf ? iface->conf->bss[0]->iface : "N/A");
- 		return -1;
- 	}
- 
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -193,7 +193,6 @@ static int wpas_mesh_init_rsn(struct wpa
- 	return !wpa_s->mesh_rsn ? -1 : 0;
- }
- 
--
- static int wpas_mesh_complete(struct wpa_supplicant *wpa_s)
- {
- 	struct hostapd_iface *ifmsh = wpa_s->ifmsh;
-@@ -244,6 +243,13 @@ static int wpas_mesh_complete(struct wpa
- }
- 
- 
-+static void wpas_mesh_complete_cb(void *arg)
-+{
-+	struct wpa_supplicant *wpa_s = arg;
-+	wpas_mesh_complete(wpa_s);
-+}
-+
-+
- static int wpa_supplicant_mesh_init(struct wpa_supplicant *wpa_s,
- 				    struct wpa_ssid *ssid,
- 				    struct hostapd_freq_params *freq)
-@@ -267,6 +273,7 @@ static int wpa_supplicant_mesh_init(stru
- 	if (!ifmsh)
- 		return -ENOMEM;
- 
-+	ifmsh->owner = wpa_s;
- 	ifmsh->drv_flags = wpa_s->drv_flags;
- 	ifmsh->drv_flags2 = wpa_s->drv_flags2;
- 	ifmsh->num_bss = 1;
-@@ -285,6 +292,8 @@ static int wpa_supplicant_mesh_init(stru
- 	bss->drv_priv = wpa_s->drv_priv;
- 	bss->iface = ifmsh;
- 	bss->mesh_sta_free_cb = mesh_mpm_free_sta;
-+	bss->setup_complete_cb = wpas_mesh_complete_cb;
-+	bss->setup_complete_cb_ctx = wpa_s;
- 	frequency = ssid->frequency;
- 	if (frequency != freq->freq &&
- 	    frequency == freq->freq + freq->sec_channel_offset * 20) {
-@@ -523,7 +532,6 @@ int wpa_supplicant_join_mesh(struct wpa_
- 		goto out;
- 	}
- 
--	ret = wpas_mesh_complete(wpa_s);
- out:
- 	return ret;
- }
diff --git a/package/network/services/hostapd/patches/009-mesh-update-ssid-frequency-as-pri-sec-channel-switch.patch b/package/network/services/hostapd/patches/009-mesh-update-ssid-frequency-as-pri-sec-channel-switch.patch
deleted file mode 100644
index b48de67636..0000000000
--- a/package/network/services/hostapd/patches/009-mesh-update-ssid-frequency-as-pri-sec-channel-switch.patch
+++ /dev/null
@@ -1,26 +0,0 @@
-From 87c5e8883898e7eb8e9637e212350c1925a22654 Mon Sep 17 00:00:00 2001
-From: Peter Oh <peter.oh@bowerswilkins.com>
-Date: Tue, 30 Jun 2020 14:18:57 +0200
-Subject: [PATCH 09/19] mesh: update ssid->frequency as pri/sec channel switch
-
-ssid->frequency is one of variables used to gets channel
-number from given frequency. Leave it as unchanged when
-pri/sec channel switched will cause picking up wrong
-channel number after applying secondary channel offset
-for HT40 and leads failing interface bring-up.
-
-Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
----
- wpa_supplicant/mesh.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -299,6 +299,7 @@ static int wpa_supplicant_mesh_init(stru
- 	    frequency == freq->freq + freq->sec_channel_offset * 20) {
- 		wpa_printf(MSG_DEBUG, "mesh: pri/sec channels switched");
- 		frequency = freq->freq;
-+		ssid->frequency = frequency;
- 	}
- 	wpa_s->assoc_freq = frequency;
- 	wpa_s->current_ssid = ssid;
diff --git a/package/network/services/hostapd/patches/010-mesh-Allow-DFS-channels-to-be-selected-if-dfs-is-ena.patch b/package/network/services/hostapd/patches/010-mesh-Allow-DFS-channels-to-be-selected-if-dfs-is-ena.patch
index 8afeba93ed..d948c41b30 100644
--- a/package/network/services/hostapd/patches/010-mesh-Allow-DFS-channels-to-be-selected-if-dfs-is-ena.patch
+++ b/package/network/services/hostapd/patches/010-mesh-Allow-DFS-channels-to-be-selected-if-dfs-is-ena.patch
@@ -14,7 +14,7 @@ Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
 
 --- a/wpa_supplicant/wpa_supplicant.c
 +++ b/wpa_supplicant/wpa_supplicant.c
-@@ -2349,6 +2349,8 @@ void ibss_mesh_setup_freq(struct wpa_sup
+@@ -2395,6 +2395,8 @@ void ibss_mesh_setup_freq(struct wpa_sup
  	int chwidth, seg0, seg1;
  	u32 vht_caps = 0;
  	int is_24ghz;
@@ -23,7 +23,7 @@ Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
  
  	freq->freq = ssid->frequency;
  
-@@ -2436,8 +2438,11 @@ void ibss_mesh_setup_freq(struct wpa_sup
+@@ -2484,8 +2486,11 @@ void ibss_mesh_setup_freq(struct wpa_sup
  		return;
  
  	/* Check primary channel flags */
@@ -36,7 +36,7 @@ Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
  
  	freq->channel = pri_chan->chan;
  
-@@ -2470,8 +2475,11 @@ void ibss_mesh_setup_freq(struct wpa_sup
+@@ -2518,8 +2523,11 @@ void ibss_mesh_setup_freq(struct wpa_sup
  		return;
  
  	/* Check secondary channel flags */
@@ -49,7 +49,7 @@ Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
  
  	if (ht40 == -1) {
  		if (!(pri_chan->flag & HOSTAPD_CHAN_HT40MINUS))
-@@ -2564,8 +2572,11 @@ skip_ht40:
+@@ -2612,8 +2620,11 @@ skip_ht40:
  			return;
  
  		/* Back to HT configuration if channel not usable */
@@ -62,7 +62,7 @@ Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
  	}
  
  	chwidth = CHANWIDTH_80MHZ;
-@@ -2585,10 +2596,12 @@ skip_ht40:
+@@ -2633,10 +2644,12 @@ skip_ht40:
  				if (!chan)
  					continue;
  
diff --git a/package/network/services/hostapd/patches/011-mesh-do-not-set-offchanok-on-DFS-channels-in-non-ETS.patch b/package/network/services/hostapd/patches/011-mesh-do-not-set-offchanok-on-DFS-channels-in-non-ETS.patch
deleted file mode 100644
index d491f7c4bc..0000000000
--- a/package/network/services/hostapd/patches/011-mesh-do-not-set-offchanok-on-DFS-channels-in-non-ETS.patch
+++ /dev/null
@@ -1,53 +0,0 @@
-From af8dcbc87466ed6472850a4f1cfe252652cb3d26 Mon Sep 17 00:00:00 2001
-From: Peter Oh <peter.oh@bowerswilkins.com>
-Date: Tue, 30 Jun 2020 14:18:59 +0200
-Subject: [PATCH 11/19] mesh: do not set offchanok on DFS channels in non-ETSI
-
-mac80211 does not allow mgmt tx to use off channel on
-DFS channels in non-ETSI domain, because it will invalidate
-CAC result on current operating channel.
-(mac80211 commit: 34373d12f3cbb74960a73431138ef619d857996f)
-Hence don't set offchanok for mgmt tx in case of DFS channels
-in non-ETSI.
-
-Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
----
- src/drivers/driver_nl80211.c | 19 +++++++++++++++++++
- 1 file changed, 19 insertions(+)
-
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -7788,7 +7788,11 @@ static int wpa_driver_nl80211_send_actio
- 	int ret = -1;
- 	u8 *buf;
- 	struct ieee80211_hdr *hdr;
-+	struct hostapd_hw_modes *modes;
- 	int offchanok = 1;
-+	u16 num_modes, flags;
-+	u8 dfs_domain;
-+	int i;
- 
- 	if (is_ap_interface(drv->nlmode) && (int) freq == bss->freq &&
- 	    bss->beacon_set)
-@@ -7817,6 +7821,21 @@ static int wpa_driver_nl80211_send_actio
- 		os_memset(bss->rand_addr, 0, ETH_ALEN);
- 	}
- 
-+	if (is_mesh_interface(drv->nlmode)) {
-+		modes = nl80211_get_hw_feature_data(bss, &num_modes,
-+						    &flags, &dfs_domain);
-+		if (dfs_domain != HOSTAPD_DFS_REGION_ETSI &&
-+		    ieee80211_is_dfs(bss->freq, modes, num_modes))
-+			offchanok = 0;
-+		if (modes) {
-+			for (i = 0; i < num_modes; i++) {
-+				os_free(modes[i].channels);
-+				os_free(modes[i].rates);
-+			}
-+			os_free(modes);
-+		}
-+	}
-+
- 	if (is_ap_interface(drv->nlmode) &&
- 	    (!(drv->capa.flags & WPA_DRIVER_FLAGS_OFFCHANNEL_TX) ||
- 	     (int) freq == bss->freq || drv->device_ap_sme ||
diff --git a/package/network/services/hostapd/patches/019-mesh-use-deterministic-channel-on-channel-switch.patch b/package/network/services/hostapd/patches/011-mesh-use-deterministic-channel-on-channel-switch.patch
similarity index 97%
rename from package/network/services/hostapd/patches/019-mesh-use-deterministic-channel-on-channel-switch.patch
rename to package/network/services/hostapd/patches/011-mesh-use-deterministic-channel-on-channel-switch.patch
index 8e38a8e53c..03a1e339a9 100644
--- a/package/network/services/hostapd/patches/019-mesh-use-deterministic-channel-on-channel-switch.patch
+++ b/package/network/services/hostapd/patches/011-mesh-use-deterministic-channel-on-channel-switch.patch
@@ -68,7 +68,7 @@ Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
  	if (!chan) {
 --- a/src/drivers/driver_nl80211.c
 +++ b/src/drivers/driver_nl80211.c
-@@ -9473,6 +9473,10 @@ static int nl80211_switch_channel(void *
+@@ -9872,6 +9872,10 @@ static int nl80211_switch_channel(void *
  	if (ret)
  		goto error;
  
diff --git a/package/network/services/hostapd/patches/012-mesh-fix-channel-switch-error-during-CAC.patch b/package/network/services/hostapd/patches/012-mesh-fix-channel-switch-error-during-CAC.patch
deleted file mode 100644
index f324d81ae3..0000000000
--- a/package/network/services/hostapd/patches/012-mesh-fix-channel-switch-error-during-CAC.patch
+++ /dev/null
@@ -1,66 +0,0 @@
-From ab6995f15aae17af93507dd2344615f91672a31a Mon Sep 17 00:00:00 2001
-From: Peter Oh <peter.oh@bowerswilkins.com>
-Date: Tue, 30 Jun 2020 14:19:00 +0200
-Subject: [PATCH 12/19] mesh: fix channel switch error during CAC
-
-Mesh interface has used its channel parameters that configured
-during its initialization even after channel switched due to
-DFS radar detection during CAC which caused channel switch error.
-This change fixes the error by updating its channel parameters
-when channel's been changed from initial one.
-
-Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
----
- wpa_supplicant/mesh.c | 34 ++++++++++++++++++++++++++++++++++
- 1 file changed, 34 insertions(+)
-
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -13,6 +13,7 @@
- #include "utils/uuid.h"
- #include "common/ieee802_11_defs.h"
- #include "common/wpa_ctrl.h"
-+#include "common/hw_features_common.h"
- #include "ap/sta_info.h"
- #include "ap/hostapd.h"
- #include "ap/ieee802_11.h"
-@@ -206,6 +207,39 @@ static int wpas_mesh_complete(struct wpa
- 		return -1;
- 	}
- 
-+	/*
-+	 * inspect if channel's been changed since initialized.
-+	 * i.e. DFS radar detection
-+	 */
-+	if (ifmsh->freq != params->freq.freq) {
-+		wpa_s->assoc_freq = ifmsh->freq;
-+		ssid->frequency = ifmsh->freq;
-+		struct he_capabilities *he_capab = NULL;
-+
-+		if (ifmsh->current_mode)
-+			he_capab = &ifmsh->current_mode->he_capab[IEEE80211_MODE_MESH];
-+
-+		if (hostapd_set_freq_params(&params->freq,
-+				ifmsh->conf->hw_mode,
-+				ifmsh->freq,
-+				ifmsh->conf->channel,
-+				ifmsh->conf->enable_edmg,
-+				ifmsh->conf->edmg_channel,
-+				ifmsh->conf->ieee80211n,
-+				ifmsh->conf->ieee80211ac,
-+				ifmsh->conf->ieee80211ax,
-+				ifmsh->conf->secondary_channel,
-+				hostapd_get_oper_chwidth(ifmsh->conf),
-+				hostapd_get_oper_centr_freq_seg0_idx(ifmsh->conf),
-+				hostapd_get_oper_centr_freq_seg1_idx(ifmsh->conf),
-+				ifmsh->conf->vht_capab,
-+				he_capab)) {
-+			wpa_printf(MSG_ERROR, "Error updating mesh frequency params.");
-+			wpa_supplicant_mesh_deinit(wpa_s);
-+			return -1;
-+		}
-+	}
-+
- 	if (ifmsh->mconf->security != MESH_CONF_SEC_NONE &&
- 	    wpas_mesh_init_rsn(wpa_s)) {
- 		wpa_printf(MSG_ERROR,
diff --git a/package/network/services/hostapd/patches/013-mesh-inform-kernel-driver-DFS-handler-in-userspace.patch b/package/network/services/hostapd/patches/013-mesh-inform-kernel-driver-DFS-handler-in-userspace.patch
deleted file mode 100644
index fb4e68636e..0000000000
--- a/package/network/services/hostapd/patches/013-mesh-inform-kernel-driver-DFS-handler-in-userspace.patch
+++ /dev/null
@@ -1,48 +0,0 @@
-From f1118eca5b1a63a4acb2a11ceea15dc4bc259c77 Mon Sep 17 00:00:00 2001
-From: Peter Oh <peter.oh@bowerswilkins.com>
-Date: Tue, 30 Jun 2020 14:19:01 +0200
-Subject: [PATCH 13/19] mesh: inform kernel driver DFS handler in userspace
-
-NL80211_ATTR_HANDLE_DFS is required by kerenel space
-to enable DFS channels that indicates DFS handler
-resides in userspace.
-
-Signed-off-by: Peter Oh <peter.oh@bowerswilkins.com>
----
- src/drivers/driver.h         | 1 +
- src/drivers/driver_nl80211.c | 3 +++
- wpa_supplicant/mesh.c        | 1 +
- 3 files changed, 5 insertions(+)
-
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -1542,6 +1542,7 @@ struct wpa_driver_mesh_join_params {
- #define WPA_DRIVER_MESH_FLAG_SAE_AUTH	0x00000004
- #define WPA_DRIVER_MESH_FLAG_AMPE	0x00000008
- 	unsigned int flags;
-+	u8 handle_dfs;
- };
- 
- struct wpa_driver_set_key_params {
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -10070,6 +10070,9 @@ static int nl80211_join_mesh(struct i802
- 
- 	wpa_printf(MSG_DEBUG, "  * flags=%08X", params->flags);
- 
-+	if (params->handle_dfs)
-+		if (nla_put_flag(msg, NL80211_ATTR_HANDLE_DFS))
-+			goto fail;
- 	container = nla_nest_start(msg, NL80211_ATTR_MESH_SETUP);
- 	if (!container)
- 		goto fail;
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -355,6 +355,7 @@ static int wpa_supplicant_mesh_init(stru
- 		conf->country[0] = wpa_s->conf->country[0];
- 		conf->country[1] = wpa_s->conf->country[1];
- 		conf->country[2] = ' ';
-+		wpa_s->mesh_params->handle_dfs = 1;
- 	}
- 
- 	bss->iconf = conf;
diff --git a/package/network/services/hostapd/patches/014-mesh-fixes-for-mesh-init-deinit.patch b/package/network/services/hostapd/patches/014-mesh-fixes-for-mesh-init-deinit.patch
deleted file mode 100644
index fe12d401e4..0000000000
--- a/package/network/services/hostapd/patches/014-mesh-fixes-for-mesh-init-deinit.patch
+++ /dev/null
@@ -1,158 +0,0 @@
-From 30bdefd7559d57eae8c3c7e6f721ecf7be929bf2 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 14:19:02 +0200
-Subject: [PATCH 14/19] mesh: fixes for mesh init/deinit
-
-Send mesh group started notification after join completion
-callback is called.
-
-Implement outstanding TODO, to leave the mesh network on deinit.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- wpa_supplicant/mesh.c           | 32 ++++++++++++++++++++------------
- wpa_supplicant/mesh.h           |  6 ++++--
- wpa_supplicant/wpa_supplicant.c |  8 ++------
- 3 files changed, 26 insertions(+), 20 deletions(-)
-
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -30,20 +30,20 @@
- 
- static void wpa_supplicant_mesh_deinit(struct wpa_supplicant *wpa_s)
- {
--	wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh);
-+	wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh, true);
- 	wpa_s->ifmsh = NULL;
- 	wpa_s->current_ssid = NULL;
- 	os_free(wpa_s->mesh_rsn);
- 	wpa_s->mesh_rsn = NULL;
- 	os_free(wpa_s->mesh_params);
- 	wpa_s->mesh_params = NULL;
--	/* TODO: leave mesh (stop beacon). This will happen on link down
--	 * anyway, so it's not urgent */
-+	wpa_supplicant_leave_mesh(wpa_s, false);
- }
- 
- 
- void wpa_supplicant_mesh_iface_deinit(struct wpa_supplicant *wpa_s,
--				      struct hostapd_iface *ifmsh)
-+				      struct hostapd_iface *ifmsh,
-+				      bool also_clear_hostapd)
- {
- 	if (!ifmsh)
- 		return;
-@@ -64,8 +64,10 @@ void wpa_supplicant_mesh_iface_deinit(st
- 	}
- 
- 	/* take care of shared data */
--	hostapd_interface_deinit(ifmsh);
--	hostapd_interface_free(ifmsh);
-+	if (also_clear_hostapd) {
-+		hostapd_interface_deinit(ifmsh);
-+		hostapd_interface_free(ifmsh);
-+	}
- }
- 
- 
-@@ -244,8 +246,7 @@ static int wpas_mesh_complete(struct wpa
- 	    wpas_mesh_init_rsn(wpa_s)) {
- 		wpa_printf(MSG_ERROR,
- 			   "mesh: RSN initialization failed - deinit mesh");
--		wpa_supplicant_mesh_deinit(wpa_s);
--		wpa_drv_leave_mesh(wpa_s);
-+		wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh, false);
- 		return -1;
- 	}
- 
-@@ -270,9 +271,15 @@ static int wpas_mesh_complete(struct wpa
- 	/* hostapd sets the interface down until we associate */
- 	wpa_drv_set_operstate(wpa_s, 1);
- 
--	if (!ret)
-+	if (!ret) {
- 		wpa_supplicant_set_state(wpa_s, WPA_COMPLETED);
- 
-+		wpa_msg(wpa_s, MSG_INFO, MESH_GROUP_STARTED "ssid=\"%s\" id=%d",
-+			wpa_ssid_txt(ssid->ssid, ssid->ssid_len),
-+			ssid->id);
-+		wpas_notify_mesh_group_started(wpa_s, ssid);
-+	}
-+
- 	return ret;
- }
- 
-@@ -563,7 +570,7 @@ int wpa_supplicant_join_mesh(struct wpa_
- 	wpa_s->mesh_params = params;
- 	if (wpa_supplicant_mesh_init(wpa_s, ssid, &params->freq)) {
- 		wpa_msg(wpa_s, MSG_ERROR, "Failed to init mesh");
--		wpa_drv_leave_mesh(wpa_s);
-+		wpa_supplicant_leave_mesh(wpa_s, true);
- 		ret = -1;
- 		goto out;
- 	}
-@@ -573,14 +580,15 @@ out:
- }
- 
- 
--int wpa_supplicant_leave_mesh(struct wpa_supplicant *wpa_s)
-+int wpa_supplicant_leave_mesh(struct wpa_supplicant *wpa_s, bool need_deinit)
- {
- 	int ret = 0;
- 
- 	wpa_msg(wpa_s, MSG_INFO, "leaving mesh");
- 
- 	/* Need to send peering close messages first */
--	wpa_supplicant_mesh_deinit(wpa_s);
-+	if (need_deinit)
-+		wpa_supplicant_mesh_deinit(wpa_s);
- 
- 	ret = wpa_drv_leave_mesh(wpa_s);
- 	if (ret)
---- a/wpa_supplicant/mesh.h
-+++ b/wpa_supplicant/mesh.h
-@@ -11,9 +11,11 @@
- 
- int wpa_supplicant_join_mesh(struct wpa_supplicant *wpa_s,
- 			     struct wpa_ssid *ssid);
--int wpa_supplicant_leave_mesh(struct wpa_supplicant *wpa_s);
-+int wpa_supplicant_leave_mesh(struct wpa_supplicant *wpa_s,
-+			      bool need_deinit);
- void wpa_supplicant_mesh_iface_deinit(struct wpa_supplicant *wpa_s,
--				      struct hostapd_iface *ifmsh);
-+				      struct hostapd_iface *ifmsh,
-+				      bool also_clear_hostapd);
- int wpas_mesh_scan_result_text(const u8 *ies, size_t ies_len, char *buf,
- 			       char *end);
- int wpas_mesh_add_interface(struct wpa_supplicant *wpa_s, char *ifname,
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -2225,10 +2225,6 @@ void wpa_supplicant_associate(struct wpa
- 			return;
- 		}
- 		wpa_s->current_bss = bss;
--		wpa_msg(wpa_s, MSG_INFO, MESH_GROUP_STARTED "ssid=\"%s\" id=%d",
--			wpa_ssid_txt(ssid->ssid, ssid->ssid_len),
--			ssid->id);
--		wpas_notify_mesh_group_started(wpa_s, ssid);
- #else /* CONFIG_MESH */
- 		wpa_msg(wpa_s, MSG_ERROR,
- 			"mesh mode support not included in the build");
-@@ -3938,7 +3934,7 @@ void wpa_supplicant_deauthenticate(struc
- 			wpa_s->ifname);
- 		wpas_notify_mesh_group_removed(wpa_s, mconf->meshid,
- 					       mconf->meshid_len, reason_code);
--		wpa_supplicant_leave_mesh(wpa_s);
-+		wpa_supplicant_leave_mesh(wpa_s, true);
- 	}
- #endif /* CONFIG_MESH */
- 
-@@ -6551,7 +6547,7 @@ static void wpa_supplicant_deinit_iface(
- 
- #ifdef CONFIG_MESH
- 	if (wpa_s->ifmsh) {
--		wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh);
-+		wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh, true);
- 		wpa_s->ifmsh = NULL;
- 	}
- #endif /* CONFIG_MESH */
diff --git a/package/network/services/hostapd/patches/015-mesh-fix-DFS-deinit-init.patch b/package/network/services/hostapd/patches/015-mesh-fix-DFS-deinit-init.patch
deleted file mode 100644
index c540dd6786..0000000000
--- a/package/network/services/hostapd/patches/015-mesh-fix-DFS-deinit-init.patch
+++ /dev/null
@@ -1,262 +0,0 @@
-From d017f5d98a143c46c3c3fcb0e6507ca0b2bebdb0 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 14:19:03 +0200
-Subject: [PATCH 15/19] mesh: fix DFS deinit/init
-
-The hostapd DFS code deinitializes and initializes the
-AP interface, if a clean channel switch is not possible.
-In this case the AP code paths would deinit the driver, for
-example nl80211, without wpa_supplicant code paths getting
-notice of this.
-
-Therefore add callbacks for wpa_supplicant mesh methods,
-which are called on init/deinit of the AP bss. These
-callbacks are then used to handle the reset in the mesh
-code.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- src/ap/dfs.c          |  2 +-
- src/ap/hostapd.c      | 17 ++++++--
- src/ap/hostapd.h      |  6 +++
- wpa_supplicant/mesh.c | 90 +++++++++++++++++++++++++++++++++++++------
- 4 files changed, 100 insertions(+), 15 deletions(-)
-
---- a/src/ap/dfs.c
-+++ b/src/ap/dfs.c
-@@ -1112,7 +1112,7 @@ static int hostapd_dfs_start_channel_swi
- 				      oper_centr_freq_seg0_idx,
- 				      oper_centr_freq_seg1_idx,
- 				      cmode->vht_capab,
--				      &cmode->he_capab[IEEE80211_MODE_AP]);
-+				      &cmode->he_capab[iface->conf->hw_mode]);
- 
- 	if (err) {
- 		wpa_printf(MSG_ERROR, "DFS failed to calculate CSA freq params");
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -354,7 +354,7 @@ static int hostapd_broadcast_wep_set(str
- #endif /* CONFIG_WEP */
- 
- 
--static void hostapd_free_hapd_data(struct hostapd_data *hapd)
-+void hostapd_free_hapd_data(struct hostapd_data *hapd)
- {
- 	os_free(hapd->probereq_cb);
- 	hapd->probereq_cb = NULL;
-@@ -498,7 +498,7 @@ static void sta_track_deinit(struct host
- }
- 
- 
--static void hostapd_cleanup_iface_partial(struct hostapd_iface *iface)
-+void hostapd_cleanup_iface_partial(struct hostapd_iface *iface)
- {
- 	wpa_printf(MSG_DEBUG, "%s(%p)", __func__, iface);
- #ifdef NEED_AP_MLME
-@@ -626,7 +626,7 @@ static int hostapd_flush_old_stations(st
- }
- 
- 
--static void hostapd_bss_deinit_no_free(struct hostapd_data *hapd)
-+void hostapd_bss_deinit_no_free(struct hostapd_data *hapd)
- {
- 	hostapd_free_stas(hapd);
- 	hostapd_flush_old_stations(hapd, WLAN_REASON_DEAUTH_LEAVING);
-@@ -2690,6 +2690,13 @@ int hostapd_enable_iface(struct hostapd_
- {
- 	size_t j;
- 
-+	if (hapd_iface == NULL)
-+		return -1;
-+
-+	if (hapd_iface->enable_iface_cb != NULL) {
-+		return hapd_iface->enable_iface_cb(hapd_iface);
-+	}
-+
- 	if (hapd_iface->bss[0]->drv_priv != NULL) {
- 		wpa_printf(MSG_ERROR, "Interface %s already enabled",
- 			   hapd_iface->conf->bss[0]->iface);
-@@ -2751,6 +2758,10 @@ int hostapd_disable_iface(struct hostapd
- 	if (hapd_iface == NULL)
- 		return -1;
- 
-+	if (hapd_iface->disable_iface_cb != NULL) {
-+		return hapd_iface->disable_iface_cb(hapd_iface);
-+	}
-+
- 	if (hapd_iface->bss[0]->drv_priv == NULL) {
- 		wpa_printf(MSG_INFO, "Interface %s already disabled",
- 			   hapd_iface->conf->bss[0]->iface);
---- a/src/ap/hostapd.h
-+++ b/src/ap/hostapd.h
-@@ -589,6 +589,9 @@ struct hostapd_iface {
- 
- 	/* Previous WMM element information */
- 	struct hostapd_wmm_ac_params prev_wmm[WMM_AC_NUM];
-+
-+	int (*enable_iface_cb)(struct hostapd_iface *iface);
-+	int (*disable_iface_cb)(struct hostapd_iface *iface);
- };
- 
- /* hostapd.c */
-@@ -617,6 +620,9 @@ void hostapd_interface_deinit_free(struc
- int hostapd_enable_iface(struct hostapd_iface *hapd_iface);
- int hostapd_reload_iface(struct hostapd_iface *hapd_iface);
- int hostapd_disable_iface(struct hostapd_iface *hapd_iface);
-+void hostapd_bss_deinit_no_free(struct hostapd_data *hapd);
-+void hostapd_free_hapd_data(struct hostapd_data *hapd);
-+void hostapd_cleanup_iface_partial(struct hostapd_iface *iface);
- int hostapd_add_iface(struct hapd_interfaces *ifaces, char *buf);
- int hostapd_remove_iface(struct hapd_interfaces *ifaces, char *buf);
- void hostapd_channel_list_updated(struct hostapd_iface *iface, int initiator);
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -28,15 +28,20 @@
- #include "mesh.h"
- 
- 
--static void wpa_supplicant_mesh_deinit(struct wpa_supplicant *wpa_s)
-+static void wpa_supplicant_mesh_deinit(struct wpa_supplicant *wpa_s, bool also_clear_hostapd)
- {
--	wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh, true);
--	wpa_s->ifmsh = NULL;
--	wpa_s->current_ssid = NULL;
-+	wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh, also_clear_hostapd);
-+
-+	if (also_clear_hostapd) {
-+		wpa_s->ifmsh = NULL;
-+		wpa_s->current_ssid = NULL;
-+		os_free(wpa_s->mesh_params);
-+		wpa_s->mesh_params = NULL;
-+	}
-+
- 	os_free(wpa_s->mesh_rsn);
- 	wpa_s->mesh_rsn = NULL;
--	os_free(wpa_s->mesh_params);
--	wpa_s->mesh_params = NULL;
-+
- 	wpa_supplicant_leave_mesh(wpa_s, false);
- }
- 
-@@ -237,7 +242,7 @@ static int wpas_mesh_complete(struct wpa
- 				ifmsh->conf->vht_capab,
- 				he_capab)) {
- 			wpa_printf(MSG_ERROR, "Error updating mesh frequency params.");
--			wpa_supplicant_mesh_deinit(wpa_s);
-+			wpa_supplicant_mesh_deinit(wpa_s, true);
- 			return -1;
- 		}
- 	}
-@@ -246,7 +251,7 @@ static int wpas_mesh_complete(struct wpa
- 	    wpas_mesh_init_rsn(wpa_s)) {
- 		wpa_printf(MSG_ERROR,
- 			   "mesh: RSN initialization failed - deinit mesh");
--		wpa_supplicant_mesh_iface_deinit(wpa_s, wpa_s->ifmsh, false);
-+		wpa_supplicant_mesh_deinit(wpa_s, false);
- 		return -1;
- 	}
- 
-@@ -291,6 +296,67 @@ static void wpas_mesh_complete_cb(void *
- }
- 
- 
-+static int wpa_supplicant_mesh_enable_iface_cb(struct hostapd_iface *ifmsh)
-+{
-+	struct wpa_supplicant *wpa_s = ifmsh->owner;
-+	struct hostapd_data *bss;
-+
-+	ifmsh->mconf = mesh_config_create(wpa_s, wpa_s->current_ssid);
-+
-+	bss = ifmsh->bss[0];
-+	bss->msg_ctx = wpa_s;
-+	os_memcpy(bss->own_addr, wpa_s->own_addr, ETH_ALEN);
-+	bss->driver = wpa_s->driver;
-+	bss->drv_priv = wpa_s->drv_priv;
-+	bss->iface = ifmsh;
-+	bss->mesh_sta_free_cb = mesh_mpm_free_sta;
-+	bss->setup_complete_cb = wpas_mesh_complete_cb;
-+	bss->setup_complete_cb_ctx = wpa_s;
-+
-+	bss->conf->start_disabled = 1;
-+	bss->conf->mesh = MESH_ENABLED;
-+	bss->conf->ap_max_inactivity = wpa_s->conf->mesh_max_inactivity;
-+
-+	if (wpa_drv_init_mesh(wpa_s)) {
-+		wpa_msg(wpa_s, MSG_ERROR, "Failed to init mesh in driver");
-+		return -1;
-+	}
-+
-+	if (hostapd_setup_interface(ifmsh)) {
-+		wpa_printf(MSG_ERROR,
-+			   "Failed to initialize hostapd interface for mesh");
-+		return -1;
-+	}
-+
-+	return 0;
-+}
-+
-+
-+static int wpa_supplicant_mesh_disable_iface_cb(struct hostapd_iface *ifmsh)
-+{
-+	struct wpa_supplicant *wpa_s = ifmsh->owner;
-+	int j;
-+
-+	wpa_supplicant_mesh_deinit(wpa_s, false);
-+
-+#ifdef NEED_AP_MLME
-+	for (j = 0; j < ifmsh->num_bss; j++)
-+		hostapd_cleanup_cs_params(ifmsh->bss[j]);
-+#endif /* NEED_AP_MLME */
-+
-+	/* same as hostapd_interface_deinit without deinitializing ctrl-iface */
-+	for (j = 0; j < ifmsh->num_bss; j++) {
-+		struct hostapd_data *hapd = ifmsh->bss[j];
-+		hostapd_bss_deinit_no_free(hapd);
-+		hostapd_free_hapd_data(hapd);
-+	}
-+
-+	hostapd_cleanup_iface_partial(ifmsh);
-+
-+	return 0;
-+}
-+
-+
- static int wpa_supplicant_mesh_init(struct wpa_supplicant *wpa_s,
- 				    struct wpa_ssid *ssid,
- 				    struct hostapd_freq_params *freq)
-@@ -318,6 +384,8 @@ static int wpa_supplicant_mesh_init(stru
- 	ifmsh->drv_flags = wpa_s->drv_flags;
- 	ifmsh->drv_flags2 = wpa_s->drv_flags2;
- 	ifmsh->num_bss = 1;
-+	ifmsh->enable_iface_cb = wpa_supplicant_mesh_enable_iface_cb;
-+	ifmsh->disable_iface_cb = wpa_supplicant_mesh_disable_iface_cb;
- 	ifmsh->bss = os_calloc(wpa_s->ifmsh->num_bss,
- 			       sizeof(struct hostapd_data *));
- 	if (!ifmsh->bss)
-@@ -451,7 +519,7 @@ static int wpa_supplicant_mesh_init(stru
- 
- 	return 0;
- out_free:
--	wpa_supplicant_mesh_deinit(wpa_s);
-+	wpa_supplicant_mesh_deinit(wpa_s, true);
- 	return -ENOMEM;
- }
- 
-@@ -499,7 +567,7 @@ int wpa_supplicant_join_mesh(struct wpa_
- 		goto out;
- 	}
- 
--	wpa_supplicant_mesh_deinit(wpa_s);
-+	wpa_supplicant_mesh_deinit(wpa_s, true);
- 
- 	wpa_s->pairwise_cipher = WPA_CIPHER_NONE;
- 	wpa_s->group_cipher = WPA_CIPHER_NONE;
-@@ -588,7 +656,7 @@ int wpa_supplicant_leave_mesh(struct wpa
- 
- 	/* Need to send peering close messages first */
- 	if (need_deinit)
--		wpa_supplicant_mesh_deinit(wpa_s);
-+		wpa_supplicant_mesh_deinit(wpa_s, true);
- 
- 	ret = wpa_drv_leave_mesh(wpa_s);
- 	if (ret)
diff --git a/package/network/services/hostapd/patches/016-tests-DFS-test-for-wpa_supplicant-mesh.patch b/package/network/services/hostapd/patches/016-tests-DFS-test-for-wpa_supplicant-mesh.patch
deleted file mode 100644
index b6a51b2f35..0000000000
--- a/package/network/services/hostapd/patches/016-tests-DFS-test-for-wpa_supplicant-mesh.patch
+++ /dev/null
@@ -1,94 +0,0 @@
-From 6ee4e70d469b8ce05013ed524eea32ea303e6563 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 14:19:04 +0200
-Subject: [PATCH 16/19] tests: DFS test for wpa_supplicant mesh
-
-Add a test with uses a DFS channel, waits for CAC
-afterwards successfull mesh join and then triggers
-a radar event and check if the mesh comes up again
-on the same device.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- tests/hwsim/test_wpas_mesh.py | 56 +++++++++++++++++++++++++++++++++--
- 1 file changed, 54 insertions(+), 2 deletions(-)
-
---- a/tests/hwsim/test_wpas_mesh.py
-+++ b/tests/hwsim/test_wpas_mesh.py
-@@ -80,8 +80,23 @@ def check_mesh_scan(dev, params, other_s
-     if '[MESH]' not in bss['flags']:
-         raise Exception("BSS output did not include MESH flag")
- 
--def check_mesh_group_added(dev):
--    ev = dev.wait_event(["MESH-GROUP-STARTED"])
-+def check_dfs_started(dev, timeout=10):
-+    ev = dev.wait_event(["DFS-CAC-START"], timeout=timeout)
-+    if ev is None:
-+        raise Exception("Test exception: CAC did not start")
-+
-+def check_dfs_finished(dev, timeout=70):
-+    ev = dev.wait_event(["DFS-CAC-COMPLETED"], timeout=timeout)
-+    if ev is None:
-+        raise Exception("Test exception: CAC did not finish")
-+
-+def check_mesh_radar_handling_finished(dev, timeout=75):
-+    ev = dev.wait_event(["CTRL-EVENT-CHANNEL-SWITCH", "MESH-GROUP-STARTED"], timeout=timeout)
-+    if ev is None:
-+        raise Exception("Test exception: Couldn't join mesh")
-+
-+def check_mesh_group_added(dev, timeout=10):
-+    ev = dev.wait_event(["MESH-GROUP-STARTED"], timeout=timeout)
-     if ev is None:
-         raise Exception("Test exception: Couldn't join mesh")
- 
-@@ -91,6 +106,10 @@ def check_mesh_group_removed(dev):
-     if ev is None:
-         raise Exception("Test exception: Couldn't leave mesh")
- 
-+def check_regdom_change(dev, timeout=10):
-+    ev = dev.wait_event(["CTRL-EVENT-REGDOM-CHANGE"], timeout=timeout)
-+    if ev is None:
-+        raise Exception("Test exception: No regdom change happened.")
- 
- def check_mesh_peer_connected(dev, timeout=10):
-     ev = dev.wait_event(["MESH-PEER-CONNECTED"], timeout=timeout)
-@@ -167,6 +186,39 @@ def test_wpas_mesh_group_remove(dev):
-     check_mesh_group_removed(dev[0])
-     dev[0].mesh_group_remove()
- 
-+def dfs_simulate_radar(dev):
-+    logger.info("Trigger a simulated radar event")
-+    phyname = dev.get_driver_status_field("phyname")
-+    radar_file = '/sys/kernel/debug/ieee80211/' + phyname + '/hwsim/dfs_simulate_radar'
-+    with open(radar_file, 'w') as f:
-+        f.write('1')
-+
-+@long_duration_test
-+def test_wpas_mesh_peer_connected_dfs(dev):
-+    """wpa_supplicant MESH peer connected"""
-+    dev[0].set("country", "DE")
-+    dev[1].set("country", "DE")
-+
-+    check_regdom_change(dev[0])
-+    check_regdom_change(dev[1])
-+
-+    check_mesh_support(dev[0])
-+    add_open_mesh_network(dev[0], freq="5500", beacon_int=160)
-+    add_open_mesh_network(dev[1], freq="5500", beacon_int=160)
-+    check_dfs_started(dev[0])
-+    check_dfs_finished(dev[0])
-+    check_mesh_joined_connected(dev, timeout0=10)
-+
-+    dfs_simulate_radar(dev[0])
-+
-+    check_mesh_radar_handling_finished(dev[0], timeout=75)
-+
-+    dev[0].set("country", "00")
-+    dev[1].set("country", "00")
-+
-+    check_regdom_change(dev[0])
-+    check_regdom_change(dev[1])
-+
- def test_wpas_mesh_peer_connected(dev):
-     """wpa_supplicant MESH peer connected"""
-     check_mesh_support(dev[0])
diff --git a/package/network/services/hostapd/patches/017-mesh-fix-mesh_oom-test.patch b/package/network/services/hostapd/patches/017-mesh-fix-mesh_oom-test.patch
deleted file mode 100644
index cc566c7de2..0000000000
--- a/package/network/services/hostapd/patches/017-mesh-fix-mesh_oom-test.patch
+++ /dev/null
@@ -1,24 +0,0 @@
-From 928da9a270deaf4409aee4d87a33a6f61b56c136 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 14:19:05 +0200
-Subject: [PATCH 17/19] mesh: fix mesh_oom test
-
-Only change freq params, if ifmsh->freq is set initially, which only
-happens if hostapd_get_hw_features in setup_interface2 succeeds.
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- wpa_supplicant/mesh.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -218,7 +218,7 @@ static int wpas_mesh_complete(struct wpa
- 	 * inspect if channel's been changed since initialized.
- 	 * i.e. DFS radar detection
- 	 */
--	if (ifmsh->freq != params->freq.freq) {
-+	if (ifmsh->freq > 0 && ifmsh->freq != params->freq.freq) {
- 		wpa_s->assoc_freq = ifmsh->freq;
- 		ssid->frequency = ifmsh->freq;
- 		struct he_capabilities *he_capab = NULL;
diff --git a/package/network/services/hostapd/patches/018-mesh-move-mesh-freq-setting-to-own-function.patch b/package/network/services/hostapd/patches/018-mesh-move-mesh-freq-setting-to-own-function.patch
deleted file mode 100644
index 1dd7d37411..0000000000
--- a/package/network/services/hostapd/patches/018-mesh-move-mesh-freq-setting-to-own-function.patch
+++ /dev/null
@@ -1,93 +0,0 @@
-From 1eab0e62920f443f8814bad846f6439843223b69 Mon Sep 17 00:00:00 2001
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Tue, 30 Jun 2020 14:19:06 +0200
-Subject: [PATCH 18/19] mesh: move mesh freq setting to own function
-
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
----
- wpa_supplicant/mesh.c | 59 ++++++++++++++++++++++++++-----------------
- 1 file changed, 36 insertions(+), 23 deletions(-)
-
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -201,6 +201,40 @@ static int wpas_mesh_init_rsn(struct wpa
- 	return !wpa_s->mesh_rsn ? -1 : 0;
- }
- 
-+
-+static int wpas_mesh_update_freq_params(struct wpa_supplicant *wpa_s)
-+{
-+	struct wpa_driver_mesh_join_params *params = wpa_s->mesh_params;
-+	struct hostapd_iface *ifmsh = wpa_s->ifmsh;
-+	struct he_capabilities *he_capab = NULL;
-+
-+	if (ifmsh->current_mode)
-+		he_capab = &ifmsh->current_mode->he_capab[IEEE80211_MODE_MESH];
-+
-+	if (hostapd_set_freq_params(&params->freq,
-+			ifmsh->conf->hw_mode,
-+			ifmsh->freq,
-+			ifmsh->conf->channel,
-+			ifmsh->conf->enable_edmg,
-+			ifmsh->conf->edmg_channel,
-+			ifmsh->conf->ieee80211n,
-+			ifmsh->conf->ieee80211ac,
-+			ifmsh->conf->ieee80211ax,
-+			ifmsh->conf->secondary_channel,
-+			hostapd_get_oper_chwidth(ifmsh->conf),
-+			hostapd_get_oper_centr_freq_seg0_idx(ifmsh->conf),
-+			hostapd_get_oper_centr_freq_seg1_idx(ifmsh->conf),
-+			ifmsh->conf->vht_capab,
-+			he_capab)) {
-+		wpa_printf(MSG_ERROR, "Error updating mesh frequency params.");
-+		wpa_supplicant_mesh_deinit(wpa_s, true);
-+		return -1;
-+	}
-+
-+	return 0;
-+}
-+
-+
- static int wpas_mesh_complete(struct wpa_supplicant *wpa_s)
- {
- 	struct hostapd_iface *ifmsh = wpa_s->ifmsh;
-@@ -221,30 +255,8 @@ static int wpas_mesh_complete(struct wpa
- 	if (ifmsh->freq > 0 && ifmsh->freq != params->freq.freq) {
- 		wpa_s->assoc_freq = ifmsh->freq;
- 		ssid->frequency = ifmsh->freq;
--		struct he_capabilities *he_capab = NULL;
--
--		if (ifmsh->current_mode)
--			he_capab = &ifmsh->current_mode->he_capab[IEEE80211_MODE_MESH];
--
--		if (hostapd_set_freq_params(&params->freq,
--				ifmsh->conf->hw_mode,
--				ifmsh->freq,
--				ifmsh->conf->channel,
--				ifmsh->conf->enable_edmg,
--				ifmsh->conf->edmg_channel,
--				ifmsh->conf->ieee80211n,
--				ifmsh->conf->ieee80211ac,
--				ifmsh->conf->ieee80211ax,
--				ifmsh->conf->secondary_channel,
--				hostapd_get_oper_chwidth(ifmsh->conf),
--				hostapd_get_oper_centr_freq_seg0_idx(ifmsh->conf),
--				hostapd_get_oper_centr_freq_seg1_idx(ifmsh->conf),
--				ifmsh->conf->vht_capab,
--				he_capab)) {
--			wpa_printf(MSG_ERROR, "Error updating mesh frequency params.");
--			wpa_supplicant_mesh_deinit(wpa_s, true);
-+		if (wpas_mesh_update_freq_params(wpa_s) != 0)
- 			return -1;
--		}
- 	}
- 
- 	if (ifmsh->mconf->security != MESH_CONF_SEC_NONE &&
-@@ -518,6 +530,7 @@ static int wpa_supplicant_mesh_init(stru
- 	}
- 
- 	return 0;
-+
- out_free:
- 	wpa_supplicant_mesh_deinit(wpa_s, true);
- 	return -ENOMEM;
diff --git a/package/network/services/hostapd/patches/020-ignore-4addr-mode-enabling-error.patch b/package/network/services/hostapd/patches/020-ignore-4addr-mode-enabling-error.patch
deleted file mode 100644
index 3431ac0949..0000000000
--- a/package/network/services/hostapd/patches/020-ignore-4addr-mode-enabling-error.patch
+++ /dev/null
@@ -1,78 +0,0 @@
-From c7cca9b08f3e1e49c4a4a59ec66c47d91448e6ae Mon Sep 17 00:00:00 2001
-From: Jouni Malinen <j@w1.fi>
-Date: Sat, 13 Feb 2021 23:59:28 +0200
-Subject: [PATCH] nl80211: Ignore 4addr mode enabling error if it was already
- enabled
-
-nl80211_set_4addr_mode() could fail when trying to enable 4addr mode on
-an interface that is in a bridge and has 4addr mode already enabled.
-This operation would not have been necessary in the first place and this
-failure results in disconnecting, e.g., when roaming from one backhaul
-BSS to another BSS with Multi AP.
-
-Avoid this issue by ignoring the nl80211 command failure in the case
-where 4addr mode is being enabled while it has already been enabled.
-
-Signed-off-by: Jouni Malinen <j@w1.fi>
----
- src/drivers/driver_nl80211.c | 23 +++++++++++++++++++++++
- 1 file changed, 23 insertions(+)
-
-diff --git a/src/drivers/driver_nl80211.c b/src/drivers/driver_nl80211.c
-index 72189da24..011a15e68 100644
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -617,6 +617,7 @@ struct wiphy_idx_data {
- 	int wiphy_idx;
- 	enum nl80211_iftype nlmode;
- 	u8 *macaddr;
-+	u8 use_4addr;
- };
- 
- 
-@@ -639,6 +640,9 @@ static int netdev_info_handler(struct nl_msg *msg, void *arg)
- 		os_memcpy(info->macaddr, nla_data(tb[NL80211_ATTR_MAC]),
- 			  ETH_ALEN);
- 
-+	if (tb[NL80211_ATTR_4ADDR])
-+		info->use_4addr = nla_get_u8(tb[NL80211_ATTR_4ADDR]);
-+
- 	return NL_SKIP;
- }
- 
-@@ -691,6 +695,20 @@ static int nl80211_get_macaddr(struct i802_bss *bss)
- }
- 
- 
-+static int nl80211_get_4addr(struct i802_bss *bss)
-+{
-+	struct nl_msg *msg;
-+	struct wiphy_idx_data data = {
-+		.use_4addr = 0,
-+	};
-+
-+	if (!(msg = nl80211_cmd_msg(bss, 0, NL80211_CMD_GET_INTERFACE)) ||
-+	    send_and_recv_msgs(bss->drv, msg, netdev_info_handler, &data))
-+		return -1;
-+	return data.use_4addr;
-+}
-+
-+
- static int nl80211_register_beacons(struct wpa_driver_nl80211_data *drv,
- 				    struct nl80211_wiphy_data *w)
- {
-@@ -11482,6 +11500,11 @@ static int nl80211_set_4addr_mode(void *priv, const char *bridge_ifname,
- 
- 	ret = send_and_recv_msgs(drv, msg, NULL, NULL);
- 	msg = NULL;
-+	if (ret && val && nl80211_get_4addr(bss) == 1) {
-+		wpa_printf(MSG_DEBUG,
-+			   "nl80211: 4addr mode was already enabled");
-+		ret = 0;
-+	}
- 	if (!ret) {
- 		if (bridge_ifname[0] && val &&
- 		    i802_check_bridge(drv, bss, bridge_ifname, bss->ifname) < 0)
--- 
-2.29.2
-
diff --git a/package/network/services/hostapd/patches/050-mesh-make-forwarding-configurable.patch b/package/network/services/hostapd/patches/020-mesh-make-forwarding-configurable.patch
similarity index 89%
rename from package/network/services/hostapd/patches/050-mesh-make-forwarding-configurable.patch
rename to package/network/services/hostapd/patches/020-mesh-make-forwarding-configurable.patch
index 0ecb9ba078..75726a6750 100644
--- a/package/network/services/hostapd/patches/050-mesh-make-forwarding-configurable.patch
+++ b/package/network/services/hostapd/patches/020-mesh-make-forwarding-configurable.patch
@@ -31,7 +31,7 @@ Signed-off-by: Daniel Golle <daniel@makrotopia.org>
  };
  
  #define MAX_STA_COUNT 2007
-@@ -701,6 +702,7 @@ struct hostapd_bss_config {
+@@ -696,6 +697,7 @@ struct hostapd_bss_config {
  
  #define MESH_ENABLED BIT(0)
  	int mesh;
@@ -41,7 +41,7 @@ Signed-off-by: Daniel Golle <daniel@makrotopia.org>
  
 --- a/src/drivers/driver.h
 +++ b/src/drivers/driver.h
-@@ -1515,6 +1515,7 @@ struct wpa_driver_mesh_bss_params {
+@@ -1584,6 +1584,7 @@ struct wpa_driver_mesh_bss_params {
  #define WPA_DRIVER_MESH_CONF_FLAG_MAX_PEER_LINKS	0x00000004
  #define WPA_DRIVER_MESH_CONF_FLAG_HT_OP_MODE		0x00000008
  #define WPA_DRIVER_MESH_CONF_FLAG_RSSI_THRESHOLD	0x00000010
@@ -49,7 +49,7 @@ Signed-off-by: Daniel Golle <daniel@makrotopia.org>
  	/*
  	 * TODO: Other mesh configuration parameters would go here.
  	 * See NL80211_MESHCONF_* for all the mesh config parameters.
-@@ -1524,6 +1525,7 @@ struct wpa_driver_mesh_bss_params {
+@@ -1593,6 +1594,7 @@ struct wpa_driver_mesh_bss_params {
  	int peer_link_timeout;
  	int max_peer_links;
  	int rssi_threshold;
@@ -59,7 +59,7 @@ Signed-off-by: Daniel Golle <daniel@makrotopia.org>
  
 --- a/src/drivers/driver_nl80211.c
 +++ b/src/drivers/driver_nl80211.c
-@@ -10023,6 +10023,9 @@ static int nl80211_put_mesh_config(struc
+@@ -10456,6 +10456,9 @@ static int nl80211_put_mesh_config(struc
  	if (((params->flags & WPA_DRIVER_MESH_CONF_FLAG_AUTO_PLINKS) &&
  	     nla_put_u8(msg, NL80211_MESHCONF_AUTO_OPEN_PLINKS,
  			params->auto_plinks)) ||
@@ -71,7 +71,7 @@ Signed-off-by: Daniel Golle <daniel@makrotopia.org>
  			 params->max_peer_links)) ||
 --- a/wpa_supplicant/config.c
 +++ b/wpa_supplicant/config.c
-@@ -2473,6 +2473,7 @@ static const struct parse_data ssid_fiel
+@@ -2527,6 +2527,7 @@ static const struct parse_data ssid_fiel
  #ifdef CONFIG_MESH
  	{ INT_RANGE(mode, 0, 5) },
  	{ INT_RANGE(no_auto_peer, 0, 1) },
@@ -79,7 +79,7 @@ Signed-off-by: Daniel Golle <daniel@makrotopia.org>
  	{ INT_RANGE(mesh_rssi_threshold, -255, 1) },
  #else /* CONFIG_MESH */
  	{ INT_RANGE(mode, 0, 4) },
-@@ -3049,6 +3050,7 @@ void wpa_config_set_network_defaults(str
+@@ -3106,6 +3107,7 @@ void wpa_config_set_network_defaults(str
  	ssid->dot11MeshRetryTimeout = DEFAULT_MESH_RETRY_TIMEOUT;
  	ssid->dot11MeshConfirmTimeout = DEFAULT_MESH_CONFIRM_TIMEOUT;
  	ssid->dot11MeshHoldingTimeout = DEFAULT_MESH_HOLDING_TIMEOUT;
@@ -87,7 +87,7 @@ Signed-off-by: Daniel Golle <daniel@makrotopia.org>
  	ssid->mesh_rssi_threshold = DEFAULT_MESH_RSSI_THRESHOLD;
  #endif /* CONFIG_MESH */
  #ifdef CONFIG_HT_OVERRIDES
-@@ -4276,6 +4278,7 @@ struct wpa_config * wpa_config_alloc_emp
+@@ -4347,6 +4349,7 @@ struct wpa_config * wpa_config_alloc_emp
  	config->user_mpm = DEFAULT_USER_MPM;
  	config->max_peer_links = DEFAULT_MAX_PEER_LINKS;
  	config->mesh_max_inactivity = DEFAULT_MESH_MAX_INACTIVITY;
@@ -95,7 +95,7 @@ Signed-off-by: Daniel Golle <daniel@makrotopia.org>
  	config->dot11RSNASAERetransPeriod =
  		DEFAULT_DOT11_RSNA_SAE_RETRANS_PERIOD;
  	config->fast_reauth = DEFAULT_FAST_REAUTH;
-@@ -4914,6 +4917,7 @@ static const struct global_parse_data gl
+@@ -5047,6 +5050,7 @@ static const struct global_parse_data gl
  	{ INT(user_mpm), 0 },
  	{ INT_RANGE(max_peer_links, 0, 255), 0 },
  	{ INT(mesh_max_inactivity), 0 },
@@ -113,7 +113,7 @@ Signed-off-by: Daniel Golle <daniel@makrotopia.org>
  /*
   * The default dot11RSNASAERetransPeriod is defined as 40 ms in the standard,
   * but use 1000 ms in practice to avoid issues on low power CPUs.
-@@ -1351,6 +1352,14 @@ struct wpa_config {
+@@ -1378,6 +1379,14 @@ struct wpa_config {
  	int mesh_max_inactivity;
  
  	/**
@@ -130,7 +130,7 @@ Signed-off-by: Daniel Golle <daniel@makrotopia.org>
  	 * This timeout value is used in mesh STA to retransmit
 --- a/wpa_supplicant/config_file.c
 +++ b/wpa_supplicant/config_file.c
-@@ -866,6 +866,7 @@ static void wpa_config_write_network(FIL
+@@ -768,6 +768,7 @@ static void wpa_config_write_network(FIL
  #endif /* IEEE8021X_EAPOL */
  	INT(mode);
  	INT(no_auto_peer);
@@ -138,7 +138,7 @@ Signed-off-by: Daniel Golle <daniel@makrotopia.org>
  	INT(frequency);
  	INT(enable_edmg);
  	INT(edmg_channel);
-@@ -1527,6 +1528,9 @@ static void wpa_config_write_global(FILE
+@@ -1449,6 +1450,9 @@ static void wpa_config_write_global(FILE
  		fprintf(f, "mesh_max_inactivity=%d\n",
  			config->mesh_max_inactivity);
  
@@ -164,7 +164,7 @@ Signed-off-by: Daniel Golle <daniel@makrotopia.org>
  
 --- a/wpa_supplicant/mesh.c
 +++ b/wpa_supplicant/mesh.c
-@@ -137,6 +137,7 @@ static struct mesh_conf * mesh_config_cr
+@@ -140,6 +140,7 @@ static struct mesh_conf * mesh_config_cr
  	conf->mesh_cc_id = 0;
  	conf->mesh_sp_id = MESH_SYNC_METHOD_NEIGHBOR_OFFSET;
  	conf->mesh_auth_id = (conf->security & MESH_CONF_SEC_AUTH) ? 1 : 0;
@@ -172,7 +172,7 @@ Signed-off-by: Daniel Golle <daniel@makrotopia.org>
  	conf->dot11MeshMaxRetries = ssid->dot11MeshMaxRetries;
  	conf->dot11MeshRetryTimeout = ssid->dot11MeshRetryTimeout;
  	conf->dot11MeshConfirmTimeout = ssid->dot11MeshConfirmTimeout;
-@@ -434,6 +435,7 @@ static int wpa_supplicant_mesh_init(stru
+@@ -441,6 +442,7 @@ static int wpa_supplicant_mesh_init(stru
  	bss->conf->start_disabled = 1;
  	bss->conf->mesh = MESH_ENABLED;
  	bss->conf->ap_max_inactivity = wpa_s->conf->mesh_max_inactivity;
@@ -180,7 +180,7 @@ Signed-off-by: Daniel Golle <daniel@makrotopia.org>
  
  	if (ieee80211_is_dfs(ssid->frequency, wpa_s->hw.modes,
  			     wpa_s->hw.num_modes) && wpa_s->conf->country[0]) {
-@@ -647,6 +649,10 @@ int wpa_supplicant_join_mesh(struct wpa_
+@@ -655,6 +657,10 @@ int wpa_supplicant_join_mesh(struct wpa_
  	}
  	params->conf.peer_link_timeout = wpa_s->conf->mesh_max_inactivity;
  
diff --git a/package/network/services/hostapd/patches/021-fix-sta-add-after-previous-connection.patch b/package/network/services/hostapd/patches/021-fix-sta-add-after-previous-connection.patch
new file mode 100644
index 0000000000..124fd8bdf1
--- /dev/null
+++ b/package/network/services/hostapd/patches/021-fix-sta-add-after-previous-connection.patch
@@ -0,0 +1,26 @@
+--- a/src/ap/ieee802_11.c
++++ b/src/ap/ieee802_11.c
+@@ -4942,6 +4942,13 @@ static int add_associated_sta(struct hos
+ 	 * drivers to accept the STA parameter configuration. Since this is
+ 	 * after a new FT-over-DS exchange, a new TK has been derived, so key
+ 	 * reinstallation is not a concern for this case.
++	 *
++	 * If the STA was associated and authorized earlier, but came for a new
++	 * connection (!added_unassoc + !reassoc), remove the existing STA entry
++	 * so that it can be re-added. This case is rarely seen when the AP could
++	 * not receive the deauth/disassoc frame from the STA. And the STA comes
++	 * back with new connection within a short period or before the inactive
++	 * STA entry is removed from the list.
+ 	 */
+ 	wpa_printf(MSG_DEBUG, "Add associated STA " MACSTR
+ 		   " (added_unassoc=%d auth_alg=%u ft_over_ds=%u reassoc=%d authorized=%d ft_tk=%d fils_tk=%d)",
+@@ -4955,7 +4962,8 @@ static int add_associated_sta(struct hos
+ 	    (!(sta->flags & WLAN_STA_AUTHORIZED) ||
+ 	     (reassoc && sta->ft_over_ds && sta->auth_alg == WLAN_AUTH_FT) ||
+ 	     (!wpa_auth_sta_ft_tk_already_set(sta->wpa_sm) &&
+-	      !wpa_auth_sta_fils_tk_already_set(sta->wpa_sm)))) {
++	      !wpa_auth_sta_fils_tk_already_set(sta->wpa_sm)) ||
++	     (!reassoc && (sta->flags & WLAN_STA_AUTHORIZED)))) {
+ 		hostapd_drv_sta_remove(hapd, sta->addr);
+ 		wpa_auth_sm_event(sta->wpa_sm, WPA_DRV_STA_REMOVED);
+ 		set = 0;
diff --git a/package/network/services/hostapd/patches/022-hostapd-fix-use-of-uninitialized-stack-variables.patch b/package/network/services/hostapd/patches/022-hostapd-fix-use-of-uninitialized-stack-variables.patch
new file mode 100644
index 0000000000..c7da33f029
--- /dev/null
+++ b/package/network/services/hostapd/patches/022-hostapd-fix-use-of-uninitialized-stack-variables.patch
@@ -0,0 +1,25 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Thu, 8 Jul 2021 16:33:03 +0200
+Subject: [PATCH] hostapd: fix use of uninitialized stack variables
+
+When a CSA is performed on an 80 MHz channel, hostapd_change_config_freq
+unconditionally calls hostapd_set_oper_centr_freq_seg0/1_idx with seg0/1
+filled by ieee80211_freq_to_chan.
+However, if ieee80211_freq_to_chan fails (because the freq is 0 or invalid),
+seg0/1 remains uninitialized and filled with stack garbage, causing errors
+such as "hostapd: 80 MHz: center segment 1 configured"
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/src/ap/hostapd.c
++++ b/src/ap/hostapd.c
+@@ -3431,7 +3431,7 @@ static int hostapd_change_config_freq(st
+ 				      struct hostapd_freq_params *old_params)
+ {
+ 	int channel;
+-	u8 seg0, seg1;
++	u8 seg0 = 0, seg1 = 0;
+ 	struct hostapd_hw_modes *mode;
+ 
+ 	if (!params->channel) {
diff --git a/package/network/services/hostapd/patches/023-ndisc_snoop-call-dl_list_del-before-freeing-ipv6-add.patch b/package/network/services/hostapd/patches/023-ndisc_snoop-call-dl_list_del-before-freeing-ipv6-add.patch
new file mode 100644
index 0000000000..9ff9b2398d
--- /dev/null
+++ b/package/network/services/hostapd/patches/023-ndisc_snoop-call-dl_list_del-before-freeing-ipv6-add.patch
@@ -0,0 +1,19 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Wed, 28 Jul 2021 05:43:29 +0200
+Subject: [PATCH] ndisc_snoop: call dl_list_del before freeing ipv6 addresses
+
+Fixes a segmentation fault on sta disconnect
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/src/ap/ndisc_snoop.c
++++ b/src/ap/ndisc_snoop.c
+@@ -61,6 +61,7 @@ void sta_ip6addr_del(struct hostapd_data
+ 	dl_list_for_each_safe(ip6addr, prev, &sta->ip6addr, struct ip6addr,
+ 			      list) {
+ 		hostapd_drv_br_delete_ip_neigh(hapd, 6, (u8 *) &ip6addr->addr);
++		dl_list_del(&ip6addr->list);
+ 		os_free(ip6addr);
+ 	}
+ }
diff --git a/package/network/services/hostapd/patches/030-driver_nl80211-rewrite-neigh-code-to-not-depend-on-l.patch b/package/network/services/hostapd/patches/030-driver_nl80211-rewrite-neigh-code-to-not-depend-on-l.patch
new file mode 100644
index 0000000000..e8a78e355e
--- /dev/null
+++ b/package/network/services/hostapd/patches/030-driver_nl80211-rewrite-neigh-code-to-not-depend-on-l.patch
@@ -0,0 +1,275 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Wed, 28 Jul 2021 05:49:46 +0200
+Subject: [PATCH] driver_nl80211: rewrite neigh code to not depend on
+ libnl3-route
+
+Removes an unnecessary dependency and also makes the code smaller
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/src/drivers/driver_nl80211.c
++++ b/src/drivers/driver_nl80211.c
+@@ -16,9 +16,6 @@
+ #include <net/if.h>
+ #include <netlink/genl/genl.h>
+ #include <netlink/genl/ctrl.h>
+-#ifdef CONFIG_LIBNL3_ROUTE
+-#include <netlink/route/neighbour.h>
+-#endif /* CONFIG_LIBNL3_ROUTE */
+ #include <linux/rtnetlink.h>
+ #include <netpacket/packet.h>
+ #include <linux/errqueue.h>
+@@ -5284,26 +5281,29 @@ fail:
+ 
+ static void rtnl_neigh_delete_fdb_entry(struct i802_bss *bss, const u8 *addr)
+ {
+-#ifdef CONFIG_LIBNL3_ROUTE
+ 	struct wpa_driver_nl80211_data *drv = bss->drv;
+-	struct rtnl_neigh *rn;
+-	struct nl_addr *nl_addr;
++	struct ndmsg nhdr = {
++		.ndm_state = NUD_PERMANENT,
++		.ndm_ifindex = bss->ifindex,
++		.ndm_family = AF_BRIDGE,
++	};
++	struct nl_msg *msg;
+ 	int err;
+ 
+-	rn = rtnl_neigh_alloc();
+-	if (!rn)
++	msg = nlmsg_alloc_simple(RTM_DELNEIGH, NLM_F_CREATE);
++	if (!msg)
+ 		return;
+ 
+-	rtnl_neigh_set_family(rn, AF_BRIDGE);
+-	rtnl_neigh_set_ifindex(rn, bss->ifindex);
+-	nl_addr = nl_addr_build(AF_BRIDGE, (void *) addr, ETH_ALEN);
+-	if (!nl_addr) {
+-		rtnl_neigh_put(rn);
+-		return;
+-	}
+-	rtnl_neigh_set_lladdr(rn, nl_addr);
++	if (nlmsg_append(msg, &nhdr, sizeof(nhdr), NLMSG_ALIGNTO) < 0)
++		goto errout;
++
++	if (nla_put(msg, NDA_LLADDR, ETH_ALEN, (void *)addr))
++		goto errout;
++
++	if (nl_send_auto_complete(drv->rtnl_sk, msg) < 0)
++		goto errout;
+ 
+-	err = rtnl_neigh_delete(drv->rtnl_sk, rn, 0);
++	err = nl_wait_for_ack(drv->rtnl_sk);
+ 	if (err < 0) {
+ 		wpa_printf(MSG_DEBUG, "nl80211: bridge FDB entry delete for "
+ 			   MACSTR " ifindex=%d failed: %s", MAC2STR(addr),
+@@ -5313,9 +5313,8 @@ static void rtnl_neigh_delete_fdb_entry(
+ 			   MACSTR, MAC2STR(addr));
+ 	}
+ 
+-	nl_addr_put(nl_addr);
+-	rtnl_neigh_put(rn);
+-#endif /* CONFIG_LIBNL3_ROUTE */
++errout:
++	nlmsg_free(msg);
+ }
+ 
+ 
+@@ -7691,7 +7690,6 @@ static void *i802_init(struct hostapd_da
+ 	    (params->num_bridge == 0 || !params->bridge[0]))
+ 		add_ifidx(drv, br_ifindex, drv->ifindex);
+ 
+-#ifdef CONFIG_LIBNL3_ROUTE
+ 	if (bss->added_if_into_bridge || bss->already_in_bridge) {
+ 		int err;
+ 
+@@ -7708,7 +7706,6 @@ static void *i802_init(struct hostapd_da
+ 			goto failed;
+ 		}
+ 	}
+-#endif /* CONFIG_LIBNL3_ROUTE */
+ 
+ 	if (drv->capa.flags2 & WPA_DRIVER_FLAGS2_CONTROL_PORT_RX) {
+ 		wpa_printf(MSG_DEBUG,
+@@ -10655,13 +10652,14 @@ static int wpa_driver_br_add_ip_neigh(vo
+ 				      const u8 *ipaddr, int prefixlen,
+ 				      const u8 *addr)
+ {
+-#ifdef CONFIG_LIBNL3_ROUTE
+ 	struct i802_bss *bss = priv;
+ 	struct wpa_driver_nl80211_data *drv = bss->drv;
+-	struct rtnl_neigh *rn;
+-	struct nl_addr *nl_ipaddr = NULL;
+-	struct nl_addr *nl_lladdr = NULL;
+-	int family, addrsize;
++	struct ndmsg nhdr = {
++		.ndm_state = NUD_PERMANENT,
++		.ndm_ifindex = bss->br_ifindex,
++	};
++	struct nl_msg *msg;
++	int addrsize;
+ 	int res;
+ 
+ 	if (!ipaddr || prefixlen == 0 || !addr)
+@@ -10680,85 +10678,66 @@ static int wpa_driver_br_add_ip_neigh(vo
+ 	}
+ 
+ 	if (version == 4) {
+-		family = AF_INET;
++		nhdr.ndm_family = AF_INET;
+ 		addrsize = 4;
+ 	} else if (version == 6) {
+-		family = AF_INET6;
++		nhdr.ndm_family = AF_INET6;
+ 		addrsize = 16;
+ 	} else {
+ 		return -EINVAL;
+ 	}
+ 
+-	rn = rtnl_neigh_alloc();
+-	if (rn == NULL)
++	msg = nlmsg_alloc_simple(RTM_NEWNEIGH, NLM_F_CREATE);
++	if (!msg)
+ 		return -ENOMEM;
+ 
+-	/* set the destination ip address for neigh */
+-	nl_ipaddr = nl_addr_build(family, (void *) ipaddr, addrsize);
+-	if (nl_ipaddr == NULL) {
+-		wpa_printf(MSG_DEBUG, "nl80211: nl_ipaddr build failed");
+-		res = -ENOMEM;
++	res = -ENOMEM;
++	if (nlmsg_append(msg, &nhdr, sizeof(nhdr), NLMSG_ALIGNTO) < 0)
+ 		goto errout;
+-	}
+-	nl_addr_set_prefixlen(nl_ipaddr, prefixlen);
+-	res = rtnl_neigh_set_dst(rn, nl_ipaddr);
+-	if (res) {
+-		wpa_printf(MSG_DEBUG,
+-			   "nl80211: neigh set destination addr failed");
++
++	if (nla_put(msg, NDA_DST, addrsize, (void *)ipaddr))
+ 		goto errout;
+-	}
+ 
+-	/* set the corresponding lladdr for neigh */
+-	nl_lladdr = nl_addr_build(AF_BRIDGE, (u8 *) addr, ETH_ALEN);
+-	if (nl_lladdr == NULL) {
+-		wpa_printf(MSG_DEBUG, "nl80211: neigh set lladdr failed");
+-		res = -ENOMEM;
++	if (nla_put(msg, NDA_LLADDR, ETH_ALEN, (void *)addr))
+ 		goto errout;
+-	}
+-	rtnl_neigh_set_lladdr(rn, nl_lladdr);
+ 
+-	rtnl_neigh_set_ifindex(rn, bss->br_ifindex);
+-	rtnl_neigh_set_state(rn, NUD_PERMANENT);
++	res = nl_send_auto_complete(drv->rtnl_sk, msg);
++	if (res < 0)
++		goto errout;
+ 
+-	res = rtnl_neigh_add(drv->rtnl_sk, rn, NLM_F_CREATE);
++	res = nl_wait_for_ack(drv->rtnl_sk);
+ 	if (res) {
+ 		wpa_printf(MSG_DEBUG,
+ 			   "nl80211: Adding bridge ip neigh failed: %s",
+ 			   nl_geterror(res));
+ 	}
+ errout:
+-	if (nl_lladdr)
+-		nl_addr_put(nl_lladdr);
+-	if (nl_ipaddr)
+-		nl_addr_put(nl_ipaddr);
+-	if (rn)
+-		rtnl_neigh_put(rn);
++	nlmsg_free(msg);
+ 	return res;
+-#else /* CONFIG_LIBNL3_ROUTE */
+-	return -1;
+-#endif /* CONFIG_LIBNL3_ROUTE */
+ }
+ 
+ 
+ static int wpa_driver_br_delete_ip_neigh(void *priv, u8 version,
+ 					 const u8 *ipaddr)
+ {
+-#ifdef CONFIG_LIBNL3_ROUTE
+ 	struct i802_bss *bss = priv;
+ 	struct wpa_driver_nl80211_data *drv = bss->drv;
+-	struct rtnl_neigh *rn;
+-	struct nl_addr *nl_ipaddr;
+-	int family, addrsize;
++	struct ndmsg nhdr = {
++		.ndm_state = NUD_PERMANENT,
++		.ndm_ifindex = bss->br_ifindex,
++	};
++	struct nl_msg *msg;
++	int addrsize;
+ 	int res;
+ 
+ 	if (!ipaddr)
+ 		return -EINVAL;
+ 
+ 	if (version == 4) {
+-		family = AF_INET;
++		nhdr.ndm_family = AF_INET;
+ 		addrsize = 4;
+ 	} else if (version == 6) {
+-		family = AF_INET6;
++		nhdr.ndm_family = AF_INET6;
+ 		addrsize = 16;
+ 	} else {
+ 		return -EINVAL;
+@@ -10776,41 +10755,30 @@ static int wpa_driver_br_delete_ip_neigh
+ 		return -1;
+ 	}
+ 
+-	rn = rtnl_neigh_alloc();
+-	if (rn == NULL)
++	msg = nlmsg_alloc_simple(RTM_DELNEIGH, NLM_F_CREATE);
++	if (!msg)
+ 		return -ENOMEM;
+ 
+-	/* set the destination ip address for neigh */
+-	nl_ipaddr = nl_addr_build(family, (void *) ipaddr, addrsize);
+-	if (nl_ipaddr == NULL) {
+-		wpa_printf(MSG_DEBUG, "nl80211: nl_ipaddr build failed");
+-		res = -ENOMEM;
++	res = -ENOMEM;
++	if (nlmsg_append(msg, &nhdr, sizeof(nhdr), NLMSG_ALIGNTO) < 0)
+ 		goto errout;
+-	}
+-	res = rtnl_neigh_set_dst(rn, nl_ipaddr);
+-	if (res) {
+-		wpa_printf(MSG_DEBUG,
+-			   "nl80211: neigh set destination addr failed");
++
++	if (nla_put(msg, NDA_DST, addrsize, (void *)ipaddr))
+ 		goto errout;
+-	}
+ 
+-	rtnl_neigh_set_ifindex(rn, bss->br_ifindex);
++	res = nl_send_auto_complete(drv->rtnl_sk, msg);
++	if (res < 0)
++		goto errout;
+ 
+-	res = rtnl_neigh_delete(drv->rtnl_sk, rn, 0);
++	res = nl_wait_for_ack(drv->rtnl_sk);
+ 	if (res) {
+ 		wpa_printf(MSG_DEBUG,
+ 			   "nl80211: Deleting bridge ip neigh failed: %s",
+ 			   nl_geterror(res));
+ 	}
+ errout:
+-	if (nl_ipaddr)
+-		nl_addr_put(nl_ipaddr);
+-	if (rn)
+-		rtnl_neigh_put(rn);
++	nlmsg_free(msg);
+ 	return res;
+-#else /* CONFIG_LIBNL3_ROUTE */
+-	return -1;
+-#endif /* CONFIG_LIBNL3_ROUTE */
+ }
+ 
+ 
diff --git a/package/network/services/hostapd/patches/060-P2P-Fix-a-corner-case-in-peer-addition-based-on-PD-R.patch b/package/network/services/hostapd/patches/060-P2P-Fix-a-corner-case-in-peer-addition-based-on-PD-R.patch
deleted file mode 100644
index 1202ff3725..0000000000
--- a/package/network/services/hostapd/patches/060-P2P-Fix-a-corner-case-in-peer-addition-based-on-PD-R.patch
+++ /dev/null
@@ -1,45 +0,0 @@
-From 8460e3230988ef2ec13ce6b69b687e941f6cdb32 Mon Sep 17 00:00:00 2001
-From: Jouni Malinen <jouni@codeaurora.org>
-Date: Tue, 8 Dec 2020 23:52:50 +0200
-Subject: [PATCH] P2P: Fix a corner case in peer addition based on PD Request
-
-p2p_add_device() may remove the oldest entry if there is no room in the
-peer table for a new peer. This would result in any pointer to that
-removed entry becoming stale. A corner case with an invalid PD Request
-frame could result in such a case ending up using (read+write) freed
-memory. This could only by triggered when the peer table has reached its
-maximum size and the PD Request frame is received from the P2P Device
-Address of the oldest remaining entry and the frame has incorrect P2P
-Device Address in the payload.
-
-Fix this by fetching the dev pointer again after having called
-p2p_add_device() so that the stale pointer cannot be used.
-
-Fixes: 17bef1e97a50 ("P2P: Add peer entry based on Provision Discovery Request")
-Signed-off-by: Jouni Malinen <jouni@codeaurora.org>
----
- src/p2p/p2p_pd.c | 12 +++++-------
- 1 file changed, 5 insertions(+), 7 deletions(-)
-
---- a/src/p2p/p2p_pd.c
-+++ b/src/p2p/p2p_pd.c
-@@ -595,14 +595,12 @@ void p2p_process_prov_disc_req(struct p2
- 			goto out;
- 		}
- 
-+		dev = p2p_get_device(p2p, sa);
- 		if (!dev) {
--			dev = p2p_get_device(p2p, sa);
--			if (!dev) {
--				p2p_dbg(p2p,
--					"Provision Discovery device not found "
--					MACSTR, MAC2STR(sa));
--				goto out;
--			}
-+			p2p_dbg(p2p,
-+				"Provision Discovery device not found "
-+				MACSTR, MAC2STR(sa));
-+			goto out;
- 		}
- 	} else if (msg.wfd_subelems) {
- 		wpabuf_free(dev->info.wfd_subelems);
diff --git a/package/network/services/hostapd/patches/110-notify-mgmt-frames.patch b/package/network/services/hostapd/patches/110-notify-mgmt-frames.patch
deleted file mode 100644
index 9e187253d4..0000000000
--- a/package/network/services/hostapd/patches/110-notify-mgmt-frames.patch
+++ /dev/null
@@ -1,116 +0,0 @@
-From 53f8fdb534d5222a0e852e38afde3f49832ace06 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rapha=C3=ABl=20M=C3=A9lotte?= <raphael.melotte@mind.be>
-Date: Thu, 26 Nov 2020 09:27:40 +0100
-Subject: [PATCH] hostapd: Add an option to notify management frames on
- ctrl_iface
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-In some contexts (e.g. Multi-AP) it can be useful to have access to
-some of the management frames in upper layers (e.g. to be able to
-process the content of association requests externally).
-
-Add 'notify_mgmt_frames'. When enabled, it will notify the ctrl_iface
-when a management frame arrives using 'AP_MGMT_FRAME_RECEIVED'.
-
-Note that to avoid completely flooding the ctrl_iface, not all
-management frames are included (e.g. beacons are excluded).
-
-Signed-off-by: Raphal Mlotte <raphael.melotte@mind.be>
----
- hostapd/config_file.c |  2 ++
- hostapd/hostapd.conf  |  4 ++++
- src/ap/ap_config.h    |  2 ++
- src/ap/ieee802_11.c   | 25 +++++++++++++++++++++++++
- src/common/wpa_ctrl.h |  3 +++
- 5 files changed, 36 insertions(+)
-
---- a/hostapd/config_file.c
-+++ b/hostapd/config_file.c
-@@ -4456,6 +4456,8 @@ static int hostapd_config_fill(struct ho
- 		bss->multicast_to_unicast = atoi(pos);
- 	} else if (os_strcmp(buf, "broadcast_deauth") == 0) {
- 		bss->broadcast_deauth = atoi(pos);
-+	} else if (os_strcmp(buf, "notify_mgmt_frames") == 0) {
-+		conf->notify_mgmt_frames = atoi(pos);
- #ifdef CONFIG_DPP
- 	} else if (os_strcmp(buf, "dpp_name") == 0) {
- 		os_free(bss->dpp_name);
---- a/hostapd/hostapd.conf
-+++ b/hostapd/hostapd.conf
-@@ -571,6 +571,10 @@ wmm_ac_vo_acm=0
- # Default: 1 (enabled)
- #broadcast_deauth=1
- 
-+# Get notifications for management frames:
-+# Default: 0 (disabled)
-+#notify_mgmt_frames=0
-+
- ##### IEEE 802.11n related configuration ######################################
- 
- # ieee80211n: Whether IEEE 802.11n (HT) is enabled
---- a/src/ap/ap_config.h
-+++ b/src/ap/ap_config.h
-@@ -1060,6 +1060,8 @@ struct hostapd_config {
- 	unsigned int airtime_update_interval;
- #define AIRTIME_MODE_MAX (__AIRTIME_MODE_MAX - 1)
- #endif /* CONFIG_AIRTIME_POLICY */
-+
-+	u8 notify_mgmt_frames;
- };
- 
- 
---- a/src/ap/ieee802_11.c
-+++ b/src/ap/ieee802_11.c
-@@ -4878,6 +4878,28 @@ static int handle_action(struct hostapd_
- 	return 1;
- }
- 
-+/**
-+ * notify_mgmt_frame - notify of management frames on the control interface.
-+ * @hapd: hostapd BSS data structure (the BSS to which the management frame was
-+ * sent to)
-+ * @buf: management frame data (starting from IEEE 802.11 header)
-+ * @len: length of frame data in octets
-+ *
-+ * Notify the control interface of any management frame.
-+ */
-+static void notify_mgmt_frame(struct hostapd_data *hapd, const u8 *buf,
-+			      size_t len)
-+{
-+
-+	int hex_len = len * 2 + 1;
-+	char *hex = os_malloc(hex_len);
-+
-+	if (hex) {
-+		wpa_snprintf_hex(hex, hex_len, buf, len);
-+		wpa_msg_ctrl(hapd->msg_ctx, MSG_INFO, AP_MGMT_FRAME_RECEIVED "buf=%s", hex);
-+		os_free(hex);
-+	}
-+}
- 
- /**
-  * ieee802_11_mgmt - process incoming IEEE 802.11 management frames
-@@ -4969,6 +4991,9 @@ int ieee802_11_mgmt(struct hostapd_data
- 	if (hapd->iconf->track_sta_max_num)
- 		sta_track_add(hapd->iface, mgmt->sa, ssi_signal);
- 
-+	if (hapd->iconf->notify_mgmt_frames)
-+		notify_mgmt_frame(hapd, buf, len);
-+
- 	switch (stype) {
- 	case WLAN_FC_STYPE_AUTH:
- 		wpa_printf(MSG_DEBUG, "mgmt::auth");
---- a/src/common/wpa_ctrl.h
-+++ b/src/common/wpa_ctrl.h
-@@ -396,6 +396,9 @@ extern "C" {
- #define BIT(x) (1U << (x))
- #endif
- 
-+/* Event triggered for received management frame */
-+#define AP_MGMT_FRAME_RECEIVED "AP-MGMT-FRAME-RECEIVED "
-+
- /* BSS command information masks */
- 
- #define WPA_BSS_MASK_ALL		0xFFFDFFFF
diff --git a/package/network/services/hostapd/patches/110-wolfssl-compile-fix.patch b/package/network/services/hostapd/patches/110-wolfssl-compile-fix.patch
deleted file mode 100644
index a7b5409602..0000000000
--- a/package/network/services/hostapd/patches/110-wolfssl-compile-fix.patch
+++ /dev/null
@@ -1,10 +0,0 @@
---- a/src/crypto/tls_wolfssl.c
-+++ b/src/crypto/tls_wolfssl.c
-@@ -19,6 +19,7 @@
- #include <wolfssl/ssl.h>
- #include <wolfssl/error-ssl.h>
- #include <wolfssl/wolfcrypt/asn.h>
-+#include <wolfssl/openssl/x509v3.h>
- 
- #if defined(EAP_FAST) || defined(EAP_FAST_DYNAMIC) || defined(EAP_SERVER_FAST)
- #define HAVE_AESGCM
diff --git a/package/network/services/hostapd/patches/120-reconfigure-wps-credentials.patch b/package/network/services/hostapd/patches/120-reconfigure-wps-credentials.patch
deleted file mode 100644
index 1826b6685b..0000000000
--- a/package/network/services/hostapd/patches/120-reconfigure-wps-credentials.patch
+++ /dev/null
@@ -1,178 +0,0 @@
-From b389a77a0f6dccf495dbce5be9476000f6ec06a2 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rapha=C3=ABl=20M=C3=A9lotte?= <raphael.melotte@mind.be>
-Date: Wed, 9 Dec 2020 19:55:53 +0100
-Subject: [PATCH] wps: reconfigure credentials on reload
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-When new credentials are configured and hostapd is reconfigured using
-SIGHUP (or reload on the ctrl_iface), also update the wps credentials.
-
-Before these changes, when WPS is triggered the registar always serves
-the credentials that were configured when hostapd started.
-
-Signed-off-by: Raphal Mlotte <raphael.melotte@mind.be>
----
- src/ap/wps_hostapd.c    | 86 +++++++++++++++++++++++++++++++++++++++--
- src/wps/wps.h           |  6 +++
- src/wps/wps_registrar.c | 29 ++++++++++++++
- 3 files changed, 118 insertions(+), 3 deletions(-)
-
---- a/src/ap/wps_hostapd.c
-+++ b/src/ap/wps_hostapd.c
-@@ -1375,6 +1375,43 @@ static void hostapd_wps_nfc_clear(struct
- #endif /* CONFIG_WPS_NFC */
- }
- 
-+int hostapd_wps_update_multi_ap(struct hostapd_data *hapd,
-+				struct wps_registrar *reg) {
-+	struct hostapd_bss_config *conf = hapd->conf;
-+	u8 *multi_ap_backhaul_network_key = NULL;
-+	size_t multi_ap_backhaul_network_key_len = 0;
-+	int ret = -1;
-+
-+	if ((conf->multi_ap & FRONTHAUL_BSS) &&
-+	    conf->multi_ap_backhaul_ssid.ssid_len) {
-+		if (conf->multi_ap_backhaul_ssid.wpa_passphrase) {
-+			multi_ap_backhaul_network_key =
-+				(u8 *) os_strdup(conf->multi_ap_backhaul_ssid.wpa_passphrase);
-+			if (multi_ap_backhaul_network_key == NULL)
-+				return -1;
-+			multi_ap_backhaul_network_key_len =
-+				os_strlen(conf->multi_ap_backhaul_ssid.wpa_passphrase);
-+		} else if (conf->multi_ap_backhaul_ssid.wpa_psk) {
-+			multi_ap_backhaul_network_key = os_malloc(2 * PMK_LEN + 1);
-+			if (multi_ap_backhaul_network_key == NULL)
-+				return -1;
-+			wpa_snprintf_hex((char *) multi_ap_backhaul_network_key,
-+					 2 * PMK_LEN + 1,
-+					 conf->multi_ap_backhaul_ssid.wpa_psk->psk,
-+					 PMK_LEN);
-+			multi_ap_backhaul_network_key_len = 2 * PMK_LEN;
-+		}
-+		ret = wps_registrar_update_multi_ap(reg,
-+						    conf->multi_ap_backhaul_ssid.ssid,
-+						    conf->multi_ap_backhaul_ssid.ssid_len,
-+						    multi_ap_backhaul_network_key,
-+						    multi_ap_backhaul_network_key_len);
-+		os_free(multi_ap_backhaul_network_key);
-+	}
-+	return ret;
-+}
-+
-+
- 
- void hostapd_deinit_wps(struct hostapd_data *hapd)
- {
-@@ -1409,11 +1446,54 @@ void hostapd_update_wps(struct hostapd_d
- 	hapd->wps->upc = hapd->conf->upc;
- #endif /* CONFIG_WPS_UPNP */
- 
--	hostapd_wps_set_vendor_ext(hapd, hapd->wps);
--	hostapd_wps_set_application_ext(hapd, hapd->wps);
-+	struct wps_context *wps = hapd->wps;
-+	struct hostapd_bss_config *conf = hapd->conf;
-+
-+	os_memcpy(wps->ssid, conf->ssid.ssid, conf->ssid.ssid_len);
-+	wps->ssid_len = conf->ssid.ssid_len;
-+
-+	/* Clear wps settings, then fill them again */
-+	os_free(wps->network_key);
-+	wps->network_key = NULL;
-+	wps->network_key_len = 0;
-+	wps->psk_set = 0;
-+	if (conf->ssid.wpa_psk_file) {
-+		/* Use per-device PSKs */
-+	} else if (conf->ssid.wpa_passphrase) {
-+		wps->network_key = (u8 *) os_strdup(conf->ssid.wpa_passphrase);
-+		if (wps->network_key == NULL)
-+			return;
-+		wps->network_key_len = os_strlen(conf->ssid.wpa_passphrase);
-+	} else if (conf->ssid.wpa_psk) {
-+		wps->network_key = os_malloc(2 * PMK_LEN + 1);
-+		if (wps->network_key == NULL)
-+			return;
-+		wpa_snprintf_hex((char *) wps->network_key, 2 * PMK_LEN + 1,
-+				 conf->ssid.wpa_psk->psk, PMK_LEN);
-+		wps->network_key_len = 2 * PMK_LEN;
-+#ifdef CONFIG_WEP
-+	} else if (conf->ssid.wep.keys_set && conf->ssid.wep.key[0]) {
-+		wps->network_key = os_malloc(conf->ssid.wep.len[0]);
-+		if (wps->network_key == NULL)
-+			return;
-+		os_memcpy(wps->network_key, conf->ssid.wep.key[0],
-+			  conf->ssid.wep.len[0]);
-+		wps->network_key_len = conf->ssid.wep.len[0];
-+#endif /* CONFIG_WEP */
-+	}
-+
-+	if (conf->ssid.wpa_psk) {
-+		os_memcpy(wps->psk, conf->ssid.wpa_psk->psk, PMK_LEN);
-+		wps->psk_set = 1;
-+	}
-+
-+	hostapd_wps_update_multi_ap(hapd, wps->registrar);
-+
-+	hostapd_wps_set_vendor_ext(hapd, wps);
-+	hostapd_wps_set_application_ext(hapd, wps);
- 
- 	if (hapd->conf->wps_state)
--		wps_registrar_update_ie(hapd->wps->registrar);
-+		wps_registrar_update_ie(wps->registrar);
- 	else
- 		hostapd_deinit_wps(hapd);
- }
---- a/src/wps/wps.h
-+++ b/src/wps/wps.h
-@@ -938,6 +938,12 @@ struct wpabuf * wps_build_nfc_handover_s
- 					       struct wpabuf *nfc_dh_pubkey,
- 					       struct wpabuf *nfc_dev_pw);
- 
-+int wps_registrar_update_multi_ap(struct wps_registrar *reg,
-+				  const u8 *multi_ap_backhaul_ssid,
-+				  size_t multi_ap_backhaul_ssid_len,
-+				  const u8 *multi_ap_backhaul_network_key,
-+				  size_t multi_ap_backhaul_network_key_len);
-+
- /* ndef.c */
- struct wpabuf * ndef_parse_wifi(const struct wpabuf *buf);
- struct wpabuf * ndef_build_wifi(const struct wpabuf *buf);
---- a/src/wps/wps_registrar.c
-+++ b/src/wps/wps_registrar.c
-@@ -3669,6 +3669,35 @@ int wps_registrar_config_ap(struct wps_r
- }
- 
- 
-+int wps_registrar_update_multi_ap(struct wps_registrar *reg,
-+				  const u8 *multi_ap_backhaul_ssid,
-+				  size_t multi_ap_backhaul_ssid_len,
-+				  const u8 *multi_ap_backhaul_network_key,
-+				  size_t multi_ap_backhaul_network_key_len)
-+{
-+	if (multi_ap_backhaul_ssid != NULL) {
-+		os_memcpy(reg->multi_ap_backhaul_ssid,
-+			  multi_ap_backhaul_ssid,
-+			  multi_ap_backhaul_ssid_len);
-+		reg->multi_ap_backhaul_ssid_len =
-+			multi_ap_backhaul_ssid_len;
-+	}
-+	os_free(reg->multi_ap_backhaul_network_key);
-+	reg->multi_ap_backhaul_network_key = NULL;
-+	reg->multi_ap_backhaul_network_key_len = 0;
-+
-+	if (multi_ap_backhaul_network_key != NULL) {
-+		reg->multi_ap_backhaul_network_key =
-+			os_memdup(multi_ap_backhaul_network_key,
-+				  multi_ap_backhaul_network_key_len);
-+		if (reg->multi_ap_backhaul_network_key == NULL)
-+			return -1;
-+		reg->multi_ap_backhaul_network_key_len =
-+			multi_ap_backhaul_network_key_len;
-+	}
-+	return 0;
-+}
-+
- #ifdef CONFIG_WPS_NFC
- 
- int wps_registrar_add_nfc_pw_token(struct wps_registrar *reg,
diff --git a/package/network/services/hostapd/patches/200-multicall.patch b/package/network/services/hostapd/patches/200-multicall.patch
index 4f3e3decfe..8dce260871 100644
--- a/package/network/services/hostapd/patches/200-multicall.patch
+++ b/package/network/services/hostapd/patches/200-multicall.patch
@@ -1,14 +1,14 @@
 --- a/hostapd/Makefile
 +++ b/hostapd/Makefile
-@@ -31,6 +31,7 @@ CFLAGS += -I$(abspath ../src/utils)
- export BINDIR ?= /usr/local/bin/
+@@ -1,6 +1,7 @@
+ ALL=hostapd hostapd_cli
+ CONFIG_FILE = .config
  
- -include .config
 +-include $(if $(MULTICALL), ../wpa_supplicant/.config)
+ include ../src/build.rules
  
- ifndef CONFIG_NO_GITVER
- # Add VERSION_STR postfix for builds from a git repository
-@@ -204,7 +205,8 @@ endif
+ ifdef LIBS
+@@ -199,7 +200,8 @@ endif
  
  ifdef CONFIG_NO_VLAN
  CFLAGS += -DCONFIG_NO_VLAN
@@ -18,7 +18,7 @@
  OBJS += ../src/ap/vlan_init.o
  OBJS += ../src/ap/vlan_ifconfig.o
  OBJS += ../src/ap/vlan.o
-@@ -354,10 +356,14 @@ CFLAGS += -DCONFIG_MBO
+@@ -349,10 +351,14 @@ CFLAGS += -DCONFIG_MBO
  OBJS += ../src/ap/mbo_ap.o
  endif
  
@@ -36,9 +36,9 @@
  LIBS += $(DRV_AP_LIBS)
  
  ifdef CONFIG_L2_PACKET
-@@ -1311,6 +1317,12 @@ install: $(addprefix $(DESTDIR)$(BINDIR)
- 
- BCHECK=../src/drivers/build.hostapd
+@@ -1277,6 +1283,12 @@ install: $(addprefix $(DESTDIR)$(BINDIR)
+ _OBJS_VAR := OBJS
+ include ../src/objs.mk
  
 +hostapd_multi.a: $(BCHECK) $(OBJS)
 +	$(Q)$(CC) -c -o hostapd_multi.o -Dmain=hostapd_main $(CFLAGS) main.c
@@ -46,12 +46,12 @@
 +	@rm -f $@
 +	@$(AR) cr $@ hostapd_multi.o $(OBJS)
 +
- hostapd: $(BCHECK) $(OBJS)
+ hostapd: $(OBJS)
  	$(Q)$(CC) $(LDFLAGS) -o hostapd $(OBJS) $(LIBS)
  	@$(E) "  LD " $@
-@@ -1374,6 +1386,12 @@ SOBJS += ../src/crypto/sha256-kdf.o
- SOBJS += ../src/crypto/sha384-kdf.o
- SOBJS += ../src/crypto/sha512-kdf.o
+@@ -1351,6 +1363,12 @@ include ../src/objs.mk
+ _OBJS_VAR := SOBJS
+ include ../src/objs.mk
  
 +dump_cflags:
 +	@printf "%s " "$(CFLAGS)"
@@ -64,15 +64,15 @@
  	@$(E) "  LD " $@
 --- a/wpa_supplicant/Makefile
 +++ b/wpa_supplicant/Makefile
-@@ -27,6 +27,7 @@ CFLAGS += -I$(abspath ../src)
- CFLAGS += -I$(abspath ../src/utils)
+@@ -17,6 +17,7 @@ endif
+ EXTRA_TARGETS=dynamic_eap_methods
  
- -include .config
+ CONFIG_FILE=.config
 +-include $(if $(MULTICALL),../hostapd/.config)
+ include ../src/build.rules
  
- ifndef CONFIG_NO_GITVER
- # Add VERSION_STR postfix for builds from a git repository
-@@ -369,7 +370,9 @@ endif
+ ifdef LIBS
+@@ -359,7 +360,9 @@ endif
  ifdef CONFIG_IBSS_RSN
  NEED_RSN_AUTHENTICATOR=y
  CFLAGS += -DCONFIG_IBSS_RSN
@@ -82,7 +82,7 @@
  OBJS += ibss_rsn.o
  endif
  
-@@ -890,6 +893,10 @@ ifdef CONFIG_DYNAMIC_EAP_METHODS
+@@ -897,6 +900,10 @@ ifdef CONFIG_DYNAMIC_EAP_METHODS
  CFLAGS += -DCONFIG_DYNAMIC_EAP_METHODS
  LIBS += -ldl -rdynamic
  endif
@@ -93,7 +93,7 @@
  endif
  
  ifdef CONFIG_AP
-@@ -897,9 +904,11 @@ NEED_EAP_COMMON=y
+@@ -904,9 +911,11 @@ NEED_EAP_COMMON=y
  NEED_RSN_AUTHENTICATOR=y
  CFLAGS += -DCONFIG_AP
  OBJS += ap.o
@@ -105,7 +105,7 @@
  OBJS += ../src/ap/hostapd.o
  OBJS += ../src/ap/wpa_auth_glue.o
  OBJS += ../src/ap/utils.o
-@@ -979,6 +988,12 @@ endif
+@@ -986,6 +995,12 @@ endif
  ifdef CONFIG_HS20
  OBJS += ../src/ap/hs20.o
  endif
@@ -118,7 +118,7 @@
  endif
  
  ifdef CONFIG_MBO
-@@ -987,7 +1002,9 @@ CFLAGS += -DCONFIG_MBO
+@@ -994,7 +1009,9 @@ CFLAGS += -DCONFIG_MBO
  endif
  
  ifdef NEED_RSN_AUTHENTICATOR
@@ -128,10 +128,10 @@
  NEED_AES_WRAP=y
  OBJS += ../src/ap/wpa_auth.o
  OBJS += ../src/ap/wpa_auth_ie.o
-@@ -1897,6 +1914,12 @@ wpa_priv: $(BCHECK) $(OBJS_priv)
- 
- $(OBJS_c) $(OBJS_t) $(OBJS_t2) $(OBJS) $(BCHECK) $(EXTRA_progs): .config
+@@ -1889,6 +1906,12 @@ wpa_priv: $(BCHECK) $(OBJS_priv)
  
+ _OBJS_VAR := OBJS
+ include ../src/objs.mk
 +wpa_supplicant_multi.a: .config $(BCHECK) $(OBJS) $(EXTRA_progs)
 +	$(Q)$(CC) -c -o wpa_supplicant_multi.o -Dmain=wpa_supplicant_main $(CFLAGS) main.c
 +	@$(E) "  CC " $<
@@ -141,7 +141,7 @@
  wpa_supplicant: $(BCHECK) $(OBJS) $(EXTRA_progs)
  	$(Q)$(LDO) $(LDFLAGS) -o wpa_supplicant $(OBJS) $(LIBS) $(EXTRALIBS)
  	@$(E) "  LD " $@
-@@ -1997,6 +2020,12 @@ endif
+@@ -2021,6 +2044,12 @@ eap_gpsk.so: $(SRC_EAP_GPSK)
  	$(Q)sed -e 's|\@BINDIR\@|$(BINDIR)|g' $< >$@
  	@$(E) "  sed" $<
  
@@ -156,7 +156,7 @@
  wpa_cli.exe: wpa_cli
 --- a/src/drivers/driver.h
 +++ b/src/drivers/driver.h
-@@ -5886,8 +5886,8 @@ union wpa_event_data {
+@@ -6025,8 +6025,8 @@ union wpa_event_data {
   * Driver wrapper code should call this function whenever an event is received
   * from the driver.
   */
@@ -167,7 +167,7 @@
  
  /**
   * wpa_supplicant_event_global - Report a driver event for wpa_supplicant
-@@ -5899,7 +5899,7 @@ void wpa_supplicant_event(void *ctx, enu
+@@ -6038,7 +6038,7 @@ void wpa_supplicant_event(void *ctx, enu
   * Same as wpa_supplicant_event(), but we search for the interface in
   * wpa_global.
   */
@@ -178,7 +178,7 @@
  /*
 --- a/src/ap/drv_callbacks.c
 +++ b/src/ap/drv_callbacks.c
-@@ -1789,8 +1789,8 @@ err:
+@@ -1836,8 +1836,8 @@ err:
  #endif /* CONFIG_OWE */
  
  
@@ -189,7 +189,7 @@
  {
  	struct hostapd_data *hapd = ctx;
  #ifndef CONFIG_NO_STDOUT_DEBUG
-@@ -2035,7 +2035,7 @@ void wpa_supplicant_event(void *ctx, enu
+@@ -2082,7 +2082,7 @@ void wpa_supplicant_event(void *ctx, enu
  }
  
  
@@ -231,7 +231,7 @@
  	os_memset(&global, 0, sizeof(global));
 --- a/wpa_supplicant/events.c
 +++ b/wpa_supplicant/events.c
-@@ -4581,8 +4581,8 @@ static void wpas_event_unprot_beacon(str
+@@ -4665,8 +4665,8 @@ static void wpas_event_unprot_beacon(str
  }
  
  
@@ -242,7 +242,7 @@
  {
  	struct wpa_supplicant *wpa_s = ctx;
  	int resched;
-@@ -5400,7 +5400,7 @@ void wpa_supplicant_event(void *ctx, enu
+@@ -5511,7 +5511,7 @@ void wpa_supplicant_event(void *ctx, enu
  }
  
  
@@ -253,7 +253,7 @@
  	struct wpa_supplicant *wpa_s;
 --- a/wpa_supplicant/wpa_supplicant.c
 +++ b/wpa_supplicant/wpa_supplicant.c
-@@ -6594,7 +6594,6 @@ struct wpa_interface * wpa_supplicant_ma
+@@ -6819,7 +6819,6 @@ struct wpa_interface * wpa_supplicant_ma
  	return NULL;
  }
  
@@ -261,7 +261,7 @@
  /**
   * wpa_supplicant_match_existing - Match existing interfaces
   * @global: Pointer to global data from wpa_supplicant_init()
-@@ -6631,6 +6630,11 @@ static int wpa_supplicant_match_existing
+@@ -6854,6 +6853,11 @@ static int wpa_supplicant_match_existing
  
  #endif /* CONFIG_MATCH_IFACE */
  
@@ -273,7 +273,7 @@
  
  /**
   * wpa_supplicant_add_iface - Add a new network interface
-@@ -6887,6 +6891,8 @@ struct wpa_global * wpa_supplicant_init(
+@@ -7110,6 +7114,8 @@ struct wpa_global * wpa_supplicant_init(
  #ifndef CONFIG_NO_WPA_MSG
  	wpa_msg_register_ifname_cb(wpa_supplicant_msg_ifname_cb);
  #endif /* CONFIG_NO_WPA_MSG */
@@ -296,7 +296,7 @@
  
  #ifdef CONFIG_WPS
  static int gen_uuid(const char *txt_addr)
-@@ -684,6 +689,8 @@ int main(int argc, char *argv[])
+@@ -683,6 +688,8 @@ int main(int argc, char *argv[])
  		return -1;
  #endif /* CONFIG_DPP */
  
@@ -333,7 +333,7 @@
  
  const struct wpa_driver_ops *const wpa_drivers[] = { NULL };
  
-@@ -1292,6 +1297,10 @@ static void usage(void)
+@@ -1291,6 +1296,10 @@ static void usage(void)
  	       "option several times.\n");
  }
  
@@ -344,7 +344,7 @@
  
  int main(int argc, char *argv[])
  {
-@@ -1312,6 +1321,8 @@ int main(int argc, char *argv[])
+@@ -1311,6 +1320,8 @@ int main(int argc, char *argv[])
  	if (os_program_init())
  		return -1;
  
diff --git a/package/network/services/hostapd/patches/300-noscan.patch b/package/network/services/hostapd/patches/300-noscan.patch
index 638b76f84e..93b0934283 100644
--- a/package/network/services/hostapd/patches/300-noscan.patch
+++ b/package/network/services/hostapd/patches/300-noscan.patch
@@ -1,6 +1,6 @@
 --- a/hostapd/config_file.c
 +++ b/hostapd/config_file.c
-@@ -3493,6 +3493,10 @@ static int hostapd_config_fill(struct ho
+@@ -3459,6 +3459,10 @@ static int hostapd_config_fill(struct ho
  		if (bss->ocv && !bss->ieee80211w)
  			bss->ieee80211w = 1;
  #endif /* CONFIG_OCV */
@@ -13,7 +13,7 @@
  	} else if (os_strcmp(buf, "ht_capab") == 0) {
 --- a/src/ap/ap_config.h
 +++ b/src/ap/ap_config.h
-@@ -984,6 +984,8 @@ struct hostapd_config {
+@@ -1009,6 +1009,8 @@ struct hostapd_config {
  
  	int ht_op_mode_fixed;
  	u16 ht_capab;
@@ -24,7 +24,7 @@
  	int no_pri_sec_switch;
 --- a/src/ap/hw_features.c
 +++ b/src/ap/hw_features.c
-@@ -500,7 +500,8 @@ static int ieee80211n_check_40mhz(struct
+@@ -517,7 +517,8 @@ static int ieee80211n_check_40mhz(struct
  	int ret;
  
  	/* Check that HT40 is used and PRI / SEC switch is allowed */
diff --git a/package/network/services/hostapd/patches/301-mesh-noscan.patch b/package/network/services/hostapd/patches/301-mesh-noscan.patch
index f85b72453e..0d78329441 100644
--- a/package/network/services/hostapd/patches/301-mesh-noscan.patch
+++ b/package/network/services/hostapd/patches/301-mesh-noscan.patch
@@ -1,6 +1,6 @@
 --- a/wpa_supplicant/config.c
 +++ b/wpa_supplicant/config.c
-@@ -2478,6 +2478,7 @@ static const struct parse_data ssid_fiel
+@@ -2532,6 +2532,7 @@ static const struct parse_data ssid_fiel
  #else /* CONFIG_MESH */
  	{ INT_RANGE(mode, 0, 4) },
  #endif /* CONFIG_MESH */
@@ -10,7 +10,7 @@
  	{ STR(id_str) },
 --- a/wpa_supplicant/config_file.c
 +++ b/wpa_supplicant/config_file.c
-@@ -866,6 +866,7 @@ static void wpa_config_write_network(FIL
+@@ -768,6 +768,7 @@ static void wpa_config_write_network(FIL
  #endif /* IEEE8021X_EAPOL */
  	INT(mode);
  	INT(no_auto_peer);
@@ -20,7 +20,7 @@
  	INT(enable_edmg);
 --- a/wpa_supplicant/mesh.c
 +++ b/wpa_supplicant/mesh.c
-@@ -467,6 +467,8 @@ static int wpa_supplicant_mesh_init(stru
+@@ -474,6 +474,8 @@ static int wpa_supplicant_mesh_init(stru
  			   frequency);
  		goto out_free;
  	}
@@ -31,7 +31,7 @@
  		/*
 --- a/wpa_supplicant/wpa_supplicant.c
 +++ b/wpa_supplicant/wpa_supplicant.c
-@@ -2334,12 +2334,12 @@ void ibss_mesh_setup_freq(struct wpa_sup
+@@ -2384,12 +2384,12 @@ void ibss_mesh_setup_freq(struct wpa_sup
  	int ieee80211_mode = wpas_mode_to_ieee80211_mode(ssid->mode);
  	enum hostapd_hw_mode hw_mode;
  	struct hostapd_hw_modes *mode = NULL;
@@ -46,7 +46,7 @@
  	unsigned int j, k;
  	struct hostapd_freq_params vht_freq;
  	int chwidth, seg0, seg1;
-@@ -2421,7 +2421,7 @@ void ibss_mesh_setup_freq(struct wpa_sup
+@@ -2473,7 +2473,7 @@ void ibss_mesh_setup_freq(struct wpa_sup
  #endif /* CONFIG_HE_OVERRIDES */
  
  	/* Setup higher BW only for 5 GHz */
diff --git a/package/network/services/hostapd/patches/310-rescan_immediately.patch b/package/network/services/hostapd/patches/310-rescan_immediately.patch
index 0040b61c6b..7f5e207069 100644
--- a/package/network/services/hostapd/patches/310-rescan_immediately.patch
+++ b/package/network/services/hostapd/patches/310-rescan_immediately.patch
@@ -1,6 +1,6 @@
 --- a/wpa_supplicant/wpa_supplicant.c
 +++ b/wpa_supplicant/wpa_supplicant.c
-@@ -4949,7 +4949,7 @@ wpa_supplicant_alloc(struct wpa_supplica
+@@ -5154,7 +5154,7 @@ wpa_supplicant_alloc(struct wpa_supplica
  	if (wpa_s == NULL)
  		return NULL;
  	wpa_s->scan_req = INITIAL_SCAN_REQ;
diff --git a/package/network/services/hostapd/patches/320-optional_rfkill.patch b/package/network/services/hostapd/patches/320-optional_rfkill.patch
index a703c7e132..01537790e0 100644
--- a/package/network/services/hostapd/patches/320-optional_rfkill.patch
+++ b/package/network/services/hostapd/patches/320-optional_rfkill.patch
@@ -1,6 +1,6 @@
 --- a/src/drivers/drivers.mak
 +++ b/src/drivers/drivers.mak
-@@ -50,7 +50,6 @@ NEED_SME=y
+@@ -54,7 +54,6 @@ NEED_SME=y
  NEED_AP_MLME=y
  NEED_NETLINK=y
  NEED_LINUX_IOCTL=y
@@ -8,7 +8,7 @@
  NEED_RADIOTAP=y
  NEED_LIBNL=y
  endif
-@@ -107,7 +106,6 @@ DRV_WPA_CFLAGS += -DCONFIG_DRIVER_WEXT
+@@ -111,7 +110,6 @@ DRV_WPA_CFLAGS += -DCONFIG_DRIVER_WEXT
  CONFIG_WIRELESS_EXTENSION=y
  NEED_NETLINK=y
  NEED_LINUX_IOCTL=y
@@ -16,7 +16,7 @@
  endif
  
  ifdef CONFIG_DRIVER_NDIS
-@@ -133,7 +131,6 @@ endif
+@@ -137,7 +135,6 @@ endif
  ifdef CONFIG_WIRELESS_EXTENSION
  DRV_WPA_CFLAGS += -DCONFIG_WIRELESS_EXTENSION
  DRV_WPA_OBJS += ../src/drivers/driver_wext.o
@@ -24,7 +24,7 @@
  endif
  
  ifdef NEED_NETLINK
-@@ -142,6 +139,7 @@ endif
+@@ -146,6 +143,7 @@ endif
  
  ifdef NEED_RFKILL
  DRV_OBJS += ../src/drivers/rfkill.o
diff --git a/package/network/services/hostapd/patches/330-nl80211_fix_set_freq.patch b/package/network/services/hostapd/patches/330-nl80211_fix_set_freq.patch
index 9e2551ce60..9ced08801e 100644
--- a/package/network/services/hostapd/patches/330-nl80211_fix_set_freq.patch
+++ b/package/network/services/hostapd/patches/330-nl80211_fix_set_freq.patch
@@ -1,6 +1,6 @@
 --- a/src/drivers/driver_nl80211.c
 +++ b/src/drivers/driver_nl80211.c
-@@ -4646,7 +4646,7 @@ static int nl80211_set_channel(struct i8
+@@ -4973,7 +4973,7 @@ static int nl80211_set_channel(struct i8
  		   freq->freq, freq->ht_enabled, freq->vht_enabled, freq->he_enabled,
  		   freq->bandwidth, freq->center_freq1, freq->center_freq2);
  
diff --git a/package/network/services/hostapd/patches/340-reload_freq_change.patch b/package/network/services/hostapd/patches/340-reload_freq_change.patch
index e0e62c2a11..3d51a47a1e 100644
--- a/package/network/services/hostapd/patches/340-reload_freq_change.patch
+++ b/package/network/services/hostapd/patches/340-reload_freq_change.patch
@@ -1,6 +1,6 @@
 --- a/src/ap/hostapd.c
 +++ b/src/ap/hostapd.c
-@@ -114,6 +114,28 @@ static void hostapd_reload_bss(struct ho
+@@ -115,6 +115,28 @@ static void hostapd_reload_bss(struct ho
  #endif /* CONFIG_NO_RADIUS */
  
  	ssid = &hapd->conf->ssid;
@@ -29,7 +29,7 @@
  	if (!ssid->wpa_psk_set && ssid->wpa_psk && !ssid->wpa_psk->next &&
  	    ssid->wpa_passphrase_set && ssid->wpa_passphrase) {
  		/*
-@@ -215,6 +237,7 @@ int hostapd_reload_config(struct hostapd
+@@ -216,6 +238,7 @@ int hostapd_reload_config(struct hostapd
  	struct hostapd_data *hapd = iface->bss[0];
  	struct hostapd_config *newconf, *oldconf;
  	size_t j;
@@ -37,7 +37,7 @@
  
  	if (iface->config_fname == NULL) {
  		/* Only in-memory config in use - assume it has been updated */
-@@ -265,24 +288,20 @@ int hostapd_reload_config(struct hostapd
+@@ -266,24 +289,20 @@ int hostapd_reload_config(struct hostapd
  	}
  	iface->conf = newconf;
  
diff --git a/package/network/services/hostapd/patches/341-mesh-ctrl-iface-channel-switch.patch b/package/network/services/hostapd/patches/341-mesh-ctrl-iface-channel-switch.patch
index 90fa5eff5d..73f81f65e6 100644
--- a/package/network/services/hostapd/patches/341-mesh-ctrl-iface-channel-switch.patch
+++ b/package/network/services/hostapd/patches/341-mesh-ctrl-iface-channel-switch.patch
@@ -1,6 +1,6 @@
 --- a/wpa_supplicant/ap.c
 +++ b/wpa_supplicant/ap.c
-@@ -1466,15 +1466,35 @@ int ap_switch_channel(struct wpa_supplic
+@@ -1513,15 +1513,35 @@ int ap_switch_channel(struct wpa_supplic
  
  
  #ifdef CONFIG_CTRL_IFACE
diff --git a/package/network/services/hostapd/patches/350-nl80211_del_beacon_bss.patch b/package/network/services/hostapd/patches/350-nl80211_del_beacon_bss.patch
index a2a03c04f7..1f9b74e97e 100644
--- a/package/network/services/hostapd/patches/350-nl80211_del_beacon_bss.patch
+++ b/package/network/services/hostapd/patches/350-nl80211_del_beacon_bss.patch
@@ -1,6 +1,6 @@
 --- a/src/drivers/driver_nl80211.c
 +++ b/src/drivers/driver_nl80211.c
-@@ -2788,10 +2788,15 @@ static int wpa_driver_nl80211_del_beacon
+@@ -2918,10 +2918,15 @@ static int wpa_driver_nl80211_del_beacon
  	struct nl_msg *msg;
  	struct wpa_driver_nl80211_data *drv = bss->drv;
  
@@ -15,10 +15,10 @@
  	nl80211_put_wiphy_data_ap(bss);
 -	msg = nl80211_drv_msg(drv, 0, NL80211_CMD_DEL_BEACON);
 +	msg = nl80211_bss_msg(bss, 0, NL80211_CMD_DEL_BEACON);
- 	return send_and_recv_msgs(drv, msg, NULL, NULL);
+ 	return send_and_recv_msgs(drv, msg, NULL, NULL, NULL, NULL);
  }
  
-@@ -5261,7 +5266,7 @@ static void nl80211_teardown_ap(struct i
+@@ -5602,7 +5607,7 @@ static void nl80211_teardown_ap(struct i
  		nl80211_mgmt_unsubscribe(bss, "AP teardown");
  
  	nl80211_put_wiphy_data_ap(bss);
@@ -27,7 +27,7 @@
  }
  
  
-@@ -7679,8 +7684,6 @@ static int wpa_driver_nl80211_if_remove(
+@@ -8051,8 +8056,6 @@ static int wpa_driver_nl80211_if_remove(
  	} else {
  		wpa_printf(MSG_DEBUG, "nl80211: First BSS - reassign context");
  		nl80211_teardown_ap(bss);
@@ -36,7 +36,7 @@
  		nl80211_destroy_bss(bss);
  		if (!bss->added_if)
  			i802_set_iface_flags(bss, 0);
-@@ -8074,7 +8077,6 @@ static int wpa_driver_nl80211_deinit_ap(
+@@ -8449,7 +8452,6 @@ static int wpa_driver_nl80211_deinit_ap(
  	if (!is_ap_interface(drv->nlmode))
  		return -1;
  	wpa_driver_nl80211_del_beacon(bss);
@@ -44,7 +44,7 @@
  
  	/*
  	 * If the P2P GO interface was dynamically added, then it is
-@@ -8094,7 +8096,6 @@ static int wpa_driver_nl80211_stop_ap(vo
+@@ -8469,7 +8471,6 @@ static int wpa_driver_nl80211_stop_ap(vo
  	if (!is_ap_interface(drv->nlmode))
  		return -1;
  	wpa_driver_nl80211_del_beacon(bss);
diff --git a/package/network/services/hostapd/patches/360-ctrl_iface_reload.patch b/package/network/services/hostapd/patches/360-ctrl_iface_reload.patch
index 31c5102cb1..349522e06a 100644
--- a/package/network/services/hostapd/patches/360-ctrl_iface_reload.patch
+++ b/package/network/services/hostapd/patches/360-ctrl_iface_reload.patch
@@ -1,6 +1,6 @@
 --- a/hostapd/ctrl_iface.c
 +++ b/hostapd/ctrl_iface.c
-@@ -65,6 +65,7 @@
+@@ -67,6 +67,7 @@
  #include "fst/fst_ctrl_iface.h"
  #include "config_file.h"
  #include "ctrl_iface.h"
@@ -8,7 +8,7 @@
  
  
  #define HOSTAPD_CLI_DUP_VALUE_MAX_LEN 256
-@@ -80,6 +81,7 @@ static void hostapd_ctrl_iface_send(stru
+@@ -82,6 +83,7 @@ static void hostapd_ctrl_iface_send(stru
  				    enum wpa_msg_type type,
  				    const char *buf, size_t len);
  
@@ -16,7 +16,7 @@
  
  static int hostapd_ctrl_iface_attach(struct hostapd_data *hapd,
  				     struct sockaddr_storage *from,
-@@ -131,6 +133,61 @@ static int hostapd_ctrl_iface_new_sta(st
+@@ -133,6 +135,61 @@ static int hostapd_ctrl_iface_new_sta(st
  	return 0;
  }
  
@@ -78,7 +78,7 @@
  
  #ifdef NEED_AP_MLME
  static int hostapd_ctrl_iface_sa_query(struct hostapd_data *hapd,
-@@ -3546,6 +3603,8 @@ static int hostapd_ctrl_iface_receive_pr
+@@ -3754,6 +3811,8 @@ static int hostapd_ctrl_iface_receive_pr
  	} else if (os_strncmp(buf, "VENDOR ", 7) == 0) {
  		reply_len = hostapd_ctrl_iface_vendor(hapd, buf + 7, reply,
  						      reply_size);
@@ -89,7 +89,7 @@
  #ifdef RADIUS_SERVER
 --- a/src/ap/ctrl_iface_ap.c
 +++ b/src/ap/ctrl_iface_ap.c
-@@ -917,7 +917,13 @@ int hostapd_parse_csa_settings(const cha
+@@ -919,7 +919,13 @@ int hostapd_parse_csa_settings(const cha
  
  int hostapd_ctrl_iface_stop_ap(struct hostapd_data *hapd)
  {
diff --git a/package/network/services/hostapd/patches/370-ap_sta_support.patch b/package/network/services/hostapd/patches/370-ap_sta_support.patch
index a7a646d2d1..c5cad3bb8d 100644
--- a/package/network/services/hostapd/patches/370-ap_sta_support.patch
+++ b/package/network/services/hostapd/patches/370-ap_sta_support.patch
@@ -1,17 +1,6 @@
 --- a/wpa_supplicant/Makefile
 +++ b/wpa_supplicant/Makefile
-@@ -26,6 +26,10 @@ CFLAGS += $(EXTRA_CFLAGS)
- CFLAGS += -I$(abspath ../src)
- CFLAGS += -I$(abspath ../src/utils)
- 
-+ifdef MULTICALL
-+CFLAGS += -DMULTICALL
-+endif
-+
- -include .config
- -include $(if $(MULTICALL),../hostapd/.config)
- 
-@@ -118,6 +122,8 @@ OBJS_c += ../src/utils/common.o
+@@ -108,6 +108,8 @@ OBJS_c += ../src/utils/common.o
  OBJS_c += ../src/common/cli.o
  OBJS += wmm_ac.o
  
@@ -30,7 +19,7 @@
  #include "drivers/driver.h"
  #include "eap_peer/eap.h"
  #include "wpa_supplicant_i.h"
-@@ -294,6 +295,10 @@ void calculate_update_time(const struct
+@@ -282,6 +283,10 @@ void calculate_update_time(const struct
  static void wpa_bss_copy_res(struct wpa_bss *dst, struct wpa_scan_res *src,
  			     struct os_reltime *fetch_time)
  {
@@ -41,7 +30,7 @@
  	dst->flags = src->flags;
  	os_memcpy(dst->bssid, src->bssid, ETH_ALEN);
  	dst->freq = src->freq;
-@@ -306,6 +311,15 @@ static void wpa_bss_copy_res(struct wpa_
+@@ -294,6 +299,15 @@ static void wpa_bss_copy_res(struct wpa_
  	dst->est_throughput = src->est_throughput;
  	dst->snr = src->snr;
  
@@ -59,7 +48,7 @@
  
 --- a/wpa_supplicant/bss.h
 +++ b/wpa_supplicant/bss.h
-@@ -83,6 +83,10 @@ struct wpa_bss {
+@@ -94,6 +94,10 @@ struct wpa_bss {
  	u8 ssid[SSID_MAX_LEN];
  	/** Length of SSID */
  	size_t ssid_len;
@@ -110,7 +99,7 @@
  			break;
 --- a/wpa_supplicant/wpa_supplicant.c
 +++ b/wpa_supplicant/wpa_supplicant.c
-@@ -129,6 +129,54 @@ static void wpas_update_fils_connect_par
+@@ -130,6 +130,54 @@ static void wpas_update_fils_connect_par
  static void wpas_update_owe_connect_params(struct wpa_supplicant *wpa_s);
  #endif /* CONFIG_OWE */
  
@@ -165,7 +154,7 @@
  
  #ifdef CONFIG_WEP
  /* Configure default/group WEP keys for static WEP */
-@@ -991,6 +1039,8 @@ void wpa_supplicant_set_state(struct wpa
+@@ -1007,6 +1055,8 @@ void wpa_supplicant_set_state(struct wpa
  
  		sme_sched_obss_scan(wpa_s, 1);
  
@@ -174,7 +163,7 @@
  #if defined(CONFIG_FILS) && defined(IEEE8021X_EAPOL)
  		if (!fils_hlp_sent && ssid && ssid->eap.erp)
  			update_fils_connect_params = true;
-@@ -1001,6 +1051,8 @@ void wpa_supplicant_set_state(struct wpa
+@@ -1017,6 +1067,8 @@ void wpa_supplicant_set_state(struct wpa
  #endif /* CONFIG_OWE */
  	} else if (state == WPA_DISCONNECTED || state == WPA_ASSOCIATING ||
  		   state == WPA_ASSOCIATED) {
@@ -183,7 +172,7 @@
  		wpa_s->new_connection = 1;
  		wpa_drv_set_operstate(wpa_s, 0);
  #ifndef IEEE8021X_EAPOL
-@@ -2225,6 +2277,8 @@ void wpa_supplicant_associate(struct wpa
+@@ -2276,6 +2328,8 @@ void wpa_supplicant_associate(struct wpa
  			return;
  		}
  		wpa_s->current_bss = bss;
@@ -192,7 +181,7 @@
  #else /* CONFIG_MESH */
  		wpa_msg(wpa_s, MSG_ERROR,
  			"mesh mode support not included in the build");
-@@ -6207,6 +6261,16 @@ static int wpa_supplicant_init_iface(str
+@@ -6426,6 +6480,16 @@ static int wpa_supplicant_init_iface(str
  			   sizeof(wpa_s->bridge_ifname));
  	}
  
@@ -209,7 +198,7 @@
  	/* RSNA Supplicant Key Management - INITIALIZE */
  	eapol_sm_notify_portEnabled(wpa_s->eapol, false);
  	eapol_sm_notify_portValid(wpa_s->eapol, false);
-@@ -6540,6 +6604,11 @@ static void wpa_supplicant_deinit_iface(
+@@ -6763,6 +6827,11 @@ static void wpa_supplicant_deinit_iface(
  	if (terminate)
  		wpa_msg(wpa_s, MSG_INFO, WPA_EVENT_TERMINATING);
  
@@ -218,12 +207,12 @@
 +		wpa_s->hostapd = NULL;
 +	}
 +
- 	if (wpa_s->ctrl_iface) {
- 		wpa_supplicant_ctrl_iface_deinit(wpa_s->ctrl_iface);
- 		wpa_s->ctrl_iface = NULL;
+ 	wpa_supplicant_ctrl_iface_deinit(wpa_s, wpa_s->ctrl_iface);
+ 	wpa_s->ctrl_iface = NULL;
+ 
 --- a/wpa_supplicant/wpa_supplicant_i.h
 +++ b/wpa_supplicant/wpa_supplicant_i.h
-@@ -104,6 +104,11 @@ struct wpa_interface {
+@@ -103,6 +103,11 @@ struct wpa_interface {
  	const char *ifname;
  
  	/**
@@ -235,7 +224,7 @@
  	 * bridge_ifname - Optional bridge interface name
  	 *
  	 * If the driver interface (ifname) is included in a Linux bridge
-@@ -530,6 +535,8 @@ struct wpa_supplicant {
+@@ -615,6 +620,8 @@ struct wpa_supplicant {
  #endif /* CONFIG_CTRL_IFACE_BINDER */
  	char bridge_ifname[16];
  
@@ -246,7 +235,7 @@
  
 --- a/hostapd/ctrl_iface.c
 +++ b/hostapd/ctrl_iface.c
-@@ -2712,6 +2712,11 @@ static int hostapd_ctrl_iface_chan_switc
+@@ -2883,6 +2883,11 @@ static int hostapd_ctrl_iface_chan_switc
  		return 0;
  	}
  
@@ -257,12 +246,12 @@
 +
  	for (i = 0; i < iface->num_bss; i++) {
  
- 		/* Save CHAN_SWITCH VHT config */
+ 		/* Save CHAN_SWITCH VHT and HE config */
 --- a/src/ap/beacon.c
 +++ b/src/ap/beacon.c
-@@ -1468,11 +1468,6 @@ int ieee802_11_set_beacon(struct hostapd
- 	struct wpabuf *beacon, *proberesp, *assocresp;
- 	int res, ret = -1;
+@@ -1758,11 +1758,6 @@ int ieee802_11_set_beacon(struct hostapd
+ 		return -1;
+ 	}
  
 -	if (hapd->csa_in_progress) {
 -		wpa_printf(MSG_ERROR, "Cannot set beacons during CSA period");
@@ -274,7 +263,7 @@
  	if (ieee802_11_build_ap_params(hapd, &params) < 0)
 --- a/wpa_supplicant/events.c
 +++ b/wpa_supplicant/events.c
-@@ -4581,6 +4581,60 @@ static void wpas_event_unprot_beacon(str
+@@ -4665,6 +4665,60 @@ static void wpas_event_unprot_beacon(str
  }
  
  
@@ -335,7 +324,7 @@
  void supplicant_event(void *ctx, enum wpa_event_type event,
  		      union wpa_event_data *data)
  {
-@@ -4883,8 +4937,10 @@ void supplicant_event(void *ctx, enum wp
+@@ -4980,8 +5034,10 @@ void supplicant_event(void *ctx, enum wp
  			channel_width_to_string(data->ch_switch.ch_width),
  			data->ch_switch.cf1,
  			data->ch_switch.cf2);
@@ -349,7 +338,7 @@
  		wpa_s->current_ssid->frequency = data->ch_switch.freq;
 --- a/src/drivers/driver.h
 +++ b/src/drivers/driver.h
-@@ -5690,6 +5690,7 @@ union wpa_event_data {
+@@ -5829,6 +5829,7 @@ union wpa_event_data {
  
  	/**
  	 * struct ch_switch
@@ -357,7 +346,7 @@
  	 * @freq: Frequency of new channel in MHz
  	 * @ht_enabled: Whether this is an HT channel
  	 * @ch_offset: Secondary channel offset
-@@ -5698,6 +5699,7 @@ union wpa_event_data {
+@@ -5837,6 +5838,7 @@ union wpa_event_data {
  	 * @cf2: Center frequency 2
  	 */
  	struct ch_switch {
@@ -367,7 +356,7 @@
  		int ch_offset;
 --- a/src/drivers/driver_nl80211_event.c
 +++ b/src/drivers/driver_nl80211_event.c
-@@ -541,7 +541,7 @@ static void mlme_event_ch_switch(struct
+@@ -684,7 +684,7 @@ static void mlme_event_ch_switch(struct
  				 struct nlattr *ifindex, struct nlattr *freq,
  				 struct nlattr *type, struct nlattr *bw,
  				 struct nlattr *cf1, struct nlattr *cf2,
@@ -376,7 +365,7 @@
  {
  	struct i802_bss *bss;
  	union wpa_event_data data;
-@@ -600,6 +600,8 @@ static void mlme_event_ch_switch(struct
+@@ -745,6 +745,8 @@ static void mlme_event_ch_switch(struct
  		data.ch_switch.cf1 = nla_get_u32(cf1);
  	if (cf2)
  		data.ch_switch.cf2 = nla_get_u32(cf2);
@@ -385,7 +374,7 @@
  
  	if (finished)
  		bss->freq = data.ch_switch.freq;
-@@ -2686,6 +2688,7 @@ static void do_process_drv_event(struct
+@@ -3003,6 +3005,7 @@ static void do_process_drv_event(struct
  				     tb[NL80211_ATTR_CHANNEL_WIDTH],
  				     tb[NL80211_ATTR_CENTER_FREQ1],
  				     tb[NL80211_ATTR_CENTER_FREQ2],
@@ -393,7 +382,7 @@
  				     0);
  		break;
  	case NL80211_CMD_CH_SWITCH_NOTIFY:
-@@ -2696,6 +2699,7 @@ static void do_process_drv_event(struct
+@@ -3013,6 +3016,7 @@ static void do_process_drv_event(struct
  				     tb[NL80211_ATTR_CHANNEL_WIDTH],
  				     tb[NL80211_ATTR_CENTER_FREQ1],
  				     tb[NL80211_ATTR_CENTER_FREQ2],
diff --git a/package/network/services/hostapd/patches/380-disable_ctrl_iface_mib.patch b/package/network/services/hostapd/patches/380-disable_ctrl_iface_mib.patch
index b98b2d0cba..ca634077b7 100644
--- a/package/network/services/hostapd/patches/380-disable_ctrl_iface_mib.patch
+++ b/package/network/services/hostapd/patches/380-disable_ctrl_iface_mib.patch
@@ -1,6 +1,6 @@
 --- a/hostapd/Makefile
 +++ b/hostapd/Makefile
-@@ -226,6 +226,9 @@ endif
+@@ -221,6 +221,9 @@ endif
  ifdef CONFIG_NO_CTRL_IFACE
  CFLAGS += -DCONFIG_NO_CTRL_IFACE
  else
@@ -12,7 +12,7 @@
  else
 --- a/hostapd/ctrl_iface.c
 +++ b/hostapd/ctrl_iface.c
-@@ -3370,6 +3370,7 @@ static int hostapd_ctrl_iface_receive_pr
+@@ -3569,6 +3569,7 @@ static int hostapd_ctrl_iface_receive_pr
  						      reply_size);
  	} else if (os_strcmp(buf, "STATUS-DRIVER") == 0) {
  		reply_len = hostapd_drv_status(hapd, reply, reply_size);
@@ -20,7 +20,7 @@
  	} else if (os_strcmp(buf, "MIB") == 0) {
  		reply_len = ieee802_11_get_mib(hapd, reply, reply_size);
  		if (reply_len >= 0) {
-@@ -3411,6 +3412,7 @@ static int hostapd_ctrl_iface_receive_pr
+@@ -3610,6 +3611,7 @@ static int hostapd_ctrl_iface_receive_pr
  	} else if (os_strncmp(buf, "STA-NEXT ", 9) == 0) {
  		reply_len = hostapd_ctrl_iface_sta_next(hapd, buf + 9, reply,
  							reply_size);
@@ -30,7 +30,7 @@
  			reply_len = -1;
 --- a/wpa_supplicant/Makefile
 +++ b/wpa_supplicant/Makefile
-@@ -952,6 +952,9 @@ ifdef CONFIG_FILS
+@@ -955,6 +955,9 @@ ifdef CONFIG_FILS
  OBJS += ../src/ap/fils_hlp.o
  endif
  ifdef CONFIG_CTRL_IFACE
@@ -42,7 +42,7 @@
  
 --- a/wpa_supplicant/ctrl_iface.c
 +++ b/wpa_supplicant/ctrl_iface.c
-@@ -2267,7 +2267,7 @@ static int wpa_supplicant_ctrl_iface_sta
+@@ -2308,7 +2308,7 @@ static int wpa_supplicant_ctrl_iface_sta
  			pos += ret;
  		}
  
@@ -51,7 +51,7 @@
  		if (wpa_s->ap_iface) {
  			pos += ap_ctrl_iface_wpa_get_status(wpa_s, pos,
  							    end - pos,
-@@ -10366,6 +10366,7 @@ char * wpa_supplicant_ctrl_iface_process
+@@ -10919,6 +10919,7 @@ char * wpa_supplicant_ctrl_iface_process
  			reply_len = -1;
  	} else if (os_strncmp(buf, "NOTE ", 5) == 0) {
  		wpa_printf(MSG_INFO, "NOTE: %s", buf + 5);
@@ -59,7 +59,7 @@
  	} else if (os_strcmp(buf, "MIB") == 0) {
  		reply_len = wpa_sm_get_mib(wpa_s->wpa, reply, reply_size);
  		if (reply_len >= 0) {
-@@ -10378,6 +10379,7 @@ char * wpa_supplicant_ctrl_iface_process
+@@ -10931,6 +10932,7 @@ char * wpa_supplicant_ctrl_iface_process
  				reply_size - reply_len);
  #endif /* CONFIG_MACSEC */
  		}
@@ -67,7 +67,7 @@
  	} else if (os_strncmp(buf, "STATUS", 6) == 0) {
  		reply_len = wpa_supplicant_ctrl_iface_status(
  			wpa_s, buf + 6, reply, reply_size);
-@@ -10862,6 +10864,7 @@ char * wpa_supplicant_ctrl_iface_process
+@@ -11419,6 +11421,7 @@ char * wpa_supplicant_ctrl_iface_process
  		reply_len = wpa_supplicant_ctrl_iface_bss(
  			wpa_s, buf + 4, reply, reply_size);
  #ifdef CONFIG_AP
@@ -75,7 +75,7 @@
  	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
  		reply_len = ap_ctrl_iface_sta_first(wpa_s, reply, reply_size);
  	} else if (os_strncmp(buf, "STA ", 4) == 0) {
-@@ -10870,12 +10873,15 @@ char * wpa_supplicant_ctrl_iface_process
+@@ -11427,12 +11430,15 @@ char * wpa_supplicant_ctrl_iface_process
  	} else if (os_strncmp(buf, "STA-NEXT ", 9) == 0) {
  		reply_len = ap_ctrl_iface_sta_next(wpa_s, buf + 9, reply,
  						   reply_size);
@@ -109,7 +109,7 @@
  
  #ifdef CONFIG_P2P_MANAGER
  static int p2p_manager_disconnect(struct hostapd_data *hapd, u16 stype,
-@@ -806,12 +808,12 @@ int hostapd_ctrl_iface_status(struct hos
+@@ -807,12 +809,12 @@ int hostapd_ctrl_iface_status(struct hos
  			return len;
  		len += ret;
  	}
@@ -126,7 +126,7 @@
  		if (os_snprintf_error(buflen - len, ret))
 --- a/src/ap/ieee802_1x.c
 +++ b/src/ap/ieee802_1x.c
-@@ -2711,6 +2711,7 @@ static const char * bool_txt(bool val)
+@@ -2712,6 +2712,7 @@ static const char * bool_txt(bool val)
  	return val ? "TRUE" : "FALSE";
  }
  
@@ -134,7 +134,7 @@
  
  int ieee802_1x_get_mib(struct hostapd_data *hapd, char *buf, size_t buflen)
  {
-@@ -2897,6 +2898,7 @@ int ieee802_1x_get_mib_sta(struct hostap
+@@ -2898,6 +2899,7 @@ int ieee802_1x_get_mib_sta(struct hostap
  	return len;
  }
  
@@ -144,7 +144,7 @@
  static void ieee802_1x_wnm_notif_send(void *eloop_ctx, void *timeout_ctx)
 --- a/src/ap/wpa_auth.c
 +++ b/src/ap/wpa_auth.c
-@@ -4451,6 +4451,7 @@ static const char * wpa_bool_txt(int val
+@@ -4519,6 +4519,7 @@ static const char * wpa_bool_txt(int val
  	return val ? "TRUE" : "FALSE";
  }
  
@@ -152,7 +152,7 @@
  
  #define RSN_SUITE "%02x-%02x-%02x-%d"
  #define RSN_SUITE_ARG(s) \
-@@ -4601,7 +4602,7 @@ int wpa_get_mib_sta(struct wpa_state_mac
+@@ -4669,7 +4670,7 @@ int wpa_get_mib_sta(struct wpa_state_mac
  
  	return len;
  }
@@ -163,7 +163,7 @@
  {
 --- a/src/rsn_supp/wpa.c
 +++ b/src/rsn_supp/wpa.c
-@@ -2728,6 +2728,8 @@ static u32 wpa_key_mgmt_suite(struct wpa
+@@ -2767,6 +2767,8 @@ static u32 wpa_key_mgmt_suite(struct wpa
  }
  
  
@@ -172,7 +172,7 @@
  #define RSN_SUITE "%02x-%02x-%02x-%d"
  #define RSN_SUITE_ARG(s) \
  ((s) >> 24) & 0xff, ((s) >> 16) & 0xff, ((s) >> 8) & 0xff, (s) & 0xff
-@@ -2809,6 +2811,7 @@ int wpa_sm_get_mib(struct wpa_sm *sm, ch
+@@ -2848,6 +2850,7 @@ int wpa_sm_get_mib(struct wpa_sm *sm, ch
  
  	return (int) len;
  }
@@ -182,7 +182,7 @@
  
 --- a/wpa_supplicant/ap.c
 +++ b/wpa_supplicant/ap.c
-@@ -1324,7 +1324,7 @@ int wpas_ap_wps_nfc_report_handover(stru
+@@ -1364,7 +1364,7 @@ int wpas_ap_wps_nfc_report_handover(stru
  #endif /* CONFIG_WPS */
  
  
diff --git a/package/network/services/hostapd/patches/390-wpa_ie_cap_workaround.patch b/package/network/services/hostapd/patches/390-wpa_ie_cap_workaround.patch
index 9dee2d738e..65a8b07e65 100644
--- a/package/network/services/hostapd/patches/390-wpa_ie_cap_workaround.patch
+++ b/package/network/services/hostapd/patches/390-wpa_ie_cap_workaround.patch
@@ -1,6 +1,6 @@
 --- a/src/common/wpa_common.c
 +++ b/src/common/wpa_common.c
-@@ -2121,6 +2121,31 @@ u32 wpa_akm_to_suite(int akm)
+@@ -2444,6 +2444,31 @@ u32 wpa_akm_to_suite(int akm)
  }
  
  
@@ -32,7 +32,7 @@
  int wpa_compare_rsn_ie(int ft_initial_assoc,
  		       const u8 *ie1, size_t ie1len,
  		       const u8 *ie2, size_t ie2len)
-@@ -2128,8 +2153,19 @@ int wpa_compare_rsn_ie(int ft_initial_as
+@@ -2451,8 +2476,19 @@ int wpa_compare_rsn_ie(int ft_initial_as
  	if (ie1 == NULL || ie2 == NULL)
  		return -1;
  
diff --git a/package/network/services/hostapd/patches/420-indicate-features.patch b/package/network/services/hostapd/patches/420-indicate-features.patch
index 9f216347f4..f9dff66073 100644
--- a/package/network/services/hostapd/patches/420-indicate-features.patch
+++ b/package/network/services/hostapd/patches/420-indicate-features.patch
@@ -8,7 +8,7 @@
  #include "crypto/random.h"
  #include "crypto/tls.h"
  #include "common/version.h"
-@@ -692,7 +693,7 @@ int main(int argc, char *argv[])
+@@ -691,7 +692,7 @@ int main(int argc, char *argv[])
  	wpa_supplicant_event = hostapd_wpa_event;
  	wpa_supplicant_event_global = hostapd_wpa_event_global;
  	for (;;) {
@@ -17,7 +17,7 @@
  		if (c < 0)
  			break;
  		switch (c) {
-@@ -729,6 +730,8 @@ int main(int argc, char *argv[])
+@@ -728,6 +729,8 @@ int main(int argc, char *argv[])
  			break;
  #endif /* CONFIG_DEBUG_LINUX_TRACING */
  		case 'v':
diff --git a/package/network/services/hostapd/patches/430-hostapd_cli_ifdef.patch b/package/network/services/hostapd/patches/430-hostapd_cli_ifdef.patch
index 3744464c89..dc1fa3d29d 100644
--- a/package/network/services/hostapd/patches/430-hostapd_cli_ifdef.patch
+++ b/package/network/services/hostapd/patches/430-hostapd_cli_ifdef.patch
@@ -32,7 +32,7 @@
  
  
  static int hostapd_cli_cmd_disassoc_imminent(struct wpa_ctrl *ctrl, int argc,
-@@ -1532,13 +1528,10 @@ static const struct hostapd_cli_cmd host
+@@ -1579,13 +1575,10 @@ static const struct hostapd_cli_cmd host
  	{ "disassociate", hostapd_cli_cmd_disassociate,
  	  hostapd_complete_stations,
  	  "<addr> = disassociate a station" },
@@ -46,7 +46,7 @@
  	{ "wps_pin", hostapd_cli_cmd_wps_pin, NULL,
  	  "<uuid> <pin> [timeout] [addr] = add WPS Enrollee PIN" },
  	{ "wps_check_pin", hostapd_cli_cmd_wps_check_pin, NULL,
-@@ -1563,7 +1556,6 @@ static const struct hostapd_cli_cmd host
+@@ -1610,7 +1603,6 @@ static const struct hostapd_cli_cmd host
  	  "<SSID> <auth> <encr> <key> = configure AP" },
  	{ "wps_get_status", hostapd_cli_cmd_wps_get_status, NULL,
  	  "= show current WPS status" },
diff --git a/package/network/services/hostapd/patches/460-wpa_supplicant-add-new-config-params-to-be-used-with.patch b/package/network/services/hostapd/patches/460-wpa_supplicant-add-new-config-params-to-be-used-with.patch
index 99c552821b..e0e687e161 100644
--- a/package/network/services/hostapd/patches/460-wpa_supplicant-add-new-config-params-to-be-used-with.patch
+++ b/package/network/services/hostapd/patches/460-wpa_supplicant-add-new-config-params-to-be-used-with.patch
@@ -22,7 +22,7 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
  #include "common/defs.h"
  #include "common/ieee802_11_defs.h"
  #include "common/wpa_common.h"
-@@ -850,6 +851,9 @@ struct wpa_driver_associate_params {
+@@ -851,6 +852,9 @@ struct wpa_driver_associate_params {
  	 * responsible for selecting with which BSS to associate. */
  	const u8 *bssid;
  
@@ -42,7 +42,7 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
  #include "config.h"
  
  
-@@ -2269,6 +2270,97 @@ static char * wpa_config_write_peerkey(c
+@@ -2321,6 +2322,97 @@ static char * wpa_config_write_peerkey(c
  #endif /* NO_CONFIG_WRITE */
  
  
@@ -140,7 +140,7 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
  /* Helper macros for network block parser */
  
  #ifdef OFFSET
-@@ -2552,6 +2644,8 @@ static const struct parse_data ssid_fiel
+@@ -2606,6 +2698,8 @@ static const struct parse_data ssid_fiel
  	{ INT(ap_max_inactivity) },
  	{ INT(dtim_period) },
  	{ INT(beacon_int) },
@@ -174,7 +174,7 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
  	 * macsec_policy - Determines the policy for MACsec secure session
 --- a/wpa_supplicant/wpa_supplicant.c
 +++ b/wpa_supplicant/wpa_supplicant.c
-@@ -3638,6 +3638,12 @@ static void wpas_start_assoc_cb(struct w
+@@ -3726,6 +3726,12 @@ static void wpas_start_assoc_cb(struct w
  			params.beacon_int = ssid->beacon_int;
  		else
  			params.beacon_int = wpa_s->conf->beacon_int;
diff --git a/package/network/services/hostapd/patches/461-driver_nl80211-use-new-parameters-during-ibss-join.patch b/package/network/services/hostapd/patches/461-driver_nl80211-use-new-parameters-during-ibss-join.patch
index 61d2089bc8..1d2a053faa 100644
--- a/package/network/services/hostapd/patches/461-driver_nl80211-use-new-parameters-during-ibss-join.patch
+++ b/package/network/services/hostapd/patches/461-driver_nl80211-use-new-parameters-during-ibss-join.patch
@@ -10,7 +10,7 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
 
 --- a/src/drivers/driver_nl80211.c
 +++ b/src/drivers/driver_nl80211.c
-@@ -5584,7 +5584,7 @@ static int wpa_driver_nl80211_ibss(struc
+@@ -5951,7 +5951,7 @@ static int wpa_driver_nl80211_ibss(struc
  				   struct wpa_driver_associate_params *params)
  {
  	struct nl_msg *msg;
@@ -19,7 +19,7 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
  	int count = 0;
  
  	wpa_printf(MSG_DEBUG, "nl80211: Join IBSS (ifindex=%d)", drv->ifindex);
-@@ -5611,6 +5611,37 @@ retry:
+@@ -5978,6 +5978,37 @@ retry:
  	    nl80211_put_beacon_int(msg, params->beacon_int))
  		goto fail;
  
diff --git a/package/network/services/hostapd/patches/463-add-mcast_rate-to-11s.patch b/package/network/services/hostapd/patches/463-add-mcast_rate-to-11s.patch
index 33ef097e75..1794befe95 100644
--- a/package/network/services/hostapd/patches/463-add-mcast_rate-to-11s.patch
+++ b/package/network/services/hostapd/patches/463-add-mcast_rate-to-11s.patch
@@ -19,17 +19,17 @@ Tested-by: Simon Wunderlich <simon.wunderlich@openmesh.com>
 
 --- a/src/drivers/driver.h
 +++ b/src/drivers/driver.h
-@@ -1549,6 +1549,7 @@ struct wpa_driver_mesh_join_params {
+@@ -1618,6 +1618,7 @@ struct wpa_driver_mesh_join_params {
  #define WPA_DRIVER_MESH_FLAG_AMPE	0x00000008
  	unsigned int flags;
- 	u8 handle_dfs;
+ 	bool handle_dfs;
 +	int mcast_rate;
  };
  
  struct wpa_driver_set_key_params {
 --- a/src/drivers/driver_nl80211.c
 +++ b/src/drivers/driver_nl80211.c
-@@ -10043,6 +10043,18 @@ static int nl80211_put_mesh_id(struct nl
+@@ -10476,6 +10476,18 @@ static int nl80211_put_mesh_id(struct nl
  }
  
  
@@ -48,7 +48,7 @@ Tested-by: Simon Wunderlich <simon.wunderlich@openmesh.com>
  static int nl80211_put_mesh_config(struct nl_msg *msg,
  				   struct wpa_driver_mesh_bss_params *params)
  {
-@@ -10104,6 +10116,7 @@ static int nl80211_join_mesh(struct i802
+@@ -10537,6 +10549,7 @@ static int nl80211_join_mesh(struct i802
  	    nl80211_put_basic_rates(msg, params->basic_rates) ||
  	    nl80211_put_mesh_id(msg, params->meshid, params->meshid_len) ||
  	    nl80211_put_beacon_int(msg, params->beacon_int) ||
@@ -58,7 +58,7 @@ Tested-by: Simon Wunderlich <simon.wunderlich@openmesh.com>
  
 --- a/wpa_supplicant/mesh.c
 +++ b/wpa_supplicant/mesh.c
-@@ -592,6 +592,7 @@ int wpa_supplicant_join_mesh(struct wpa_
+@@ -600,6 +600,7 @@ int wpa_supplicant_join_mesh(struct wpa_
  
  	params->meshid = ssid->ssid;
  	params->meshid_len = ssid->ssid_len;
diff --git a/package/network/services/hostapd/patches/464-fix-mesh-obss-check.patch b/package/network/services/hostapd/patches/464-fix-mesh-obss-check.patch
index 6d48175163..4c7cb9ea36 100644
--- a/package/network/services/hostapd/patches/464-fix-mesh-obss-check.patch
+++ b/package/network/services/hostapd/patches/464-fix-mesh-obss-check.patch
@@ -1,6 +1,6 @@
 --- a/wpa_supplicant/wpa_supplicant.c
 +++ b/wpa_supplicant/wpa_supplicant.c
-@@ -2407,11 +2407,13 @@ void ibss_mesh_setup_freq(struct wpa_sup
+@@ -2457,11 +2457,13 @@ void ibss_mesh_setup_freq(struct wpa_sup
  	for (j = 0; j < wpa_s->last_scan_res_used; j++) {
  		struct wpa_bss *bss = wpa_s->last_scan_res[j];
  
diff --git a/package/network/services/hostapd/patches/470-survey_data_fallback.patch b/package/network/services/hostapd/patches/470-survey_data_fallback.patch
index 57a78ee865..efd82599d3 100644
--- a/package/network/services/hostapd/patches/470-survey_data_fallback.patch
+++ b/package/network/services/hostapd/patches/470-survey_data_fallback.patch
@@ -20,7 +20,7 @@
  
  	total = survey->channel_time;
  
-@@ -415,20 +409,19 @@ static int acs_usable_vht160_chan(const
+@@ -422,20 +416,19 @@ static int acs_usable_bw160_chan(const s
  static int acs_survey_is_sufficient(struct freq_survey *survey)
  {
  	if (!(survey->filled & SURVEY_HAS_NF)) {
diff --git a/package/network/services/hostapd/patches/500-lto-jobserver-support.patch b/package/network/services/hostapd/patches/500-lto-jobserver-support.patch
index 46030859de..1475590d06 100644
--- a/package/network/services/hostapd/patches/500-lto-jobserver-support.patch
+++ b/package/network/services/hostapd/patches/500-lto-jobserver-support.patch
@@ -1,16 +1,17 @@
 --- a/hostapd/Makefile
 +++ b/hostapd/Makefile
-@@ -1327,14 +1327,14 @@ hostapd_multi.a: $(BCHECK) $(OBJS)
+@@ -1293,7 +1293,7 @@ hostapd_multi.a: $(BCHECK) $(OBJS)
  	@$(AR) cr $@ hostapd_multi.o $(OBJS)
  
- hostapd: $(BCHECK) $(OBJS)
+ hostapd: $(OBJS)
 -	$(Q)$(CC) $(LDFLAGS) -o hostapd $(OBJS) $(LIBS)
 +	+$(Q)$(CC) $(LDFLAGS) -o hostapd $(OBJS) $(LIBS)
  	@$(E) "  LD " $@
  
  ifdef CONFIG_WPA_TRACE
- OBJS_c += ../src/utils/trace.o
- endif
+@@ -1304,7 +1304,7 @@ _OBJS_VAR := OBJS_c
+ include ../src/objs.mk
+ 
  hostapd_cli: $(OBJS_c)
 -	$(Q)$(CC) $(LDFLAGS) -o hostapd_cli $(OBJS_c) $(LIBS_c)
 +	+$(Q)$(CC) $(LDFLAGS) -o hostapd_cli $(OBJS_c) $(LIBS_c)
@@ -19,7 +20,7 @@
  NOBJS = nt_password_hash.o ../src/crypto/ms_funcs.o $(SHA1OBJS)
 --- a/wpa_supplicant/Makefile
 +++ b/wpa_supplicant/Makefile
-@@ -1930,23 +1930,23 @@ wpa_supplicant_multi.a: .config $(BCHECK
+@@ -1918,31 +1918,31 @@ wpa_supplicant_multi.a: .config $(BCHECK
  	@$(AR) cr $@ wpa_supplicant_multi.o $(OBJS)
  
  wpa_supplicant: $(BCHECK) $(OBJS) $(EXTRA_progs)
@@ -27,21 +28,29 @@
 +	+$(Q)$(LDO) $(LDFLAGS) -o wpa_supplicant $(OBJS) $(LIBS) $(EXTRALIBS)
  	@$(E) "  LD " $@
  
+ _OBJS_VAR := OBJS_t
+ include ../src/objs.mk
  eapol_test: $(OBJS_t)
 -	$(Q)$(LDO) $(LDFLAGS) -o eapol_test $(OBJS_t) $(LIBS)
 +	+$(Q)$(LDO) $(LDFLAGS) -o eapol_test $(OBJS_t) $(LIBS)
  	@$(E) "  LD " $@
  
+ _OBJS_VAR := OBJS_t2
+ include ../src/objs.mk
  preauth_test: $(OBJS_t2)
 -	$(Q)$(LDO) $(LDFLAGS) -o preauth_test $(OBJS_t2) $(LIBS)
 +	+$(Q)$(LDO) $(LDFLAGS) -o preauth_test $(OBJS_t2) $(LIBS)
  	@$(E) "  LD " $@
  
+ _OBJS_VAR := OBJS_p
+ include ../src/objs.mk
  wpa_passphrase: $(OBJS_p)
 -	$(Q)$(LDO) $(LDFLAGS) -o wpa_passphrase $(OBJS_p) $(LIBS_p) $(LIBS)
 +	+$(Q)$(LDO) $(LDFLAGS) -o wpa_passphrase $(OBJS_p) $(LIBS_p) $(LIBS)
  	@$(E) "  LD " $@
  
+ _OBJS_VAR := OBJS_c
+ include ../src/objs.mk
  wpa_cli: $(OBJS_c)
 -	$(Q)$(LDO) $(LDFLAGS) -o wpa_cli $(OBJS_c) $(LIBS_c)
 +	+$(Q)$(LDO) $(LDFLAGS) -o wpa_cli $(OBJS_c) $(LIBS_c)
diff --git a/package/network/services/hostapd/patches/600-ubus_support.patch b/package/network/services/hostapd/patches/600-ubus_support.patch
index 938840755a..005ed54e0c 100644
--- a/package/network/services/hostapd/patches/600-ubus_support.patch
+++ b/package/network/services/hostapd/patches/600-ubus_support.patch
@@ -1,6 +1,6 @@
 --- a/hostapd/Makefile
 +++ b/hostapd/Makefile
-@@ -171,6 +171,11 @@ OBJS += ../src/common/hw_features_common
+@@ -166,6 +166,11 @@ OBJS += ../src/common/hw_features_common
  
  OBJS += ../src/eapol_auth/eapol_auth_sm.o
  
@@ -39,7 +39,7 @@
  	int interface_added; /* virtual interface added for this BSS */
  	unsigned int started:1;
  	unsigned int disabled:1;
-@@ -606,6 +608,7 @@ hostapd_alloc_bss_data(struct hostapd_if
+@@ -610,6 +612,7 @@ hostapd_alloc_bss_data(struct hostapd_if
  		       struct hostapd_bss_config *bss);
  int hostapd_setup_interface(struct hostapd_iface *iface);
  int hostapd_setup_interface_complete(struct hostapd_iface *iface, int err);
@@ -49,7 +49,7 @@
  struct hostapd_iface * hostapd_alloc_iface(void);
 --- a/src/ap/hostapd.c
 +++ b/src/ap/hostapd.c
-@@ -395,6 +395,7 @@ void hostapd_free_hapd_data(struct hosta
+@@ -396,6 +396,7 @@ void hostapd_free_hapd_data(struct hosta
  	hapd->beacon_set_done = 0;
  
  	wpa_printf(MSG_DEBUG, "%s(%s)", __func__, hapd->conf->iface);
@@ -57,7 +57,7 @@
  	accounting_deinit(hapd);
  	hostapd_deinit_wpa(hapd);
  	vlan_deinit(hapd);
-@@ -1417,6 +1418,8 @@ static int hostapd_setup_bss(struct host
+@@ -1422,6 +1423,8 @@ static int hostapd_setup_bss(struct host
  	if (hapd->driver && hapd->driver->set_operstate)
  		hapd->driver->set_operstate(hapd->drv_priv, 1);
  
@@ -66,7 +66,7 @@
  	return 0;
  }
  
-@@ -1999,6 +2002,7 @@ static int hostapd_setup_interface_compl
+@@ -2028,6 +2031,7 @@ static int hostapd_setup_interface_compl
  	if (err)
  		goto fail;
  
@@ -74,7 +74,7 @@
  	wpa_printf(MSG_DEBUG, "Completing interface initialization");
  	if (iface->freq) {
  #ifdef NEED_AP_MLME
-@@ -2196,6 +2200,7 @@ dfs_offload:
+@@ -2225,6 +2229,7 @@ dfs_offload:
  
  fail:
  	wpa_printf(MSG_ERROR, "Interface initialization failed");
@@ -82,7 +82,7 @@
  	hostapd_set_state(iface, HAPD_IFACE_DISABLED);
  	wpa_msg(hapd->msg_ctx, MSG_INFO, AP_EVENT_DISABLED);
  #ifdef CONFIG_FST
-@@ -2669,6 +2674,7 @@ void hostapd_interface_deinit_free(struc
+@@ -2700,6 +2705,7 @@ void hostapd_interface_deinit_free(struc
  		   (unsigned int) iface->conf->num_bss);
  	driver = iface->bss[0]->driver;
  	drv_priv = iface->bss[0]->drv_priv;
@@ -92,7 +92,7 @@
  		   __func__, driver, drv_priv);
 --- a/src/ap/ieee802_11.c
 +++ b/src/ap/ieee802_11.c
-@@ -2327,13 +2327,18 @@ static void handle_auth(struct hostapd_d
+@@ -3553,13 +3553,18 @@ static void handle_auth(struct hostapd_d
  	u16 auth_alg, auth_transaction, status_code;
  	u16 resp = WLAN_STATUS_SUCCESS;
  	struct sta_info *sta = NULL;
@@ -112,7 +112,7 @@
  
  	if (len < IEEE80211_HDRLEN + sizeof(mgmt->u.auth)) {
  		wpa_printf(MSG_INFO, "handle_auth - too short payload (len=%lu)",
-@@ -2493,6 +2498,13 @@ static void handle_auth(struct hostapd_d
+@@ -3727,6 +3732,13 @@ static void handle_auth(struct hostapd_d
  		resp = WLAN_STATUS_UNSPECIFIED_FAILURE;
  		goto fail;
  	}
@@ -126,16 +126,16 @@
  	if (res == HOSTAPD_ACL_PENDING)
  		return;
  
-@@ -4166,7 +4178,7 @@ static void handle_assoc(struct hostapd_
+@@ -5454,7 +5466,7 @@ static void handle_assoc(struct hostapd_
  	int resp = WLAN_STATUS_SUCCESS;
- 	u16 reply_res;
+ 	u16 reply_res = WLAN_STATUS_UNSPECIFIED_FAILURE;
  	const u8 *pos;
 -	int left, i;
 +	int left, i, ubus_resp;
  	struct sta_info *sta;
  	u8 *tmp = NULL;
  #ifdef CONFIG_FILS
-@@ -4379,6 +4391,11 @@ static void handle_assoc(struct hostapd_
+@@ -5667,6 +5679,11 @@ static void handle_assoc(struct hostapd_
  		left = res;
  	}
  #endif /* CONFIG_FILS */
@@ -147,7 +147,7 @@
  
  	/* followed by SSID and Supported rates; and HT capabilities if 802.11n
  	 * is used */
-@@ -4543,6 +4560,14 @@ static void handle_assoc(struct hostapd_
+@@ -5831,6 +5848,14 @@ static void handle_assoc(struct hostapd_
  					    pos, left, rssi, omit_rsnxe);
  	os_free(tmp);
  
@@ -160,9 +160,9 @@
 +	}
 +
  	/*
- 	 * Remove the station in case tranmission of a success response fails
+ 	 * Remove the station in case transmission of a success response fails
  	 * (the STA was added associated to the driver) or if the station was
-@@ -4570,6 +4595,7 @@ static void handle_disassoc(struct hosta
+@@ -5858,6 +5883,7 @@ static void handle_disassoc(struct hosta
  	wpa_printf(MSG_DEBUG, "disassocation: STA=" MACSTR " reason_code=%d",
  		   MAC2STR(mgmt->sa),
  		   le_to_host16(mgmt->u.disassoc.reason_code));
@@ -170,9 +170,9 @@
  
  	sta = ap_get_sta(hapd, mgmt->sa);
  	if (sta == NULL) {
-@@ -4636,6 +4662,8 @@ static void handle_deauth(struct hostapd
- 		" reason_code=%d",
- 		MAC2STR(mgmt->sa), le_to_host16(mgmt->u.deauth.reason_code));
+@@ -5927,6 +5953,8 @@ static void handle_deauth(struct hostapd
+ 	/* Clear the PTKSA cache entries for PASN */
+ 	ptksa_cache_flush(hapd->ptksa, mgmt->sa, WPA_CIPHER_NONE);
  
 +	hostapd_ubus_notify(hapd, "deauth", mgmt->sa);
 +
@@ -181,7 +181,7 @@
  		wpa_msg(hapd->msg_ctx, MSG_DEBUG, "Station " MACSTR " trying "
 --- a/src/ap/beacon.c
 +++ b/src/ap/beacon.c
-@@ -814,6 +814,12 @@ void handle_probe_req(struct hostapd_dat
+@@ -823,6 +823,12 @@ void handle_probe_req(struct hostapd_dat
  	u16 csa_offs[2];
  	size_t csa_offs_len;
  	struct radius_sta rad_info;
@@ -192,9 +192,9 @@
 +		.elems = &elems,
 +	};
  
- 	if (len < IEEE80211_HDRLEN)
- 		return;
-@@ -996,6 +1002,12 @@ void handle_probe_req(struct hostapd_dat
+ 	if (hapd->iconf->rssi_ignore_probe_request && ssi_signal &&
+ 	    ssi_signal < hapd->iconf->rssi_ignore_probe_request)
+@@ -1009,6 +1015,12 @@ void handle_probe_req(struct hostapd_dat
  	}
  #endif /* CONFIG_P2P */
  
@@ -209,7 +209,7 @@
  
 --- a/src/ap/drv_callbacks.c
 +++ b/src/ap/drv_callbacks.c
-@@ -119,6 +119,10 @@ int hostapd_notif_assoc(struct hostapd_d
+@@ -145,6 +145,10 @@ int hostapd_notif_assoc(struct hostapd_d
  	u16 reason = WLAN_REASON_UNSPECIFIED;
  	int status = WLAN_STATUS_SUCCESS;
  	const u8 *p2p_dev_addr = NULL;
@@ -220,7 +220,7 @@
  
  	if (addr == NULL) {
  		/*
-@@ -211,6 +215,12 @@ int hostapd_notif_assoc(struct hostapd_d
+@@ -237,6 +241,12 @@ int hostapd_notif_assoc(struct hostapd_d
  		goto fail;
  	}
  
@@ -235,7 +235,7 @@
  		wpabuf_free(sta->p2p_ie);
 --- a/src/ap/sta_info.c
 +++ b/src/ap/sta_info.c
-@@ -424,6 +424,7 @@ void ap_handle_timer(void *eloop_ctx, vo
+@@ -459,6 +459,7 @@ void ap_handle_timer(void *eloop_ctx, vo
  			       HOSTAPD_LEVEL_INFO, "deauthenticated due to "
  			       "local deauth request");
  		ap_free_sta(hapd, sta);
@@ -243,7 +243,7 @@
  		return;
  	}
  
-@@ -579,6 +580,7 @@ skip_poll:
+@@ -614,6 +615,7 @@ skip_poll:
  			hapd, sta,
  			WLAN_REASON_PREV_AUTH_NOT_VALID);
  		ap_free_sta(hapd, sta);
@@ -251,7 +251,7 @@
  		break;
  	}
  }
-@@ -1294,6 +1296,7 @@ void ap_sta_set_authorized(struct hostap
+@@ -1329,6 +1331,7 @@ void ap_sta_set_authorized(struct hostap
  					  buf, ip_addr, keyid_buf);
  	} else {
  		wpa_msg(hapd->msg_ctx, MSG_INFO, AP_STA_DISCONNECTED "%s", buf);
@@ -261,7 +261,7 @@
  		    hapd->msg_ctx_parent != hapd->msg_ctx)
 --- a/src/ap/wpa_auth_glue.c
 +++ b/src/ap/wpa_auth_glue.c
-@@ -259,6 +259,7 @@ static void hostapd_wpa_auth_psk_failure
+@@ -265,6 +265,7 @@ static void hostapd_wpa_auth_psk_failure
  	struct hostapd_data *hapd = ctx;
  	wpa_msg(hapd->msg_ctx, MSG_INFO, AP_STA_POSSIBLE_PSK_MISMATCH MACSTR,
  		MAC2STR(addr));
@@ -271,7 +271,7 @@
  
 --- a/wpa_supplicant/Makefile
 +++ b/wpa_supplicant/Makefile
-@@ -190,6 +190,12 @@ ifdef CONFIG_EAPOL_TEST
+@@ -176,6 +176,12 @@ ifdef CONFIG_EAPOL_TEST
  CFLAGS += -Werror -DEAPOL_TEST
  endif
  
@@ -284,7 +284,7 @@
  ifdef CONFIG_CODE_COVERAGE
  CFLAGS += -O0 -fprofile-arcs -ftest-coverage
  LIBS += -lgcov
-@@ -956,6 +962,9 @@ ifdef CONFIG_CTRL_IFACE_MIB
+@@ -959,6 +965,9 @@ ifdef CONFIG_CTRL_IFACE_MIB
  CFLAGS += -DCONFIG_CTRL_IFACE_MIB
  endif
  OBJS += ../src/ap/ctrl_iface_ap.o
@@ -296,7 +296,7 @@
  CFLAGS += -DEAP_SERVER -DEAP_SERVER_IDENTITY
 --- a/wpa_supplicant/wpa_supplicant.c
 +++ b/wpa_supplicant/wpa_supplicant.c
-@@ -6794,6 +6794,8 @@ struct wpa_supplicant * wpa_supplicant_a
+@@ -7017,6 +7017,8 @@ struct wpa_supplicant * wpa_supplicant_a
  	}
  #endif /* CONFIG_P2P */
  
@@ -305,7 +305,7 @@
  	return wpa_s;
  }
  
-@@ -6820,6 +6822,8 @@ int wpa_supplicant_remove_iface(struct w
+@@ -7043,6 +7045,8 @@ int wpa_supplicant_remove_iface(struct w
  	struct wpa_supplicant *parent = wpa_s->parent;
  #endif /* CONFIG_MESH */
  
@@ -314,7 +314,7 @@
  	/* Remove interface from the global list of interfaces */
  	prev = global->ifaces;
  	if (prev == wpa_s) {
-@@ -7123,8 +7127,12 @@ int wpa_supplicant_run(struct wpa_global
+@@ -7346,8 +7350,12 @@ int wpa_supplicant_run(struct wpa_global
  	eloop_register_signal_terminate(wpa_supplicant_terminate, global);
  	eloop_register_signal_reconfig(wpa_supplicant_reconfig, global);
  
@@ -329,7 +329,7 @@
  
 --- a/wpa_supplicant/wpa_supplicant_i.h
 +++ b/wpa_supplicant/wpa_supplicant_i.h
-@@ -17,6 +17,7 @@
+@@ -19,6 +19,7 @@
  #include "wps/wps_defs.h"
  #include "config_ssid.h"
  #include "wmm_ac.h"
@@ -337,7 +337,7 @@
  
  extern const char *const wpa_supplicant_version;
  extern const char *const wpa_supplicant_license;
-@@ -310,6 +311,8 @@ struct wpa_global {
+@@ -321,6 +322,8 @@ struct wpa_global {
  #endif /* CONFIG_WIFI_DISPLAY */
  
  	struct psk_list_entry *add_psk; /* From group formation */
@@ -346,7 +346,7 @@
  };
  
  
-@@ -520,6 +523,7 @@ struct wpa_supplicant {
+@@ -605,6 +608,7 @@ struct wpa_supplicant {
  	unsigned char own_addr[ETH_ALEN];
  	unsigned char perm_addr[ETH_ALEN];
  	char ifname[100];
@@ -375,7 +375,7 @@
  
 --- a/hostapd/main.c
 +++ b/hostapd/main.c
-@@ -896,6 +896,7 @@ int main(int argc, char *argv[])
+@@ -895,6 +895,7 @@ int main(int argc, char *argv[])
  	}
  
  	hostapd_global_ctrl_iface_init(&interfaces);
@@ -383,7 +383,7 @@
  
  	if (hostapd_global_run(&interfaces, daemonize, pid_file)) {
  		wpa_printf(MSG_ERROR, "Failed to start eloop");
-@@ -905,6 +906,7 @@ int main(int argc, char *argv[])
+@@ -904,6 +905,7 @@ int main(int argc, char *argv[])
  	ret = 0;
  
   out:
@@ -424,3 +424,93 @@
  }
  
  
+--- a/src/ap/vlan_init.c
++++ b/src/ap/vlan_init.c
+@@ -22,6 +22,7 @@
+ static int vlan_if_add(struct hostapd_data *hapd, struct hostapd_vlan *vlan,
+ 		       int existsok)
+ {
++	bool vlan_exists = iface_exists(vlan->ifname);
+ 	int ret;
+ #ifdef CONFIG_WEP
+ 	int i;
+@@ -36,7 +37,7 @@ static int vlan_if_add(struct hostapd_da
+ 	}
+ #endif /* CONFIG_WEP */
+ 
+-	if (!iface_exists(vlan->ifname))
++	if (!vlan_exists)
+ 		ret = hostapd_vlan_if_add(hapd, vlan->ifname);
+ 	else if (!existsok)
+ 		return -1;
+@@ -51,6 +52,9 @@ static int vlan_if_add(struct hostapd_da
+ 	if (hapd->wpa_auth)
+ 		ret = wpa_auth_ensure_group(hapd->wpa_auth, vlan->vlan_id);
+ 
++	if (!ret && !vlan_exists)
++		hostapd_ubus_add_vlan(hapd, vlan);
++
+ 	if (ret == 0)
+ 		return ret;
+ 
+@@ -77,6 +81,8 @@ int vlan_if_remove(struct hostapd_data *
+ 			   "WPA deinitialization for VLAN %d failed (%d)",
+ 			   vlan->vlan_id, ret);
+ 
++	hostapd_ubus_remove_vlan(hapd, vlan);
++
+ 	return hostapd_vlan_if_remove(hapd, vlan->ifname);
+ }
+ 
+--- a/src/ap/dfs.c
++++ b/src/ap/dfs.c
+@@ -1193,6 +1193,8 @@ int hostapd_dfs_radar_detected(struct ho
+ 		"freq=%d ht_enabled=%d chan_offset=%d chan_width=%d cf1=%d cf2=%d",
+ 		freq, ht_enabled, chan_offset, chan_width, cf1, cf2);
+ 
++	hostapd_ubus_notify_radar_detected(iface, freq, chan_width, cf1, cf2);
++
+ 	/* Proceed only if DFS is not offloaded to the driver */
+ 	if (iface->drv_flags & WPA_DRIVER_FLAGS_DFS_OFFLOAD)
+ 		return 0;
+--- a/src/ap/airtime_policy.c
++++ b/src/ap/airtime_policy.c
+@@ -112,8 +112,14 @@ static void set_sta_weights(struct hosta
+ {
+ 	struct sta_info *sta;
+ 
+-	for (sta = hapd->sta_list; sta; sta = sta->next)
+-		sta_set_airtime_weight(hapd, sta, weight);
++	for (sta = hapd->sta_list; sta; sta = sta->next) {
++		unsigned int sta_weight = weight;
++
++		if (sta->dyn_airtime_weight)
++			sta_weight = (weight * sta->dyn_airtime_weight) / 256;
++
++		sta_set_airtime_weight(hapd, sta, sta_weight);
++	}
+ }
+ 
+ 
+@@ -244,7 +250,10 @@ int airtime_policy_new_sta(struct hostap
+ 	unsigned int weight;
+ 
+ 	if (hapd->iconf->airtime_mode == AIRTIME_MODE_STATIC) {
+-		weight = get_weight_for_sta(hapd, sta->addr);
++		if (sta->dyn_airtime_weight)
++			weight = sta->dyn_airtime_weight;
++		else
++			weight = get_weight_for_sta(hapd, sta->addr);
+ 		if (weight)
+ 			return sta_set_airtime_weight(hapd, sta, weight);
+ 	}
+--- a/src/ap/sta_info.h
++++ b/src/ap/sta_info.h
+@@ -324,6 +324,7 @@ struct sta_info {
+ #endif /* CONFIG_TESTING_OPTIONS */
+ #ifdef CONFIG_AIRTIME_POLICY
+ 	unsigned int airtime_weight;
++	unsigned int dyn_airtime_weight;
+ 	struct os_reltime backlogged_until;
+ #endif /* CONFIG_AIRTIME_POLICY */
+ 
diff --git a/package/network/services/hostapd/patches/700-wifi-reload.patch b/package/network/services/hostapd/patches/700-wifi-reload.patch
index d5520d0b77..5993b0d445 100644
--- a/package/network/services/hostapd/patches/700-wifi-reload.patch
+++ b/package/network/services/hostapd/patches/700-wifi-reload.patch
@@ -1,6 +1,6 @@
 --- a/hostapd/config_file.c
 +++ b/hostapd/config_file.c
-@@ -2501,6 +2501,8 @@ static int hostapd_config_fill(struct ho
+@@ -2453,6 +2453,8 @@ static int hostapd_config_fill(struct ho
  		bss->isolate = atoi(pos);
  	} else if (os_strcmp(buf, "ap_max_inactivity") == 0) {
  		bss->ap_max_inactivity = atoi(pos);
@@ -9,7 +9,7 @@
  	} else if (os_strcmp(buf, "skip_inactivity_poll") == 0) {
  		bss->skip_inactivity_poll = atoi(pos);
  	} else if (os_strcmp(buf, "country_code") == 0) {
-@@ -3197,6 +3199,8 @@ static int hostapd_config_fill(struct ho
+@@ -3153,6 +3155,8 @@ static int hostapd_config_fill(struct ho
  		}
  	} else if (os_strcmp(buf, "acs_exclude_dfs") == 0) {
  		conf->acs_exclude_dfs = atoi(pos);
@@ -20,7 +20,7 @@
  	} else if (os_strcmp(buf, "channel") == 0) {
 --- a/src/ap/ap_config.c
 +++ b/src/ap/ap_config.c
-@@ -780,6 +780,7 @@ void hostapd_config_free_bss(struct host
+@@ -791,6 +791,7 @@ void hostapd_config_free_bss(struct host
  	os_free(conf->radius_req_attr_sqlite);
  	os_free(conf->rsn_preauth_interfaces);
  	os_free(conf->ctrl_interface);
@@ -28,7 +28,7 @@
  	os_free(conf->ca_cert);
  	os_free(conf->server_cert);
  	os_free(conf->server_cert2);
-@@ -972,6 +973,7 @@ void hostapd_config_free(struct hostapd_
+@@ -987,6 +988,7 @@ void hostapd_config_free(struct hostapd_
  
  	for (i = 0; i < conf->num_bss; i++)
  		hostapd_config_free_bss(conf->bss[i]);
@@ -38,25 +38,26 @@
  	os_free(conf->basic_rates);
 --- a/src/ap/ap_config.h
 +++ b/src/ap/ap_config.h
-@@ -871,6 +871,7 @@ struct hostapd_bss_config {
- 	 */
- 	u8 mka_psk_set;
- #endif /* CONFIG_MACSEC */
+@@ -279,6 +279,8 @@ struct hostapd_bss_config {
+ 	char vlan_bridge[IFNAMSIZ + 1];
+ 	char wds_bridge[IFNAMSIZ + 1];
+ 
 +	char *config_id;
- };
++
+ 	enum hostapd_logger_level logger_syslog_level, logger_stdout_level;
  
- /**
-@@ -1062,6 +1063,7 @@ struct hostapd_config {
- 	unsigned int airtime_update_interval;
- #define AIRTIME_MODE_MAX (__AIRTIME_MODE_MAX - 1)
- #endif /* CONFIG_AIRTIME_POLICY */
+ 	unsigned int logger_syslog; /* module bitfield */
+@@ -938,6 +940,7 @@ struct spatial_reuse {
+ struct hostapd_config {
+ 	struct hostapd_bss_config **bss, *last_bss;
+ 	size_t num_bss;
 +	char *config_id;
  
- 	u8 notify_mgmt_frames;
- };
+ 	u16 beacon_int;
+ 	int rts_threshold;
 --- a/src/ap/hostapd.c
 +++ b/src/ap/hostapd.c
-@@ -218,6 +218,10 @@ static int hostapd_iface_conf_changed(st
+@@ -219,6 +219,10 @@ static int hostapd_iface_conf_changed(st
  {
  	size_t i;
  
@@ -67,7 +68,7 @@
  	if (newconf->num_bss != oldconf->num_bss)
  		return 1;
  
-@@ -231,7 +235,7 @@ static int hostapd_iface_conf_changed(st
+@@ -232,7 +236,7 @@ static int hostapd_iface_conf_changed(st
  }
  
  
@@ -76,7 +77,7 @@
  {
  	struct hapd_interfaces *interfaces = iface->interfaces;
  	struct hostapd_data *hapd = iface->bss[0];
-@@ -254,13 +258,16 @@ int hostapd_reload_config(struct hostapd
+@@ -255,13 +259,16 @@ int hostapd_reload_config(struct hostapd
  	if (newconf == NULL)
  		return -1;
  
@@ -95,7 +96,7 @@
  		wpa_printf(MSG_DEBUG,
  			   "Configuration changes include interface/BSS modification - force full disable+enable sequence");
  		fname = os_strdup(iface->config_fname);
-@@ -285,6 +292,24 @@ int hostapd_reload_config(struct hostapd
+@@ -286,6 +293,24 @@ int hostapd_reload_config(struct hostapd
  			wpa_printf(MSG_ERROR,
  				   "Failed to enable interface on config reload");
  		return res;
@@ -120,7 +121,7 @@
  	}
  	iface->conf = newconf;
  
-@@ -301,6 +326,12 @@ int hostapd_reload_config(struct hostapd
+@@ -302,6 +327,12 @@ int hostapd_reload_config(struct hostapd
  
  	for (j = 0; j < iface->num_bss; j++) {
  		hapd = iface->bss[j];
@@ -133,7 +134,7 @@
  		hapd->iconf = newconf;
  		hapd->conf = newconf->bss[j];
  		hostapd_reload_bss(hapd);
-@@ -2366,6 +2397,10 @@ hostapd_alloc_bss_data(struct hostapd_if
+@@ -2397,6 +2428,10 @@ hostapd_alloc_bss_data(struct hostapd_if
  	hapd->iconf = conf;
  	hapd->conf = bss;
  	hapd->iface = hapd_iface;
@@ -163,7 +164,7 @@
  	int interface_added; /* virtual interface added for this BSS */
  	unsigned int started:1;
  	unsigned int disabled:1;
-@@ -600,7 +601,7 @@ struct hostapd_iface {
+@@ -604,7 +605,7 @@ struct hostapd_iface {
  int hostapd_for_each_interface(struct hapd_interfaces *interfaces,
  			       int (*cb)(struct hostapd_iface *iface,
  					 void *ctx), void *ctx);
@@ -174,7 +175,7 @@
  hostapd_alloc_bss_data(struct hostapd_iface *hapd_iface,
 --- a/src/drivers/driver_nl80211.c
 +++ b/src/drivers/driver_nl80211.c
-@@ -4493,6 +4493,9 @@ static int wpa_driver_nl80211_set_ap(voi
+@@ -4820,6 +4820,9 @@ static int wpa_driver_nl80211_set_ap(voi
  	if (ret) {
  		wpa_printf(MSG_DEBUG, "nl80211: Beacon set failed: %d (%s)",
  			   ret, strerror(-ret));
@@ -186,7 +187,7 @@
  		nl80211_set_bss(bss, params->cts_protect, params->preamble,
 --- a/hostapd/ctrl_iface.c
 +++ b/hostapd/ctrl_iface.c
-@@ -184,7 +184,7 @@ static int hostapd_ctrl_iface_update(str
+@@ -186,7 +186,7 @@ static int hostapd_ctrl_iface_update(str
  	iface->interfaces->config_read_cb = hostapd_ctrl_iface_config_read;
  	reload_opts = txt;
  
diff --git a/package/network/services/hostapd/patches/710-vlan_no_bridge.patch b/package/network/services/hostapd/patches/710-vlan_no_bridge.patch
new file mode 100644
index 0000000000..73db32e54a
--- /dev/null
+++ b/package/network/services/hostapd/patches/710-vlan_no_bridge.patch
@@ -0,0 +1,41 @@
+--- a/src/ap/ap_config.h
++++ b/src/ap/ap_config.h
+@@ -115,6 +115,7 @@ struct hostapd_ssid {
+ #define DYNAMIC_VLAN_OPTIONAL 1
+ #define DYNAMIC_VLAN_REQUIRED 2
+ 	int dynamic_vlan;
++	int vlan_no_bridge;
+ #define DYNAMIC_VLAN_NAMING_WITHOUT_DEVICE 0
+ #define DYNAMIC_VLAN_NAMING_WITH_DEVICE 1
+ #define DYNAMIC_VLAN_NAMING_END 2
+--- a/src/ap/vlan_full.c
++++ b/src/ap/vlan_full.c
+@@ -475,6 +475,9 @@ void vlan_newlink(const char *ifname, st
+ 	if (!vlan)
+ 		return;
+ 
++	if (hapd->conf->ssid.vlan_no_bridge)
++		goto out;
++
+ 	vlan->configured = 1;
+ 
+ 	notempty = vlan->vlan_desc.notempty;
+@@ -506,6 +509,7 @@ void vlan_newlink(const char *ifname, st
+ 				    ifname, br_name, tagged[i], hapd);
+ 	}
+ 
++out:
+ 	ifconfig_up(ifname);
+ }
+ 
+--- a/hostapd/config_file.c
++++ b/hostapd/config_file.c
+@@ -3366,6 +3366,8 @@ static int hostapd_config_fill(struct ho
+ #ifndef CONFIG_NO_VLAN
+ 	} else if (os_strcmp(buf, "dynamic_vlan") == 0) {
+ 		bss->ssid.dynamic_vlan = atoi(pos);
++	} else if (os_strcmp(buf, "vlan_no_bridge") == 0) {
++		bss->ssid.vlan_no_bridge = atoi(pos);
+ 	} else if (os_strcmp(buf, "per_sta_vif") == 0) {
+ 		bss->ssid.per_sta_vif = atoi(pos);
+ 	} else if (os_strcmp(buf, "vlan_file") == 0) {
diff --git a/package/network/services/hostapd/patches/711-wds_bridge_force.patch b/package/network/services/hostapd/patches/711-wds_bridge_force.patch
new file mode 100644
index 0000000000..76a3547805
--- /dev/null
+++ b/package/network/services/hostapd/patches/711-wds_bridge_force.patch
@@ -0,0 +1,26 @@
+Index: hostapd-2021-05-22-b102f19b/hostapd/config_file.c
+===================================================================
+--- hostapd-2021-05-22-b102f19b.orig/hostapd/config_file.c
++++ hostapd-2021-05-22-b102f19b/hostapd/config_file.c
+@@ -2357,6 +2357,8 @@ static int hostapd_config_fill(struct ho
+ 			   sizeof(conf->bss[0]->iface));
+ 	} else if (os_strcmp(buf, "bridge") == 0) {
+ 		os_strlcpy(bss->bridge, pos, sizeof(bss->bridge));
++		if (!bss->wds_bridge[0])
++			os_strlcpy(bss->wds_bridge, pos, sizeof(bss->wds_bridge));
+ 	} else if (os_strcmp(buf, "vlan_bridge") == 0) {
+ 		os_strlcpy(bss->vlan_bridge, pos, sizeof(bss->vlan_bridge));
+ 	} else if (os_strcmp(buf, "wds_bridge") == 0) {
+Index: hostapd-2021-05-22-b102f19b/src/ap/ap_drv_ops.c
+===================================================================
+--- hostapd-2021-05-22-b102f19b.orig/src/ap/ap_drv_ops.c
++++ hostapd-2021-05-22-b102f19b/src/ap/ap_drv_ops.c
+@@ -340,8 +340,6 @@ int hostapd_set_wds_sta(struct hostapd_d
+ 		return -1;
+ 	if (hapd->conf->wds_bridge[0])
+ 		bridge = hapd->conf->wds_bridge;
+-	else if (hapd->conf->bridge[0])
+-		bridge = hapd->conf->bridge;
+ 	return hapd->driver->set_wds_sta(hapd->drv_priv, addr, aid, val,
+ 					 bridge, ifname_wds);
+ }
diff --git a/package/network/services/hostapd/patches/720-ACS-fix-channel-100-frequency.patch b/package/network/services/hostapd/patches/720-ACS-fix-channel-100-frequency.patch
new file mode 100644
index 0000000000..3ef19e5298
--- /dev/null
+++ b/package/network/services/hostapd/patches/720-ACS-fix-channel-100-frequency.patch
@@ -0,0 +1,30 @@
+From 5a24286ed6315e1fef755ca1970792554f59b1fc Mon Sep 17 00:00:00 2001
+From: David Bauer <mail@david-bauer.net>
+Date: Wed, 26 May 2021 22:15:35 +0200
+Subject: [PATCH] ACS: fix channel 100 frequency
+
+Channel 100 is a valid channel to choose for 80MHz operation. However,
+it's assigned to 5500 MHz, not 5550MHz. In fact, there is no channel
+assigned to this frequency.
+
+Fix this obbvious typo to allow ACS to select channel 100 for 80 MHz
+operation again.
+
+Fixes commit bef5eee4f7b2 ("Convert channel to frequency based selection for AP mode ACS")
+
+Signed-off-by: David Bauer <mail@david-bauer.net>
+---
+ src/ap/acs.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/src/ap/acs.c
++++ b/src/ap/acs.c
+@@ -386,7 +386,7 @@ static int acs_usable_bw40_chan(const st
+ 
+ static int acs_usable_bw80_chan(const struct hostapd_channel_data *chan)
+ {
+-	const int allowed[] = { 5180, 5260, 5550, 5580, 5660, 5745, 5955, 6035,
++	const int allowed[] = { 5180, 5260, 5500, 5580, 5660, 5745, 5955, 6035,
+ 				6115, 6195, 6275, 6355, 6435, 6515, 6595, 6675,
+ 				6755, 6835, 6915, 6995 };
+ 	unsigned int i;
diff --git a/package/network/services/hostapd/patches/720-iface_max_num_sta.patch b/package/network/services/hostapd/patches/720-iface_max_num_sta.patch
new file mode 100644
index 0000000000..b93a0bcbef
--- /dev/null
+++ b/package/network/services/hostapd/patches/720-iface_max_num_sta.patch
@@ -0,0 +1,82 @@
+--- a/hostapd/config_file.c
++++ b/hostapd/config_file.c
+@@ -2873,6 +2873,14 @@ static int hostapd_config_fill(struct ho
+ 				   line, bss->max_num_sta, MAX_STA_COUNT);
+ 			return 1;
+ 		}
++	} else if (os_strcmp(buf, "iface_max_num_sta") == 0) {
++		conf->max_num_sta = atoi(pos);
++		if (conf->max_num_sta < 0 ||
++		    conf->max_num_sta > MAX_STA_COUNT) {
++			wpa_printf(MSG_ERROR, "Line %d: Invalid max_num_sta=%d; allowed range 0..%d",
++				   line, conf->max_num_sta, MAX_STA_COUNT);
++			return 1;
++		}
+ 	} else if (os_strcmp(buf, "wpa") == 0) {
+ 		bss->wpa = atoi(pos);
+ 	} else if (os_strcmp(buf, "extended_key_id") == 0) {
+--- a/src/ap/hostapd.h
++++ b/src/ap/hostapd.h
+@@ -648,6 +648,7 @@ void hostapd_cleanup_cs_params(struct ho
+ void hostapd_periodic_iface(struct hostapd_iface *iface);
+ int hostapd_owe_trans_get_info(struct hostapd_data *hapd);
+ void hostapd_ocv_check_csa_sa_query(void *eloop_ctx, void *timeout_ctx);
++int hostapd_check_max_sta(struct hostapd_data *hapd);
+ 
+ /* utils.c */
+ int hostapd_register_probereq_cb(struct hostapd_data *hapd,
+--- a/src/ap/hostapd.c
++++ b/src/ap/hostapd.c
+@@ -236,6 +236,30 @@ static int hostapd_iface_conf_changed(st
+ }
+ 
+ 
++static inline int hostapd_iface_num_sta(struct hostapd_iface *iface)
++{
++	int num_sta = 0;
++	int i;
++
++	for (i = 0; i < iface->num_bss; i++)
++		num_sta += iface->bss[i]->num_sta;
++
++	return num_sta;
++}
++
++
++int hostapd_check_max_sta(struct hostapd_data *hapd)
++{
++	if (hapd->num_sta >= hapd->conf->max_num_sta)
++		return 1;
++
++	if (hapd->iconf->max_num_sta &&
++	    hostapd_iface_num_sta(hapd->iface) >= hapd->iconf->max_num_sta)
++		return 1;
++
++	return 0;
++}
++
+ int hostapd_reload_config(struct hostapd_iface *iface, int reconf)
+ {
+ 	struct hapd_interfaces *interfaces = iface->interfaces;
+--- a/src/ap/beacon.c
++++ b/src/ap/beacon.c
+@@ -1039,7 +1039,7 @@ void handle_probe_req(struct hostapd_dat
+ 	if (hapd->conf->no_probe_resp_if_max_sta &&
+ 	    is_multicast_ether_addr(mgmt->da) &&
+ 	    is_multicast_ether_addr(mgmt->bssid) &&
+-	    hapd->num_sta >= hapd->conf->max_num_sta &&
++	    hostapd_check_max_sta(hapd) &&
+ 	    !ap_get_sta(hapd, mgmt->sa)) {
+ 		wpa_printf(MSG_MSGDUMP, "%s: Ignore Probe Request from " MACSTR
+ 			   " since no room for additional STA",
+--- a/src/ap/ap_config.h
++++ b/src/ap/ap_config.h
+@@ -976,6 +976,8 @@ struct hostapd_config {
+ 	unsigned int track_sta_max_num;
+ 	unsigned int track_sta_max_age;
+ 
++	int max_num_sta;
++
+ 	char country[3]; /* first two octets: country code as described in
+ 			  * ISO/IEC 3166-1. Third octet:
+ 			  * ' ' (ascii 32): all environments
diff --git a/package/network/services/hostapd/patches/730-ft_iface.patch b/package/network/services/hostapd/patches/730-ft_iface.patch
new file mode 100644
index 0000000000..793e8e0194
--- /dev/null
+++ b/package/network/services/hostapd/patches/730-ft_iface.patch
@@ -0,0 +1,38 @@
+--- a/hostapd/config_file.c
++++ b/hostapd/config_file.c
+@@ -3031,6 +3031,8 @@ static int hostapd_config_fill(struct ho
+ 		wpa_printf(MSG_INFO,
+ 			   "Line %d: Obsolete peerkey parameter ignored", line);
+ #ifdef CONFIG_IEEE80211R_AP
++	} else if (os_strcmp(buf, "ft_iface") == 0) {
++		os_strlcpy(bss->ft_iface, pos, sizeof(bss->ft_iface));
+ 	} else if (os_strcmp(buf, "mobility_domain") == 0) {
+ 		if (os_strlen(pos) != 2 * MOBILITY_DOMAIN_ID_LEN ||
+ 		    hexstr2bin(pos, bss->mobility_domain,
+--- a/src/ap/ap_config.h
++++ b/src/ap/ap_config.h
+@@ -277,6 +277,7 @@ struct airtime_sta_weight {
+ struct hostapd_bss_config {
+ 	char iface[IFNAMSIZ + 1];
+ 	char bridge[IFNAMSIZ + 1];
++	char ft_iface[IFNAMSIZ + 1];
+ 	char vlan_bridge[IFNAMSIZ + 1];
+ 	char wds_bridge[IFNAMSIZ + 1];
+ 
+--- a/src/ap/wpa_auth_glue.c
++++ b/src/ap/wpa_auth_glue.c
+@@ -1565,8 +1565,12 @@ int hostapd_setup_wpa(struct hostapd_dat
+ 	    wpa_key_mgmt_ft(hapd->conf->wpa_key_mgmt)) {
+ 		const char *ft_iface;
+ 
+-		ft_iface = hapd->conf->bridge[0] ? hapd->conf->bridge :
+-			   hapd->conf->iface;
++		if (hapd->conf->ft_iface[0])
++			ft_iface = hapd->conf->ft_iface;
++		else if (hapd->conf->bridge[0])
++			ft_iface = hapd->conf->bridge;
++		else
++			ft_iface = hapd->conf->iface;
+ 		hapd->l2 = l2_packet_init(ft_iface, NULL, ETH_P_RRB,
+ 					  hostapd_rrb_receive, hapd, 1);
+ 		if (!hapd->l2) {
diff --git a/package/network/services/hostapd/patches/740-snoop_iface.patch b/package/network/services/hostapd/patches/740-snoop_iface.patch
new file mode 100644
index 0000000000..6e60cde844
--- /dev/null
+++ b/package/network/services/hostapd/patches/740-snoop_iface.patch
@@ -0,0 +1,72 @@
+Index: hostapd-2021-05-22-b102f19b/src/ap/ap_config.h
+===================================================================
+--- hostapd-2021-05-22-b102f19b.orig/src/ap/ap_config.h
++++ hostapd-2021-05-22-b102f19b/src/ap/ap_config.h
+@@ -278,6 +278,7 @@ struct hostapd_bss_config {
+ 	char iface[IFNAMSIZ + 1];
+ 	char bridge[IFNAMSIZ + 1];
+ 	char ft_iface[IFNAMSIZ + 1];
++	char snoop_iface[IFNAMSIZ + 1];
+ 	char vlan_bridge[IFNAMSIZ + 1];
+ 	char wds_bridge[IFNAMSIZ + 1];
+ 
+Index: hostapd-2021-05-22-b102f19b/src/ap/x_snoop.c
+===================================================================
+--- hostapd-2021-05-22-b102f19b.orig/src/ap/x_snoop.c
++++ hostapd-2021-05-22-b102f19b/src/ap/x_snoop.c
+@@ -31,14 +31,16 @@ int x_snoop_init(struct hostapd_data *ha
+ 		return -1;
+ 	}
+ 
+-	if (hostapd_drv_br_port_set_attr(hapd, DRV_BR_PORT_ATTR_HAIRPIN_MODE,
++	if (!conf->snoop_iface[0] &&
++	    hostapd_drv_br_port_set_attr(hapd, DRV_BR_PORT_ATTR_HAIRPIN_MODE,
+ 					 1)) {
+ 		wpa_printf(MSG_DEBUG,
+ 			   "x_snoop: Failed to enable hairpin_mode on the bridge port");
+ 		return -1;
+ 	}
+ 
+-	if (hostapd_drv_br_port_set_attr(hapd, DRV_BR_PORT_ATTR_PROXYARP, 1)) {
++	if (!conf->snoop_iface[0] &&
++	    hostapd_drv_br_port_set_attr(hapd, DRV_BR_PORT_ATTR_PROXYARP, 1)) {
+ 		wpa_printf(MSG_DEBUG,
+ 			   "x_snoop: Failed to enable proxyarp on the bridge port");
+ 		return -1;
+@@ -52,7 +54,8 @@ int x_snoop_init(struct hostapd_data *ha
+ 	}
+ 
+ #ifdef CONFIG_IPV6
+-	if (hostapd_drv_br_set_net_param(hapd, DRV_BR_MULTICAST_SNOOPING, 1)) {
++	if (!conf->snoop_iface[0] &&
++	    hostapd_drv_br_set_net_param(hapd, DRV_BR_MULTICAST_SNOOPING, 1)) {
+ 		wpa_printf(MSG_DEBUG,
+ 			   "x_snoop: Failed to enable multicast snooping on the bridge");
+ 		return -1;
+@@ -71,8 +74,12 @@ x_snoop_get_l2_packet(struct hostapd_dat
+ {
+ 	struct hostapd_bss_config *conf = hapd->conf;
+ 	struct l2_packet_data *l2;
++	const char *ifname = conf->bridge;
+ 
+-	l2 = l2_packet_init(conf->bridge, NULL, ETH_P_ALL, handler, hapd, 1);
++	if (conf->snoop_iface[0])
++		ifname = conf->snoop_iface;
++
++	l2 = l2_packet_init(ifname, NULL, ETH_P_ALL, handler, hapd, 1);
+ 	if (l2 == NULL) {
+ 		wpa_printf(MSG_DEBUG,
+ 			   "x_snoop: Failed to initialize L2 packet processing %s",
+Index: hostapd-2021-05-22-b102f19b/hostapd/config_file.c
+===================================================================
+--- hostapd-2021-05-22-b102f19b.orig/hostapd/config_file.c
++++ hostapd-2021-05-22-b102f19b/hostapd/config_file.c
+@@ -2359,6 +2359,8 @@ static int hostapd_config_fill(struct ho
+ 		os_strlcpy(bss->bridge, pos, sizeof(bss->bridge));
+ 		if (!bss->wds_bridge[0])
+ 			os_strlcpy(bss->wds_bridge, pos, sizeof(bss->wds_bridge));
++	} else if (os_strcmp(buf, "snoop_iface") == 0) {
++		os_strlcpy(bss->snoop_iface, pos, sizeof(bss->snoop_iface));
+ 	} else if (os_strcmp(buf, "vlan_bridge") == 0) {
+ 		os_strlcpy(bss->vlan_bridge, pos, sizeof(bss->vlan_bridge));
+ 	} else if (os_strcmp(buf, "wds_bridge") == 0) {
diff --git a/package/network/services/hostapd/patches/800-dfs-enter-DFS-state-if-no-available-channel-is-found.patch b/package/network/services/hostapd/patches/800-dfs-enter-DFS-state-if-no-available-channel-is-found.patch
deleted file mode 100644
index 3e4638d7ff..0000000000
--- a/package/network/services/hostapd/patches/800-dfs-enter-DFS-state-if-no-available-channel-is-found.patch
+++ /dev/null
@@ -1,37 +0,0 @@
-From cefc52e6b93731c713f1bba1cb5e7e92105b758b Mon Sep 17 00:00:00 2001
-From: David Bauer <mail@david-bauer.net>
-Date: Fri, 3 Jul 2020 23:00:34 +0200
-Subject: [PATCH] dfs: enter DFS state if no available channel is found
-
-Previously hostapd would not stop transmitting when a DFS event was
-detected and no available channel to switch to was available.
-
-Disable and re-enable the interface to enter DFS state. This way, TX
-does not happen until the kernel notifies hostapd about the NOP
-expiring.
-
-Signed-off-by: David Bauer <mail@david-bauer.net>
----
- src/ap/dfs.c | 11 +++++++++--
- 1 file changed, 9 insertions(+), 2 deletions(-)
-
---- a/src/ap/dfs.c
-+++ b/src/ap/dfs.c
-@@ -1086,8 +1086,15 @@ static int hostapd_dfs_start_channel_swi
- 						  &oper_centr_freq_seg0_idx,
- 						  &oper_centr_freq_seg1_idx,
- 						  &skip_radar);
--		if (!channel)
--			return err;
-+		if (!channel) {
-+			/*
-+			 * Toggle interface state to enter DFS state
-+			 * until NOP is finished.
-+			 */
-+			hostapd_disable_iface(iface);
-+			hostapd_enable_iface(iface);
-+			return 0;
-+		}
- 		if (!skip_radar) {
- 			iface->freq = channel->freq;
- 			iface->conf->channel = channel->chan;
diff --git a/package/network/services/hostapd/patches/801-P2P-Fix-copying-of-secondary-device-types-for-P2P-gr.patch b/package/network/services/hostapd/patches/801-P2P-Fix-copying-of-secondary-device-types-for-P2P-gr.patch
deleted file mode 100644
index 944f7d71c9..0000000000
--- a/package/network/services/hostapd/patches/801-P2P-Fix-copying-of-secondary-device-types-for-P2P-gr.patch
+++ /dev/null
@@ -1,33 +0,0 @@
-From 947272febe24a8f0ea828b5b2f35f13c3821901e Mon Sep 17 00:00:00 2001
-From: Jouni Malinen <jouni@codeaurora.org>
-Date: Mon, 9 Nov 2020 11:43:12 +0200
-Subject: [PATCH] P2P: Fix copying of secondary device types for P2P group
- client
-
-Parsing and copying of WPS secondary device types list was verifying
-that the contents is not too long for the internal maximum in the case
-of WPS messages, but similar validation was missing from the case of P2P
-group information which encodes this information in a different
-attribute. This could result in writing beyond the memory area assigned
-for these entries and corrupting memory within an instance of struct
-p2p_device. This could result in invalid operations and unexpected
-behavior when trying to free pointers from that corrupted memory.
-
-Credit to OSS-Fuzz: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=27269
-Fixes: e57ae6e19edf ("P2P: Keep track of secondary device types for peers")
-Signed-off-by: Jouni Malinen <jouni@codeaurora.org>
----
- src/p2p/p2p.c | 2 ++
- 1 file changed, 2 insertions(+)
-
---- a/src/p2p/p2p.c
-+++ b/src/p2p/p2p.c
-@@ -453,6 +453,8 @@ static void p2p_copy_client_info(struct
- 	dev->info.config_methods = cli->config_methods;
- 	os_memcpy(dev->info.pri_dev_type, cli->pri_dev_type, 8);
- 	dev->info.wps_sec_dev_type_list_len = 8 * cli->num_sec_dev_types;
-+	if (dev->info.wps_sec_dev_type_list_len > WPS_SEC_DEV_TYPE_MAX_LEN)
-+		dev->info.wps_sec_dev_type_list_len = WPS_SEC_DEV_TYPE_MAX_LEN;
- 	os_memcpy(dev->info.wps_sec_dev_type_list, cli->sec_dev_types,
- 		  dev->info.wps_sec_dev_type_list_len);
- }
diff --git a/package/network/services/hostapd/src/src/ap/ubus.c b/package/network/services/hostapd/src/src/ap/ubus.c
index d03b848f94..09b25a29e5 100644
--- a/package/network/services/hostapd/src/src/ap/ubus.c
+++ b/package/network/services/hostapd/src/src/ap/ubus.c
@@ -21,6 +21,7 @@
 #include "rrm.h"
 #include "wnm_ap.h"
 #include "taxonomy.h"
+#include "airtime_policy.h"
 
 static struct ubus_context *ctx;
 static struct blob_buf b;
@@ -297,6 +298,7 @@ hostapd_bss_get_clients(struct ubus_context *ctx, struct ubus_object *obj,
 		{ "wmm", WLAN_STA_WMM },
 		{ "ht", WLAN_STA_HT },
 		{ "vht", WLAN_STA_VHT },
+		{ "he", WLAN_STA_HE },
 		{ "wps", WLAN_STA_WPS },
 		{ "mfp", WLAN_STA_MFP },
 	};
@@ -372,6 +374,32 @@ hostapd_bss_get_features(struct ubus_context *ctx, struct ubus_object *obj,
 	return 0;
 }
 
+/* Imported from iw/util.c
+ *  https://git.kernel.org/pub/scm/linux/kernel/git/jberg/iw.git/tree/util.c?id=4b25ae3537af48dbf9d0abf94132e5ba01b32c18#n200
+ */
+int ieee80211_frequency_to_channel(int freq)
+{
+	/* see 802.11-2007 17.3.8.3.2 and Annex J */
+	if (freq == 2484)
+		return 14;
+	/* see 802.11ax D6.1 27.3.23.2 and Annex E */
+	else if (freq == 5935)
+		return 2;
+	else if (freq < 2484)
+		return (freq - 2407) / 5;
+	else if (freq >= 4910 && freq <= 4980)
+		return (freq - 4000) / 5;
+	else if (freq < 5950)
+		return (freq - 5000) / 5;
+	else if (freq <= 45000) /* DMG band lower limit */
+		/* see 802.11ax D6.1 27.3.23.2 */
+		return (freq - 5950) / 5;
+	else if (freq >= 58320 && freq <= 70200)
+		return (freq - 56160) / 2160;
+	else
+		return 0;
+}
+
 static int
 hostapd_bss_get_status(struct ubus_context *ctx, struct ubus_object *obj,
 		       struct ubus_request_data *req, const char *method,
@@ -380,12 +408,23 @@ hostapd_bss_get_status(struct ubus_context *ctx, struct ubus_object *obj,
 	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
 	void *airtime_table, *dfs_table;
 	struct os_reltime now;
+	char ssid[SSID_MAX_LEN + 1];
 	char phy_name[17];
-	char mac_buf[20];
+	size_t ssid_len = SSID_MAX_LEN;
+
+	if (hapd->conf->ssid.ssid_len < SSID_MAX_LEN)
+		ssid_len = hapd->conf->ssid.ssid_len;
 
 	blob_buf_init(&b, 0);
 	blobmsg_add_string(&b, "status", hostapd_state_text(hapd->iface->state));
+	blobmsg_printf(&b, "bssid", MACSTR, MAC2STR(hapd->conf->bssid));
+
+	memset(ssid, 0, SSID_MAX_LEN + 1);
+	memcpy(ssid, hapd->conf->ssid.ssid, ssid_len);
+	blobmsg_add_string(&b, "ssid", ssid);
+
 	blobmsg_add_u32(&b, "freq", hapd->iface->freq);
+	blobmsg_add_u32(&b, "channel", ieee80211_frequency_to_channel(hapd->iface->freq));
 
 	snprintf(phy_name, 17, "%s", hapd->iface->phy);
 	blobmsg_add_string(&b, "phy", phy_name);
@@ -703,7 +742,9 @@ enum {
 	CSA_SEC_CHANNEL_OFFSET,
 	CSA_HT,
 	CSA_VHT,
+	CSA_HE,
 	CSA_BLOCK_TX,
+	CSA_FORCE,
 	__CSA_MAX
 };
 
@@ -716,9 +757,20 @@ static const struct blobmsg_policy csa_policy[__CSA_MAX] = {
 	[CSA_SEC_CHANNEL_OFFSET] = { "sec_channel_offset", BLOBMSG_TYPE_INT32 },
 	[CSA_HT] = { "ht", BLOBMSG_TYPE_BOOL },
 	[CSA_VHT] = { "vht", BLOBMSG_TYPE_BOOL },
+	[CSA_HE] = { "he", BLOBMSG_TYPE_BOOL },
 	[CSA_BLOCK_TX] = { "block_tx", BLOBMSG_TYPE_BOOL },
+	[CSA_FORCE] = { "force", BLOBMSG_TYPE_BOOL },
 };
 
+
+static void switch_chan_fallback_cb(void *eloop_data, void *user_ctx)
+{
+	struct hostapd_iface *iface = eloop_data;
+	struct hostapd_freq_params *freq_params = user_ctx;
+
+	hostapd_switch_channel_fallback(iface, freq_params);
+}
+
 #ifdef NEED_AP_MLME
 static int
 hostapd_switch_chan(struct ubus_context *ctx, struct ubus_object *obj,
@@ -727,14 +779,39 @@ hostapd_switch_chan(struct ubus_context *ctx, struct ubus_object *obj,
 {
 	struct blob_attr *tb[__CSA_MAX];
 	struct hostapd_data *hapd = get_hapd_from_object(obj);
-	struct csa_settings css;
+	struct hostapd_config *iconf = hapd->iface->conf;
+	struct hostapd_freq_params *freq_params;
+	struct csa_settings css = {
+		.freq_params = {
+			.ht_enabled = iconf->ieee80211n,
+			.vht_enabled = iconf->ieee80211ac,
+			.he_enabled = iconf->ieee80211ax,
+			.sec_channel_offset = iconf->secondary_channel,
+		}
+	};
+	int ret = UBUS_STATUS_OK;
+	int i;
 
 	blobmsg_parse(csa_policy, __CSA_MAX, tb, blob_data(msg), blob_len(msg));
 
 	if (!tb[CSA_FREQ])
 		return UBUS_STATUS_INVALID_ARGUMENT;
 
-	memset(&css, 0, sizeof(css));
+	switch (iconf->vht_oper_chwidth) {
+	case CHANWIDTH_USE_HT:
+		if (iconf->secondary_channel)
+			css.freq_params.bandwidth = 40;
+		else
+			css.freq_params.bandwidth = 20;
+		break;
+	case CHANWIDTH_160MHZ:
+		css.freq_params.bandwidth = 160;
+		break;
+	default:
+		css.freq_params.bandwidth = 80;
+		break;
+	}
+
 	css.freq_params.freq = blobmsg_get_u32(tb[CSA_FREQ]);
 
 #define SET_CSA_SETTING(name, field, type) \
@@ -750,12 +827,25 @@ hostapd_switch_chan(struct ubus_context *ctx, struct ubus_object *obj,
 	SET_CSA_SETTING(CSA_SEC_CHANNEL_OFFSET, freq_params.sec_channel_offset, u32);
 	SET_CSA_SETTING(CSA_HT, freq_params.ht_enabled, bool);
 	SET_CSA_SETTING(CSA_VHT, freq_params.vht_enabled, bool);
+	SET_CSA_SETTING(CSA_HE, freq_params.he_enabled, bool);
 	SET_CSA_SETTING(CSA_BLOCK_TX, block_tx, bool);
 
+	for (i = 0; i < hapd->iface->num_bss; i++) {
+		struct hostapd_data *bss = hapd->iface->bss[i];
 
-	if (hostapd_switch_channel(hapd, &css) != 0)
-		return UBUS_STATUS_NOT_SUPPORTED;
-	return UBUS_STATUS_OK;
+		if (hostapd_switch_channel(bss, &css) != 0)
+			ret = UBUS_STATUS_NOT_SUPPORTED;
+	}
+
+	if (!ret || !tb[CSA_FORCE] || !blobmsg_get_bool(tb[CSA_FORCE]))
+		return ret;
+
+	freq_params = malloc(sizeof(*freq_params));
+	memcpy(freq_params, &css.freq_params, sizeof(*freq_params));
+	eloop_register_timeout(0, 1, switch_chan_fallback_cb,
+			       hapd->iface, freq_params);
+
+	return 0;
 #undef SET_CSA_SETTING
 }
 #endif
@@ -1282,11 +1372,68 @@ hostapd_wnm_disassoc_imminent(struct ubus_context *ctx, struct ubus_object *obj,
 }
 #endif
 
+#ifdef CONFIG_AIRTIME_POLICY
+enum {
+	UPDATE_AIRTIME_STA,
+	UPDATE_AIRTIME_WEIGHT,
+	__UPDATE_AIRTIME_MAX,
+};
+
+
+static const struct blobmsg_policy airtime_policy[__UPDATE_AIRTIME_MAX] = {
+	[UPDATE_AIRTIME_STA] = { "sta", BLOBMSG_TYPE_STRING },
+	[UPDATE_AIRTIME_WEIGHT] = { "weight", BLOBMSG_TYPE_INT32 },
+};
+
+static int
+hostapd_bss_update_airtime(struct ubus_context *ctx, struct ubus_object *obj,
+			   struct ubus_request_data *ureq, const char *method,
+			   struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+	struct blob_attr *tb[__UPDATE_AIRTIME_MAX];
+	struct sta_info *sta = NULL;
+	u8 addr[ETH_ALEN];
+	int weight;
+
+	blobmsg_parse(airtime_policy, __UPDATE_AIRTIME_MAX, tb, blob_data(msg), blob_len(msg));
+
+	if (!tb[UPDATE_AIRTIME_WEIGHT])
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	weight = blobmsg_get_u32(tb[UPDATE_AIRTIME_WEIGHT]);
+
+	if (!tb[UPDATE_AIRTIME_STA]) {
+		if (!weight)
+			return UBUS_STATUS_INVALID_ARGUMENT;
+
+		hapd->conf->airtime_weight = weight;
+		return 0;
+	}
+
+	if (hwaddr_aton(blobmsg_data(tb[UPDATE_AIRTIME_STA]), addr))
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	sta = ap_get_sta(hapd, addr);
+	if (!sta)
+		return UBUS_STATUS_NOT_FOUND;
+
+	sta->dyn_airtime_weight = weight;
+	airtime_policy_new_sta(hapd, sta);
+
+	return 0;
+}
+#endif
+
+
 static const struct ubus_method bss_methods[] = {
 	UBUS_METHOD_NOARG("reload", hostapd_bss_reload),
 	UBUS_METHOD_NOARG("get_clients", hostapd_bss_get_clients),
 	UBUS_METHOD_NOARG("get_status", hostapd_bss_get_status),
 	UBUS_METHOD("del_client", hostapd_bss_del_client, del_policy),
+#ifdef CONFIG_AIRTIME_POLICY
+	UBUS_METHOD("update_airtime", hostapd_bss_update_airtime, airtime_policy),
+#endif
 	UBUS_METHOD_NOARG("list_bans", hostapd_bss_list_bans),
 #ifdef CONFIG_WPS
 	UBUS_METHOD_NOARG("wps_start", hostapd_bss_wps_start),
@@ -1364,6 +1511,43 @@ void hostapd_ubus_free_bss(struct hostapd_data *hapd)
 	free(name);
 }
 
+static void
+hostapd_ubus_vlan_action(struct hostapd_data *hapd, struct hostapd_vlan *vlan,
+			 const char *action)
+{
+	struct vlan_description *desc = &vlan->vlan_desc;
+	void *c;
+	int i;
+
+	if (!hapd->ubus.obj.has_subscribers)
+		return;
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_string(&b, "ifname", vlan->ifname);
+	blobmsg_add_string(&b, "bridge", vlan->bridge);
+	blobmsg_add_u32(&b, "vlan_id", vlan->vlan_id);
+
+	if (desc->notempty) {
+		blobmsg_add_u32(&b, "untagged", desc->untagged);
+		c = blobmsg_open_array(&b, "tagged");
+		for (i = 0; i < ARRAY_SIZE(desc->tagged) && desc->tagged[i]; i++)
+			blobmsg_add_u32(&b, "", desc->tagged[i]);
+		blobmsg_close_array(&b, c);
+	}
+
+	ubus_notify(ctx, &hapd->ubus.obj, action, b.head, -1);
+}
+
+void hostapd_ubus_add_vlan(struct hostapd_data *hapd, struct hostapd_vlan *vlan)
+{
+	hostapd_ubus_vlan_action(hapd, vlan, "vlan_add");
+}
+
+void hostapd_ubus_remove_vlan(struct hostapd_data *hapd, struct hostapd_vlan *vlan)
+{
+	hostapd_ubus_vlan_action(hapd, vlan, "vlan_remove");
+}
+
 static const struct ubus_method daemon_methods[] = {
 	UBUS_METHOD("config_add", hostapd_config_add, config_add_policy),
 	UBUS_METHOD("config_remove", hostapd_config_remove, config_remove_policy),
@@ -1550,3 +1734,21 @@ void hostapd_ubus_notify_beacon_report(
 
 	ubus_notify(ctx, &hapd->ubus.obj, "beacon-report", b.head, -1);
 }
+
+void hostapd_ubus_notify_radar_detected(struct hostapd_iface *iface, int frequency,
+					int chan_width, int cf1, int cf2)
+{
+	struct hostapd_data *hapd;
+	int i;
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_u16(&b, "frequency", frequency);
+	blobmsg_add_u16(&b, "width", chan_width);
+	blobmsg_add_u16(&b, "center1", cf1);
+	blobmsg_add_u16(&b, "center2", cf2);
+
+	for (i = 0; i < iface->num_bss; i++) {
+		hapd = iface->bss[i];
+		ubus_notify(ctx, &hapd->ubus.obj, "radar-detected", b.head, -1);
+	}
+}
diff --git a/package/network/services/hostapd/src/src/ap/ubus.h b/package/network/services/hostapd/src/src/ap/ubus.h
index e16017394f..acdac74360 100644
--- a/package/network/services/hostapd/src/src/ap/ubus.h
+++ b/package/network/services/hostapd/src/src/ap/ubus.h
@@ -43,6 +43,8 @@ void hostapd_ubus_add_iface(struct hostapd_iface *iface);
 void hostapd_ubus_free_iface(struct hostapd_iface *iface);
 void hostapd_ubus_add_bss(struct hostapd_data *hapd);
 void hostapd_ubus_free_bss(struct hostapd_data *hapd);
+void hostapd_ubus_add_vlan(struct hostapd_data *hapd, struct hostapd_vlan *vlan);
+void hostapd_ubus_remove_vlan(struct hostapd_data *hapd, struct hostapd_vlan *vlan);
 
 int hostapd_ubus_handle_event(struct hostapd_data *hapd, struct hostapd_ubus_request *req);
 void hostapd_ubus_notify(struct hostapd_data *hapd, const char *type, const u8 *mac);
@@ -50,6 +52,8 @@ void hostapd_ubus_notify_beacon_report(struct hostapd_data *hapd,
 				       const u8 *addr, u8 token, u8 rep_mode,
 				       struct rrm_measurement_beacon_report *rep,
 				       size_t len);
+void hostapd_ubus_notify_radar_detected(struct hostapd_iface *iface, int frequency,
+					int chan_width, int cf1, int cf2);
 
 void hostapd_ubus_add(struct hapd_interfaces *interfaces);
 void hostapd_ubus_free(struct hapd_interfaces *interfaces);
@@ -74,6 +78,14 @@ static inline void hostapd_ubus_free_bss(struct hostapd_data *hapd)
 {
 }
 
+static inline void hostapd_ubus_add_vlan(struct hostapd_data *hapd, struct hostapd_vlan *vlan)
+{
+}
+
+static inline void hostapd_ubus_remove_vlan(struct hostapd_data *hapd, struct hostapd_vlan *vlan)
+{
+}
+
 static inline int hostapd_ubus_handle_event(struct hostapd_data *hapd, struct hostapd_ubus_request *req)
 {
 	return 0;
@@ -90,6 +102,10 @@ static inline void hostapd_ubus_notify_beacon_report(struct hostapd_data *hapd,
 						     size_t len)
 {
 }
+static inline void hostapd_ubus_notify_radar_detected(struct hostapd_iface *iface, int frequency,
+						      int chan_width, int cf1, int cf2)
+{
+}
 
 static inline void hostapd_ubus_add(struct hapd_interfaces *interfaces)
 {
diff --git a/package/network/services/hostapd/src/src/utils/build_features.h b/package/network/services/hostapd/src/src/utils/build_features.h
index c7fccad413..3ab5246c78 100644
--- a/package/network/services/hostapd/src/src/utils/build_features.h
+++ b/package/network/services/hostapd/src/src/utils/build_features.h
@@ -23,8 +23,6 @@ static inline int has_feature(const char *feat)
 	if (!strcmp(feat, "11r"))
 		return 1;
 #endif
-	if (!strcmp(feat, "11w"))
-		return 1;
 #ifdef CONFIG_ACS
 	if (!strcmp(feat, "acs"))
 		return 1;
-- 
2.25.1

