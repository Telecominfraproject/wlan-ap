From 834907903a41e03c8988cbd97ca2b9b819b75843 Mon Sep 17 00:00:00 2001
From: Your Name <you@example.com>
Date: Wed, 10 Jul 2024 14:22:28 +0800
Subject: [PATCH] add sonicfi rap630w 211g

Signed-off-by: Your Name <you@example.com>
---
 include/image-commands.mk                     |  27 +
 .../sonicfi/nand_sonicfi_rap630w_211g.sh      | 511 ++++++++++++++++++
 package/base-files/files/sbin/sysupgrade      |   8 +
 scripts/mkits_sonicfi_rap630w_211g.sh         | 237 ++++++++
 tools/Makefile                                |   1 +
 tools/crc32sum/Makefile                       |  23 +
 tools/crc32sum/src/Makefile                   |  18 +
 tools/crc32sum/src/crc32sum.c                 | 282 ++++++++++
 8 files changed, 1107 insertions(+)
 create mode 100644 package/base-files/files/lib/upgrade/sonicfi/nand_sonicfi_rap630w_211g.sh
 create mode 100755 scripts/mkits_sonicfi_rap630w_211g.sh
 create mode 100644 tools/crc32sum/Makefile
 create mode 100644 tools/crc32sum/src/Makefile
 create mode 100644 tools/crc32sum/src/crc32sum.c

diff --git a/include/image-commands.mk b/include/image-commands.mk
index dc6ee6e7c1..0013eeb540 100644
--- a/include/image-commands.mk
+++ b/include/image-commands.mk
@@ -291,6 +291,32 @@ define Build/initrd_compression
 	$(if $(CONFIG_TARGET_INITRAMFS_COMPRESSION_ZSTD),.zstd)
 endef
 
+ifeq ($(CONFIG_TARGET_mediatek_mt7981_DEVICE_sonicfi_rap630w_211g),y)
+define Build/fit
+	$(TOPDIR)/scripts/mkits_sonicfi_rap630w_211g.sh \
+		-D $(DEVICE_NAME) -o $@.its -k $@ \
+		-C $(word 1,$(1)) \
+		$(if $(word 2,$(1)),\
+			$(if $(findstring 11,$(if $(DEVICE_DTS_OVERLAY),1)$(if $(findstring $(KERNEL_BUILD_DIR)/image-,$(word 2,$(1))),,1)), \
+				-d $(KERNEL_BUILD_DIR)/image-$$(basename $(word 2,$(1))), \
+				-d $(word 2,$(1)))) \
+		$(if $(findstring with-rootfs,$(word 3,$(1))),-r $(IMAGE_ROOTFS)) \
+		$(if $(findstring with-initrd,$(word 3,$(1))), \
+			$(if $(CONFIG_TARGET_ROOTFS_INITRAMFS_SEPARATE), \
+				-i $(KERNEL_BUILD_DIR)/initrd.cpio$(strip $(call Build/initrd_compression)))) \
+		-a $(KERNEL_LOADADDR) -e $(if $(KERNEL_ENTRY),$(KERNEL_ENTRY),$(KERNEL_LOADADDR)) \
+		$(if $(DEVICE_FDT_NUM),-n $(DEVICE_FDT_NUM)) \
+		$(if $(DEVICE_DTS_DELIMITER),-l $(DEVICE_DTS_DELIMITER)) \
+		$(if $(DEVICE_DTS_LOADADDR),-s $(DEVICE_DTS_LOADADDR)) \
+		$(if $(DEVICE_DTS_OVERLAY),$(foreach dtso,$(DEVICE_DTS_OVERLAY), -O $(dtso):$(KERNEL_BUILD_DIR)/image-$(dtso).dtbo)) \
+		-c $(if $(DEVICE_DTS_CONFIG),$(DEVICE_DTS_CONFIG),"config-1") \
+		-A $(LINUX_KARCH) -v $(LINUX_VERSION) \
+		$(if $(CONFIG_TARGET_ROOTFS_SQUASHFS),-r $(ROOTFS/squashfs/$(DEVICE_NAME)))
+	PATH=$(LINUX_DIR)/scripts/dtc:$(PATH) mkimage $(if $(findstring external,$(word 3,$(1))),\
+		-E -B 0x1000 $(if $(findstring static,$(word 3,$(1))),-p 0x1000)) -f $@.its $@.new
+	@mv $@.new $@
+endef
+else
 define Build/fit
 	$(TOPDIR)/scripts/mkits.sh \
 		-D $(DEVICE_NAME) -o $@.its -k $@ \
@@ -314,6 +340,7 @@ define Build/fit
 		-E -B 0x1000 $(if $(findstring static,$(word 3,$(1))),-p 0x1000)) -f $@.its $@.new
 	@mv $@.new $@
 endef
+endif
 
 define Build/libdeflate-gzip
 	$(STAGING_DIR_HOST)/bin/libdeflate-gzip -f -12 -c $@ $(1) > $@.new
diff --git a/package/base-files/files/lib/upgrade/sonicfi/nand_sonicfi_rap630w_211g.sh b/package/base-files/files/lib/upgrade/sonicfi/nand_sonicfi_rap630w_211g.sh
new file mode 100644
index 0000000000..6c2f167993
--- /dev/null
+++ b/package/base-files/files/lib/upgrade/sonicfi/nand_sonicfi_rap630w_211g.sh
@@ -0,0 +1,511 @@
+# Copyright (C) 2014 OpenWrt.org
+#
+
+. /lib/functions.sh
+
+# 'kernel' partition on NAND contains the kernel
+CI_KERNPART="${CI_KERNPART:-kernel}"
+
+# 'ubi' partition on NAND contains UBI
+CI_UBIPART="${CI_UBIPART:-ubi}"
+
+# 'rootfs' partition on NAND contains the rootfs
+CI_ROOTPART="${CI_ROOTPART:-rootfs}"
+
+get_boot_param()
+{
+	local cmdline_param=$(cat /proc/cmdline)
+	local name
+	for var in $cmdline_param
+	do
+		#echo "aaa---$var"
+		if [ $var == $1 ];
+		then
+			echo "Y"
+			return
+		else
+			name=$(echo $var | awk -F '=' '{print $1}')
+			#echo "$name"
+			if [ $name == $1 ];
+			then
+					echo $(echo $var | awk -F '=' '{print $2}')
+					return
+			fi
+		fi
+	done
+	echo "N"
+}
+
+ubi_mknod() {
+	local dir="$1"
+	local dev="/dev/$(basename $dir)"
+
+	[ -e "$dev" ] && return 0
+
+	local devid="$(cat $dir/dev)"
+	local major="${devid%%:*}"
+	local minor="${devid##*:}"
+	mknod "$dev" c $major $minor
+}
+
+nand_find_volume() {
+	local ubidevdir ubivoldir
+	ubidevdir="/sys/devices/virtual/ubi/$1"
+	[ ! -d "$ubidevdir" ] && return 1
+	for ubivoldir in $ubidevdir/${1}_*; do
+		[ ! -d "$ubivoldir" ] && continue
+		if [ "$( cat $ubivoldir/name )" = "$2" ]; then
+			basename $ubivoldir
+			ubi_mknod "$ubivoldir"
+			return 0
+		fi
+	done
+}
+
+nand_find_ubi() {
+	local ubidevdir ubidev mtdnum
+	mtdnum="$( find_mtd_index $1 )"
+	[ ! "$mtdnum" ] && return 1
+	for ubidevdir in /sys/devices/virtual/ubi/ubi*; do
+		[ ! -d "$ubidevdir" ] && continue
+		cmtdnum="$( cat $ubidevdir/mtd_num )"
+		[ ! "$mtdnum" ] && continue
+		if [ "$mtdnum" = "$cmtdnum" ]; then
+			ubidev=$( basename $ubidevdir )
+			ubi_mknod "$ubidevdir"
+			echo $ubidev
+			return 0
+		fi
+	done
+}
+
+nand_get_magic_long() {
+	dd if="$1" skip=$2 bs=4 count=1 2>/dev/null | hexdump -v -n 4 -e '1/1 "%02x"'
+}
+
+get_magic_long_tar() {
+	( tar xf $1 $2 -O | dd bs=4 count=1 | hexdump -v -n 4 -e '1/1 "%02x"') 2> /dev/null
+}
+
+identify_magic() {
+	local magic=$1
+	case "$magic" in
+		"55424923")
+			echo "ubi"
+			;;
+		"31181006")
+			echo "ubifs"
+			;;
+		"68737173")
+			echo "squashfs"
+			;;
+		"d00dfeed")
+			echo "fit"
+			;;
+		"4349"*)
+			echo "combined"
+			;;
+		*)
+			echo "unknown $magic"
+			;;
+	esac
+}
+
+
+identify() {
+	identify_magic $(nand_get_magic_long "$1" "${2:-0}")
+}
+
+identify_tar() {
+	identify_magic $(get_magic_long_tar "$1" "$2")
+}
+
+nand_restore_config() {
+	sync
+	local ubidev=$( nand_find_ubi $CI_UBIPART )
+	local ubivol="$( nand_find_volume $ubidev rootfs_data )"
+	[ ! "$ubivol" ] &&
+		ubivol="$( nand_find_volume $ubidev $CI_ROOTPART )"
+	mkdir /tmp/new_root
+	if ! mount -t ubifs /dev/$ubivol /tmp/new_root; then
+		echo "mounting ubifs $ubivol failed"
+		rmdir /tmp/new_root
+		return 1
+	fi
+	mv "$1" "/tmp/new_root/$BACKUP_FILE"
+	umount /tmp/new_root
+	sync
+	rmdir /tmp/new_root
+}
+
+nand_upgrade_prepare_ubi() {
+	local rootfs_length="$1"
+	local rootfs_type="$2"
+	local has_kernel="${3:-0}"
+	local has_env="${4:-0}"
+
+	local mtdnum="$( find_mtd_index "$CI_UBIPART" )"
+	if [ ! "$mtdnum" ]; then
+		echo "cannot find ubi mtd partition $CI_UBIPART"
+		return 1
+	fi
+
+	local ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+	if [ ! "$ubidev" ]; then
+		ubiattach -m "$mtdnum"
+		sync
+		ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+	fi
+
+	if [ ! "$ubidev" ]; then
+		ubiformat /dev/mtd$mtdnum -y
+		ubiattach -m "$mtdnum"
+		sync
+		ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+		[ "$has_env" -gt 0 ] && {
+			ubimkvol /dev/$ubidev -n 0 -N ubootenv -s 1MiB
+			ubimkvol /dev/$ubidev -n 1 -N ubootenv2 -s 1MiB
+		}
+	fi
+
+	local kern_ubivol="$( nand_find_volume $ubidev $CI_KERNPART )"
+	local root_ubivol="$( nand_find_volume $ubidev $CI_ROOTPART )"
+	local data_ubivol="$( nand_find_volume $ubidev rootfs_data )"
+
+	# remove ubiblock device of rootfs
+	local root_ubiblk="ubiblock${root_ubivol:3}"
+	if [ "$root_ubivol" -a -e "/dev/$root_ubiblk" ]; then
+		echo "removing $root_ubiblk"
+		if ! ubiblock -r /dev/$root_ubivol; then
+			echo "cannot remove $root_ubiblk"
+			return 1;
+		fi
+	fi
+
+	# kill volumes
+	[ "$kern_ubivol" ] && ubirmvol /dev/$ubidev -N $CI_KERNPART || true
+	[ "$root_ubivol" ] && ubirmvol /dev/$ubidev -N $CI_ROOTPART || true
+	[ "$data_ubivol" ] && ubirmvol /dev/$ubidev -N rootfs_data || true
+
+	# update kernel
+	if [ "$has_kernel" = "1" ]; then
+		if ! ubimkvol /dev/$ubidev -N $CI_KERNPART -s $kernel_length; then
+			echo "cannot create kernel volume"
+			return 1;
+		fi
+	fi
+
+	# update rootfs
+	local root_size_param
+	if [ "$rootfs_type" = "ubifs" ]; then
+		root_size_param="-m"
+	else
+		root_size_param="-s $rootfs_length"
+	fi
+	if ! ubimkvol /dev/$ubidev -N $CI_ROOTPART $root_size_param; then
+		echo "cannot create rootfs volume"
+		return 1;
+	fi
+
+	# create rootfs_data for non-ubifs rootfs
+	if [ "$rootfs_type" != "ubifs" ]; then
+		if ! ubimkvol /dev/$ubidev -N rootfs_data -m; then
+			echo "cannot initialize rootfs_data volume"
+			return 1
+		fi
+	fi
+	sync
+	return 0
+}
+
+nand_do_upgrade_success() {
+	local conf_tar="/tmp/sysupgrade.tgz"
+
+	sync
+	[ -f "$conf_tar" ] && nand_restore_config "$conf_tar"
+	echo "sysupgrade successful"
+	umount -a
+	reboot -f
+}
+
+# Flash the UBI image to MTD partition
+nand_upgrade_ubinized() {
+	local ubi_file="$1"
+	local mtdnum="$(find_mtd_index "$CI_UBIPART")"
+
+	[ ! "$mtdnum" ] && {
+		CI_UBIPART="rootfs"
+		mtdnum="$(find_mtd_index "$CI_UBIPART")"
+	}
+
+	if [ ! "$mtdnum" ]; then
+		echo "cannot find mtd device $CI_UBIPART"
+		umount -a
+		reboot -f
+	fi
+
+	local mtddev="/dev/mtd${mtdnum}"
+	ubidetach -p "${mtddev}" || true
+	sync
+	ubiformat "${mtddev}" -y -f "${ubi_file}"
+	ubiattach -p "${mtddev}"
+	nand_do_upgrade_success
+}
+
+# Write the UBIFS image to UBI volume
+nand_upgrade_ubifs() {
+	local rootfs_length=$( (cat $1 | wc -c) 2> /dev/null)
+
+	nand_upgrade_prepare_ubi "$rootfs_length" "ubifs" "0" "0"
+
+	local ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+	local root_ubivol="$(nand_find_volume $ubidev $CI_ROOTPART)"
+	ubiupdatevol /dev/$root_ubivol -s $rootfs_length $1
+
+	nand_do_upgrade_success
+}
+
+nand_upgrade_tar() {
+	local tar_file="$1"
+	local kernel_mtd="$(find_mtd_index $CI_KERNPART)"
+
+	local board_dir=$(tar tf $tar_file | grep -m 1 '^sysupgrade-.*/$')
+	board_dir=${board_dir%/}
+
+	local kernel_length=$( (tar xf $tar_file ${board_dir}/kernel -O | wc -c) 2> /dev/null)
+	local rootfs_length=$( (tar xf $tar_file ${board_dir}/root -O | wc -c) 2> /dev/null)
+
+	local rootfs_type="$(identify_tar "$tar_file" ${board_dir}/root)"
+
+	local has_kernel=1
+	local has_env=0
+
+	[ "$kernel_length" != 0 -a -n "$kernel_mtd" ] && {
+		tar xf $tar_file ${board_dir}/kernel -O | mtd write - $CI_KERNPART
+	}
+	[ "$kernel_length" = 0 -o ! -z "$kernel_mtd" ] && has_kernel=0
+
+	nand_upgrade_prepare_ubi "$rootfs_length" "$rootfs_type" "$has_kernel" "$has_env"
+
+	local ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+	[ "$has_kernel" = "1" ] && {
+		local kern_ubivol="$(nand_find_volume $ubidev $CI_KERNPART)"
+		tar xf $tar_file ${board_dir}/kernel -O | \
+			ubiupdatevol /dev/$kern_ubivol -s $kernel_length -
+	}
+
+	local root_ubivol="$(nand_find_volume $ubidev $CI_ROOTPART)"
+	tar xf $tar_file ${board_dir}/root -O | \
+		ubiupdatevol /dev/$root_ubivol -s $rootfs_length -
+
+	nand_do_upgrade_success
+}
+
+# Recognize type of passed file and start the upgrade process
+nand_do_upgrade() {
+	local file_type=$(identify $1)
+
+	[ ! "$(find_mtd_index "$CI_UBIPART")" ] && CI_UBIPART="rootfs"
+
+	case "$file_type" in
+		"ubi")		nand_upgrade_ubinized $1;;
+		"ubifs")	nand_upgrade_ubifs $1;;
+		*)		nand_upgrade_tar $1;;
+	esac
+}
+
+# Check if passed file is a valid one for NAND sysupgrade. Currently it accepts
+# 3 types of files:
+# 1) UBI - should contain an ubinized image, header is checked for the proper
+#    MAGIC
+# 2) UBIFS - should contain UBIFS partition that will replace "rootfs" volume,
+#    header is checked for the proper MAGIC
+# 3) TAR - archive has to include "sysupgrade-BOARD" directory with a non-empty
+#    "CONTROL" file (at this point its content isn't verified)
+#
+# You usually want to call this function in platform_check_image.
+#
+# $(1): board name, used in case of passing TAR file
+# $(2): file to be checked
+nand_do_platform_check() {
+	local board_name="$1"
+	local tar_file="$2"
+	local control_length=$( (tar xf $tar_file sysupgrade-$board_name/CONTROL -O | wc -c) 2> /dev/null)
+	local file_type="$(identify $2)"
+
+	[ "$control_length" = 0 -a "$file_type" != "ubi" -a "$file_type" != "ubifs" ] && {
+		echo "Invalid sysupgrade file."
+		return 1
+	}
+
+	return 0
+}
+
+dual_boot_upgrade_prepare_ubi() {
+	local kernel_vol_name="$1"
+	local rootfs_vol_name="$2"
+	local kernel_length="$3"
+	local rootfs_length="$4"
+	local reserve_rootfs_data="$5"
+	local conf_tar="/tmp/sysupgrade.tgz"
+
+	local mtdnum="$( find_mtd_index "$CI_UBIPART" )"
+	if [ ! "$mtdnum" ]; then
+		echo "cannot find ubi mtd partition $CI_UBIPART"
+		return 1
+	fi
+
+	local ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+	if [ ! "$ubidev" ]; then
+		ubiattach -m "$mtdnum"
+		sync
+		ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+	fi
+
+	if [ ! "$ubidev" ]; then
+		ubiformat /dev/mtd$mtdnum -y
+		ubiattach -m "$mtdnum"
+		sync
+		ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+		ubimkvol /dev/$ubidev -n 0 -N u-boot-env -s 512KiB
+	fi
+
+	#local rootfs_data_vol_name=$(cat /sys/module/boot_param/parameters/rootfs_data_part 2>/dev/null)
+	local rootfs_data_vol_name=$(get_boot_param "boot_param.rootfs_data_part")
+	
+	local kern_ubivol="$( nand_find_volume $ubidev $kernel_vol_name )"
+	local root_ubivol="$( nand_find_volume $ubidev $rootfs_vol_name )"
+	local data_ubivol="$( nand_find_volume $ubidev $rootfs_data_vol_name )"
+
+	# remove ubiblock device of rootfs
+	local root_ubiblk="ubiblock${root_ubivol:3}"
+	if [ "$root_ubivol" -a -e "/dev/$root_ubiblk" ]; then
+		echo "removing $root_ubiblk"
+		if ! ubiblock -r /dev/$root_ubivol; then
+			echo "cannot remove $root_ubiblk"
+			return 1;
+		fi
+	fi
+
+	# kill volumes
+	[ "$kern_ubivol" ] && ubirmvol /dev/$ubidev -N $kernel_vol_name || true
+	[ "$root_ubivol" ] && ubirmvol /dev/$ubidev -N $rootfs_vol_name || true
+
+	# update kernel
+	if ! ubimkvol /dev/$ubidev -N $kernel_vol_name -s $kernel_length; then
+		echo "cannot create kernel volume"
+		return 1;
+	fi
+
+	# update rootfs
+	if ! ubimkvol /dev/$ubidev -N $rootfs_vol_name -s $rootfs_length; then
+		echo "cannot create rootfs volume"
+		return 1;
+	fi
+
+	if [ x"${reserve_rootfs_data}" = xY ] && [ -f "$conf_tar" ]; then
+		# Do not touch rootfs_data
+		sync
+		return 0
+	fi
+
+	# 'format' rootfs_data volume
+	[ "$data_ubivol" ] && {
+		local rootfs_data_length=$(cat /sys/class/ubi/$data_ubivol/data_bytes)
+
+		# kill rootfs_data volume
+		ubirmvol /dev/$ubidev -N $rootfs_data_vol_name || true
+
+		# update rootfs_data
+		if ! ubimkvol /dev/$ubidev -N $rootfs_data_vol_name -s $rootfs_data_length; then
+			echo "cannot create $rootfs_data_vol_name volume"
+		fi
+	}
+
+	sync
+	return 0
+}
+
+ubi_dual_boot_upgrade_tar() {
+	local tar_file="$1"
+	local board_dir=$(tar tf ${tar_file} | grep -m 1 '^sysupgrade-.*/$')
+	#local reserve_rootfs_data=$(cat /sys/module/boot_param/parameters/reserve_rootfs_data 2>/dev/null)
+	local reserve_rootfs_data=$(get_boot_param "boot_param.reserve_rootfs_data")
+	board_dir=${board_dir%/}
+
+	#kernel_vol_name=$(cat /sys/module/boot_param/parameters/upgrade_kernel_part 2>/dev/null)
+	kernel_vol_name=$(get_boot_param "boot_param.upgrade_kernel_part")
+	[ -z "${kernel_vol_name}" -o $? -ne 0 ] && return 1
+
+	#rootfs_vol_name=$(cat /sys/module/boot_param/parameters/upgrade_rootfs_part 2>/dev/null)
+	rootfs_vol_name=$(get_boot_param "boot_param.upgrade_rootfs_part")
+	[ -z "${rootfs_vol_name}" -o $? -ne 0 ] && return 1
+
+	local kernel_length=$( (tar xf ${tar_file} ${board_dir}/kernel -O | wc -c) 2> /dev/null)
+	local rootfs_length=$( (tar xf ${tar_file} ${board_dir}/root -O | wc -c) 2> /dev/null)
+	echo "kernel_vol_name=$kernel_vol_name,rootfs_vol_name=$rootfs_vol_name,kernel_length=$kernel_length,rootfs_length=$rootfs_length,reserve_rootfs_data=$reserve_rootfs_data"
+	dual_boot_upgrade_prepare_ubi "${kernel_vol_name}" "${rootfs_vol_name}" \
+				      "${kernel_length}" "${rootfs_length}" \
+				      "${reserve_rootfs_data}"
+
+	local ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+
+	[ "${kernel_length}" != 0 ] && {
+		local kern_ubivol="$(nand_find_volume $ubidev ${kernel_vol_name})"
+		tar xf ${tar_file} ${board_dir}/kernel -O | \
+			ubiupdatevol /dev/${kern_ubivol} -s ${kernel_length} -
+	}
+
+	[ "${rootfs_length}" != 0 ] && {
+		local root_ubivol="$(nand_find_volume $ubidev ${rootfs_vol_name})"
+		tar xf ${tar_file} ${board_dir}/root -O | \
+			ubiupdatevol /dev/${root_ubivol} -s ${rootfs_length} -
+	}
+
+	#upgrade_image_slot=$(cat /sys/module/boot_param/parameters/upgrade_image_slot 2>/dev/null)
+	upgrade_image_slot=$(get_boot_param "boot_param.upgrade_image_slot")
+	[ -n "${upgrade_image_slot}" ] && {
+		echo "Set new boot image slot to ${upgrade_image_slot}"
+		# Force the creation of fw_printenv.lock
+		mkdir -p /var/lock
+		touch /var/lock/fw_printenv.lock
+		fw_setenv "dual_boot.current_slot" "${upgrade_image_slot}"
+		fw_setenv "dual_boot.slot_${upgrade_image_slot}_invalid" "0"
+	}
+
+	if [ x"${reserve_rootfs_data}" != xY ]; then
+		# do normal upgrade flow
+		nand_do_upgrade_success
+	fi
+
+	# Do not touch rootfs_data
+	sync
+
+	echo "sysupgrade successful"
+	umount -a
+	reboot -f
+}
+
+ubi_do_upgrade() {
+	#local dual_boot=$(cat /sys/module/boot_param/parameters/dual_boot 2>/dev/null)
+	local dual_boot=$(get_boot_param "boot_param.dual_boot")
+	local file_type=$(identify $1)
+
+	if [ -b /dev/dm-0 ]; then
+		v "Detach all device mapper devices"
+		dmsetup remove_all
+	fi
+	echo "dual_boot=$dual_boot file_type=$file_type"
+	if [ x"${dual_boot}" != xY ]; then
+		nand_do_upgrade "$1"
+		return
+	fi
+
+	case "$file_type" in
+		"ubi")		v "Unsupported firmware type: ubinized";;
+		"ubifs")	v "Unsupported firmware type: ubifs";;
+		*)		ubi_dual_boot_upgrade_tar $1;;
+	esac
+}
+
+ubi_do_upgrade "$1"
diff --git a/package/base-files/files/sbin/sysupgrade b/package/base-files/files/sbin/sysupgrade
index 9315091302..28b9ed3c8e 100755
--- a/package/base-files/files/sbin/sysupgrade
+++ b/package/base-files/files/sbin/sysupgrade
@@ -366,6 +366,14 @@ v "Commencing upgrade. Closing all shell sessions."
 
 COMMAND='/lib/upgrade/do_stage2'
 
+board=$(board_name)
+case "$board" in
+	sonicfi,rap630w-211g)
+	cp /lib/upgrade/sonicfi/nand_sonicfi_rap630w_211g.sh /tmp/nand_sonicfi_rap630w_211g.sh
+	chmod 777 /tmp/nand_sonicfi_rap630w_211g.sh
+	;;
+esac
+
 if [ -n "$FAILSAFE" ]; then
 	printf '%s\x00%s\x00%s' "$RAM_ROOT" "$IMAGE" "$COMMAND" >/tmp/sysupgrade
 	lock -u /tmp/.failsafe
diff --git a/scripts/mkits_sonicfi_rap630w_211g.sh b/scripts/mkits_sonicfi_rap630w_211g.sh
new file mode 100755
index 0000000000..35f2d00767
--- /dev/null
+++ b/scripts/mkits_sonicfi_rap630w_211g.sh
@@ -0,0 +1,237 @@
+#!/bin/sh
+#
+# Licensed under the terms of the GNU GPL License version 2 or later.
+#
+# Author: Peter Tyser <ptyser@xes-inc.com>
+#
+# U-Boot firmware supports the booting of images in the Flattened Image
+# Tree (FIT) format.  The FIT format uses a device tree structure to
+# describe a kernel image, device tree blob, ramdisk, etc.  This script
+# creates an Image Tree Source (.its file) which can be passed to the
+# 'mkimage' utility to generate an Image Tree Blob (.itb file).  The .itb
+# file can then be booted by U-Boot (or other bootloaders which support
+# FIT images).  See doc/uImage.FIT/howto.txt in U-Boot source code for
+# additional information on FIT images.
+#
+
+usage() {
+	printf "Usage: %s -A arch -C comp -a addr -e entry" "$(basename "$0")"
+	printf " -v version -k kernel [-D name -n address -d dtb] -o its_file"
+
+	printf "\n\t-A ==> set architecture to 'arch'"
+	printf "\n\t-C ==> set compression type 'comp'"
+	printf "\n\t-c ==> set config name 'config'"
+	printf "\n\t-a ==> set load address to 'addr' (hex)"
+	printf "\n\t-e ==> set entry point to 'entry' (hex)"
+	printf "\n\t-f ==> set device tree compatible string"
+	printf "\n\t-i ==> include initrd Blob 'initrd'"
+	printf "\n\t-v ==> set kernel version to 'version'"
+	printf "\n\t-k ==> include kernel image 'kernel'"
+	printf "\n\t-D ==> human friendly Device Tree Blob 'name'"
+	printf "\n\t-n ==> fdt unit-address 'address'"
+	printf "\n\t-d ==> include Device Tree Blob 'dtb'"
+	printf "\n\t-r ==> include RootFS blob 'rootfs'"
+	printf "\n\t-H ==> specify hash algo instead of SHA1"
+	printf "\n\t-l ==> legacy mode character (@ etc otherwise -)"
+	printf "\n\t-o ==> create output file 'its_file'"
+	printf "\n\t-O ==> create config with dt overlay 'name:dtb'"
+	printf "\n\t-s ==> set FDT load address to 'addr' (hex)"
+	printf "\n\t\t(can be specified more than once)\n"
+	exit 1
+}
+
+REFERENCE_CHAR='-'
+FDTNUM=1
+ROOTFSNUM=1
+INITRDNUM=1
+HASH=sha1
+LOADABLES=
+DTOVERLAY=
+DTADDR=
+
+while getopts ":A:a:c:C:D:d:e:f:i:k:l:n:o:O:v:r:s:H:" OPTION
+do
+	case $OPTION in
+		A ) ARCH=$OPTARG;;
+		a ) LOAD_ADDR=$OPTARG;;
+		c ) CONFIG=$OPTARG;;
+		C ) COMPRESS=$OPTARG;;
+		D ) DEVICE=$OPTARG;;
+		d ) DTB=$OPTARG;;
+		e ) ENTRY_ADDR=$OPTARG;;
+		f ) COMPATIBLE=$OPTARG;;
+		i ) INITRD=$OPTARG;;
+		k ) KERNEL=$OPTARG;;
+		l ) REFERENCE_CHAR=$OPTARG;;
+		n ) FDTNUM=$OPTARG;;
+		o ) OUTPUT=$OPTARG;;
+		O ) DTOVERLAY="$DTOVERLAY ${OPTARG}";;
+		r ) ROOTFS=$OPTARG;;
+		s ) FDTADDR=$OPTARG;;
+		H ) HASH=$OPTARG;;
+		v ) VERSION=$OPTARG;;
+		* ) echo "Invalid option passed to '$0' (options:$*)"
+		usage;;
+	esac
+done
+
+# Make sure user entered all required parameters
+if [ -z "${ARCH}" ] || [ -z "${COMPRESS}" ] || [ -z "${LOAD_ADDR}" ] || \
+	[ -z "${ENTRY_ADDR}" ] || [ -z "${VERSION}" ] || [ -z "${KERNEL}" ] || \
+	[ -z "${OUTPUT}" ] || [ -z "${CONFIG}" ]; then
+	usage
+fi
+
+ARCH_UPPER=$(echo "$ARCH" | tr '[:lower:]' '[:upper:]')
+
+if [ -n "${COMPATIBLE}" ]; then
+	COMPATIBLE_PROP="compatible = \"${COMPATIBLE}\";"
+fi
+
+[ "$FDTADDR" ] && {
+	DTADDR="$FDTADDR"
+}
+
+# Conditionally create fdt information
+if [ -n "${DTB}" ]; then
+	FDT_NODE="
+		fdt${REFERENCE_CHAR}$FDTNUM {
+			description = \"${ARCH_UPPER} OpenWrt ${DEVICE} device tree blob\";
+			${COMPATIBLE_PROP}
+			data = /incbin/(\"${DTB}\");
+			type = \"flat_dt\";
+			${DTADDR:+load = <${DTADDR}>;}
+			arch = \"${ARCH}\";
+			compression = \"none\";
+			hash${REFERENCE_CHAR}1 {
+				algo = \"crc32\";
+			};
+			hash${REFERENCE_CHAR}2 {
+				algo = \"${HASH}\";
+			};
+		};
+"
+	FDT_PROP="fdt = \"fdt${REFERENCE_CHAR}$FDTNUM\";"
+fi
+
+if [ -n "${INITRD}" ]; then
+	INITRD_NODE="
+		initrd${REFERENCE_CHAR}$INITRDNUM {
+			description = \"${ARCH_UPPER} OpenWrt ${DEVICE} initrd\";
+			${COMPATIBLE_PROP}
+			data = /incbin/(\"${INITRD}\");
+			type = \"ramdisk\";
+			arch = \"${ARCH}\";
+			os = \"linux\";
+			hash${REFERENCE_CHAR}1 {
+				algo = \"crc32\";
+			};
+			hash${REFERENCE_CHAR}2 {
+				algo = \"${HASH}\";
+			};
+		};
+"
+	INITRD_PROP="ramdisk=\"initrd${REFERENCE_CHAR}${INITRDNUM}\";"
+fi
+
+
+if [ -n "${ROOTFS}" ]; then
+	ROOTFS_SIZE=$(stat -c %s ${ROOTFS})
+	ROOTFS_SHA1=$(sha1sum ${ROOTFS} | awk '{print "<0x"substr($0,1,8) " 0x"substr($0,9,8) " 0x"substr($0,17,8) " 0x"substr($0,25,8) " 0x"substr($0,33,8) ">"}')
+	ROOTFS_CRC32=$(crc32sum ${ROOTFS})
+	ROOTFS_NODE="
+		rootfs {
+				size = <${ROOTFS_SIZE}>;
+				hash-1 {
+					value = <0x${ROOTFS_CRC32}>;
+					algo = \"crc32\";
+					};
+				hash-2 {
+					value = ${ROOTFS_SHA1};
+					algo = \"sha1\";
+					};
+			};
+"
+fi
+
+# add DT overlay blobs
+FDTOVERLAY_NODE=""
+OVCONFIGS=""
+[ "$DTOVERLAY" ] && for overlay in $DTOVERLAY ; do
+	overlay_blob=${overlay##*:}
+	ovname=${overlay%%:*}
+	ovnode="fdt-$ovname"
+	ovsize=$(wc -c "$overlay_blob" | awk '{print $1}')
+	echo "$ovname ($overlay_blob) : $ovsize" >&2
+	FDTOVERLAY_NODE="$FDTOVERLAY_NODE
+
+		$ovnode {
+			description = \"${ARCH_UPPER} OpenWrt ${DEVICE} device tree overlay $ovname\";
+			${COMPATIBLE_PROP}
+			data = /incbin/(\"${overlay_blob}\");
+			type = \"flat_dt\";
+			arch = \"${ARCH}\";
+			compression = \"none\";
+			hash${REFERENCE_CHAR}1 {
+				algo = \"crc32\";
+			};
+			hash${REFERENCE_CHAR}2 {
+				algo = \"${HASH}\";
+			};
+		};
+"
+	OVCONFIGS="$OVCONFIGS
+
+		$ovname {
+			description = \"OpenWrt ${DEVICE} overlay $ovname\";
+			fdt = \"$ovnode\";
+			${COMPATIBLE_PROP}
+		};
+	"
+done
+
+# Create a default, fully populated DTS file
+DATA="/dts-v1/;
+
+/ {
+	description = \"${ARCH_UPPER} OpenWrt FIT (Flattened Image Tree)\";
+	#address-cells = <1>;
+
+	images {
+		kernel${REFERENCE_CHAR}1 {
+			description = \"${ARCH_UPPER} OpenWrt Linux-${VERSION}\";
+			data = /incbin/(\"${KERNEL}\");
+			type = \"kernel\";
+			arch = \"${ARCH}\";
+			os = \"linux\";
+			compression = \"${COMPRESS}\";
+			load = <${LOAD_ADDR}>;
+			entry = <${ENTRY_ADDR}>;
+			hash${REFERENCE_CHAR}1 {
+				algo = \"crc32\";
+			};
+			hash${REFERENCE_CHAR}2 {
+				algo = \"$HASH\";
+			};
+		};
+${INITRD_NODE}
+${FDT_NODE}
+${FDTOVERLAY_NODE}
+	};
+${ROOTFS_NODE}
+	configurations {
+		default = \"${CONFIG}\";
+		${CONFIG} {
+			description = \"OpenWrt ${DEVICE}\";
+			kernel = \"kernel${REFERENCE_CHAR}1\";
+			${FDT_PROP}
+			${LOADABLES:+loadables = ${LOADABLES};}
+			${COMPATIBLE_PROP}
+			${INITRD_PROP}
+		};
+		${OVCONFIGS}
+	};
+};"
+
+# Write .its file to disk
+echo "$DATA" > "${OUTPUT}"
diff --git a/tools/Makefile b/tools/Makefile
index 40c3ec1ab0..6c7abaaf9c 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -68,6 +68,7 @@ tools-y += sstrip
 tools-y += zip
 tools-y += zlib
 tools-y += zstd
+tools-y += crc32sum
 tools-$(if $(CONFIG_BUILD_ALL_HOST_TOOLS),y) += liblzo
 tools-$(if $(CONFIG_BUILD_ALL_HOST_TOOLS)$(BUILD_B43_TOOLS),y) += b43-tools
 tools-$(if $(CONFIG_BUILD_ALL_HOST_TOOLS)$(BUILD_BZIP2_TOOLS),y) += bzip2
diff --git a/tools/crc32sum/Makefile b/tools/crc32sum/Makefile
new file mode 100644
index 0000000000..bc13ecf92b
--- /dev/null
+++ b/tools/crc32sum/Makefile
@@ -0,0 +1,23 @@
+#
+# Copyright (C) 2021 MediaTek Inc. All rights reserved.
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=crc32sum
+PKG_VERSION:=1.0
+
+include $(INCLUDE_DIR)/host-build.mk
+
+define Host/Prepare
+	mkdir -p $(HOST_BUILD_DIR)
+	$(CP) -a ./src/* $(HOST_BUILD_DIR)/
+endef
+
+define Host/Install
+	$(INSTALL_BIN) $(HOST_BUILD_DIR)/crc32sum $(STAGING_DIR_HOST)/bin/
+endef
+
+$(eval $(call HostBuild))
diff --git a/tools/crc32sum/src/Makefile b/tools/crc32sum/src/Makefile
new file mode 100644
index 0000000000..7428ba2f54
--- /dev/null
+++ b/tools/crc32sum/src/Makefile
@@ -0,0 +1,18 @@
+#
+# Copyright (C) 2021 MediaTek Inc. All rights reserved.
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+all: crc32sum
+
+crc32sum: crc32sum.c
+	$(CC) $(CFLAGS) -O2 -ggdb -MD -o $@ $< $(LDFLAGS)
+
+clean:
+	rm -f crc32sum crc32sum.d
+
+.PHONY: clean
+
+-include crc32sum.d
diff --git a/tools/crc32sum/src/crc32sum.c b/tools/crc32sum/src/crc32sum.c
new file mode 100644
index 0000000000..381c7a95a7
--- /dev/null
+++ b/tools/crc32sum/src/crc32sum.c
@@ -0,0 +1,282 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 MediaTek Inc. All Rights Reserved.
+ *
+ * Author: Weijie Gao <weijie.gao@mediatek.com>
+ */
+#include <stdio.h>
+#include <stdarg.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#include <getopt.h>
+
+#ifdef _WIN32
+#include <io.h>
+#include <fcntl.h>
+#define SET_BINARY_MODE(_f)		_setmode(_fileno(_f, O_BINARY)
+#else
+#define SET_BINARY_MODE(_f)		((void)0)
+#endif
+
+#define CRC32_LE_POLY_DEFAULT		0xedb88320
+#define CRC32_BE_POLY_DEFAULT		0x04c11db7
+#define CRC32_TABLE_ITEMS		256
+
+static uint32_t crc32_le_calc(uint32_t crc, const uint8_t *data, size_t length,
+			      const uint32_t *crc_table)
+{
+	while (length--)
+		crc = crc_table[(uint8_t)(crc ^ *data++)] ^ (crc >> 8);
+
+	return crc;
+}
+
+static void crc32_le_init(uint32_t *crc_table, uint32_t poly)
+{
+	uint32_t i, j, v;
+
+	for (i = 0; i < CRC32_TABLE_ITEMS; i++) {
+		v = i;
+
+		for (j = 0; j < 8; j++)
+			v = (v >> 1) ^ ((v & 1) ? poly : 0);
+
+		crc_table[i] = v;
+	}
+}
+
+static uint32_t crc32_be_calc(uint32_t crc, const uint8_t *data, size_t length,
+			      const uint32_t *crc_table)
+{
+	while (length--)
+		crc = crc_table[(uint8_t)((crc >> 24) ^ *data++)] ^ (crc << 8);
+
+	return crc;
+}
+
+static void crc32_be_init(uint32_t *crc_table, uint32_t poly)
+{
+	uint32_t i, j, v;
+
+	for (i = 0; i < CRC32_TABLE_ITEMS; i++) {
+		v = i << 24;
+
+		for (j = 0; j < 8; j++)
+			v = (v << 1) ^ ((v & (1 << 31)) ? poly : 0);
+
+		crc_table[i] = v;
+	}
+}
+
+struct crc_funcs {
+	uint32_t poly;
+
+	void (*init)(uint32_t *crc_table, uint32_t poly);
+	uint32_t (*calc)(uint32_t crc, const uint8_t *data, size_t length,
+			 const uint32_t *crc_table);
+};
+
+static const struct crc_funcs crc32_le = {
+	.poly = CRC32_LE_POLY_DEFAULT,
+	.init = crc32_le_init,
+	.calc = crc32_le_calc,
+};
+
+static const struct crc_funcs crc32_be = {
+	.poly = CRC32_BE_POLY_DEFAULT,
+	.init = crc32_be_init,
+	.calc = crc32_be_calc,
+};
+
+static const struct crc_funcs *crc32_algo = &crc32_le;
+static uint32_t crc32_poly;
+static uint32_t crc32_val;
+static const char *input_file;
+static bool output_decimal;
+static bool no_comp;
+
+static void err(const char *fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+	fprintf(stderr, "Error: ");
+	vfprintf(stderr, fmt, ap);
+	va_end(ap);
+}
+
+static void usage(FILE *con, const char *progname, int exitcode)
+{
+	const char *prog;
+	size_t len;
+
+	len = strlen(progname);
+	prog = progname + len - 1;
+
+	while (prog > progname) {
+		if (*prog == '\\' || *prog == '/') {
+			prog++;
+			break;
+		}
+
+		prog--;
+	}
+
+	fprintf(con, "CRC32 checksum tool\n");
+	fprintf(con, "\n");
+	fprintf(con, "Usage: %s [options] <input_file>\n", prog);
+	fprintf(con, "\n");
+	fprintf(con, "Options:\n");
+	fprintf(con, "\t-h         display help message\n");
+	fprintf(con, "\t-i <val>   crc value for incremental calculation\n");
+	fprintf(con, "\t           (default is 0)\n");
+	fprintf(con, "\t-p <val>   polynomial for calculation\n");
+	fprintf(con, "\t           (default is 0x%08x for LE, 0x%08x for BE)\n",
+		crc32_le.poly, crc32_be.poly);
+	fprintf(con, "\t-b         use big-endian mode\n");
+	fprintf(con, "\t-n         do not use one's complement\n");
+	fprintf(con, "\t-d         use decimal output\n");
+	fprintf(con, "\n");
+
+	exit(exitcode);
+}
+
+static int parse_args(int argc, char *argv[])
+{
+	int opt;
+
+	static const char *optstring = "i:p:bndh";
+
+	opterr = 0;
+
+	while ((opt = getopt(argc, argv, optstring)) >= 0) {
+		switch (opt) {
+		case 'i':
+			if (!isxdigit(optarg[0])) {
+				err("Invalid crc value - %s\n", optarg);
+				return -EINVAL;
+			}
+
+			crc32_val = strtoul(optarg, NULL, 0);
+			break;
+
+		case 'p':
+			if (!isxdigit(optarg[0])) {
+				err("Invalid polynomial value - %s\n", optarg);
+				return -EINVAL;
+			}
+
+			crc32_poly = strtoul(optarg, NULL, 0);
+			break;
+
+		case 'b':
+			crc32_algo = &crc32_be;
+			break;
+
+		case 'n':
+			no_comp = true;
+			break;
+
+		case 'd':
+			output_decimal = true;
+			break;
+
+		case 'h':
+			usage(stdout, argv[0], 0);
+			break;
+
+		default:
+			usage(stderr, argv[0], EXIT_FAILURE);
+		}
+	}
+
+	if (!crc32_poly)
+		crc32_poly = crc32_algo->poly;
+
+	if (optind >= argc)
+		input_file = "-";
+	else
+		input_file = argv[optind];
+
+	if (!input_file[0]) {
+		err("Input file must not be empty\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int crc32_calc(void)
+{
+	uint32_t crc_table[CRC32_TABLE_ITEMS];
+	bool using_stdin = false;
+	uint8_t buf[4096];
+	size_t size;
+	int ret, i;
+	FILE *f;
+
+	if (!strcmp(input_file, "-")) {
+		SET_BINARY_MODE(stdin);
+		using_stdin = true;
+		f = stdin;
+	} else {
+		f = fopen(input_file, "rb");
+	}
+
+	if (!f) {
+		err("Failed to open file '%s'\n", input_file);
+		return -EINVAL;
+	}
+
+	crc32_algo->init(crc_table, crc32_poly);
+
+	if (!no_comp)
+		crc32_val ^= 0xffffffff;
+
+	do {
+		size = fread(buf, 1, sizeof(buf), f);
+
+		if (size) {
+			crc32_val = crc32_algo->calc(crc32_val, buf, size,
+						     crc_table);
+		}
+
+		if (size < sizeof(buf)) {
+			ret = ferror(f);
+
+			if (!ret && feof(f))
+				break;
+
+			err("Error while reading file: %d\n", ret);
+			break;
+		}
+	} while (true);
+
+	if (!using_stdin)
+		fclose(f);
+
+	if (ret)
+		return ret;
+
+	if (!no_comp)
+		crc32_val ^= 0xffffffff;
+
+	if (output_decimal)
+		printf("%u\n", crc32_val);
+	else
+		printf("%08x\n", crc32_val);
+
+	return 0;
+}
+
+int main(int argc, char *argv[])
+{
+	if (parse_args(argc, argv))
+		return 1;
+
+	return crc32_calc();
+}
-- 
2.43.2

