From b45949463768ed53a0d8783ae56b9a8f4b90b0ca Mon Sep 17 00:00:00 2001
From: Shayne Chen <shayne.chen@mediatek.com>
Date: Tue, 18 Mar 2025 23:16:05 +080r
Subject: [PATCH 011/119] mtk: mt76: add debug tools


Add radio idx in mt76_links_info

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

Handle PLR PHY mode reported by FW.

Signed-off-by: Benjamin Lin <benjamin-jw.lin@mediatek.com>

The mt7992 firmware will skip to run mcu cmd but still reply the response
to driver if the mcu cmd is not 4 byte alignment. Fix the alignment of
mcu cmd 'UNI_BAND_CONFIG_EDCCA_THRESHOLD'.

Signed-off-by: Howard Hsu <howard-yh.hsu@mediatek.com>


This commit introduces two changes. First, do not hold the mutex in the
atomic operation function, as it may cause a call trace when enabling
the kernel build option "Compile the kernel with sleep inside atomic
section checking." This mutex is removed since there is no significant
benefit to use it. Second, iterate over the link station instead of the
stations to find the minimum RSSI for each band.

Signed-off-by: Howard Hsu <howard-yh.hsu@mediatek.com>


Add ampdu_state to mt76_links_info for tracking ampdu status of each
link.


1. Add debug logs related to tokens
- Add wcid index in 'token'
- Add trace log 'mt7996:mt7996_mac_tx_free' to show wcdi and msdu id
when receiving invalid wcid and invalid msdu id.
2. Parse TxFree status to show 'Drop by HW' and 'Drop by MCU' in 'tx_stats'.
3. Add debugfs knob 'red' to get the status of HW RED.

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

Add new FW event format to support per-link & per-AC TX failed byte counters.
This patch prevents kernel crash.

[FW Dependency after 20250527 firmware]

Signed-off-by: Benjamin Lin <benjamin-jw.lin@mediatek.com>

Use designated array initializer for AC-to-string conversion.

Signed-off-by: Benjamin Lin <benjamin-jw.lin@mediatek.com>

Due to different HW design, mt7990 doesn't need the duplicated WTBL
improvement.

Signed-off-by: Shayne Chen <shayne.chen@mediatek.com>

When frequently doing "cat /sys/kernel/debug/ieee80211/phy0/
netdev:sta-mld-1/mt76_links_info", sometime the following calltrace
appears:

[ 3141.308039] Internal error: Oops: 0000000096000005 [#1] SMP
[ 3141.313606] Modules linked in: ksmbd pppoe ppp_async nft_fib_inet nf_flow_table_inet l2tp_ppp pptp pppox ppp_mppe ppp_generic nft_reject_ipv6 nft_reject_ipv4 nft_reject_inet nfte
[ 3141.313753]  iptable_filter ipt_ECN ip_tables compat(O) br_netfilter at24 mt76qos(O) crypto_safexcel ntfs3 sg pwm_fan i2c_gpio i2c_algo_bit i2c_mux_pca954x i2c_mux ip6table_mang]
[ 3141.474291] CPU: 3 PID: 24204 Comm: cat Tainted: G           O       6.6.92 #0
[ 3141.481503] Hardware name: MediaTek MT7988A Reference Board (DT)
[ 3141.487495] pstate: 80400005 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
[ 3141.494444] pc : mt7996_vif_links_info_show+0x174/0x1c8 [mt7996e]
[ 3141.500547] lr : mt7996_vif_links_info_show+0x144/0x1c8 [mt7996e]
[ 3141.506639] sp : ffffffc083a03ba0
[ 3141.509942] x29: ffffffc083a03ba0 x28: 0000000000400cc0 x27: 000000007ffff000
[ 3141.517066] x26: ffffff801d675ff8 x25: 0000000000000000 x24: ffffffc079863ff0
[ 3141.524190] x23: ffffffc07986f850 x22: ffffff800dde34c0 x21: 0000000000000001
[ 3141.531312] x20: ffffff801d675ff8 x19: ffffff80014c3690 x18: 0000000000000001
[ 3141.538436] x17: 0000000000000000 x16: 0000000000000000 x15: ffffffffffffffff
[ 3141.545560] x14: 0000000000000000 x13: ffffff8003cb70ca x12: 616d6f2020202020
[ 3141.552683] x11: 00000000ffffffd0 x10: 000000000000000a x9 : 0000000000000013
[ 3141.559806] x8 : 00000000000000cd x7 : 3d64695f646c6d5f x6 : 000000000000000a
[ 3141.566929] x5 : 0000000000000002 x4 : 0000000000000001 x3 : 0000000000000000
[ 3141.574051] x2 : 0000000000000000 x1 : ffffffc07986f8a8 x0 : ffffff80014c3690
[ 3141.581174] Call trace:
[ 3141.583610]  mt7996_vif_links_info_show+0x174/0x1c8 [mt7996e]
[ 3141.589358]  seq_read_iter+0xd8/0x47c
[ 3141.593013]  seq_read+0x70/0x88
[ 3141.596144]  full_proxy_read+0x5c/0xa8
[ 3141.599885]  vfs_read+0x9c/0x264
[ 3141.603106]  ksys_read+0x58/0xd4
[ 3141.606323]  __arm64_sys_read+0x18/0x20
[ 3141.610148]  invoke_syscall.constprop.0+0x4c/0xe0
[ 3141.614842]  do_el0_svc+0x3c/0xbc
[ 3141.618146]  el0_svc+0x18/0x4c
[ 3141.621192]  el0t_64_sync_handler+0x118/0x124
[ 3141.625538]  el0t_64_sync+0x150/0x154
[ 3141.629191] Code: f9400b43 b9401045 79401484 39400f42 (b9406063)
[ 3141.635271] ---[ end trace 0000000000000000 ]---
[ 3141.640625] Kernel panic - not syncing: Oops: Fatal exception
[ 3141.646363] SMP: stopping secondary CPUs
[ 3141.650277] Kernel Offset: disabled
[ 3141.653753] CPU features: 0x0,00000000,20000000,1000400b
[ 3141.659053] Memory Limit: none

In Linux, an "Oops" with error code 5 typically indicates a protection
fault, specifically a read from a memory area that is mapped but not
readable.

It seems that directly using "mlink->ctx" (ieee80211_chanctx_conf) could
be unsafe in debugfs, since in upper layer it is mostly be accessed with
wiphy-lock protected or rcu. So remove this access from mt76's debugfs.

Signed-off-by: Shayne Chen <shayne.chen@mediatek.com>

Refactor parsing rates-mcs sku table and fix wrong default
value of length check.

Signed-off-by: Allen Ye <allen.ye@mediatek.com>

Use signed variable to present correct bbp value.

Signed-off-by: Allen Ye <allen.ye@mediatek.com>

Grant permission to read DebugFS knob "red".

Signed-off-by: Benjamin Lin <benjamin-jw.lin@mediatek.com>

Previously, when enabling FW log, we would directly enable many debug
modules; however, this made WM very busy and thus increased the latency
for some FW functions, e.g., generate TXCMD.

To prevent this, rework the flow of setting FW debug modules.
Now we only enable those most frequently used modules by default.
To enable other modules, users should use "fw_debug_module" and
"fw_debug_level".

For example, to enable IDS_PP log:
echo 93 > fw_debug_module && echo 1 > fw_debug_level
The module numbers could be found in code or wiki.

When disabling FW log, we'll also disable all the debug modules, no
matter those set by default or by users.

Signed-off-by: Shayne Chen <shayne.chen@mediatek.com>

mtk: mt76: mt7996: add debugfs to show tx drop reason

1. Add drop reason in debugfs.
2. Fix the issue that statistics is incorrect when hw path
is enabled.

For the detail, please refer to wiki.
https://wiki.mediatek.inc/pages/viewpage.action?pageId=2095684121

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mt76: mt7996: remove for_each_sta_active_link

Use for_each_set_bit instead of for_each_sta_active_link.
The non-active links cannot be manipulated when using
for_each_sta_active_link because it would check if the
link is active first.

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>
---
 Makefile               |    1 +
 agg-rx.c               |   11 +
 dma.c                  |  104 +-
 dma.h                  |   20 +-
 eeprom.c               |   90 +-
 mac80211.c             |   77 +-
 mcu.c                  |   70 +-
 mt76.h                 |  214 +-
 mt76_connac3_mac.h     |    1 +
 mt76_connac_mac.c      |    7 +-
 mt76_connac_mcu.c      |    2 +-
 mt76_connac_mcu.h      |   29 +
 mt7996/Makefile        |   10 +-
 mt7996/coredump.c      |  238 ++-
 mt7996/coredump.h      |   42 +-
 mt7996/debugfs.c       |  959 +++++++--
 mt7996/dma.c           |  245 ++-
 mt7996/eeprom.c        |  302 ++-
 mt7996/eeprom.h        |  147 ++
 mt7996/init.c          |  469 ++++-
 mt7996/mac.c           |  850 ++++++--
 mt7996/main.c          | 1230 +++++++----
 mt7996/mcu.c           | 2224 ++++++++++++++++++--
 mt7996/mcu.h           |  335 ++-
 mt7996/mmio.c          |   84 +-
 mt7996/mt7996.h        |  501 ++++-
 mt7996/mt7996_trace.h  |  169 ++
 mt7996/mtk_debug.h     | 2951 ++++++++++++++++++++++++++
 mt7996/mtk_debug_i.h   | 1019 +++++++++
 mt7996/mtk_debugfs.c   | 4517 ++++++++++++++++++++++++++++++++++++++++
 mt7996/mtk_debugfs_i.c | 1017 +++++++++
 mt7996/mtk_mcu.c       | 1374 ++++++++++++
 mt7996/mtk_mcu.h       | 1167 +++++++++++
 mt7996/pci.c           |   39 +-
 mt7996/regs.h          |   61 +-
 mt7996/testmode.c      | 2198 +++++++++++++++++++
 mt7996/testmode.h      |  378 ++++
 mt7996/trace.c         |   12 +
 mt7996/vendor.c        | 1396 +++++++++++++
 mt7996/vendor.h        |  298 +++
 testmode.c             |  359 +++-
 testmode.h             |  150 +-
 tools/CMakeLists.txt   |    7 +
 tools/eeprom.c         |    6 +-
 tools/fields.c         |  162 +-
 tools/fwlog.c          |  247 ++-
 tools/main.c           |  127 ++
 tools/mt76-test.h      |    3 +
 trace.h                |   58 +
 tx.c                   |   65 +-
 wed.c                  |   33 +-
 51 files changed, 24626 insertions(+), 1449 deletions(-)
 create mode 100644 mt7996/mt7996_trace.h
 create mode 100644 mt7996/mtk_debug.h
 create mode 100644 mt7996/mtk_debug_i.h
 create mode 100644 mt7996/mtk_debugfs.c
 create mode 100644 mt7996/mtk_debugfs_i.c
 create mode 100644 mt7996/mtk_mcu.c
 create mode 100644 mt7996/mtk_mcu.h
 create mode 100644 mt7996/testmode.c
 create mode 100644 mt7996/testmode.h
 create mode 100644 mt7996/trace.c
 create mode 100644 mt7996/vendor.c
 create mode 100644 mt7996/vendor.h

diff --git a/Makefile b/Makefile
index a4663ccd..4af8fcb8 100644
--- a/Makefile
+++ b/Makefile
@@ -1,5 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0-only
 EXTRA_CFLAGS += -Werror -DCONFIG_MT76_LEDS
+ADDITIONAL_CFLAGS += $(ADDITIONAL_CFLAGS)
 obj-m := mt76.o
 obj-$(CONFIG_MT76_USB) += mt76-usb.o
 obj-$(CONFIG_MT76_SDIO) += mt76-sdio.o
diff --git a/agg-rx.c b/agg-rx.c
index 936ab1ca..bd4249a9 100644
--- a/agg-rx.c
+++ b/agg-rx.c
@@ -3,6 +3,7 @@
  * Copyright (C) 2018 Felix Fietkau <nbd@nbd.name>
  */
 #include "mt76.h"
+#include "trace.h"
 
 static unsigned long mt76_aggr_tid_to_timeo(u8 tidno)
 {
@@ -151,6 +152,7 @@ void mt76_rx_aggr_reorder(struct sk_buff *skb, struct sk_buff_head *frames)
 	struct mt76_wcid *wcid = status->wcid;
 	struct ieee80211_sta *sta;
 	struct mt76_rx_tid *tid;
+	struct mt76_phy *phy;
 	bool sn_less;
 	u16 seqno, head, size, idx;
 	u8 tidno = status->qos_ctl & IEEE80211_QOS_CTL_TID_MASK;
@@ -179,6 +181,8 @@ void mt76_rx_aggr_reorder(struct sk_buff *skb, struct sk_buff_head *frames)
 	if (!tid)
 		return;
 
+	phy = mt76_dev_phy(tid->dev, wcid->phy_idx);
+
 	status->flag |= RX_FLAG_DUP_VALIDATED;
 	spin_lock_bh(&tid->lock);
 
@@ -189,6 +193,7 @@ void mt76_rx_aggr_reorder(struct sk_buff *skb, struct sk_buff_head *frames)
 	seqno = status->seqno;
 	size = tid->size;
 	sn_less = ieee80211_sn_less(seqno, head);
+	trace_mt76_rx_aggr_reorder(tid->dev, wcid, head, seqno, sn_less);
 
 	if (!tid->started) {
 		if (sn_less)
@@ -200,6 +205,9 @@ void mt76_rx_aggr_reorder(struct sk_buff *skb, struct sk_buff_head *frames)
 	if (sn_less) {
 		__skb_unlink(skb, frames);
 		dev_kfree_skb(skb);
+		spin_lock_bh(&phy->rx_dbg_stats.lock);
+		phy->rx_dbg_stats.rx_drop[MT_RX_DROP_AGG_SN_LESS]++;
+		spin_unlock_bh(&phy->rx_dbg_stats.lock);
 		goto out;
 	}
 
@@ -226,6 +234,9 @@ void mt76_rx_aggr_reorder(struct sk_buff *skb, struct sk_buff_head *frames)
 	/* Discard if the current slot is already in use */
 	if (tid->reorder_buf[idx]) {
 		dev_kfree_skb(skb);
+		spin_lock_bh(&phy->rx_dbg_stats.lock);
+		phy->rx_dbg_stats.rx_drop[MT_RX_DROP_AGG_DUP]++;
+		spin_unlock_bh(&phy->rx_dbg_stats.lock);
 		goto out;
 	}
 
diff --git a/dma.c b/dma.c
index c132e37f..a192805f 100644
--- a/dma.c
+++ b/dma.c
@@ -218,9 +218,9 @@ void __mt76_dma_queue_reset(struct mt76_dev *dev, struct mt76_queue *q,
 	mt76_dma_sync_idx(dev, q);
 }
 
-void mt76_dma_queue_reset(struct mt76_dev *dev, struct mt76_queue *q)
+void mt76_dma_queue_reset(struct mt76_dev *dev, struct mt76_queue *q, bool reset)
 {
-	__mt76_dma_queue_reset(dev, q, true);
+	__mt76_dma_queue_reset(dev, q, reset);
 }
 
 static int
@@ -250,12 +250,15 @@ mt76_dma_add_rx_buf(struct mt76_dev *dev, struct mt76_queue *q,
 
 	if (mt76_queue_is_wed_rx(q)) {
 		txwi = mt76_get_rxwi(dev);
-		if (!txwi)
+		if (!txwi) {
+			q->rx_drop[MT_RX_DROP_DMAD_GET_RXWI_FAIL]++;
 			return -ENOMEM;
+		}
 
 		rx_token = mt76_rx_token_consume(dev, data, txwi, buf->addr);
 		if (rx_token < 0) {
 			mt76_put_rxwi(dev, txwi);
+			q->rx_drop[MT_RX_DROP_DMAD_GET_TOKEN_FAIL]++;
 			return -ENOMEM;
 		}
 
@@ -426,6 +429,7 @@ mt76_dma_get_buf(struct mt76_dev *dev, struct mt76_queue *q, int idx,
 	struct mt76_desc *desc = &q->desc[idx];
 	u32 ctrl, desc_info, buf1;
 	void *buf = e->buf;
+	int reason;
 
 	if (mt76_queue_is_wed_rro_ind(q))
 		goto done;
@@ -441,14 +445,43 @@ mt76_dma_get_buf(struct mt76_dev *dev, struct mt76_queue *q, int idx,
 		*info = desc_info;
 
 	buf1 = le32_to_cpu(desc->buf1);
-	mt76_dma_should_drop_buf(drop, ctrl, buf1, desc_info);
+	reason = mt76_dma_should_drop_buf(drop, ctrl, buf1, desc_info);
+	if (drop && *drop && reason >= 0)
+		q->rx_drop[reason]++;
 
 	if (mt76_queue_is_wed_rx(q)) {
+		u32 id, find = 0;
 		u32 token = FIELD_GET(MT_DMA_CTL_TOKEN, buf1);
-		struct mt76_txwi_cache *t = mt76_rx_token_release(dev, token);
+		struct mt76_txwi_cache *t;
+
+		if (*more) {
+			spin_lock_bh(&dev->rx_token_lock);
+
+			idr_for_each_entry(&dev->rx_token, t, id) {
+				if (t->dma_addr == le32_to_cpu(desc->buf0)) {
+					find = 1;
+					token = id;
+
+					/* Write correct id back to DMA*/
+					u32p_replace_bits(&buf1, id,
+							  MT_DMA_CTL_TOKEN);
+					WRITE_ONCE(desc->buf1, cpu_to_le32(buf1));
+					break;
+				}
+			}
+
+			spin_unlock_bh(&dev->rx_token_lock);
+			if (!find) {
+				q->rx_drop[MT_RX_DROP_DMAD_ADDR_NOT_FOUND]++;
+				return NULL;
+			}
+		}
 
-		if (!t)
+		t = mt76_rx_token_release(dev, token);
+		if (!t) {
+			q->rx_drop[MT_RX_DROP_DMAD_TOKEN_NOT_FOUND]++;
 			return NULL;
+		}
 
 		dma_sync_single_for_cpu(dev->dma_dev, t->dma_addr,
 				SKB_WITH_OVERHEAD(q->buf_size),
@@ -458,9 +491,11 @@ mt76_dma_get_buf(struct mt76_dev *dev, struct mt76_queue *q, int idx,
 		t->dma_addr = 0;
 		t->ptr = NULL;
 
-		mt76_put_rxwi(dev, t);
-		if (drop)
+		if (drop) {
 			*drop |= !!(buf1 & MT_DMA_CTL_WO_DROP);
+			if (buf1 & MT_DMA_CTL_WO_DROP)
+				q->rx_drop[MT_RX_DROP_DMAD_WO_FRAG]++;
+		}
 	} else {
 		dma_sync_single_for_cpu(dev->dma_dev, e->dma_addr[0],
 				SKB_WITH_OVERHEAD(q->buf_size),
@@ -482,7 +517,8 @@ mt76_dma_dequeue(struct mt76_dev *dev, struct mt76_queue *q, bool flush,
 	if (!q->queued)
 		return NULL;
 
-	if (mt76_queue_is_wed_rro_data(q))
+	if (mt76_queue_is_wed_rro_data(q) ||
+	    mt76_queue_is_wed_rro_msdu_pg(q))
 		return NULL;
 
 	if (!mt76_queue_is_wed_rro_ind(q)) {
@@ -504,9 +540,12 @@ mt76_dma_tx_queue_skb_raw(struct mt76_dev *dev, struct mt76_queue *q,
 {
 	struct mt76_queue_buf buf = {};
 	dma_addr_t addr;
+	int ret = -ENOMEM;
 
-	if (test_bit(MT76_MCU_RESET, &dev->phy.state))
+	if (test_bit(MT76_MCU_RESET, &dev->phy.state)) {
+		ret = -EAGAIN;
 		goto error;
+	}
 
 	if (q->queued + 1 >= q->ndesc - 1)
 		goto error;
@@ -528,7 +567,7 @@ mt76_dma_tx_queue_skb_raw(struct mt76_dev *dev, struct mt76_queue *q,
 
 error:
 	dev_kfree_skb(skb);
-	return -ENOMEM;
+	return ret;
 }
 
 static int
@@ -550,12 +589,16 @@ mt76_dma_tx_queue_skb(struct mt76_phy *phy, struct mt76_queue *q,
 	dma_addr_t addr;
 	u8 *txwi;
 
-	if (test_bit(MT76_RESET, &phy->state))
+	if (test_bit(MT76_RESET, &phy->state)) {
+		phy->tx_dbg_stats.tx_drop[MT_TX_DROP_RESET_STATE]++;
 		goto free_skb;
+	}
 
 	t = mt76_get_txwi(dev);
-	if (!t)
+	if (!t) {
+		dev->tx_dbg_stats.tx_drop[MT_TX_DROP_GET_TXWI_FAIL]++;
 		goto free_skb;
+	}
 
 	txwi = mt76_get_txwi_ptr(dev, t);
 
@@ -565,8 +608,10 @@ mt76_dma_tx_queue_skb(struct mt76_phy *phy, struct mt76_queue *q,
 
 	len = skb_headlen(skb);
 	addr = dma_map_single(dev->dma_dev, skb->data, len, DMA_TO_DEVICE);
-	if (unlikely(dma_mapping_error(dev->dma_dev, addr)))
+	if (unlikely(dma_mapping_error(dev->dma_dev, addr))) {
+		dev->tx_dbg_stats.tx_drop[MT_TX_DROP_DMA_FAIL]++;
 		goto free;
+	}
 
 	tx_info.buf[n].addr = t->dma_addr;
 	tx_info.buf[n++].len = dev->drv->txwi_size;
@@ -574,13 +619,17 @@ mt76_dma_tx_queue_skb(struct mt76_phy *phy, struct mt76_queue *q,
 	tx_info.buf[n++].len = len;
 
 	skb_walk_frags(skb, iter) {
-		if (n == ARRAY_SIZE(tx_info.buf))
+		if (n == ARRAY_SIZE(tx_info.buf)) {
+			dev->tx_dbg_stats.tx_drop[MT_TX_DROP_AGG_EXCEEDED]++;
 			goto unmap;
+		}
 
 		addr = dma_map_single(dev->dma_dev, iter->data, iter->len,
 				      DMA_TO_DEVICE);
-		if (unlikely(dma_mapping_error(dev->dma_dev, addr)))
+		if (unlikely(dma_mapping_error(dev->dma_dev, addr))) {
+			dev->tx_dbg_stats.tx_drop[MT_TX_DROP_DMA_FAIL]++;
 			goto unmap;
+		}
 
 		tx_info.buf[n].addr = addr;
 		tx_info.buf[n++].len = iter->len;
@@ -589,6 +638,7 @@ mt76_dma_tx_queue_skb(struct mt76_phy *phy, struct mt76_queue *q,
 
 	if (q->queued + (tx_info.nbuf + 1) / 2 >= q->ndesc - 1) {
 		ret = -ENOMEM;
+		phy->tx_dbg_stats.tx_drop[MT_TX_DROP_RING_FULL]++;
 		goto unmap;
 	}
 
@@ -600,6 +650,7 @@ mt76_dma_tx_queue_skb(struct mt76_phy *phy, struct mt76_queue *q,
 	if (ret < 0)
 		goto unmap;
 
+	phy->tx_dbg_stats.tx_to_hw++;
 	return mt76_dma_add_buf(dev, q, tx_info.buf, tx_info.nbuf,
 				tx_info.info, tx_info.skb, t);
 
@@ -631,9 +682,8 @@ free_skb:
 	return ret;
 }
 
-static int
-mt76_dma_rx_fill_buf(struct mt76_dev *dev, struct mt76_queue *q,
-		     bool allow_direct)
+int mt76_dma_rx_fill_buf(struct mt76_dev *dev, struct mt76_queue *q,
+			 bool allow_direct)
 {
 	int len = SKB_WITH_OVERHEAD(q->buf_size);
 	int frames = 0;
@@ -740,7 +790,7 @@ mt76_dma_alloc_queue(struct mt76_dev *dev, struct mt76_queue *q,
 			return 0;
 	}
 
-	mt76_dma_queue_reset(dev, q);
+	mt76_dma_queue_reset(dev, q, true);
 
 	return 0;
 }
@@ -821,16 +871,19 @@ mt76_add_fragment(struct mt76_dev *dev, struct mt76_queue *q, void *data,
 		skb_add_rx_frag(skb, nr_frags, page, offset, len, q->buf_size);
 	} else {
 		mt76_put_page_pool_buf(data, allow_direct);
+		q->rx_drop[MT_RX_DROP_FRAG]++;
 	}
 
 	if (more)
 		return;
 
 	q->rx_head = NULL;
-	if (nr_frags < ARRAY_SIZE(shinfo->frags))
+	if (nr_frags < ARRAY_SIZE(shinfo->frags)) {
 		dev->drv->rx_skb(dev, q - dev->q_rx, skb, &info);
-	else
+	} else {
+		q->rx_drop[MT_RX_DROP_FRAG]++;
 		dev_kfree_skb(skb);
+	}
 }
 
 static int
@@ -866,7 +919,7 @@ mt76_dma_rx_process(struct mt76_dev *dev, struct mt76_queue *q, int budget)
 		if (!data)
 			break;
 
-		if (drop)
+		if (drop || (len == 0))
 			goto free_frag;
 
 		if (q->rx_head)
@@ -875,6 +928,7 @@ mt76_dma_rx_process(struct mt76_dev *dev, struct mt76_queue *q, int budget)
 			data_len = SKB_WITH_OVERHEAD(q->buf_size);
 
 		if (data_len < len + q->buf_offset) {
+			q->rx_drop[MT_RX_DROP_FRAG]++;
 			dev_kfree_skb(q->rx_head);
 			q->rx_head = NULL;
 			goto free_frag;
@@ -891,8 +945,10 @@ mt76_dma_rx_process(struct mt76_dev *dev, struct mt76_queue *q, int budget)
 			goto free_frag;
 
 		skb = napi_build_skb(data, q->buf_size);
-		if (!skb)
+		if (!skb) {
+			q->rx_drop[MT_RX_DROP_BUILD_SKB_FAIL]++;
 			goto free_frag;
+		}
 
 		skb_reserve(skb, q->buf_offset);
 		skb_mark_for_recycle(skb);
diff --git a/dma.h b/dma.h
index 1de5a2b2..e8d13903 100644
--- a/dma.h
+++ b/dma.h
@@ -81,39 +81,43 @@ void mt76_dma_attach(struct mt76_dev *dev);
 void mt76_dma_cleanup(struct mt76_dev *dev);
 int mt76_dma_rx_fill(struct mt76_dev *dev, struct mt76_queue *q,
 		     bool allow_direct);
+int mt76_dma_rx_fill_buf(struct mt76_dev *dev, struct mt76_queue *q,
+			 bool allow_direct);
 void __mt76_dma_queue_reset(struct mt76_dev *dev, struct mt76_queue *q,
 			    bool reset_idx);
-void mt76_dma_queue_reset(struct mt76_dev *dev, struct mt76_queue *q);
+void mt76_dma_queue_reset(struct mt76_dev *dev, struct mt76_queue *q, bool reset);
 
 static inline void
 mt76_dma_reset_tx_queue(struct mt76_dev *dev, struct mt76_queue *q)
 {
-	dev->queue_ops->reset_q(dev, q);
+	dev->queue_ops->reset_q(dev, q, true);
 	if (mtk_wed_device_active(&dev->mmio.wed))
 		mt76_wed_dma_setup(dev, q, true);
 }
 
-static inline void
+static inline int
 mt76_dma_should_drop_buf(bool *drop, u32 ctrl, u32 buf1, u32 info)
 {
 	if (!drop)
-		return;
+		return -1;
 
 	*drop = !!(ctrl & (MT_DMA_CTL_TO_HOST_A | MT_DMA_CTL_DROP));
 	if (!(ctrl & MT_DMA_CTL_VER_MASK))
-		return;
+		return MT_RX_DROP_DMAD_WO_DROP;
 
 	switch (FIELD_GET(MT_DMA_WED_IND_REASON, buf1)) {
 	case MT_DMA_WED_IND_REASON_REPEAT:
 		*drop = true;
-		break;
+		return MT_RX_DROP_DMAD_RRO_REPEAT;
 	case MT_DMA_WED_IND_REASON_OLDPKT:
 		*drop = !(info & MT_DMA_INFO_DMA_FRAG);
-		break;
+		return MT_RX_DROP_DMAD_RRO_OLDPKT;
 	default:
 		*drop = !!(ctrl & MT_DMA_CTL_PN_CHK_FAIL);
-		break;
+		return MT_RX_DROP_DMAD_RRO_PN_CHK_FAIL;
 	}
+
+	return -1;
 }
 
 #endif
diff --git a/eeprom.c b/eeprom.c
index 30b744a1..5501b2ff 100644
--- a/eeprom.c
+++ b/eeprom.c
@@ -94,12 +94,10 @@ int mt76_get_of_data_from_mtd(struct mt76_dev *dev, void *eep, int offset, int l
 	}
 
 #ifdef CONFIG_NL80211_TESTMODE
-	dev->test_mtd.name = devm_kstrdup(dev->dev, part, GFP_KERNEL);
-	if (!dev->test_mtd.name) {
-		ret = -ENOMEM;
-		goto out_put_node;
+	if (len == dev->eeprom.size) {
+		dev->test_mtd.name = devm_kstrdup(dev->dev, part, GFP_KERNEL);
+		dev->test_mtd.offset = offset;
 	}
-	dev->test_mtd.offset = offset;
 #endif
 
 out_put_node:
@@ -163,6 +161,29 @@ static int mt76_get_of_eeprom(struct mt76_dev *dev, void *eep, int len)
 	return mt76_get_of_data_from_nvmem(dev, eep, "eeprom", len);
 }
 
+bool mt76_check_bin_file_mode(struct mt76_dev *dev)
+{
+	struct device_node *np = dev->dev->of_node;
+	const char *bin_file_name = NULL;
+
+	if (!np)
+		return false;
+
+	of_property_read_string(np, "bin_file_name", &bin_file_name);
+
+	dev->bin_file_name = bin_file_name;
+	if (dev->bin_file_name) {
+		dev_info(dev->dev, "Using bin file %s\n", dev->bin_file_name);
+#ifdef CONFIG_NL80211_TESTMODE
+		dev->test_mtd.name = devm_kstrdup(dev->dev, bin_file_name, GFP_KERNEL);
+		dev->test_mtd.offset = -1;
+#endif
+	}
+
+	return dev->bin_file_name ? true : false;
+}
+EXPORT_SYMBOL_GPL(mt76_check_bin_file_mode);
+
 void
 mt76_eeprom_override(struct mt76_phy *phy)
 {
@@ -322,9 +343,10 @@ mt76_apply_array_limit(s8 *pwr, size_t pwr_len, const __be32 *data,
 static void
 mt76_apply_multi_array_limit(s8 *pwr, size_t pwr_len, s8 pwr_num,
 			     const __be32 *data, size_t len, s8 target_power,
-			     s8 nss_delta, s8 *max_power)
+			     s8 nss_delta)
 {
 	int i, cur;
+	s8 max_power = -128;
 
 	if (!data)
 		return;
@@ -336,7 +358,7 @@ mt76_apply_multi_array_limit(s8 *pwr, size_t pwr_len, s8 pwr_num,
 			break;
 
 		mt76_apply_array_limit(pwr + pwr_len * i, pwr_len, data + 1,
-				       target_power, nss_delta, max_power);
+				       target_power, nss_delta, &max_power);
 		if (--cur > 0)
 			continue;
 
@@ -352,23 +374,23 @@ mt76_apply_multi_array_limit(s8 *pwr, size_t pwr_len, s8 pwr_num,
 s8 mt76_get_rate_power_limits(struct mt76_phy *phy,
 			      struct ieee80211_channel *chan,
 			      struct mt76_power_limits *dest,
+			      struct mt76_power_path_limits *dest_path,
 			      s8 target_power)
 {
-	struct mt76_dev *dev = phy->dev;
 	struct device_node *np;
 	const __be32 *val;
 	char name[16];
-	u32 mcs_rates = dev->drv->mcs_rates;
-	u32 ru_rates = ARRAY_SIZE(dest->ru[0]);
 	char band;
 	size_t len;
-	s8 max_power = 0;
+	s8 max_power = -127;
+	s8 max_power_backoff = -127;
 	s8 txs_delta;
-
-	if (!mcs_rates)
-		mcs_rates = 10;
+	int n_chains = hweight16(phy->chainmask);
+	s8 target_power_combine = target_power + mt76_tx_power_path_delta(n_chains);
 
 	memset(dest, target_power, sizeof(*dest));
+	if (dest_path != NULL)
+		memset(dest_path, 0, sizeof(*dest_path));
 
 	if (!IS_ENABLED(CONFIG_OF))
 		return target_power;
@@ -411,15 +433,47 @@ s8 mt76_get_rate_power_limits(struct mt76_phy *phy,
 	mt76_apply_array_limit(dest->ofdm, ARRAY_SIZE(dest->ofdm), val,
 			       target_power, txs_delta, &max_power);
 
-	val = mt76_get_of_array(np, "rates-mcs", &len, mcs_rates + 1);
+	val = mt76_get_of_array(np, "rates-mcs", &len, ARRAY_SIZE(dest->mcs[0]) + 1);
 	mt76_apply_multi_array_limit(dest->mcs[0], ARRAY_SIZE(dest->mcs[0]),
 				     ARRAY_SIZE(dest->mcs), val, len,
-				     target_power, txs_delta, &max_power);
+				     target_power, txs_delta);
 
-	val = mt76_get_of_array(np, "rates-ru", &len, ru_rates + 1);
+	val = mt76_get_of_array(np, "rates-ru", &len, ARRAY_SIZE(dest->ru[0]) + 1);
 	mt76_apply_multi_array_limit(dest->ru[0], ARRAY_SIZE(dest->ru[0]),
 				     ARRAY_SIZE(dest->ru), val, len,
-				     target_power, txs_delta, &max_power);
+				     target_power, txs_delta);
+
+	val = mt76_get_of_array(np, "rates-eht", &len, ARRAY_SIZE(dest->eht[0]) + 1);
+	mt76_apply_multi_array_limit(dest->eht[0], ARRAY_SIZE(dest->eht[0]),
+				     ARRAY_SIZE(dest->eht), val, len,
+				     target_power, txs_delta);
+
+	if (dest_path == NULL)
+		return max_power;
+
+	max_power_backoff = max_power;
+
+	val = mt76_get_of_array(np, "paths-cck", &len, ARRAY_SIZE(dest_path->cck));
+	mt76_apply_array_limit(dest_path->cck, ARRAY_SIZE(dest_path->cck), val,
+			       target_power_combine, txs_delta, &max_power_backoff);
+
+	val = mt76_get_of_array(np, "paths-ofdm", &len, ARRAY_SIZE(dest_path->ofdm));
+	mt76_apply_array_limit(dest_path->ofdm, ARRAY_SIZE(dest_path->ofdm), val,
+			       target_power_combine, txs_delta, &max_power_backoff);
+
+	val = mt76_get_of_array(np, "paths-ofdm-bf", &len, ARRAY_SIZE(dest_path->ofdm_bf));
+	mt76_apply_array_limit(dest_path->ofdm_bf, ARRAY_SIZE(dest_path->ofdm_bf), val,
+			       target_power_combine, txs_delta, &max_power_backoff);
+
+	val = mt76_get_of_array(np, "paths-ru", &len, ARRAY_SIZE(dest_path->ru[0]) + 1);
+	mt76_apply_multi_array_limit(dest_path->ru[0], ARRAY_SIZE(dest_path->ru[0]),
+				     ARRAY_SIZE(dest_path->ru), val, len,
+				     target_power_combine, txs_delta);
+
+	val = mt76_get_of_array(np, "paths-ru-bf", &len, ARRAY_SIZE(dest_path->ru_bf[0]) + 1);
+	mt76_apply_multi_array_limit(dest_path->ru_bf[0], ARRAY_SIZE(dest_path->ru_bf[0]),
+				     ARRAY_SIZE(dest_path->ru_bf), val, len,
+				     target_power_combine, txs_delta);
 
 	return max_power;
 }
diff --git a/mac80211.c b/mac80211.c
index 8f02a806..8cdbfe21 100644
--- a/mac80211.c
+++ b/mac80211.c
@@ -5,27 +5,7 @@
 #include <linux/sched.h>
 #include <linux/of.h>
 #include "mt76.h"
-
-#define CHAN2G(_idx, _freq) {			\
-	.band = NL80211_BAND_2GHZ,		\
-	.center_freq = (_freq),			\
-	.hw_value = (_idx),			\
-	.max_power = 30,			\
-}
-
-#define CHAN5G(_idx, _freq) {			\
-	.band = NL80211_BAND_5GHZ,		\
-	.center_freq = (_freq),			\
-	.hw_value = (_idx),			\
-	.max_power = 30,			\
-}
-
-#define CHAN6G(_idx, _freq) {			\
-	.band = NL80211_BAND_6GHZ,		\
-	.center_freq = (_freq),			\
-	.hw_value = (_idx),			\
-	.max_power = 30,			\
-}
+#include "trace.h"
 
 static const struct ieee80211_channel mt76_channels_2ghz[] = {
 	CHAN2G(1, 2412),
@@ -55,6 +35,15 @@ static const struct ieee80211_channel mt76_channels_5ghz[] = {
 	CHAN5G(60, 5300),
 	CHAN5G(64, 5320),
 
+	CHAN5G(68, 5340),
+	CHAN5G(72, 5360),
+	CHAN5G(76, 5380),
+	CHAN5G(80, 5400),
+	CHAN5G(84, 5420),
+	CHAN5G(88, 5440),
+	CHAN5G(92, 5460),
+	CHAN5G(96, 5480),
+
 	CHAN5G(100, 5500),
 	CHAN5G(104, 5520),
 	CHAN5G(108, 5540),
@@ -432,6 +421,8 @@ mt76_phy_init(struct mt76_phy *phy, struct ieee80211_hw *hw)
 	INIT_LIST_HEAD(&phy->tx_list);
 	spin_lock_init(&phy->tx_lock);
 	INIT_DELAYED_WORK(&phy->roc_work, mt76_roc_complete_work);
+	spin_lock_init(&phy->tx_dbg_stats.lock);
+	spin_lock_init(&phy->rx_dbg_stats.lock);
 
 	if ((void *)phy != hw->priv)
 		return 0;
@@ -683,6 +674,7 @@ mt76_alloc_device(struct device *pdev, unsigned int size,
 	spin_lock_init(&dev->cc_lock);
 	spin_lock_init(&dev->status_lock);
 	spin_lock_init(&dev->wed_lock);
+	spin_lock_init(&dev->tx_dbg_stats.lock);
 	mutex_init(&dev->mutex);
 	init_waitqueue_head(&dev->tx_wait);
 
@@ -893,6 +885,9 @@ static void mt76_rx_release_amsdu(struct mt76_phy *phy, enum mt76_rxq_id q)
 		}
 
 		if (ether_addr_equal(skb->data + offset, rfc1042_header)) {
+			spin_lock_bh(&phy->rx_dbg_stats.lock);
+			phy->rx_dbg_stats.rx_drop[MT_RX_DROP_RFC_PKT]++;
+			spin_unlock_bh(&phy->rx_dbg_stats.lock);
 			dev_kfree_skb(skb);
 			return;
 		}
@@ -930,11 +925,15 @@ void mt76_rx(struct mt76_dev *dev, enum mt76_rxq_id q, struct sk_buff *skb)
 
 	if (!test_bit(MT76_STATE_RUNNING, &phy->state)) {
 		dev_kfree_skb(skb);
+		spin_lock_bh(&phy->rx_dbg_stats.lock);
+		phy->rx_dbg_stats.rx_drop[MT_RX_DROP_STATE_ERR]++;
+		spin_unlock_bh(&phy->rx_dbg_stats.lock);
 		return;
 	}
 
 #ifdef CONFIG_NL80211_TESTMODE
-	if (phy->test.state == MT76_TM_STATE_RX_FRAMES) {
+	if (!(phy->test.flag & MT_TM_FW_RX_COUNT) &&
+	    phy->test.state == MT76_TM_STATE_RX_FRAMES) {
 		phy->test.rx_stats.packets[q]++;
 		if (status->flag & RX_FLAG_FAILED_FCS_CRC)
 			phy->test.rx_stats.fcs_error[q]++;
@@ -1015,6 +1014,7 @@ int __mt76_set_channel(struct mt76_phy *phy, struct cfg80211_chan_def *chandef,
 	struct mt76_dev *dev = phy->dev;
 	int timeout = HZ / 5;
 	int ret;
+	unsigned long was_scanning = ieee80211_get_scanning(phy->hw);
 
 	set_bit(MT76_RESET, &phy->state);
 
@@ -1033,7 +1033,7 @@ int __mt76_set_channel(struct mt76_phy *phy, struct cfg80211_chan_def *chandef,
 	if (!offchannel)
 		phy->main_chandef = *chandef;
 
-	if (chandef->chan != phy->main_chandef.chan)
+	if (chandef->chan != phy->main_chandef.chan || was_scanning)
 		memset(phy->chan_state, 0, sizeof(*phy->chan_state));
 
 	ret = dev->drv->set_channel(phy);
@@ -1222,6 +1222,7 @@ mt76_rx_convert(struct mt76_dev *dev, struct sk_buff *skb,
 {
 	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
 	struct ieee80211_hdr *hdr = mt76_skb_get_hdr(skb);
+	struct mt76_phy *phy;
 	struct mt76_rx_status mstat;
 
 	mstat = *((struct mt76_rx_status *)skb->cb);
@@ -1269,6 +1270,11 @@ mt76_rx_convert(struct mt76_dev *dev, struct sk_buff *skb,
 
 	*sta = wcid_to_sta(mstat.wcid);
 	*hw = mt76_phy_hw(dev, mstat.phy_idx);
+
+	phy = mt76_dev_phy(dev, mstat.phy_idx);
+	spin_lock_bh(&phy->rx_dbg_stats.lock);
+	phy->rx_dbg_stats.rx_to_mac80211++;
+	spin_unlock_bh(&phy->rx_dbg_stats.lock);
 }
 
 static void
@@ -1502,6 +1508,7 @@ void mt76_rx_complete(struct mt76_dev *dev, struct sk_buff_head *frames,
 
 		mt76_check_ccmp_pn(skb);
 		skb_shinfo(skb)->frag_list = NULL;
+		trace_mt76_rx_complete(dev, (struct mt76_rx_status *)skb->cb, 0);
 		mt76_rx_convert(dev, skb, &hw, &sta);
 		ieee80211_rx_list(hw, sta, skb, &list);
 
@@ -1511,6 +1518,7 @@ void mt76_rx_complete(struct mt76_dev *dev, struct sk_buff_head *frames,
 			nskb = nskb->next;
 			skb->next = NULL;
 
+			trace_mt76_rx_complete(dev, (struct mt76_rx_status *)skb->cb, 1);
 			mt76_rx_convert(dev, skb, &hw, &sta);
 			ieee80211_rx_list(hw, sta, skb, &list);
 		}
@@ -1563,6 +1571,9 @@ mt76_sta_add(struct mt76_phy *phy, struct ieee80211_vif *vif,
 	if (ret)
 		goto out;
 
+	if (phy->hw->wiphy->flags & WIPHY_FLAG_SUPPORTS_MLO)
+		goto out;
+
 	for (i = 0; i < ARRAY_SIZE(sta->txq); i++) {
 		struct mt76_txq *mtxq;
 
@@ -1591,12 +1602,15 @@ void __mt76_sta_remove(struct mt76_phy *phy, struct ieee80211_vif *vif,
 	struct mt76_wcid *wcid = (struct mt76_wcid *)sta->drv_priv;
 	int i, idx = wcid->idx;
 
-	for (i = 0; i < ARRAY_SIZE(wcid->aggr); i++)
+	for (i = 0; !sta->valid_links && i < ARRAY_SIZE(wcid->aggr); i++)
 		mt76_rx_aggr_stop(dev, wcid, i);
 
 	if (dev->drv->sta_remove)
 		dev->drv->sta_remove(dev, vif, sta);
 
+	if (sta->valid_links)
+		return;
+
 	mt76_wcid_cleanup(dev, wcid);
 
 	mt76_wcid_mask_clear(dev->wcid_mask, idx);
@@ -1747,14 +1761,10 @@ EXPORT_SYMBOL_GPL(mt76_get_power_bound);
 int mt76_get_txpower(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		     unsigned int link_id, int *dbm)
 {
-	struct mt76_phy *phy = mt76_vif_phy(hw, vif);
-	int n_chains, delta;
-
-	if (!phy)
-		return -EINVAL;
+	struct mt76_phy *phy = hw->priv;
+	int n_chains = hweight16(phy->chainmask);
+	int delta = mt76_tx_power_path_delta(n_chains);
 
-	n_chains = hweight16(phy->chainmask);
-	delta = mt76_tx_power_path_delta(n_chains);
 	*dbm = DIV_ROUND_UP(phy->txpower_cur + delta, 2);
 
 	return 0;
@@ -1925,7 +1935,8 @@ void mt76_sw_scan_complete(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 }
 EXPORT_SYMBOL_GPL(mt76_sw_scan_complete);
 
-int mt76_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant)
+int mt76_get_antenna(struct ieee80211_hw *hw, int radio_idx,
+		     u32 *tx_ant, u32 *rx_ant)
 {
 	struct mt76_phy *phy = hw->priv;
 	struct mt76_dev *dev = phy->dev;
@@ -2026,7 +2037,7 @@ enum mt76_dfs_state mt76_phy_dfs_state(struct mt76_phy *phy)
 		return MT_DFS_STATE_DISABLED;
 
 	if (!phy->radar_enabled) {
-		if ((hw->conf.flags & IEEE80211_CONF_MONITOR) &&
+		if (((hw->conf.flags & IEEE80211_CONF_MONITOR) || phy->monitor_vif) &&
 		    (phy->chandef.chan->flags & IEEE80211_CHAN_RADAR))
 			return MT_DFS_STATE_ACTIVE;
 
diff --git a/mcu.c b/mcu.c
index 65d4c2ad..05361e00 100644
--- a/mcu.c
+++ b/mcu.c
@@ -4,6 +4,7 @@
  */
 
 #include "mt76.h"
+#include "mt76_connac.h"
 
 struct sk_buff *
 __mt76_mcu_msg_alloc(struct mt76_dev *dev, const void *data,
@@ -74,7 +75,7 @@ int mt76_mcu_skb_send_and_get_msg(struct mt76_dev *dev, struct sk_buff *skb,
 				  struct sk_buff **ret_skb)
 {
 	unsigned int retry = 0;
-	struct sk_buff *orig_skb = NULL;
+	struct sk_buff *skb_tmp;
 	unsigned long expires;
 	int ret, seq;
 
@@ -87,48 +88,49 @@ int mt76_mcu_skb_send_and_get_msg(struct mt76_dev *dev, struct sk_buff *skb,
 
 	mutex_lock(&dev->mcu.mutex);
 
-	if (dev->mcu_ops->mcu_skb_prepare_msg) {
-		orig_skb = skb;
-		ret = dev->mcu_ops->mcu_skb_prepare_msg(dev, skb, cmd, &seq);
-		if (ret < 0)
+	while (retry < dev->mcu_ops->max_retry) {
+		skb_tmp = mt76_mcu_msg_alloc(dev, skb->data, skb->len);
+		if (!skb_tmp)
 			goto out;
-	}
-
-retry:
-	/* orig skb might be needed for retry, mcu_skb_send_msg consumes it */
-	if (orig_skb)
-		skb_get(orig_skb);
-	ret = dev->mcu_ops->mcu_skb_send_msg(dev, skb, cmd, &seq);
-	if (ret < 0)
-		goto out;
-
-	if (!wait_resp) {
-		ret = 0;
-		goto out;
-	}
-
-	expires = jiffies + dev->mcu.timeout;
 
-	do {
-		skb = mt76_mcu_get_response(dev, expires);
-		if (!skb && !test_bit(MT76_MCU_RESET, &dev->phy.state) &&
-		    orig_skb && retry++ < dev->mcu_ops->max_retry) {
+		if (wait_resp && retry) {
+			if (test_bit(MT76_MCU_RESET, &dev->phy.state))
+				usleep_range(200000, 500000);
 			dev_err(dev->dev, "Retry message %08x (seq %d)\n",
 				cmd, seq);
-			skb = orig_skb;
-			goto retry;
 		}
 
-		ret = dev->mcu_ops->mcu_parse_response(dev, cmd, skb, seq);
-		if (!ret && ret_skb)
-			*ret_skb = skb;
-		else
-			dev_kfree_skb(skb);
-	} while (ret == -EAGAIN);
+		ret = dev->mcu_ops->mcu_skb_send_msg(dev, skb_tmp, cmd, &seq);
+		if (ret < 0 && ret != -EAGAIN)
+			goto out;
 
+		if (!wait_resp) {
+			ret = 0;
+			goto out;
+		}
+
+		expires = jiffies + dev->mcu.timeout;
+
+		do {
+			skb_tmp = mt76_mcu_get_response(dev, expires);
+			ret = dev->mcu_ops->mcu_parse_response(dev, cmd, skb_tmp, seq);
+			if (ret == -ETIMEDOUT)
+				break;
+
+			if (!ret && ret_skb)
+				*ret_skb = skb_tmp;
+			else
+				dev_kfree_skb(skb_tmp);
+
+			if (ret != -EAGAIN)
+				goto out;
+		} while (ret == -EAGAIN);
+
+		retry++;
+	}
 
 out:
-	dev_kfree_skb(orig_skb);
+	dev_kfree_skb(skb);
 	mutex_unlock(&dev->mcu.mutex);
 
 	return ret;
diff --git a/mt76.h b/mt76.h
index f6cfdf0f..6a4a9030 100644
--- a/mt76.h
+++ b/mt76.h
@@ -24,6 +24,27 @@
 #include "util.h"
 #include "testmode.h"
 
+#define CHAN2G(_idx, _freq) {			\
+	.band = NL80211_BAND_2GHZ,		\
+	.center_freq = (_freq),			\
+	.hw_value = (_idx),			\
+	.max_power = 30,			\
+}
+
+#define CHAN5G(_idx, _freq) {			\
+	.band = NL80211_BAND_5GHZ,		\
+	.center_freq = (_freq),			\
+	.hw_value = (_idx),			\
+	.max_power = 30,			\
+}
+
+#define CHAN6G(_idx, _freq) {			\
+	.band = NL80211_BAND_6GHZ,		\
+	.center_freq = (_freq),			\
+	.hw_value = (_idx),			\
+	.max_power = 30,			\
+}
+
 #define MT_MCU_RING_SIZE	32
 #define MT_RX_BUF_SIZE		2048
 #define MT_SKB_HEAD_LEN		256
@@ -33,6 +54,8 @@
 
 #define MT76_TOKEN_FREE_THR	64
 
+#define MT76_WED_SW_TOKEN_SIZE	15360
+
 #define MT_QFLAG_WED_RING	GENMASK(1, 0)
 #define MT_QFLAG_WED_TYPE	GENMASK(4, 2)
 #define MT_QFLAG_WED		BIT(5)
@@ -177,6 +200,34 @@ struct mt76_scan_rnr_param {
 	u32 sreq_flag;
 };
 
+enum {
+	/* Per dev counters*/
+	MT_RX_DROP_DMAD_RRO_REPEAT,
+	MT_RX_DROP_DMAD_RRO_OLDPKT,
+	MT_RX_DROP_DMAD_RRO_PN_CHK_FAIL,
+	MT_RX_DROP_DMAD_WO_FRAG,
+	MT_RX_DROP_DMAD_WO_DROP,
+	MT_RX_DROP_DMAD_ADDR_NOT_FOUND,
+	MT_RX_DROP_DMAD_TOKEN_NOT_FOUND,
+	MT_RX_DROP_DMAD_GET_TOKEN_FAIL,
+	MT_RX_DROP_DMAD_GET_RXWI_FAIL,
+	MT_RX_DROP_DMAD_NOMEM,
+	MT_RX_DROP_DMAD_DMA_MAPPING_FAIL,
+	MT_RX_DROP_FRAG,
+	MT_RX_DROP_BUILD_SKB_FAIL,
+
+	MT_RX_DROP_PER_Q_MAX,
+
+	/* Per phy counters */
+	MT_RX_DROP_RXD_ERR = 0,
+	MT_RX_DROP_STATE_ERR,
+	MT_RX_DROP_RFC_PKT,
+	MT_RX_DROP_AGG_SN_LESS,
+	MT_RX_DROP_AGG_DUP,
+
+	MT_RX_DROP_PER_PHY_MAX,
+};
+
 struct mt76_queue_buf {
 	dma_addr_t addr;
 	u16 len:15,
@@ -244,6 +295,7 @@ struct mt76_queue {
 	dma_addr_t desc_dma;
 	struct sk_buff *rx_head;
 	struct page_pool *page_pool;
+	u32 rx_drop[MT_RX_DROP_PER_Q_MAX];
 };
 
 struct mt76_mcu_ops {
@@ -295,7 +347,7 @@ struct mt76_queue_ops {
 
 	void (*kick)(struct mt76_dev *dev, struct mt76_queue *q);
 
-	void (*reset_q)(struct mt76_dev *dev, struct mt76_queue *q);
+	void (*reset_q)(struct mt76_dev *dev, struct mt76_queue *q, bool reset);
 };
 
 enum mt76_phy_type {
@@ -320,15 +372,21 @@ struct mt76_sta_stats {
 	u64 tx_nss[4];		/* 1, 2, 3, 4 */
 	u64 tx_mcs[16];		/* mcs idx */
 	u64 tx_bytes;
+	u64 tx_bytes_per_ac[IEEE80211_NUM_ACS];
+	u64 tx_bytes_failed;
+	u64 tx_bytes_failed_per_ac[IEEE80211_NUM_ACS];
 	/* WED TX */
 	u32 tx_packets;		/* unit: MSDU */
 	u32 tx_retries;
 	u32 tx_failed;
+	u64 tx_airtime;
 	/* WED RX */
 	u64 rx_bytes;
+	u64 rx_bytes_per_ac[IEEE80211_NUM_ACS];
 	u32 rx_packets;
 	u32 rx_errors;
 	u32 rx_drops;
+	u64 rx_airtime;
 };
 
 enum mt76_wcid_flags {
@@ -422,6 +480,11 @@ struct mt76_txwi_cache {
 		struct sk_buff *skb;
 		void *ptr;
 	};
+
+	unsigned long jiffies;
+
+	u8 qid;
+	u16 wcid;
 };
 
 struct mt76_rx_tid {
@@ -438,6 +501,7 @@ struct mt76_rx_tid {
 	u16 nframes;
 
 	u8 num;
+	u16 session_id;
 
 	u8 started:1, stopped:1, timer_pending:1;
 
@@ -514,7 +578,6 @@ struct mt76_driver_ops {
 	u32 survey_flags;
 	u16 txwi_size;
 	u16 token_size;
-	u8 mcs_rates;
 
 	unsigned int link_data_size;
 
@@ -741,14 +804,22 @@ struct mt76_testmode_ops {
 	int (*set_params)(struct mt76_phy *phy, struct nlattr **tb,
 			  enum mt76_testmode_state new_state);
 	int (*dump_stats)(struct mt76_phy *phy, struct sk_buff *msg);
+	void (*reset_rx_stats)(struct mt76_phy *phy);
+	void (*tx_stop)(struct mt76_phy *phy);
+	int (*set_eeprom)(struct mt76_phy *phy, u32 offset, u8 *val, u8 action);
+	int (*dump_precal)(struct mt76_phy *mphy, struct sk_buff *msg, int flag, int type);
 };
 
+#define MT_TM_FW_RX_COUNT	BIT(0)
+
 struct mt76_testmode_data {
 	enum mt76_testmode_state state;
 
 	u32 param_set[DIV_ROUND_UP(NUM_MT76_TM_ATTRS, 32)];
 	struct sk_buff *tx_skb;
 
+	u8 sku_en;
+
 	u32 tx_count;
 	u16 tx_mpdu_len;
 
@@ -758,6 +829,7 @@ struct mt76_testmode_data {
 	u8 tx_rate_sgi;
 	u8 tx_rate_ldpc;
 	u8 tx_rate_stbc;
+	u16 tx_preamble_puncture;
 	u8 tx_ltf;
 
 	u8 tx_antenna_mask;
@@ -767,6 +839,14 @@ struct mt76_testmode_data {
 	u32 tx_time;
 	u32 tx_ipg;
 
+	u8 txbf_act;
+	u16 txbf_param[8];
+	bool is_txbf_dut;
+	bool bf_en;
+	bool bf_ever_en;
+	bool ibf;
+	bool ebf;
+
 	u32 freq_offset;
 
 	u8 tx_power[4];
@@ -781,7 +861,24 @@ struct mt76_testmode_data {
 	struct {
 		u64 packets[__MT_RXQ_MAX];
 		u64 fcs_error[__MT_RXQ_MAX];
+		u64 len_mismatch;
 	} rx_stats;
+	u8 flag;
+
+	struct {
+		u8 type;
+		u8 enable;
+	} cfg;
+
+	u8 aid;
+
+	u8 offchan_ch;
+	u8 offchan_center_ch;
+	u8 offchan_bw;
+
+	u8 ipi_threshold;
+	u32 ipi_period;
+	u8 ipi_reset;
 };
 
 struct mt76_vif_link {
@@ -809,6 +906,41 @@ struct mt76_vif_data {
 	struct mt76_phy *roc_phy;
 	u16 valid_links;
 	u8 deflink_id;
+
+	u8 band_to_link[__MT_MAX_BAND];
+};
+
+enum {
+	MT_TX_DROP_IN_TESTMODE,
+	MT_TX_DROP_WCID_NOT_INIT,
+	MT_TX_DROP_STOPPED_QUEUE,
+	MT_TX_DROP_RESET_STATE,
+	MT_TX_DROP_GET_TXWI_FAIL,
+	MT_TX_DROP_DMA_FAIL,
+	MT_TX_DROP_AGG_EXCEEDED,
+	MT_TX_DROP_RING_FULL,
+	MT_TX_DROP_INVALID_SKB,
+	MT_TX_DROP_GET_TOKEN_FAIL,
+	MT_TX_DROP_ADDR_TRANS_FAIL,
+	MT_TX_DROP_INVALID_WCID,
+	MT_TX_DROP_INVALID_LINK,
+	MT_TX_DROP_MAX,
+};
+
+struct mt76_tx_debug {
+	u32 tx_from_mac80211;
+	u32 tx_to_hw;
+
+	u32 tx_drop[MT_TX_DROP_MAX];
+	spinlock_t lock;
+};
+
+struct mt76_rx_debug {
+	u32 rx_from_hw;
+	u32 rx_to_mac80211;
+
+	u32 rx_drop[MT_RX_DROP_PER_PHY_MAX];
+	spinlock_t lock;
 };
 
 struct mt76_phy {
@@ -824,6 +956,8 @@ struct mt76_phy {
 	struct list_head tx_list;
 	struct mt76_queue *q_tx[__MT_TXQ_MAX];
 
+	struct ieee80211_vif *monitor_vif;
+
 	struct cfg80211_chan_def chandef;
 	struct cfg80211_chan_def main_chandef;
 	bool offchannel;
@@ -873,6 +1007,8 @@ struct mt76_phy {
 		bool al;
 		u8 pin;
 	} leds;
+	struct mt76_tx_debug tx_dbg_stats;
+	struct mt76_rx_debug rx_dbg_stats;
 };
 
 struct mt76_dev {
@@ -990,6 +1126,9 @@ struct mt76_dev {
 	};
 
 	atomic_t bus_hung;
+
+	const char *bin_file_name;
+	struct mt76_tx_debug tx_dbg_stats;
 };
 
 /* per-phy stats.  */
@@ -1095,6 +1234,14 @@ struct mt76_power_limits {
 	s8 eht[16][16];
 };
 
+struct mt76_power_path_limits {
+	s8 cck[5];
+	s8 ofdm[5];
+	s8 ofdm_bf[4];
+	s8 ru[16][15];
+	s8 ru_bf[16][15];
+};
+
 struct mt76_ethtool_worker_info {
 	u64 *data;
 	int idx;
@@ -1105,6 +1252,10 @@ struct mt76_ethtool_worker_info {
 
 struct mt76_chanctx {
 	struct mt76_phy *phy;
+	struct cfg80211_chan_def chandef;
+
+	bool assigned;
+	u8 nbss_assigned;
 };
 
 #define CCK_RATE(_idx, _rate) {					\
@@ -1227,7 +1378,6 @@ static inline int mt76_wed_dma_setup(struct mt76_dev *dev, struct mt76_queue *q,
 	for (i = 0; i < ARRAY_SIZE((dev)->q_rx); i++)	\
 		if ((dev)->q_rx[i].ndesc)
 
-
 #define mt76_dereference(p, dev) \
 	rcu_dereference_protected(p, lockdep_is_held(&(dev)->mutex))
 
@@ -1277,6 +1427,7 @@ void mt76_eeprom_override(struct mt76_phy *phy);
 int mt76_get_of_data_from_mtd(struct mt76_dev *dev, void *eep, int offset, int len);
 int mt76_get_of_data_from_nvmem(struct mt76_dev *dev, void *eep,
 				const char *cell_name, int len);
+bool mt76_check_bin_file_mode(struct mt76_dev *dev);
 
 struct mt76_queue *
 mt76_init_queue(struct mt76_dev *dev, int qid, int idx, int n_desc,
@@ -1346,6 +1497,22 @@ static inline int mt76_decr(int val, int size)
 
 u8 mt76_ac_to_hwq(u8 ac);
 
+static inline u8
+mt76_ac_to_tid(u8 ac)
+{
+	static const u8 ac_to_tid[] = {
+		[IEEE80211_AC_BE] = 0,
+		[IEEE80211_AC_BK] = 1,
+		[IEEE80211_AC_VI] = 4,
+		[IEEE80211_AC_VO] = 6
+	};
+
+	if (WARN_ON(ac >= IEEE80211_NUM_ACS))
+		return 0;
+
+	return ac_to_tid[ac];
+}
+
 static inline struct ieee80211_txq *
 mtxq_to_txq(struct mt76_txq *mtxq)
 {
@@ -1518,8 +1685,6 @@ void mt76_sta_pre_rcu_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 
 int mt76_get_min_avg_rssi(struct mt76_dev *dev, u8 phy_idx);
 
-s8 mt76_get_power_bound(struct mt76_phy *phy, s8 txpower);
-
 int mt76_get_txpower(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		     unsigned int link_id, int *dbm);
 int mt76_init_sar_power(struct ieee80211_hw *hw,
@@ -1531,7 +1696,8 @@ int mt76_get_sar_power(struct mt76_phy *phy,
 void mt76_csa_check(struct mt76_dev *dev);
 void mt76_csa_finish(struct mt76_dev *dev);
 
-int mt76_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant);
+int mt76_get_antenna(struct ieee80211_hw *hw, int radio_idx,
+		     u32 *tx_ant, u32 *rx_ant);
 int mt76_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta, bool set);
 void mt76_insert_ccmp_hdr(struct sk_buff *skb, u8 key_id);
 int mt76_get_rate(struct mt76_dev *dev,
@@ -1576,6 +1742,24 @@ int mt76_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *skb,
 int mt76_testmode_set_state(struct mt76_phy *phy, enum mt76_testmode_state state);
 int mt76_testmode_alloc_skb(struct mt76_phy *phy, u32 len);
 
+static inline void
+mt76_testmode_param_set(struct mt76_testmode_data *td, u16 idx)
+{
+#ifdef CONFIG_NL80211_TESTMODE
+	td->param_set[idx / 32] |= BIT(idx % 32);
+#endif
+}
+
+static inline bool
+mt76_testmode_param_present(struct mt76_testmode_data *td, u16 idx)
+{
+#ifdef CONFIG_NL80211_TESTMODE
+	return td->param_set[idx / 32] & BIT(idx % 32);
+#else
+	return false;
+#endif
+}
+
 static inline void mt76_testmode_reset(struct mt76_phy *phy, bool disable)
 {
 #ifdef CONFIG_NL80211_TESTMODE
@@ -1756,6 +1940,7 @@ mt76_find_channel_node(struct device_node *np, struct ieee80211_channel *chan);
 s8 mt76_get_rate_power_limits(struct mt76_phy *phy,
 			      struct ieee80211_channel *chan,
 			      struct mt76_power_limits *dest,
+			      struct mt76_power_path_limits *dest_path,
 			      s8 target_power);
 
 static inline bool mt76_queue_is_rx(struct mt76_dev *dev, struct mt76_queue *q)
@@ -1790,8 +1975,13 @@ static inline bool mt76_queue_is_wed_rro_ind(struct mt76_queue *q)
 static inline bool mt76_queue_is_wed_rro_data(struct mt76_queue *q)
 {
 	return mt76_queue_is_wed_rro(q) &&
-	       (FIELD_GET(MT_QFLAG_WED_TYPE, q->flags) == MT76_WED_RRO_Q_DATA ||
-		FIELD_GET(MT_QFLAG_WED_TYPE, q->flags) == MT76_WED_RRO_Q_MSDU_PG);
+	       (FIELD_GET(MT_QFLAG_WED_TYPE, q->flags) == MT76_WED_RRO_Q_DATA);
+}
+
+static inline bool mt76_queue_is_wed_rro_msdu_pg(struct mt76_queue *q)
+{
+	return mt76_queue_is_wed_rro(q) &&
+	       (FIELD_GET(MT_QFLAG_WED_TYPE, q->flags) == MT76_WED_RRO_Q_MSDU_PG);
 }
 
 static inline bool mt76_queue_is_wed_rx(struct mt76_queue *q)
@@ -1800,7 +1990,8 @@ static inline bool mt76_queue_is_wed_rx(struct mt76_queue *q)
 		return false;
 
 	return FIELD_GET(MT_QFLAG_WED_TYPE, q->flags) == MT76_WED_Q_RX ||
-	       mt76_queue_is_wed_rro_ind(q) || mt76_queue_is_wed_rro_data(q);
+	       mt76_queue_is_wed_rro_ind(q) || mt76_queue_is_wed_rro_data(q) ||
+	       mt76_queue_is_wed_rro_msdu_pg(q);
 
 }
 
@@ -1883,9 +2074,6 @@ mt76_vif_link(struct mt76_dev *dev, struct ieee80211_vif *vif, int link_id)
 	struct mt76_vif_link *mlink = (struct mt76_vif_link *)vif->drv_priv;
 	struct mt76_vif_data *mvif = mlink->mvif;
 
-	if (!link_id)
-		return mlink;
-
 	return mt76_dereference(mvif->link[link_id], dev);
 }
 
@@ -1896,7 +2084,7 @@ mt76_vif_conf_link(struct mt76_dev *dev, struct ieee80211_vif *vif,
 	struct mt76_vif_link *mlink = (struct mt76_vif_link *)vif->drv_priv;
 	struct mt76_vif_data *mvif = mlink->mvif;
 
-	if (link_conf == &vif->bss_conf || !link_conf->link_id)
+	if (link_conf == &vif->bss_conf)
 		return mlink;
 
 	return mt76_dereference(mvif->link[link_conf->link_id], dev);
diff --git a/mt76_connac3_mac.h b/mt76_connac3_mac.h
index 1013cad5..d44ce132 100644
--- a/mt76_connac3_mac.h
+++ b/mt76_connac3_mac.h
@@ -314,6 +314,7 @@ enum tx_frag_idx {
 #define MT_TXFREE_INFO_MSDU_ID		GENMASK(14, 0)
 #define MT_TXFREE_INFO_COUNT		GENMASK(27, 24)
 #define MT_TXFREE_INFO_STAT		GENMASK(29, 28)
+#define MT_TXFREE_INFO_REASON		GENMASK(4, 0)
 
 #define MT_TXS_HDR_SIZE			4 /* Unit: DW */
 #define MT_TXS_SIZE			12 /* Unit: DW */
diff --git a/mt76_connac_mac.c b/mt76_connac_mac.c
index 0db00efe..7f02182f 100644
--- a/mt76_connac_mac.c
+++ b/mt76_connac_mac.c
@@ -297,14 +297,13 @@ u16 mt76_connac2_mac_tx_rate_val(struct mt76_phy *mphy,
 				 struct ieee80211_bss_conf *conf,
 				 bool beacon, bool mcast)
 {
-	struct mt76_vif_link *mvif = mt76_vif_conf_link(mphy->dev, conf->vif, conf);
-	struct cfg80211_chan_def *chandef = mvif->ctx ?
-					    &mvif->ctx->def : &mphy->chandef;
+	struct ieee80211_vif *vif = conf->vif;
+	struct cfg80211_chan_def *chandef = &mphy->chandef;
 	u8 nss = 0, mode = 0, band = chandef->chan->band;
 	int rateidx = 0, mcast_rate;
 	int offset = 0;
 
-	if (!conf)
+	if (!vif)
 		goto legacy;
 
 	if (is_mt7921(mphy->dev)) {
diff --git a/mt76_connac_mcu.c b/mt76_connac_mcu.c
index fc3e6728..abec0fdb 100644
--- a/mt76_connac_mcu.c
+++ b/mt76_connac_mcu.c
@@ -2225,7 +2225,7 @@ mt76_connac_mcu_rate_txpower_band(struct mt76_phy *phy,
 			sar_power = mt76_get_sar_power(phy, &chan, reg_power);
 
 			mt76_get_rate_power_limits(phy, &chan, limits,
-						   sar_power);
+						   NULL, sar_power);
 
 			tx_power_tlv.last_msg = ch_list[idx] == last_ch;
 			sku_tlbv.channel = ch_list[idx];
diff --git a/mt76_connac_mcu.h b/mt76_connac_mcu.h
index 27daf419..75209e98 100644
--- a/mt76_connac_mcu.h
+++ b/mt76_connac_mcu.h
@@ -833,6 +833,7 @@ enum {
 	STA_REC_KEY_V3 = 0x27,
 	STA_REC_HDRT = 0x28,
 	STA_REC_HDR_TRANS = 0x2B,
+	STA_REC_TX_CAP = 0x2f,
 	STA_REC_MAX_NUM
 };
 
@@ -1042,6 +1043,7 @@ enum {
 	MCU_EXT_EVENT_ASSERT_DUMP = 0x23,
 	MCU_EXT_EVENT_RDD_REPORT = 0x3a,
 	MCU_EXT_EVENT_CSA_NOTIFY = 0x4f,
+	MCU_EXT_EVENT_BSS_ACQ_PKT_CNT = 0x52,
 	MCU_EXT_EVENT_WA_TX_STAT = 0x74,
 	MCU_EXT_EVENT_BCC_NOTIFY = 0x75,
 	MCU_EXT_EVENT_WF_RF_PIN_CTRL = 0x9a,
@@ -1059,10 +1061,14 @@ enum {
 	MCU_UNI_EVENT_BSS_BEACON_LOSS = 0x0c,
 	MCU_UNI_EVENT_SCAN_DONE = 0x0e,
 	MCU_UNI_EVENT_RDD_REPORT = 0x11,
+	MCU_UNI_EVENT_SR = 0x25,
 	MCU_UNI_EVENT_ROC = 0x27,
 	MCU_UNI_EVENT_TX_DONE = 0x2d,
+	MCU_UNI_EVENT_BF = 0x33,
 	MCU_UNI_EVENT_THERMAL = 0x35,
 	MCU_UNI_EVENT_NIC_CAPAB = 0x43,
+	MCU_UNI_EVENT_TESTMODE_CTRL = 0x46,
+	MCU_UNI_EVENT_CSI_REPORT = 0x4A,
 	MCU_UNI_EVENT_WED_RRO = 0x57,
 	MCU_UNI_EVENT_PER_STA_INFO = 0x6d,
 	MCU_UNI_EVENT_ALL_STA_INFO = 0x6e,
@@ -1246,6 +1252,7 @@ enum {
 	MCU_EXT_CMD_TXDPD_CAL = 0x60,
 	MCU_EXT_CMD_CAL_CACHE = 0x67,
 	MCU_EXT_CMD_RED_ENABLE = 0x68,
+	MCU_EXT_CMD_PKT_BUDGET_CTRL = 0x6c,
 	MCU_EXT_CMD_CP_SUPPORT = 0x75,
 	MCU_EXT_CMD_SET_RADAR_TH = 0x7c,
 	MCU_EXT_CMD_SET_RDD_PATTERN = 0x7d,
@@ -1277,6 +1284,7 @@ enum {
 	MCU_UNI_CMD_REG_ACCESS = 0x0d,
 	MCU_UNI_CMD_CHIP_CONFIG = 0x0e,
 	MCU_UNI_CMD_POWER_CTRL = 0x0f,
+	MCU_UNI_CMD_CFG_SMESH = 0x10,
 	MCU_UNI_CMD_RX_HDR_TRANS = 0x12,
 	MCU_UNI_CMD_SER = 0x13,
 	MCU_UNI_CMD_TWT = 0x14,
@@ -1287,6 +1295,7 @@ enum {
 	MCU_UNI_CMD_GET_STAT_INFO = 0x23,
 	MCU_UNI_CMD_SNIFFER = 0x24,
 	MCU_UNI_CMD_SR = 0x25,
+	MCU_UNI_CMD_SCS = 0x26,
 	MCU_UNI_CMD_ROC = 0x27,
 	MCU_UNI_CMD_SET_DBDC_PARMS = 0x28,
 	MCU_UNI_CMD_TXPOWER = 0x2b,
@@ -1299,13 +1308,21 @@ enum {
 	MCU_UNI_CMD_CHANNEL_SWITCH = 0x34,
 	MCU_UNI_CMD_THERMAL = 0x35,
 	MCU_UNI_CMD_VOW = 0x37,
+	MCU_UNI_CMD_PP = 0x38,
+	MCU_UNI_CMD_MEC = 0x3a,
 	MCU_UNI_CMD_FIXED_RATE_TABLE = 0x40,
+	MCU_UNI_CMD_TESTMODE_TRX_PARAM = 0x42,
 	MCU_UNI_CMD_TESTMODE_CTRL = 0x46,
+	MCU_UNI_CMD_PRECAL_RESULT = 0x47,
+	MCU_UNI_CMD_CSI_CTRL = 0x4A,
+	MCU_UNI_CMD_THERMAL_CAL = 0x4c,
 	MCU_UNI_CMD_RRO = 0x57,
 	MCU_UNI_CMD_OFFCH_SCAN_CTRL = 0x58,
+	MCU_UNI_CMD_MLO = 0x59,
 	MCU_UNI_CMD_PER_STA_INFO = 0x6d,
 	MCU_UNI_CMD_ALL_STA_INFO = 0x6e,
 	MCU_UNI_CMD_ASSERT_DUMP = 0x6f,
+	MCU_UNI_CMD_PTA_3WIRE_CTRL = 0x78,
 	MCU_UNI_CMD_RADIO_STATUS = 0x80,
 	MCU_UNI_CMD_SDO = 0x88,
 };
@@ -1390,6 +1407,18 @@ enum {
 	UNI_OFFLOAD_OFFLOAD_BMC_RPY_DETECT,
 };
 
+enum UNI_PER_STA_INFO_TAG {
+	UNI_PER_STA_RSSI,
+	UNI_PER_STA_CONTENTION_RX_RATE,
+	UNI_PER_STA_PER,
+	UNI_PER_STA_SNR,
+	UNI_PER_STA_TX_RATE,
+	UNI_PER_STA_TX_CNT,
+	UNI_PER_STA_TID_SN_GET,
+	UNI_PER_STA_TID_SN_SET,
+	UNI_PER_STA_MAX_NUM
+};
+
 enum UNI_ALL_STA_INFO_TAG {
 	UNI_ALL_STA_TXRX_RATE,
 	UNI_ALL_STA_TX_STAT,
diff --git a/mt7996/Makefile b/mt7996/Makefile
index 07c8b555..c9299490 100644
--- a/mt7996/Makefile
+++ b/mt7996/Makefile
@@ -1,8 +1,16 @@
 # SPDX-License-Identifier: ISC
+EXTRA_CFLAGS += -Werror -std=gnu11
+EXTRA_CFLAGS += -DCONFIG_MT76_LEDS
+EXTRA_CFLAGS += -DCONFIG_MTK_DEBUG
+EXTRA_CFLAGS += -DCONFIG_MTK_VENDOR
+EXTRA_CFLAGS += $(ADDITIONAL_CFLAGS)
 
 obj-$(CONFIG_MT7996E) += mt7996e.o
 
 mt7996e-y := pci.o init.o dma.o eeprom.o main.o mcu.o mac.o \
-	     debugfs.o mmio.o
+	     debugfs.o mmio.o vendor.o
 
 mt7996e-$(CONFIG_DEV_COREDUMP) += coredump.o
+mt7996e-$(CONFIG_NL80211_TESTMODE) += testmode.o
+
+mt7996e-y += mtk_debugfs.o mtk_mcu.o mtk_debugfs_i.o trace.o
diff --git a/mt7996/coredump.c b/mt7996/coredump.c
index 303d6e80..9f4b14ce 100644
--- a/mt7996/coredump.c
+++ b/mt7996/coredump.c
@@ -7,11 +7,11 @@
 #include <linux/utsname.h>
 #include "coredump.h"
 
-static bool coredump_memdump;
+static bool coredump_memdump = true;
 module_param(coredump_memdump, bool, 0644);
 MODULE_PARM_DESC(coredump_memdump, "Optional ability to dump firmware memory");
 
-static const struct mt7996_mem_region mt7996_mem_regions[] = {
+static const struct mt7996_mem_region mt7996_wm_mem_regions[] = {
 	{
 		.start = 0x00800000,
 		.len = 0x0004ffff,
@@ -44,27 +44,101 @@ static const struct mt7996_mem_region mt7996_mem_regions[] = {
 	},
 };
 
+static const struct mt7996_mem_region mt7996_wa_mem_regions[] = {
+	{
+		.start = 0xE0000000,
+		.len = 0x0000ffff,
+		.name = "CRAM",
+	},
+	{
+		.start = 0xE0010000,
+		.len = 0x000117ff,
+		.name = "CRAM2",
+	},
+	{
+		.start = 0x10000000,
+		.len = 0x0001bfff,
+		.name = "ILM",
+	},
+	{
+		.start = 0x10200000,
+		.len = 0x00063fff,
+		.name = "DLM",
+	},
+};
+
+static const struct mt7996_mem_region mt7992_wm_mem_regions[] = {
+	{
+		.start = 0x00800000,
+		.len = 0x0004bfff,
+		.name = "ULM0",
+	},
+	{
+		.start = 0x00900000,
+		.len = 0x00035fff,
+		.name = "ULM1",
+	},
+	{
+		.start = 0x02200000,
+		.len = 0x0003ffff,
+		.name = "ULM2",
+	},
+	{
+		.start = 0x00400000,
+		.len = 0x00027fff,
+		.name = "SRAM",
+	},
+	{
+		.start = 0xe0000000,
+		.len = 0x0015ffff,
+		.name = "CRAM0",
+	},
+	{
+		.start = 0xe0160000,
+		.len = 0x00c7fff,
+		.name = "CRAM1",
+	},
+	{
+		.start = 0x7c050000,
+		.len = 0x00007fff,
+		.name = "CONN_INFRA",
+	},
+};
+
 const struct mt7996_mem_region*
-mt7996_coredump_get_mem_layout(struct mt7996_dev *dev, u32 *num)
+mt7996_coredump_get_mem_layout(struct mt7996_dev *dev, u8 type, u32 *num)
 {
 	switch (mt76_chip(&dev->mt76)) {
 	case MT7996_DEVICE_ID:
 	case MT7996_DEVICE_ID_2:
-		*num = ARRAY_SIZE(mt7996_mem_regions);
-		return &mt7996_mem_regions[0];
+		if (type == MT7996_RAM_TYPE_WA) {
+			*num = ARRAY_SIZE(mt7996_wa_mem_regions);
+			return &mt7996_wa_mem_regions[0];
+		}
+
+		*num = ARRAY_SIZE(mt7996_wm_mem_regions);
+		return &mt7996_wm_mem_regions[0];
+	case MT7992_DEVICE_ID:
+		if (type == MT7996_RAM_TYPE_WA) {
+			/* mt7992 wa memory regions is the same as mt7996 */
+			*num = ARRAY_SIZE(mt7996_wa_mem_regions);
+			return &mt7996_wa_mem_regions[0];
+		}
+		*num = ARRAY_SIZE(mt7992_wm_mem_regions);
+		return &mt7992_wm_mem_regions[0];
 	default:
 		return NULL;
 	}
 }
 
-static int mt7996_coredump_get_mem_size(struct mt7996_dev *dev)
+static int mt7996_coredump_get_mem_size(struct mt7996_dev *dev, u8 type)
 {
 	const struct mt7996_mem_region *mem_region;
 	size_t size = 0;
 	u32 num;
 	int i;
 
-	mem_region = mt7996_coredump_get_mem_layout(dev, &num);
+	mem_region = mt7996_coredump_get_mem_layout(dev, type, &num);
 	if (!mem_region)
 		return 0;
 
@@ -81,14 +155,13 @@ static int mt7996_coredump_get_mem_size(struct mt7996_dev *dev)
 	return size;
 }
 
-struct mt7996_crash_data *mt7996_coredump_new(struct mt7996_dev *dev)
+struct mt7996_crash_data *mt7996_coredump_new(struct mt7996_dev *dev, u8 type)
 {
-	struct mt7996_crash_data *crash_data = dev->coredump.crash_data;
+	struct mt7996_crash_data *crash_data = dev->coredump.crash_data[type];
 
 	lockdep_assert_held(&dev->dump_mutex);
 
-	if (coredump_memdump &&
-	    !mt76_poll_msec(dev, MT_FW_DUMP_STATE, 0x3, 0x2, 500))
+	if (!coredump_memdump || !crash_data->supported)
 		return NULL;
 
 	guid_gen(&crash_data->guid);
@@ -98,12 +171,15 @@ struct mt7996_crash_data *mt7996_coredump_new(struct mt7996_dev *dev)
 }
 
 static void
-mt7996_coredump_fw_state(struct mt7996_dev *dev, struct mt7996_coredump *dump,
+mt7996_coredump_fw_state(struct mt7996_dev *dev, u8 type, struct mt7996_coredump *dump,
 			 bool *exception)
 {
-	u32 count;
+	u32 count, reg = MT_FW_WM_DUMP_STATE;
+
+	if (type == MT7996_RAM_TYPE_WA)
+		reg = MT_FW_WA_DUMP_STATE;
 
-	count = mt76_rr(dev, MT_FW_ASSERT_CNT);
+	count = mt76_rr(dev, reg);
 
 	/* normal mode: driver can manually trigger assertfor detail info */
 	if (!count)
@@ -115,53 +191,59 @@ mt7996_coredump_fw_state(struct mt7996_dev *dev, struct mt7996_coredump *dump,
 }
 
 static void
-mt7996_coredump_fw_stack(struct mt7996_dev *dev, struct mt7996_coredump *dump,
+mt7996_coredump_fw_stack(struct mt7996_dev *dev, u8 type, struct mt7996_coredump *dump,
 			 bool exception)
 {
-	u32 oldest, i, idx;
+	u32 reg, i, offset = 0, val = MT7996_RAM_TYPE_WM;
 
-	strscpy(dump->pc_current, "program counter", sizeof(dump->pc_current));
+	if (type == MT7996_RAM_TYPE_WA) {
+		offset = MT_MCU_WA_EXCP_BASE - MT_MCU_WM_EXCP_BASE;
+		val = MT7996_RAM_TYPE_WA;
+	}
 
-	/* 0: WM PC log output */
-	mt76_wr(dev, MT_CONN_DBG_CTL_OUT_SEL, 0);
+	/* 0: WM PC log output, 1: WA PC log output  */
+	mt76_wr(dev, MT_CONN_DBG_CTL_OUT_SEL, val);
 	/* choose 33th PC log buffer to read current PC index */
 	mt76_wr(dev, MT_CONN_DBG_CTL_PC_LOG_SEL, 0x3f);
 
 	/* read current PC */
-	dump->pc_stack[0] = mt76_rr(dev, MT_CONN_DBG_CTL_PC_LOG);
+	for (i = 0; i < 10; i++)
+		dump->pc_cur[i] = mt76_rr(dev, MT_CONN_DBG_CTL_PC_LOG);
 
 	/* stop call stack record */
 	if (!exception) {
-		mt76_clear(dev, MT_MCU_WM_EXCP_PC_CTRL, BIT(0));
-		mt76_clear(dev, MT_MCU_WM_EXCP_LR_CTRL, BIT(0));
+		mt76_clear(dev, MT_MCU_WM_EXCP_PC_CTRL + offset, BIT(0));
+		mt76_clear(dev, MT_MCU_WM_EXCP_LR_CTRL + offset, BIT(0));
 	}
 
-	oldest = (u32)mt76_get_field(dev, MT_MCU_WM_EXCP_PC_CTRL,
-				     GENMASK(20, 16)) + 2;
-	for (i = 0; i < 16; i++) {
-		idx = ((oldest + 2 * i + 1) % 32);
-		dump->pc_stack[i + 1] =
-			mt76_rr(dev, MT_MCU_WM_EXCP_PC_LOG + idx * 4);
+	/* read PC log */
+	dump->pc_dbg_ctrl = mt76_rr(dev, MT_MCU_WM_EXCP_PC_CTRL + offset);
+	dump->pc_cur_idx = FIELD_GET(MT_MCU_WM_EXCP_PC_CTRL_IDX_STATUS,
+				     dump->pc_dbg_ctrl);
+	for (i = 0; i < 32; i++) {
+		reg = MT_MCU_WM_EXCP_PC_LOG + i * 4 + offset;
+		dump->pc_stack[i] = mt76_rr(dev, reg);
 	}
 
-	oldest = (u32)mt76_get_field(dev, MT_MCU_WM_EXCP_LR_CTRL,
-				     GENMASK(20, 16)) + 2;
-	for (i = 0; i < 16; i++) {
-		idx = ((oldest + 2 * i + 1) % 32);
-		dump->lr_stack[i] =
-			mt76_rr(dev, MT_MCU_WM_EXCP_LR_LOG + idx * 4);
+	/* read LR log */
+	dump->lr_dbg_ctrl = mt76_rr(dev, MT_MCU_WM_EXCP_LR_CTRL + offset);
+	dump->lr_cur_idx = FIELD_GET(MT_MCU_WM_EXCP_LR_CTRL_IDX_STATUS,
+				     dump->lr_dbg_ctrl);
+	for (i = 0; i < 32; i++) {
+		reg = MT_MCU_WM_EXCP_LR_LOG + i * 4 + offset;
+		dump->lr_stack[i] = mt76_rr(dev, reg);
 	}
 
 	/* start call stack record */
 	if (!exception) {
-		mt76_set(dev, MT_MCU_WM_EXCP_PC_CTRL, BIT(0));
-		mt76_set(dev, MT_MCU_WM_EXCP_LR_CTRL, BIT(0));
+		mt76_set(dev, MT_MCU_WM_EXCP_PC_CTRL + offset, BIT(0));
+		mt76_set(dev, MT_MCU_WM_EXCP_LR_CTRL + offset, BIT(0));
 	}
 }
 
-static struct mt7996_coredump *mt7996_coredump_build(struct mt7996_dev *dev)
+struct mt7996_coredump *mt7996_coredump_build(struct mt7996_dev *dev, u8 type, bool full_dump)
 {
-	struct mt7996_crash_data *crash_data = dev->coredump.crash_data;
+	struct mt7996_crash_data *crash_data = dev->coredump.crash_data[type];
 	struct mt7996_coredump *dump;
 	struct mt7996_coredump_mem *dump_mem;
 	size_t len, sofar = 0, hdr_len = sizeof(*dump);
@@ -170,7 +252,7 @@ static struct mt7996_coredump *mt7996_coredump_build(struct mt7996_dev *dev)
 
 	len = hdr_len;
 
-	if (coredump_memdump && crash_data->memdump_buf_len)
+	if (full_dump && coredump_memdump && crash_data->memdump_buf_len)
 		len += sizeof(*dump_mem) + crash_data->memdump_buf_len;
 
 	sofar += hdr_len;
@@ -186,20 +268,34 @@ static struct mt7996_coredump *mt7996_coredump_build(struct mt7996_dev *dev)
 
 	dump = (struct mt7996_coredump *)(buf);
 	dump->len = len;
+	dump->hdr_len = hdr_len;
 
 	/* plain text */
 	strscpy(dump->magic, "mt76-crash-dump", sizeof(dump->magic));
 	strscpy(dump->kernel, init_utsname()->release, sizeof(dump->kernel));
+	strscpy(dump->fw_type, ((type == MT7996_RAM_TYPE_WA) ? "WA" : "WM"),
+		sizeof(dump->fw_type));
 	strscpy(dump->fw_ver, dev->mt76.hw->wiphy->fw_version,
 		sizeof(dump->fw_ver));
+	strscpy(dump->fw_patch_date, dev->patch_build_date,
+		sizeof(dump->fw_patch_date));
+	strscpy(dump->fw_ram_date[MT7996_RAM_TYPE_WM],
+		dev->ram_build_date[MT7996_RAM_TYPE_WM],
+		MT7996_BUILD_TIME_LEN);
+	strscpy(dump->fw_ram_date[MT7996_RAM_TYPE_WA],
+		dev->ram_build_date[MT7996_RAM_TYPE_WA],
+		MT7996_BUILD_TIME_LEN);
 
 	guid_copy(&dump->guid, &crash_data->guid);
 	dump->tv_sec = crash_data->timestamp.tv_sec;
 	dump->tv_nsec = crash_data->timestamp.tv_nsec;
 	dump->device_id = mt76_chip(&dev->mt76);
 
-	mt7996_coredump_fw_state(dev, dump, &exception);
-	mt7996_coredump_fw_stack(dev, dump, exception);
+	mt7996_coredump_fw_state(dev, type, dump, &exception);
+	mt7996_coredump_fw_stack(dev, type, dump, exception);
+
+	if (!full_dump)
+		goto skip_dump_mem;
 
 	/* gather memory content */
 	dump_mem = (struct mt7996_coredump_mem *)(buf + sofar);
@@ -208,22 +304,25 @@ static struct mt7996_coredump *mt7996_coredump_build(struct mt7996_dev *dev)
 		memcpy(dump_mem->data, crash_data->memdump_buf,
 		       crash_data->memdump_buf_len);
 
+skip_dump_mem:
 	mutex_unlock(&dev->dump_mutex);
 
 	return dump;
 }
 
-int mt7996_coredump_submit(struct mt7996_dev *dev)
+int mt7996_coredump_submit(struct mt7996_dev *dev, u8 type)
 {
 	struct mt7996_coredump *dump;
 
-	dump = mt7996_coredump_build(dev);
+	dump = mt7996_coredump_build(dev, type, true);
 	if (!dump) {
 		dev_warn(dev->mt76.dev, "no crash dump data found\n");
 		return -ENODATA;
 	}
 
 	dev_coredumpv(dev->mt76.dev, dump, dump->len, GFP_KERNEL);
+	dev_info(dev->mt76.dev, "%s coredump completed\n",
+		 wiphy_name(dev->mt76.hw->wiphy));
 
 	return 0;
 }
@@ -231,38 +330,51 @@ int mt7996_coredump_submit(struct mt7996_dev *dev)
 int mt7996_coredump_register(struct mt7996_dev *dev)
 {
 	struct mt7996_crash_data *crash_data;
+	int i;
+
+	for (i = 0; i < MT7996_COREDUMP_MAX; i++) {
+		crash_data = vzalloc(sizeof(*dev->coredump.crash_data[i]));
+		if (!crash_data)
+			goto nomem;
 
-	crash_data = vzalloc(sizeof(*dev->coredump.crash_data));
-	if (!crash_data)
-		return -ENOMEM;
+		dev->coredump.crash_data[i] = crash_data;
+		crash_data->supported = false;
 
-	dev->coredump.crash_data = crash_data;
+		if (coredump_memdump) {
+			crash_data->memdump_buf_len = mt7996_coredump_get_mem_size(dev, i);
+			if (!crash_data->memdump_buf_len)
+				/* no memory content */
+				continue;
 
-	if (coredump_memdump) {
-		crash_data->memdump_buf_len = mt7996_coredump_get_mem_size(dev);
-		if (!crash_data->memdump_buf_len)
-			/* no memory content */
-			return 0;
+			crash_data->memdump_buf = vzalloc(crash_data->memdump_buf_len);
+			if (!crash_data->memdump_buf)
+				goto nomem;
 
-		crash_data->memdump_buf = vzalloc(crash_data->memdump_buf_len);
-		if (!crash_data->memdump_buf) {
-			vfree(crash_data);
-			return -ENOMEM;
+			crash_data->supported = true;
 		}
 	}
 
 	return 0;
+nomem:
+	mt7996_coredump_unregister(dev);
+	return -ENOMEM;
 }
 
 void mt7996_coredump_unregister(struct mt7996_dev *dev)
 {
-	if (dev->coredump.crash_data->memdump_buf) {
-		vfree(dev->coredump.crash_data->memdump_buf);
-		dev->coredump.crash_data->memdump_buf = NULL;
-		dev->coredump.crash_data->memdump_buf_len = 0;
-	}
+	int i;
+	struct mt7996_crash_data *crash_data;
+
+	for (i = 0; i < MT7996_COREDUMP_MAX; i++) {
+		crash_data = dev->coredump.crash_data[i];
 
-	vfree(dev->coredump.crash_data);
-	dev->coredump.crash_data = NULL;
+		if (!crash_data)
+			continue;
+
+		if (crash_data->memdump_buf)
+			vfree(crash_data->memdump_buf);
+
+		vfree(crash_data);
+	}
 }
 
diff --git a/mt7996/coredump.h b/mt7996/coredump.h
index af2ba219..93cd84a0 100644
--- a/mt7996/coredump.h
+++ b/mt7996/coredump.h
@@ -6,10 +6,13 @@
 
 #include "mt7996.h"
 
+#define MT7996_COREDUMP_MAX	(MT7996_RAM_TYPE_WA + 1)
+
 struct mt7996_coredump {
 	char magic[16];
 
 	u32 len;
+	u32 hdr_len;
 
 	guid_t guid;
 
@@ -21,17 +24,28 @@ struct mt7996_coredump {
 	char kernel[64];
 	/* firmware version */
 	char fw_ver[ETHTOOL_FWVERS_LEN];
+	char fw_patch_date[MT7996_BUILD_TIME_LEN];
+	char fw_ram_date[MT7996_COREDUMP_MAX][MT7996_BUILD_TIME_LEN];
 
 	u32 device_id;
 
+	/* fw type */
+	char fw_type[8];
+
 	/* exception state */
 	char fw_state[12];
 
 	/* program counters */
-	char pc_current[16];
-	u32 pc_stack[17];
-	/* link registers */
-	u32 lr_stack[16];
+	u32 pc_dbg_ctrl;
+	u32 pc_cur_idx;
+	u32 pc_cur[10];
+	/* PC registers */
+	u32 pc_stack[32];
+
+	u32 lr_dbg_ctrl;
+	u32 lr_cur_idx;
+	/* LR registers */
+	u32 lr_stack[32];
 
 	/* memory content */
 	u8 data[];
@@ -43,6 +57,7 @@ struct mt7996_coredump_mem {
 } __packed;
 
 struct mt7996_mem_hdr {
+	char name[64];
 	u32 start;
 	u32 len;
 	u8 data[];
@@ -58,27 +73,34 @@ struct mt7996_mem_region {
 #ifdef CONFIG_DEV_COREDUMP
 
 const struct mt7996_mem_region *
-mt7996_coredump_get_mem_layout(struct mt7996_dev *dev, u32 *num);
-struct mt7996_crash_data *mt7996_coredump_new(struct mt7996_dev *dev);
-int mt7996_coredump_submit(struct mt7996_dev *dev);
+mt7996_coredump_get_mem_layout(struct mt7996_dev *dev, u8 type, u32 *num);
+struct mt7996_crash_data *mt7996_coredump_new(struct mt7996_dev *dev, u8 type);
+struct mt7996_coredump *mt7996_coredump_build(struct mt7996_dev *dev, u8 type, bool full_dump);
+int mt7996_coredump_submit(struct mt7996_dev *dev, u8 type);
 int mt7996_coredump_register(struct mt7996_dev *dev);
 void mt7996_coredump_unregister(struct mt7996_dev *dev);
 
 #else /* CONFIG_DEV_COREDUMP */
 
 static inline const struct mt7996_mem_region *
-mt7996_coredump_get_mem_layout(struct mt7996_dev *dev, u32 *num)
+mt7996_coredump_get_mem_layout(struct mt7996_dev *dev, u8 type, u32 *num)
 {
 	return NULL;
 }
 
-static inline int mt7996_coredump_submit(struct mt7996_dev *dev)
+static inline int mt7996_coredump_submit(struct mt7996_dev *dev, u8 type)
 {
 	return 0;
 }
 
 static inline struct
-mt7996_crash_data *mt7996_coredump_new(struct mt7996_dev *dev)
+mt7996_coredump *mt7996_coredump_build(struct mt7996_dev *dev, u8 type, bool full_dump)
+{
+	return NULL;
+}
+
+static inline struct
+mt7996_crash_data *mt7996_coredump_new(struct mt7996_dev *dev, u8 type)
 {
 	return NULL;
 }
diff --git a/mt7996/debugfs.c b/mt7996/debugfs.c
index 25cb9b5e..6819d9da 100644
--- a/mt7996/debugfs.c
+++ b/mt7996/debugfs.c
@@ -51,10 +51,12 @@ static ssize_t
 mt7996_sys_recovery_set(struct file *file, const char __user *user_buf,
 			size_t count, loff_t *ppos)
 {
-	struct mt7996_dev *dev = file->private_data;
-	char buf[16], *sep;
+	struct mt7996_phy *phy = file->private_data;
+	struct mt7996_dev *dev = phy->dev;
+	bool band = phy->mt76->band_idx;
+	char buf[16];
 	int ret = 0;
-	u16 band, val;
+	u16 val;
 
 	if (count >= sizeof(buf))
 		return -EINVAL;
@@ -67,26 +69,21 @@ mt7996_sys_recovery_set(struct file *file, const char __user *user_buf,
 	else
 		buf[count] = '\0';
 
-	sep = strchr(buf, ',');
-	if (!sep)
-		return -EINVAL;
-
-	*sep = 0;
-	if (kstrtou16(buf, 0, &band) || kstrtou16(sep + 1, 0, &val))
+	if (kstrtou16(buf, 0, &val))
 		return -EINVAL;
 
 	switch (val) {
 	/*
-	 * <band>,0: grab firmware current SER state.
-	 * <band>,1: trigger & enable system error L1 recovery.
-	 * <band>,2: trigger & enable system error L2 recovery.
-	 * <band>,3: trigger & enable system error L3 rx abort.
-	 * <band>,4: trigger & enable system error L3 tx abort
-	 * <band>,5: trigger & enable system error L3 tx disable.
-	 * <band>,6: trigger & enable system error L3 bf recovery.
-	 * <band>,7: trigger & enable system error L4 mdp recovery.
-	 * <band>,8: trigger & enable system error full recovery.
-	 * <band>,9: trigger firmware crash.
+	 * 0: grab firmware current SER state.
+	 * 1: trigger & enable system error L1 recovery.
+	 * 2: trigger & enable system error L2 recovery.
+	 * 3: trigger & enable system error L3 rx abort.
+	 * 4: trigger & enable system error L3 tx abort
+	 * 5: trigger & enable system error L3 tx disable.
+	 * 6: trigger & enable system error L3 bf recovery.
+	 * 7: trigger & enable system error L4 mdp recovery.
+	 * 8: trigger & enable system error full recovery.
+	 * 9: trigger firmware crash.
 	 * 10: trigger grab wa firmware coredump.
 	 * 11: trigger grab wm firmware coredump.
 	 * 12: hw bit detect only.
@@ -111,15 +108,25 @@ mt7996_sys_recovery_set(struct file *file, const char __user *user_buf,
 	/* enable full chip reset */
 	case UNI_CMD_SER_SET_RECOVER_FULL:
 		mt76_set(dev, MT_WFDMA0_MCU_HOST_INT_ENA, MT_MCU_CMD_WDT_MASK);
-		dev->recovery.state |= MT_MCU_CMD_WDT_MASK;
+		dev->recovery.state |= MT_MCU_CMD_WM_WDT;
 		mt7996_reset(dev);
 		break;
 
 	/* WARNING: trigger firmware crash */
 	case UNI_CMD_SER_SET_SYSTEM_ASSERT:
+		// trigger wm assert exception
 		ret = mt7996_mcu_trigger_assert(dev);
 		if (ret)
 			return ret;
+		// trigger wa assert exception
+		mt76_wr(dev, 0x89098108, 0x20);
+		mt76_wr(dev, 0x89098118, 0x20);
+		break;
+	case UNI_CMD_SER_FW_COREDUMP_WA:
+		mt7996_coredump(dev, MT7996_COREDUMP_MANUAL_WA);
+		break;
+	case UNI_CMD_SER_FW_COREDUMP_WM:
+		mt7996_coredump(dev, MT7996_COREDUMP_MANUAL_WM);
 		break;
 	case UNI_CMD_SER_SET_HW_BIT_DETECT_ONLY:
 		ret = mt7996_mcu_set_ser(dev, UNI_CMD_SER_SET, BIT(0), band);
@@ -137,7 +144,8 @@ static ssize_t
 mt7996_sys_recovery_get(struct file *file, char __user *user_buf,
 			size_t count, loff_t *ppos)
 {
-	struct mt7996_dev *dev = file->private_data;
+	struct mt7996_phy *phy = file->private_data;
+	struct mt7996_dev *dev = phy->dev;
 	char *buff;
 	int desc = 0;
 	ssize_t ret;
@@ -151,25 +159,35 @@ mt7996_sys_recovery_get(struct file *file, char __user *user_buf,
 	desc += scnprintf(buff + desc, bufsz - desc,
 			  "Please echo the correct value ...\n");
 	desc += scnprintf(buff + desc, bufsz - desc,
-			  "<band>,0: grab firmware transient SER state\n");
+			  "%2d: grab firmware transient SER state\n",
+			  UNI_CMD_SER_QUERY);
 	desc += scnprintf(buff + desc, bufsz - desc,
-			  "<band>,1: trigger system error L1 recovery\n");
+			  "%2d: trigger system error L1 recovery\n",
+			  UNI_CMD_SER_SET_RECOVER_L1);
 	desc += scnprintf(buff + desc, bufsz - desc,
-			  "<band>,2: trigger system error L2 recovery\n");
+			  "%2d: trigger system error L2 recovery\n",
+			  UNI_CMD_SER_SET_RECOVER_L2);
 	desc += scnprintf(buff + desc, bufsz - desc,
-			  "<band>,3: trigger system error L3 rx abort\n");
+			  "%2d: trigger system error L3 rx abort\n",
+			  UNI_CMD_SER_SET_RECOVER_L3_RX_ABORT);
 	desc += scnprintf(buff + desc, bufsz - desc,
-			  "<band>,4: trigger system error L3 tx abort\n");
+			  "%2d: trigger system error L3 tx abort\n",
+			  UNI_CMD_SER_SET_RECOVER_L3_TX_ABORT);
 	desc += scnprintf(buff + desc, bufsz - desc,
-			  "<band>,5: trigger system error L3 tx disable\n");
+			  "%2d: trigger system error L3 tx disable\n",
+			  UNI_CMD_SER_SET_RECOVER_L3_TX_DISABLE);
 	desc += scnprintf(buff + desc, bufsz - desc,
-			  "<band>,6: trigger system error L3 bf recovery\n");
+			  "%2d: trigger system error L3 bf recovery\n",
+			  UNI_CMD_SER_SET_RECOVER_L3_BF);
 	desc += scnprintf(buff + desc, bufsz - desc,
-			  "<band>,7: trigger system error L4 mdp recovery\n");
+			  "%2d: trigger system error L4 mdp recovery\n",
+			  UNI_CMD_SER_SET_RECOVER_L4_MDP);
 	desc += scnprintf(buff + desc, bufsz - desc,
-			  "<band>,8: trigger system error full recovery\n");
+			  "%2d: trigger system error full recovery\n",
+			  UNI_CMD_SER_SET_RECOVER_FULL);
 	desc += scnprintf(buff + desc, bufsz - desc,
-			  "<band>,9: trigger firmware crash\n");
+			  "%2d: trigger firmware crash\n",
+			  UNI_CMD_SER_SET_SYSTEM_ASSERT);
 	desc += scnprintf(buff + desc, bufsz - desc,
 			  "%2d: trigger grab wa firmware coredump\n",
 			  UNI_CMD_SER_FW_COREDUMP_WA);
@@ -274,6 +292,11 @@ mt7996_rdd_monitor(struct seq_file *s, void *data)
 
 	mutex_lock(&dev->mt76.mutex);
 
+	if (!mt7996_has_background_radar(dev)) {
+		seq_puts(s, "no background radar capability\n");
+		goto out;
+	}
+
 	if (!cfg80211_chandef_valid(chandef)) {
 		ret = -EINVAL;
 		goto out;
@@ -314,6 +337,8 @@ out:
 static int
 mt7996_fw_debug_wm_set(void *data, u64 val)
 {
+#define IDS(_m)	(is_mt7996(&dev->mt76) ? DEBUG_MT7996_IDS_##_m : \
+					 DEBUG_MT7992_IDS_##_m)
 	struct mt7996_dev *dev = data;
 	enum {
 		DEBUG_TXCMD = 62,
@@ -321,36 +346,95 @@ mt7996_fw_debug_wm_set(void *data, u64 val)
 		DEBUG_CMD_RPT_TRIG,
 		DEBUG_SPL,
 		DEBUG_RPT_RX,
-		DEBUG_RPT_RA = 68,
-	} debug;
-	bool tx, rx, en;
+
+		DEBUG_IDS_SND = 84,
+		DEBUG_IDS_BSRP,
+		DEBUG_IDS_TPUT_MON,
+
+		/* IDS log for mt7996 */
+		DEBUG_MT7996_IDS_PP = 93,
+		DEBUG_MT7996_IDS_RA,
+		DEBUG_MT7996_IDS_BF,
+		DEBUG_MT7996_IDS_SR,
+		DEBUG_MT7996_IDS_RU,
+		DEBUG_MT7996_IDS_MUMIMO,
+		DEBUG_MT7996_IDS_MLO = 100,
+		DEBUG_MT7996_IDS_ERR_LOG,
+
+		/* IDS log for mt7992 */
+		DEBUG_MT7992_IDS_PP = 94,
+		DEBUG_MT7992_IDS_RA,
+		DEBUG_MT7992_IDS_BF,
+		DEBUG_MT7992_IDS_SR,
+		DEBUG_MT7992_IDS_RU,
+		DEBUG_MT7992_IDS_MUMIMO,
+		DEBUG_MT7992_IDS_MLO = 101,
+		DEBUG_MT7992_IDS_ERR_LOG,
+	};
+	u8 debug_category[] = {
+		DEBUG_TXCMD,
+		DEBUG_CMD_RPT_TX,
+		DEBUG_CMD_RPT_TRIG,
+		DEBUG_SPL,
+		DEBUG_RPT_RX,
+		DEBUG_IDS_SND,
+		DEBUG_IDS_BSRP,
+		DEBUG_IDS_TPUT_MON,
+		IDS(PP),
+		IDS(RA),
+		IDS(BF),
+		IDS(SR),
+		IDS(RU),
+		IDS(MUMIMO),
+		IDS(MLO),
+		IDS(ERR_LOG),
+	};
+	bool en;
 	int ret;
+	u8 i;
 
+#ifdef CONFIG_MTK_DEBUG
+	dev->fw_debug_wm = val;
+#else
 	dev->fw_debug_wm = val ? MCU_FW_LOG_TO_HOST : 0;
+#endif
 
 	if (dev->fw_debug_bin)
 		val = MCU_FW_LOG_RELAY;
 	else
 		val = dev->fw_debug_wm;
 
-	tx = dev->fw_debug_wm || (dev->fw_debug_bin & BIT(1));
-	rx = dev->fw_debug_wm || (dev->fw_debug_bin & BIT(2));
 	en = dev->fw_debug_wm || (dev->fw_debug_bin & BIT(0));
 
 	ret = mt7996_mcu_fw_log_2_host(dev, MCU_FW_LOG_WM, val);
 	if (ret)
 		return ret;
 
-	for (debug = DEBUG_TXCMD; debug <= DEBUG_RPT_RA; debug++) {
-		if (debug == 67)
+	if (!en) {
+		for (i = 0; i < ARRAY_SIZE(debug_category); i++) {
+			ret = mt7996_mcu_fw_dbg_ctrl(dev, debug_category[i], 0);
+			if (ret)
+				return ret;
+		}
+
+		return 0;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(debug_category); i++) {
+		/* only enable necessary fwlog modules to prevent WM busy.
+		 * for other modules, user can enable it by using fw_debug_module
+		 * and fw_debug_level
+		 */
+		if (debug_category[i] > DEBUG_RPT_RX)
 			continue;
 
-		if (debug == DEBUG_RPT_RX)
-			val = en && rx;
+		if (debug_category[i] == DEBUG_TXCMD ||
+		    debug_category[i] == DEBUG_IDS_SND)
+			val = 2;
 		else
-			val = en && tx;
+			val = 1;
 
-		ret = mt7996_mcu_fw_dbg_ctrl(dev, debug, val);
+		ret = mt7996_mcu_fw_dbg_ctrl(dev, debug_category[i], val);
 		if (ret)
 			return ret;
 	}
@@ -406,8 +490,8 @@ create_buf_file_cb(const char *filename, struct dentry *parent, umode_t mode,
 {
 	struct dentry *f;
 
-	f = debugfs_create_file("fwlog_data", mode, parent, buf,
-				&relay_file_operations);
+	f = debugfs_create_file(filename[0] == 'f' ? "fwlog_data" : "idxlog_data",
+	                        mode, parent, buf, &relay_file_operations);
 	if (IS_ERR(f))
 		return NULL;
 
@@ -424,6 +508,39 @@ remove_buf_file_cb(struct dentry *f)
 	return 0;
 }
 
+static int
+mt7996_fw_debug_muru_set(void *data)
+{
+	struct mt7996_dev *dev = data;
+	enum {
+		DEBUG_BSRP_STATUS = 256,
+		DEBUG_TX_DATA_BYTE_CONUT,
+		DEBUG_RX_DATA_BYTE_CONUT,
+		DEBUG_RX_TOTAL_BYTE_CONUT,
+		DEBUG_INVALID_TID_BSR,
+		DEBUG_UL_LONG_TERM_PPDU_TYPE,
+		DEBUG_DL_LONG_TERM_PPDU_TYPE,
+		DEBUG_PPDU_CLASS_TRIG_ONOFF,
+		DEBUG_AIRTIME_BUSY_STATUS,
+		DEBUG_UL_OFDMA_MIMO_STATUS,
+		DEBUG_RU_CANDIDATE,
+		DEBUG_MEC_UPDATE_AMSDU,
+	} debug;
+	int ret;
+
+	if (dev->fw_debug_muru_disable)
+		return 0;
+
+	for (debug = DEBUG_BSRP_STATUS; debug <= DEBUG_MEC_UPDATE_AMSDU; debug++) {
+		ret = mt7996_mcu_muru_dbg_info(dev, debug,
+					       dev->fw_debug_bin & BIT(0));
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
 static int
 mt7996_fw_debug_bin_set(void *data, u64 val)
 {
@@ -432,17 +549,32 @@ mt7996_fw_debug_bin_set(void *data, u64 val)
 		.remove_buf_file = remove_buf_file_cb,
 	};
 	struct mt7996_dev *dev = data;
+	int ret;
 
-	if (!dev->relay_fwlog)
+	if (!dev->relay_fwlog) {
 		dev->relay_fwlog = relay_open("fwlog_data", dev->debugfs_dir,
 					      1500, 512, &relay_cb, NULL);
-	if (!dev->relay_fwlog)
-		return -ENOMEM;
+		if (!dev->relay_fwlog)
+			return -ENOMEM;
+	}
 
 	dev->fw_debug_bin = val;
 
 	relay_reset(dev->relay_fwlog);
 
+	ret = mt7996_fw_debug_muru_set(dev);
+	if (ret)
+		return ret;
+
+#ifdef CONFIG_MTK_DEBUG
+	dev->dbg.dump_mcu_pkt = !!(val & BIT(4));
+	dev->dbg.dump_txd = !!(val & BIT(5));
+	dev->dbg.dump_tx_pkt = !!(val & BIT(6));
+	dev->dbg.dump_rx_pkt = !!(val & BIT(7));
+	dev->dbg.dump_rx_raw = !!(val & BIT(8));
+	dev->dbg.dump_mcu_event = !!(val & BIT(9));
+#endif
+
 	return mt7996_fw_debug_wm_set(dev, dev->fw_debug_wm);
 }
 
@@ -459,6 +591,53 @@ mt7996_fw_debug_bin_get(void *data, u64 *val)
 DEFINE_DEBUGFS_ATTRIBUTE(fops_fw_debug_bin, mt7996_fw_debug_bin_get,
 			 mt7996_fw_debug_bin_set, "%lld\n");
 
+static int
+mt7996_idxlog_enable_get(void *data, u64 *val)
+{
+	struct mt7996_dev *dev = data;
+
+	*val = dev->idxlog_enable;
+
+	return 0;
+}
+
+static int
+mt7996_idxlog_enable_set(void *data, u64 val)
+{
+	static struct rchan_callbacks relay_cb = {
+		.create_buf_file = create_buf_file_cb,
+		.remove_buf_file = remove_buf_file_cb,
+	};
+	struct mt7996_dev *dev = data;
+
+	if (dev->idxlog_enable == !!val)
+		return 0;
+
+	if (!dev->relay_idxlog) {
+		dev->relay_idxlog = relay_open("idxlog_data", dev->debugfs_dir,
+		                               1500, 512, &relay_cb, NULL);
+		if (!dev->relay_idxlog)
+			return -ENOMEM;
+	}
+
+	dev->idxlog_enable = !!val;
+
+	if (val) {
+		int ret = mt7996_mcu_fw_time_sync(&dev->mt76);
+		if (ret)
+			return ret;
+
+		/* Reset relay channel only when it is not being written to. */
+		relay_reset(dev->relay_idxlog);
+	}
+
+	return mt7996_mcu_fw_log_2_host(dev, MCU_FW_LOG_WM,
+	                                val ? MCU_FW_LOG_RELAY_IDX : 0);
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_idxlog_enable, mt7996_idxlog_enable_get,
+	                 mt7996_idxlog_enable_set, "%llu\n");
+
 static int
 mt7996_fw_util_wa_show(struct seq_file *file, void *data)
 {
@@ -551,12 +730,16 @@ mt7996_txbf_stat_read_phy(struct mt7996_phy *phy, struct seq_file *s)
 	seq_puts(s, "\n");
 }
 
-static void
-mt7996_tx_stats_show_phy(struct seq_file *file, struct mt7996_phy *phy)
+static int
+mt7996_tx_stats_show(struct seq_file *file, void *data)
 {
+	struct mt7996_phy *phy = file->private;
+	struct mt7996_dev *dev = phy->dev;
 	struct mt76_mib_stats *mib = &phy->mib;
 	u32 attempts, success, per;
-	int i;
+	int i, j;
+
+	mutex_lock(&dev->mt76.mutex);
 
 	mt7996_mac_update_stats(phy);
 	mt7996_ampdu_stat_read_phy(phy, file);
@@ -568,36 +751,19 @@ mt7996_tx_stats_show_phy(struct seq_file *file, struct mt7996_phy *phy)
 	seq_printf(file, "Tx success: %8u (MPDUs)\n", success);
 	seq_printf(file, "Tx PER: %u%%\n", per);
 
-	mt7996_txbf_stat_read_phy(phy, file);
+	seq_printf(file, "Drop by HW:\n");
+	for (i = 0; i < MT7996_HW_DROP_STAT; i++) {
+		for (j = 0; j < MT7996_HW_DROP_REASON; j++) {
+			if (!phy->hw_drop[i][j])
+				continue;
 
-	/* Tx amsdu info */
-	seq_puts(file, "Tx MSDU statistics:\n");
-	for (i = 0; i < ARRAY_SIZE(mib->tx_amsdu); i++) {
-		seq_printf(file, "AMSDU pack count of %d MSDU in TXD: %8d ",
-			   i + 1, mib->tx_amsdu[i]);
-		if (mib->tx_amsdu_cnt)
-			seq_printf(file, "(%3d%%)\n",
-				   mib->tx_amsdu[i] * 100 / mib->tx_amsdu_cnt);
-		else
-			seq_puts(file, "\n");
+			seq_printf(file,
+				   "Stat = %d, reason = %d, drop count = %d\n",
+				   i, j, phy->hw_drop[i][j]);
+		}
 	}
-}
 
-static int
-mt7996_tx_stats_show(struct seq_file *file, void *data)
-{
-	struct mt7996_dev *dev = file->private;
-	struct mt7996_phy *phy = &dev->phy;
-
-	mutex_lock(&dev->mt76.mutex);
-
-	mt7996_tx_stats_show_phy(file, phy);
-	phy = mt7996_phy2(dev);
-	if (phy)
-		mt7996_tx_stats_show_phy(file, phy);
-	phy = mt7996_phy3(dev);
-	if (phy)
-		mt7996_tx_stats_show_phy(file, phy);
+	mt7996_txbf_stat_read_phy(phy, file);
 
 	mutex_unlock(&dev->mt76.mutex);
 
@@ -643,16 +809,17 @@ mt7996_sta_hw_queue_read(void *data, struct ieee80211_sta *sta)
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
 	struct mt7996_vif *mvif = msta->vif;
 	struct mt7996_dev *dev = mvif->deflink.phy->dev;
-	struct ieee80211_link_sta *link_sta;
 	struct seq_file *s = data;
 	struct ieee80211_vif *vif;
+	unsigned long valid_links;
 	unsigned int link_id;
 
 	vif = container_of((void *)mvif, struct ieee80211_vif, drv_priv);
 
 	rcu_read_lock();
 
-	for_each_sta_active_link(vif, sta, link_sta, link_id) {
+	valid_links = vif->valid_links ?: BIT(0);
+	for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
 		struct mt7996_sta_link *msta_link;
 		struct mt76_vif_link *mlink;
 		u8 ac;
@@ -691,8 +858,8 @@ mt7996_sta_hw_queue_read(void *data, struct ieee80211_sta *sta)
 static int
 mt7996_hw_queues_show(struct seq_file *file, void *data)
 {
-	struct mt7996_dev *dev = file->private;
-	struct mt7996_phy *phy = &dev->phy;
+	struct mt7996_phy *phy = file->private;
+	struct mt7996_dev *dev = phy->dev;
 	static const struct hw_queue_map ple_queue_map[] = {
 		{ "CPU_Q0",  0,  1, MT_CTX0	      },
 		{ "CPU_Q1",  1,  1, MT_CTX0 + 1	      },
@@ -748,15 +915,6 @@ mt7996_hw_queues_show(struct seq_file *file, void *data)
 	/* iterate per-sta ple queue */
 	ieee80211_iterate_stations_atomic(phy->mt76->hw,
 					  mt7996_sta_hw_queue_read, file);
-	phy = mt7996_phy2(dev);
-	if (phy)
-		ieee80211_iterate_stations_atomic(phy->mt76->hw,
-						  mt7996_sta_hw_queue_read, file);
-	phy = mt7996_phy3(dev);
-	if (phy)
-		ieee80211_iterate_stations_atomic(phy->mt76->hw,
-						  mt7996_sta_hw_queue_read, file);
-
 	/* pse queue */
 	seq_puts(file, "PSE non-empty queue info:\n");
 	mt7996_hw_queue_read(file, ARRAY_SIZE(pse_queue_map),
@@ -770,29 +928,19 @@ DEFINE_SHOW_ATTRIBUTE(mt7996_hw_queues);
 static int
 mt7996_xmit_queues_show(struct seq_file *file, void *data)
 {
-	struct mt7996_dev *dev = file->private;
-	struct mt7996_phy *phy;
+	struct mt7996_phy *phy = file->private;
+	struct mt7996_dev *dev = phy->dev;
 	struct {
 		struct mt76_queue *q;
 		char *queue;
 	} queue_map[] = {
-		{ dev->mphy.q_tx[MT_TXQ_BE],	 "  MAIN0"  },
-		{ NULL,				 "  MAIN1"  },
-		{ NULL,				 "  MAIN2"  },
+		{ phy->mt76->q_tx[MT_TXQ_BE],	 "   MAIN"  },
 		{ dev->mt76.q_mcu[MT_MCUQ_WM],	 "  MCUWM"  },
 		{ dev->mt76.q_mcu[MT_MCUQ_WA],	 "  MCUWA"  },
 		{ dev->mt76.q_mcu[MT_MCUQ_FWDL], "MCUFWDL" },
 	};
 	int i;
 
-	phy = mt7996_phy2(dev);
-	if (phy)
-		queue_map[1].q = phy->mt76->q_tx[MT_TXQ_BE];
-
-	phy = mt7996_phy3(dev);
-	if (phy)
-		queue_map[2].q = phy->mt76->q_tx[MT_TXQ_BE];
-
 	seq_puts(file, "     queue | hw-queued |      head |      tail |\n");
 	for (i = 0; i < ARRAY_SIZE(queue_map); i++) {
 		struct mt76_queue *q = queue_map[i].q;
@@ -867,24 +1015,205 @@ mt7996_rf_regval_set(void *data, u64 val)
 DEFINE_DEBUGFS_ATTRIBUTE(fops_rf_regval, mt7996_rf_regval_get,
 			 mt7996_rf_regval_set, "0x%08llx\n");
 
-int mt7996_init_debugfs(struct mt7996_dev *dev)
+static int
+mt7996_fw_debug_muru_disable_set(void *data, u64 val)
+{
+	struct mt7996_dev *dev = data;
+
+	dev->fw_debug_muru_disable = !!val;
+
+	return 0;
+}
+
+static int
+mt7996_fw_debug_muru_disable_get(void *data, u64 *val)
+{
+	struct mt7996_dev *dev = data;
+
+	*val = dev->fw_debug_muru_disable;
+
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_fw_debug_muru_disable,
+			 mt7996_fw_debug_muru_disable_get,
+			 mt7996_fw_debug_muru_disable_set, "%lld\n");
+
+static ssize_t
+mt7996_efuse_get(struct file *file, char __user *user_buf,
+		 size_t count, loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+	struct mt76_dev *mdev = &dev->mt76;
+	u8 *buff = mdev->otp.data;
+	int i;
+	ssize_t ret;
+	u32 block_num;
+
+	mdev->otp.size = MT7996_EEPROM_SIZE;
+	if (is_mt7996(&dev->mt76) && dev->var.type == MT7996_VAR_TYPE_444)
+		mdev->otp.size += 3 * MT_EE_CAL_UNIT;
+
+	if (!mdev->otp.data) {
+		mdev->otp.data = devm_kzalloc(mdev->dev, mdev->otp.size, GFP_KERNEL);
+		if (!mdev->otp.data)
+			return -ENOMEM;
+
+		block_num = DIV_ROUND_UP(mdev->otp.size, MT7996_EEPROM_BLOCK_SIZE);
+		for (i = 0; i < block_num; i++) {
+			buff = mdev->otp.data + i * MT7996_EEPROM_BLOCK_SIZE;
+			ret = mt7996_mcu_get_eeprom(dev, i * MT7996_EEPROM_BLOCK_SIZE, buff);
+			if (ret && ret != -EINVAL)
+				return ret;
+		}
+	}
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, mdev->otp.data, mdev->otp.size);
+
+	return ret;
+}
+
+static const struct file_operations mt7996_efuse_ops = {
+	.read = mt7996_efuse_get,
+	.open = simple_open,
+	.llseek = default_llseek,
+};
+
+static int
+mt7996_vow_info_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	struct mt7996_vow_ctrl *vow = &dev->vow;
+	int i;
+
+	seq_printf(s, "VoW ATF Configuration:\n");
+	seq_printf(s, "ATF: %s\n", vow->atf_enable ? "enabled" : "disabled");
+	seq_printf(s, "WATF: %s\n", vow->watf_enable ? "enabled" : "disabled");
+	seq_printf(s, "Airtime Quantums (unit: 256 us)\n");
+	for (i = 0; i < VOW_DRR_QUANTUM_NUM; ++i)
+		seq_printf(s, "\tL%d: %hhu\n", i, vow->drr_quantum[i]);
+	seq_printf(s, "Max Airtime Deficit: %hhu (unit: 256 us)\n", vow->max_deficit);
+
+	return 0;
+}
+
+static int
+mt7996_atf_enable_get(void *data, u64 *val)
+{
+	struct mt7996_phy *phy = data;
+
+	*val = phy->dev->vow.atf_enable;
+
+	return 0;
+}
+
+static int
+mt7996_atf_enable_set(void *data, u64 val)
+{
+	struct mt7996_phy *phy = data;
+	struct mt7996_vow_ctrl *vow = &phy->dev->vow;
+	int ret;
+
+	vow->max_deficit = val ? 64 : 1;
+	ret = mt7996_mcu_set_vow_drr_ctrl(phy, NULL, NULL, VOW_DRR_CTRL_AIRTIME_DEFICIT_BOUND);
+	if (ret)
+		return ret;
+
+	vow->atf_enable = !!val;
+	return mt7996_mcu_set_vow_feature_ctrl(phy);
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_atf_enable, mt7996_atf_enable_get,
+	                 mt7996_atf_enable_set, "%llu\n");
+
+static int
+mt7996_airtime_read(struct seq_file *s, void *data)
 {
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	struct mt76_dev *mdev = &dev->mt76;
+	struct mt76_sta_stats *stats;
+	struct ieee80211_sta *sta;
+	struct mt7996_sta_link *msta_link;
+	struct mt76_wcid *wcid;
+	struct mt76_vif_link *vif;
+	u16 i;
+
+	seq_printf(s, "VoW Airtime Information:\n");
+	rcu_read_lock();
+	for (i = 1; i < MT7996_WTBL_STA; ++i) {
+		wcid = rcu_dereference(mdev->wcid[i]);
+		if (!wcid || !wcid->sta)
+			continue;
+
+		msta_link = container_of(wcid, struct mt7996_sta_link, wcid);
+		sta = container_of((void *)msta_link->sta, struct ieee80211_sta, drv_priv);
+		vif = &msta_link->sta->vif->deflink.mt76;
+		stats = &wcid->stats;
+
+		seq_printf(s, "%pM WCID: %hu BandIdx: %hhu OmacIdx: 0x%hhx\t"
+		              "TxAirtime: %llu\tRxAirtime: %llu\n",
+		              sta->addr, i, vif->band_idx, vif->omac_idx,
+		              stats->tx_airtime, stats->rx_airtime);
+
+		stats->tx_airtime = 0;
+		stats->rx_airtime = 0;
+	}
+	rcu_read_unlock();
+
+	return 0;
+}
+
+int mt7996_init_band_debugfs(struct mt7996_phy *phy)
+{
+	struct mt7996_dev *dev = phy->dev;
 	struct dentry *dir;
+	char dir_name[10];
 
-	dir = mt76_register_debugfs_fops(&dev->mphy, NULL);
+	if (!dev->debugfs_dir)
+		return -EINVAL;
+
+	snprintf(dir_name, sizeof(dir_name), "band%d", phy->mt76->band_idx);
+
+	dir = debugfs_create_dir(dir_name, dev->debugfs_dir);
 	if (!dir)
 		return -ENOMEM;
 
-	debugfs_create_file("hw-queues", 0400, dir, dev,
+	debugfs_create_file("hw-queues", 0400, dir, phy,
 			    &mt7996_hw_queues_fops);
-	debugfs_create_file("xmit-queues", 0400, dir, dev,
+	debugfs_create_file("xmit-queues", 0400, dir, phy,
 			    &mt7996_xmit_queues_fops);
-	debugfs_create_file("tx_stats", 0400, dir, dev, &mt7996_tx_stats_fops);
-	debugfs_create_file("sys_recovery", 0600, dir, dev,
+	debugfs_create_file("sys_recovery", 0600, dir, phy,
 			    &mt7996_sys_recovery_ops);
+	debugfs_create_file("atf_enable", 0600, dir, phy, &fops_atf_enable);
+	debugfs_create_file("tx_stats", 0400, dir, phy, &mt7996_tx_stats_fops);
+	if (phy->mt76->cap.has_5ghz) {
+		debugfs_create_u32("dfs_hw_pattern", 0400, dir,
+				   &dev->hw_pattern);
+		debugfs_create_file("radar_trigger", 0200, dir, dev,
+				    &fops_radar_trigger);
+		debugfs_create_devm_seqfile(dev->mt76.dev, "rdd_monitor", dir,
+					    mt7996_rdd_monitor);
+	}
+
+#ifdef CONFIG_MTK_DEBUG
+	mt7996_mtk_init_band_debugfs(phy, dir);
+	mt7996_mtk_init_band_debugfs_internal(phy, dir);
+#endif
+	return 0;
+}
+
+int mt7996_init_dev_debugfs(struct mt7996_phy *phy)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct dentry *dir;
+
+	dir = mt76_register_debugfs_fops(phy->mt76, NULL);
+	if (!dir)
+		return -ENOMEM;
 	debugfs_create_file("fw_debug_wm", 0600, dir, dev, &fops_fw_debug_wm);
 	debugfs_create_file("fw_debug_wa", 0600, dir, dev, &fops_fw_debug_wa);
 	debugfs_create_file("fw_debug_bin", 0600, dir, dev, &fops_fw_debug_bin);
+	debugfs_create_file("idxlog_enable", 0600, dir, dev, &fops_idxlog_enable);
 	/* TODO: wm fw cpu utilization */
 	debugfs_create_file("fw_util_wa", 0400, dir, dev,
 			    &mt7996_fw_util_wa_fops);
@@ -893,14 +1222,26 @@ int mt7996_init_debugfs(struct mt7996_dev *dev)
 	debugfs_create_devm_seqfile(dev->mt76.dev, "twt_stats", dir,
 				    mt7996_twt_stats);
 	debugfs_create_file("rf_regval", 0600, dir, dev, &fops_rf_regval);
+	debugfs_create_file("otp", 0400, dir, dev, &mt7996_efuse_ops);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "vow_info", dir,
+	                            mt7996_vow_info_read);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "airtime", dir,
+	                            mt7996_airtime_read);
+
+	debugfs_create_file("fw_debug_muru_disable", 0600, dir, dev,
+			    &fops_fw_debug_muru_disable);
+
+	if (phy == &dev->phy) {
+		dev->debugfs_dir = dir;
+#ifdef CONFIG_MTK_DEBUG
+		mt7996_mtk_init_dev_debugfs_internal(phy, dir);
+#endif
+	}
 
-	debugfs_create_u32("dfs_hw_pattern", 0400, dir, &dev->hw_pattern);
-	debugfs_create_file("radar_trigger", 0200, dir, dev,
-			    &fops_radar_trigger);
-	debugfs_create_devm_seqfile(dev->mt76.dev, "rdd_monitor", dir,
-				    mt7996_rdd_monitor);
-
-	dev->debugfs_dir = dir;
+#ifdef CONFIG_MTK_DEBUG
+	debugfs_create_u16("wlan_idx", 0600, dir, &dev->wlan_idx);
+	mt7996_mtk_init_dev_debugfs(dev, dir);
+#endif
 
 	return 0;
 }
@@ -913,7 +1254,11 @@ mt7996_debugfs_write_fwlog(struct mt7996_dev *dev, const void *hdr, int hdrlen,
 	unsigned long flags;
 	void *dest;
 
+	if (!dev->relay_fwlog)
+		return;
+
 	spin_lock_irqsave(&lock, flags);
+
 	dest = relay_reserve(dev->relay_fwlog, hdrlen + len + 4);
 	if (dest) {
 		*(u32 *)dest = hdrlen + len;
@@ -930,6 +1275,32 @@ mt7996_debugfs_write_fwlog(struct mt7996_dev *dev, const void *hdr, int hdrlen,
 	spin_unlock_irqrestore(&lock, flags);
 }
 
+static void
+mt7996_debugfs_write_idxlog(struct mt7996_dev *dev, const void *data, int len)
+{
+	static DEFINE_SPINLOCK(lock);
+	unsigned long flags;
+	void *dest;
+
+	if (!dev->relay_idxlog)
+		return;
+
+	spin_lock_irqsave(&lock, flags);
+
+	dest = relay_reserve(dev->relay_idxlog, len + 4);
+	if (!dest)
+		dev_err(dev->mt76.dev, "Failed to reserve slot in %s\n",
+		        dev->relay_idxlog->base_filename);
+	else {
+		*(u32 *)dest = len;
+		dest += 4;
+		memcpy(dest, data, len);
+		relay_flush(dev->relay_idxlog);
+	}
+
+	spin_unlock_irqrestore(&lock, flags);
+}
+
 void mt7996_debugfs_rx_fw_monitor(struct mt7996_dev *dev, const void *data, int len)
 {
 	struct {
@@ -957,11 +1328,18 @@ void mt7996_debugfs_rx_fw_monitor(struct mt7996_dev *dev, const void *data, int
 
 bool mt7996_debugfs_rx_log(struct mt7996_dev *dev, const void *data, int len)
 {
-	if (get_unaligned_le32(data) != FW_BIN_LOG_MAGIC)
-		return false;
+	bool is_fwlog = get_unaligned_le32(data) == FW_BIN_LOG_MAGIC;
+#ifdef CONFIG_MTK_DEBUG
+	is_fwlog |= get_unaligned_le32(data) == PKT_BIN_DEBUG_MAGIC;
+#endif
 
-	if (dev->relay_fwlog)
-		mt7996_debugfs_write_fwlog(dev, NULL, 0, data, len);
+	if (is_fwlog) {
+		if (dev->relay_fwlog)
+			mt7996_debugfs_write_fwlog(dev, NULL, 0, data, len);
+	} else if (dev->relay_idxlog)
+		mt7996_debugfs_write_idxlog(dev, data, len);
+	else
+		return false;
 
 	return true;
 }
@@ -1046,11 +1424,352 @@ mt7996_queues_show(struct seq_file *s, void *data)
 
 DEFINE_SHOW_ATTRIBUTE(mt7996_queues);
 
+static int
+mt7996_sta_links_info_show(struct seq_file *s, void *data)
+{
+	struct ieee80211_sta *sta = s->private;
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	u64 tx_cnt = 0, tx_fails = 0, tx_retries = 0, rx_cnt = 0;
+	struct mt7996_dev *dev = msta->vif->dev;
+	unsigned long valid_links;
+	u8 link_id;
+
+	seq_printf(s, "primary link, link ID = %d\n", msta->deflink_id);
+	seq_printf(s, "secondary link, link ID = %d\n", msta->sec_link);
+	seq_printf(s, "valid links = 0x%x\n", sta->valid_links);
+
+	mutex_lock(&dev->mt76.mutex);
+	valid_links = sta->valid_links ?: BIT(0);
+	for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		struct mt7996_sta_link *msta_link =
+			mt76_dereference(msta->link[link_id], &dev->mt76);
+		struct mt76_wcid *wcid;
+
+		if (!msta_link)
+			continue;
+
+		wcid = &msta_link->wcid;
+
+		tx_cnt += wcid->stats.tx_packets;
+		tx_fails += wcid->stats.tx_packets_failed;
+		tx_retries += wcid->stats.tx_packets_retried;
+		rx_cnt += wcid->stats.rx_packets;
+
+		seq_printf(s, "link%d: wcid=%d, phy=%d, link_valid=%d, ampdu_state=0x%lx\n",
+			    wcid->link_id, wcid->idx, wcid->phy_idx, wcid->link_valid,
+			    wcid->ampdu_state);
+	}
+	mutex_unlock(&dev->mt76.mutex);
+
+	/* PER may be imprecise, because MSDU total and failed counts
+	 * are updated at different times.
+	 */
+	seq_printf(s, "TX MSDU Count: %llu\n", tx_cnt);
+	seq_printf(s, "TX MSDU Fails: %llu (PER: %llu.%llu%%)\n", tx_fails,
+		   tx_cnt ? tx_fails * 1000 / tx_cnt / 10 : 0,
+		   tx_cnt ? tx_fails * 1000 / tx_cnt % 10 : 0);
+	seq_printf(s, "TX MSDU Retries: %llu\n", tx_retries);
+	seq_printf(s, "RX MSDU Count: %llu\n", rx_cnt);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_sta_links_info);
+
 void mt7996_sta_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			    struct ieee80211_sta *sta, struct dentry *dir)
 {
 	debugfs_create_file("fixed_rate", 0600, dir, sta, &fops_fixed_rate);
 	debugfs_create_file("hw-queues", 0400, dir, sta, &mt7996_queues_fops);
+	debugfs_create_file("mt76_links_info", 0400, dir, sta,
+			    &mt7996_sta_links_info_fops);
 }
 
+static int
+mt7996_vif_links_info_show(struct seq_file *s, void *data)
+{
+	struct ieee80211_vif *vif = s->private;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_dev *dev = mvif->dev;
+	struct mt7996_vif_link *mconf;
+	struct mt7996_sta_link *msta_link;
+	unsigned long valid_links;
+	u8 link_id, i;
+
+	static const char* width_to_bw[] = {
+		[NL80211_CHAN_WIDTH_40] = "40",
+		[NL80211_CHAN_WIDTH_80] = "80",
+		[NL80211_CHAN_WIDTH_80P80] = "80+80",
+		[NL80211_CHAN_WIDTH_160] = "160",
+		[NL80211_CHAN_WIDTH_5] = "5",
+		[NL80211_CHAN_WIDTH_10] = "10",
+		[NL80211_CHAN_WIDTH_20] = "20",
+		[NL80211_CHAN_WIDTH_20_NOHT] = "20_NOHT",
+		[NL80211_CHAN_WIDTH_320] = "320",
+	};
+
+	seq_printf(s, "master link id = %d\n", mvif->mt76.deflink_id);
+	seq_printf(s, "group mld id = %d\n", mvif->mld_group_idx);
+	seq_printf(s, "mld remap id = %d\n", mvif->mld_remap_idx);
+
+	seq_printf(s, "valid links = 0x%x\n", vif->valid_links);
+	for (i = 0; i < __MT_MAX_BAND; i++)
+		seq_printf(s, "band%d_link_id = %d\n", i, mvif->mt76.band_to_link[i]);
+
+	mutex_lock(&dev->mt76.mutex);
+	valid_links = vif->valid_links ?: BIT(0);
+	for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		mconf = mt7996_vif_link(dev, vif, link_id);
+		msta_link = mt76_dereference(mvif->sta.link[link_id], &dev->mt76);
+
+		if (!mconf || !msta_link)
+			continue;
+
+		seq_printf(s, "- link[%02d]: bss_idx = %d, wcid = %d\n",
+			   msta_link->wcid.link_id, mconf->mt76.idx, msta_link->wcid.idx);
+		seq_printf(s, "            omac_idx = %d, mld_idx=%d\n",
+			   mconf->mt76.omac_idx, mconf->mld_idx);
+
+		if (!mconf->phy->mt76->chanctx)
+			continue;
+
+		seq_printf(s, "            band_idx=%d, channel=%d, bw%s\n",
+			   mconf->mt76.band_idx,
+			   mconf->phy->mt76->chanctx->chandef.chan->hw_value,
+			   width_to_bw[mconf->phy->mt76->chanctx->chandef.width]);
+	}
+	mutex_unlock(&dev->mt76.mutex);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_vif_links_info);
+
+void mt7996_vif_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+{
+	debugfs_create_file("mt76_links_info", 0400, vif->debugfs_dir, vif,
+			    &mt7996_vif_links_info_fops);
+}
+
+static void
+mt7996_parse_rate(struct rate_info *rate, char *buf, size_t size)
+{
+	u32 bitrate = cfg80211_calculate_bitrate(rate);
+	bool legacy = false;
+	char *pos = buf;
+	enum {
+		GI_0_4,
+		GI_0_8,
+		GI_1_6,
+		GI_3_2
+	} gi = GI_0_8;
+
+	if (bitrate)
+		pos += snprintf(pos, size - (pos - buf), "%u.%u Mbit/s",
+				bitrate / 10, bitrate % 10);
+
+	if (rate->flags & RATE_INFO_FLAGS_MCS) {
+		pos += snprintf(pos, size - (pos - buf), " HT");
+
+		if (rate->flags & RATE_INFO_FLAGS_SHORT_GI)
+			gi = GI_0_4;
+	} else if (rate->flags & RATE_INFO_FLAGS_VHT_MCS) {
+		pos += snprintf(pos, size - (pos - buf), " VHT");
+
+		if (rate->flags & RATE_INFO_FLAGS_SHORT_GI)
+			gi = GI_0_4;
+	} else if (rate->flags & RATE_INFO_FLAGS_HE_MCS) {
+		pos += snprintf(pos, size - (pos - buf), " HE");
+
+		if (rate->he_gi == NL80211_RATE_INFO_HE_GI_1_6)
+			gi = GI_1_6;
+		else if (rate->he_gi == NL80211_RATE_INFO_HE_GI_3_2)
+			gi = GI_3_2;
+	} else if (rate->flags & RATE_INFO_FLAGS_EHT_MCS) {
+		pos += snprintf(pos, size - (pos - buf), " EHT");
+
+		if (rate->eht_gi == NL80211_RATE_INFO_EHT_GI_1_6)
+			gi = GI_1_6;
+		else if (rate->eht_gi == NL80211_RATE_INFO_EHT_GI_3_2)
+			gi = GI_3_2;
+	} else if (rate->legacy == 0) {
+		pos += snprintf(pos, size - (pos - buf), "Proprietary Long Range");
+	} else {
+		pos += snprintf(pos, size - (pos - buf), " Legacy");
+		legacy = true;
+	}
+
+	switch (rate->bw) {
+	case RATE_INFO_BW_20:
+		pos += snprintf(pos, size - (pos - buf), " 20MHz");
+		break;
+	case RATE_INFO_BW_40:
+		pos += snprintf(pos, size - (pos - buf), " 40MHz");
+		break;
+	case RATE_INFO_BW_80:
+		pos += snprintf(pos, size - (pos - buf), " 80MHz");
+		break;
+	case RATE_INFO_BW_160:
+		pos += snprintf(pos, size - (pos - buf), " 160MHz");
+		break;
+	case RATE_INFO_BW_320:
+		pos += snprintf(pos, size - (pos - buf), " 320MHz");
+		break;
+	case RATE_INFO_BW_HE_RU:
+		if (rate->he_ru_alloc == NL80211_RATE_INFO_HE_RU_ALLOC_106) {
+			pos += snprintf(pos, size - (pos - buf), " 106-tone RU");
+			break;
+		}
+		fallthrough;
+	default:
+		pos += snprintf(pos, size - (pos - buf), " (Unknown BW)");
+	}
+
+	if (!legacy) {
+		pos += snprintf(pos, size - (pos - buf), " MCS %hhu", rate->mcs);
+		pos += snprintf(pos, size - (pos - buf), " NSS %hhu", rate->nss);
+	}
+
+	switch (gi) {
+	case GI_0_4:
+		pos += snprintf(pos, size - (pos - buf), " GI 0.4us");
+		break;
+	case GI_0_8:
+		pos += snprintf(pos, size - (pos - buf), " GI 0.8us");
+		break;
+	case GI_1_6:
+		pos += snprintf(pos, size - (pos - buf), " GI 1.6us");
+		break;
+	default:
+		pos += snprintf(pos, size - (pos - buf), " GI 3.2us");
+		break;
+	}
+}
+
+static const char *ac_to_str(enum ieee80211_ac_numbers ac)
+{
+	static const char *ac_str[] = {
+		[IEEE80211_AC_VO] = "VO",
+		[IEEE80211_AC_VI] = "VI",
+		[IEEE80211_AC_BE] = "BE",
+		[IEEE80211_AC_BK] = "BK"
+	};
+
+	return ac_str[ac];
+}
+
+static int
+mt7996_link_sta_info_show(struct seq_file *file, void *data)
+{
+	struct ieee80211_link_sta *link_sta = file->private;
+	struct mt7996_sta *msta = (struct mt7996_sta *)link_sta->sta->drv_priv;
+	struct mt7996_sta_link *msta_link;
+	struct mt76_sta_stats *stats;
+	struct mt76_wcid *wcid;
+	char buf[100];
+	u8 ac;
+
+	mutex_lock(&msta->vif->dev->mt76.mutex);
+
+	msta_link = mt76_dereference(msta->link[link_sta->link_id], &msta->vif->dev->mt76);
+	if (!msta_link) {
+		mutex_unlock(&msta->vif->dev->mt76.mutex);
+		return -EINVAL;
+	}
+	wcid = &msta_link->wcid;
+	stats = &wcid->stats;
+
+	seq_printf(file, "WCID: %hu\n", wcid->idx);
+	seq_printf(file, "Link ID: %hhu\n", link_sta->link_id);
+	seq_printf(file, "Link Address: %pM\n", link_sta->addr);
+	seq_printf(file, "Status:\n");
+	seq_printf(file, "\tRSSI: %d [%hhd, %hhd, %hhd, %hhd] dBm\n",
+		   msta_link->signal, msta_link->chain_signal[0], msta_link->chain_signal[1],
+		   msta_link->chain_signal[2], msta_link->chain_signal[3]);
+	seq_printf(file, "\tACK RSSI: %d [%hhd, %hhd, %hhd, %hhd] dBm\n",
+		   msta_link->ack_signal, msta_link->chain_ack_signal[0],
+		   msta_link->chain_ack_signal[1], msta_link->chain_ack_signal[2],
+		   msta_link->chain_ack_signal[3]);
+	seq_printf(file, "\tACK SNR: [%hhd, %hhd, %hhd, %hhd] dBm\n",
+		   msta_link->chain_ack_snr[0], msta_link->chain_ack_snr[1],
+		   msta_link->chain_ack_snr[2], msta_link->chain_ack_snr[3]);
+	seq_printf(file, "Rate:\n");
+
+	mt7996_parse_rate(&wcid->rate, buf, sizeof(buf));
+	seq_printf(file, "\tTX: %s\n", buf);
+	mt7996_parse_rate(&wcid->rx_rate, buf, sizeof(buf));
+	seq_printf(file, "\tRX: %s\n", buf);
+
+	seq_printf(file, "Statistics:\n");
+	seq_printf(file, "\tTX:\n");
+	seq_printf(file, "\t\tByte Count: %llu\n", stats->tx_bytes);
+	for (ac = IEEE80211_AC_VO; ac < IEEE80211_NUM_ACS; ++ac)
+		seq_printf(file, "\t\t\t%s: %llu\n", ac_to_str(ac), stats->tx_bytes_per_ac[ac]);
+	seq_printf(file, "\t\tByte Fails: %llu\n", stats->tx_bytes_failed);
+	for (ac = IEEE80211_AC_VO; ac < IEEE80211_NUM_ACS; ++ac)
+		seq_printf(file, "\t\t\t%s: %llu\n", ac_to_str(ac), stats->tx_bytes_failed_per_ac[ac]);
+	seq_printf(file, "\t\tMPDU Count: %u\n", stats->tx_mpdus);
+	seq_printf(file, "\t\tMPDU Fails: %u (PER: %u.%u%%)\n", stats->tx_failed,
+		   stats->tx_mpdus ? stats->tx_failed * 1000 / stats->tx_mpdus / 10 : 0,
+		   stats->tx_mpdus ? stats->tx_failed * 1000 / stats->tx_mpdus % 10 : 0);
+	seq_printf(file, "\t\tMPDU Retries: %u\n", stats->tx_retries);
+	seq_printf(file, "\t\tAirtime: %llu (unit: 1.024 us)\n", stats->tx_airtime);
+	seq_printf(file, "\tRX:\n");
+	seq_printf(file, "\t\tByte Count: %llu\n", stats->rx_bytes);
+	for (ac = IEEE80211_AC_VO; ac < IEEE80211_NUM_ACS; ++ac)
+		seq_printf(file, "\t\t\t%s: %llu\n", ac_to_str(ac), stats->rx_bytes_per_ac[ac]);
+	seq_printf(file, "\t\tMPDU Count: %u\n", stats->rx_mpdus);
+	seq_printf(file, "\t\tMPDU FCS Errors: %u (PER: %u.%u%%)\n", stats->rx_fcs_err,
+		   stats->rx_mpdus ? stats->rx_fcs_err * 1000 / stats->rx_mpdus / 10 : 0,
+		   stats->rx_mpdus ? stats->rx_fcs_err * 1000 / stats->rx_mpdus % 10 : 0);
+	seq_printf(file, "\t\tAirtime: %llu (unit: 1.024 us)\n", stats->rx_airtime);
+
+	mutex_unlock(&msta->vif->dev->mt76.mutex);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_link_sta_info);
+
+void mt7996_link_sta_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+				 struct ieee80211_link_sta *link_sta,
+				 struct dentry *dir)
+{
+	debugfs_create_file("link_sta_info", 0400, dir, link_sta,
+			    &mt7996_link_sta_info_fops);
+}
+
+static int
+mt7996_link_info_show(struct seq_file *file, void *data)
+{
+	struct ieee80211_bss_conf *conf = file->private;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)conf->vif->drv_priv;
+	struct mt7996_sta *msta = &mvif->sta;
+	struct mt7996_vif_link *mconf;
+	struct mt7996_sta_link *msta_link;
+	struct mt7996_dev *dev = mvif->dev;
+	struct rate_info *r;
+
+	mutex_lock(&dev->mt76.mutex);
+
+	mconf = mt7996_vif_link(dev, conf->vif, conf->link_id);
+	msta_link = mt76_dereference(msta->link[conf->link_id], &dev->mt76);
+	if (!mconf || !msta_link) {
+		mutex_unlock(&dev->mt76.mutex);
+		return -EINVAL;
+	}
+
+	r = &msta_link->wcid.rate;
+	seq_printf(file, "band mapping=%u\n", mconf->phy->mt76->band_idx);
+	seq_printf(file, "tx rate: flags=0x%x,legacy=%u,mcs=%u,nss=%u,bw=%u,he_gi=%u,he_dcm=%u,he_ru_alloc=%u,eht_gi=%u,eht_ru_alloc=%u\n",
+		   r->flags, r->legacy, r->mcs, r->nss, r->bw, r->he_gi, r->he_dcm, r->he_ru_alloc, r->eht_gi, r->eht_ru_alloc);
+
+	mutex_unlock(&dev->mt76.mutex);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_link_info);
+
+void mt7996_link_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			     struct ieee80211_bss_conf *link_conf, struct dentry *dir)
+{
+	debugfs_create_file("link_info", 0600, dir, link_conf, &mt7996_link_info_fops);
+}
 #endif
diff --git a/mt7996/dma.c b/mt7996/dma.c
index 2d2fde12..2e1a0061 100644
--- a/mt7996/dma.c
+++ b/mt7996/dma.c
@@ -12,12 +12,20 @@ int mt7996_init_tx_queues(struct mt7996_phy *phy, int idx, int n_desc,
 {
 	struct mt7996_dev *dev = phy->dev;
 	u32 flags = 0;
+	int i;
+
+	if (phy->mt76->band_idx == MT_BAND1 && !dev->hif2 && is_mt7996(&dev->mt76)) {
+		phy->mt76->q_tx[0] = phy->mt76->dev->phys[MT_BAND0]->q_tx[0];
+		for (i = 1; i <= MT_TXQ_PSD; i++)
+			phy->mt76->q_tx[i] = phy->mt76->q_tx[0];
+		return 0;
+	}
 
 	if (mtk_wed_device_active(wed)) {
 		ring_base += MT_TXQ_ID(0) * MT_RING_SIZE;
 		idx -= MT_TXQ_ID(0);
 
-		if (phy->mt76->band_idx == MT_BAND2)
+		if (wed == &dev->mt76.mmio.wed_hif2)
 			flags = MT_WED_Q_TX(0);
 		else
 			flags = MT_WED_Q_TX(idx);
@@ -89,30 +97,55 @@ static void mt7996_dma_config(struct mt7996_dev *dev)
 			   MT7996_RXQ_RRO_BAND0);
 		RXQ_CONFIG(MT_RXQ_MSDU_PAGE_BAND0, WFDMA0, MT_INT_RX_DONE_MSDU_PG_BAND0,
 			   MT7996_RXQ_MSDU_PG_BAND0);
-		RXQ_CONFIG(MT_RXQ_TXFREE_BAND0, WFDMA0, MT_INT_RX_TXFREE_MAIN,
-			   MT7996_RXQ_TXFREE0);
-		/* band1 */
-		RXQ_CONFIG(MT_RXQ_MSDU_PAGE_BAND1, WFDMA0, MT_INT_RX_DONE_MSDU_PG_BAND1,
-			   MT7996_RXQ_MSDU_PG_BAND1);
-		/* band2 */
-		RXQ_CONFIG(MT_RXQ_RRO_BAND2, WFDMA0, MT_INT_RX_DONE_RRO_BAND2,
-			   MT7996_RXQ_RRO_BAND2);
-		RXQ_CONFIG(MT_RXQ_MSDU_PAGE_BAND2, WFDMA0, MT_INT_RX_DONE_MSDU_PG_BAND2,
-			   MT7996_RXQ_MSDU_PG_BAND2);
-		RXQ_CONFIG(MT_RXQ_TXFREE_BAND2, WFDMA0, MT_INT_RX_TXFREE_TRI,
-			   MT7996_RXQ_TXFREE2);
+		if (is_mt7996(&dev->mt76)) {
+			RXQ_CONFIG(MT_RXQ_TXFREE_BAND0, WFDMA0, MT_INT_RX_TXFREE_MAIN,
+				   MT7996_RXQ_TXFREE0);
+			/* band1 */
+			RXQ_CONFIG(MT_RXQ_MSDU_PAGE_BAND1, WFDMA0, MT_INT_RX_DONE_MSDU_PG_BAND1,
+				   MT7996_RXQ_MSDU_PG_BAND1);
+			/* band2 */
+			RXQ_CONFIG(MT_RXQ_RRO_BAND2, WFDMA0, MT_INT_RX_DONE_RRO_BAND2,
+				   MT7996_RXQ_RRO_BAND2);
+			RXQ_CONFIG(MT_RXQ_MSDU_PAGE_BAND2, WFDMA0, MT_INT_RX_DONE_MSDU_PG_BAND2,
+				   MT7996_RXQ_MSDU_PG_BAND2);
+			RXQ_CONFIG(MT_RXQ_TXFREE_BAND2, WFDMA0, MT_INT_RX_TXFREE_TRI,
+				   MT7996_RXQ_TXFREE2);
+		} else {
+			RXQ_CONFIG(MT_RXQ_RRO_BAND1, WFDMA0, MT_INT_RX_DONE_RRO_BAND1,
+				   MT7996_RXQ_RRO_BAND1);
+		}
 
 		RXQ_CONFIG(MT_RXQ_RRO_IND, WFDMA0, MT_INT_RX_DONE_RRO_IND,
 			   MT7996_RXQ_RRO_IND);
 	}
 
 	/* data tx queue */
-	TXQ_CONFIG(0, WFDMA0, MT_INT_TX_DONE_BAND0, MT7996_TXQ_BAND0);
 	if (is_mt7996(&dev->mt76)) {
-		TXQ_CONFIG(1, WFDMA0, MT_INT_TX_DONE_BAND1, MT7996_TXQ_BAND1);
-		TXQ_CONFIG(2, WFDMA0, MT_INT_TX_DONE_BAND2, MT7996_TXQ_BAND2);
+		TXQ_CONFIG(0, WFDMA0, MT_INT_TX_DONE_BAND0, MT7996_TXQ_BAND0);
+		if (dev->hif2) {
+			if (dev->option_type == 2) {
+				/*  bn1:ring21 bn2:ring19 */
+				TXQ_CONFIG(1, WFDMA0, MT_INT_TX_DONE_BAND2, MT7996_TXQ_BAND2);
+				TXQ_CONFIG(2, WFDMA0, MT_INT_TX_DONE_BAND1, MT7996_TXQ_BAND1);
+			} else {
+				/* default bn1:ring19 bn2:ring21 */
+				TXQ_CONFIG(1, WFDMA0, MT_INT_TX_DONE_BAND1, MT7996_TXQ_BAND1);
+				TXQ_CONFIG(2, WFDMA0, MT_INT_TX_DONE_BAND2, MT7996_TXQ_BAND2);
+			}
+		} else {
+			/* single pcie bn0/1:ring18 bn2:ring19 */
+			TXQ_CONFIG(2, WFDMA0, MT_INT_TX_DONE_BAND1, MT7996_TXQ_BAND1);
+		}
 	} else {
-		TXQ_CONFIG(1, WFDMA0, MT_INT_TX_DONE_BAND1, MT7996_TXQ_BAND1);
+		if (dev->hif2) {
+			/*  bn0:ring18 bn1:ring21 */
+			TXQ_CONFIG(0, WFDMA0, MT_INT_TX_DONE_BAND0, MT7996_TXQ_BAND0);
+			TXQ_CONFIG(1, WFDMA0, MT_INT_TX_DONE_BAND2, MT7996_TXQ_BAND2);
+		} else {
+			/* single pcie bn0:ring18 bn1:ring19 */
+			TXQ_CONFIG(0, WFDMA0, MT_INT_TX_DONE_BAND0, MT7996_TXQ_BAND0);
+			TXQ_CONFIG(1, WFDMA0, MT_INT_TX_DONE_BAND1, MT7996_TXQ_BAND1);
+		}
 	}
 
 	/* mcu tx queue */
@@ -288,8 +321,11 @@ void mt7996_dma_start(struct mt7996_dev *dev, bool reset, bool wed_reset)
 	if (mt7996_band_valid(dev, MT_BAND0))
 		irq_mask |= MT_INT_BAND0_RX_DONE;
 
-	if (mt7996_band_valid(dev, MT_BAND1))
+	if (mt7996_band_valid(dev, MT_BAND1)) {
 		irq_mask |= MT_INT_BAND1_RX_DONE;
+		if (is_mt7992(&dev->mt76) && dev->hif2)
+			irq_mask |= MT_INT_RX_TXFREE_BAND1_EXT;
+	}
 
 	if (mt7996_band_valid(dev, MT_BAND2))
 		irq_mask |= MT_INT_BAND2_RX_DONE;
@@ -378,13 +414,60 @@ static void mt7996_dma_enable(struct mt7996_dev *dev, bool reset)
 			 WF_WFDMA0_GLO_CFG_EXT1_TX_FCTRL_MODE);
 
 		mt76_set(dev, MT_WFDMA_HOST_CONFIG,
-			 MT_WFDMA_HOST_CONFIG_PDMA_BAND |
-			 MT_WFDMA_HOST_CONFIG_BAND2_PCIE1);
+			 MT_WFDMA_HOST_CONFIG_PDMA_BAND);
+
+		mt76_clear(dev, MT_WFDMA_HOST_CONFIG,
+			   MT_WFDMA_HOST_CONFIG_BAND0_PCIE1 |
+			   MT_WFDMA_HOST_CONFIG_BAND1_PCIE1 |
+			   MT_WFDMA_HOST_CONFIG_BAND2_PCIE1);
+
+		switch (dev->option_type) {
+		case 2:
+			/* eagle + 7988d */
+			if (is_mt7996(&dev->mt76))
+				mt76_set(dev, MT_WFDMA_HOST_CONFIG,
+					 MT_WFDMA_HOST_CONFIG_BAND0_PCIE1 |
+					 MT_WFDMA_HOST_CONFIG_BAND1_PCIE1);
+			else
+				mt76_set(dev, MT_WFDMA_HOST_CONFIG,
+					 MT_WFDMA_HOST_CONFIG_BAND1_PCIE1);
+			break;
+		case 3:
+			mt76_set(dev, MT_WFDMA_HOST_CONFIG,
+				 MT_WFDMA_HOST_CONFIG_BAND0_PCIE1);
+
+			break;
+		default:
+			if (is_mt7996(&dev->mt76))
+				mt76_set(dev, MT_WFDMA_HOST_CONFIG,
+					 MT_WFDMA_HOST_CONFIG_BAND2_PCIE1);
+			else
+				mt76_set(dev, MT_WFDMA_HOST_CONFIG,
+					 MT_WFDMA_HOST_CONFIG_BAND1_PCIE1);
+			break;
+		}
 
 		/* AXI read outstanding number */
 		mt76_rmw(dev, MT_WFDMA_AXI_R2A_CTRL,
 			 MT_WFDMA_AXI_R2A_CTRL_OUTSTAND_MASK, 0x14);
 
+		if (dev->hif2->speed < PCIE_SPEED_5_0GT ||
+		    (dev->hif2->speed == PCIE_SPEED_5_0GT && dev->hif2->width < 2)) {
+			mt76_rmw(dev, WF_WFDMA0_GLO_CFG_EXT0 + hif1_ofs,
+				 WF_WFDMA0_GLO_CFG_EXT0_OUTSTAND_MASK,
+				 FIELD_PREP(WF_WFDMA0_GLO_CFG_EXT0_OUTSTAND_MASK, 0x1));
+			mt76_rmw(dev, MT_WFDMA_AXI_R2A_CTRL2,
+				 MT_WFDMA_AXI_R2A_CTRL2_OUTSTAND_MASK,
+				 FIELD_PREP(MT_WFDMA_AXI_R2A_CTRL2_OUTSTAND_MASK, 0x1));
+		} else if (dev->hif2->speed < PCIE_SPEED_8_0GT ||
+			   (dev->hif2->speed == PCIE_SPEED_8_0GT && dev->hif2->width < 2)) {
+			mt76_rmw(dev, WF_WFDMA0_GLO_CFG_EXT0 + hif1_ofs,
+				 WF_WFDMA0_GLO_CFG_EXT0_OUTSTAND_MASK,
+				 FIELD_PREP(WF_WFDMA0_GLO_CFG_EXT0_OUTSTAND_MASK, 0x2));
+			mt76_rmw(dev, MT_WFDMA_AXI_R2A_CTRL2,
+				 MT_WFDMA_AXI_R2A_CTRL2_OUTSTAND_MASK,
+				 FIELD_PREP(MT_WFDMA_AXI_R2A_CTRL2_OUTSTAND_MASK, 0x2));
+		}
 		/* WFDMA rx threshold */
 		mt76_wr(dev, MT_WFDMA0_PAUSE_RX_Q_45_TH + hif1_ofs, 0xc000c);
 		mt76_wr(dev, MT_WFDMA0_PAUSE_RX_Q_67_TH + hif1_ofs, 0x10008);
@@ -397,12 +480,17 @@ static void mt7996_dma_enable(struct mt7996_dev *dev, bool reset)
 		 * so, redirect pcie0 rx ring3 interrupt to pcie1
 		 */
 		if (mtk_wed_device_active(&dev->mt76.mmio.wed) &&
-		    dev->has_rro)
+		    dev->has_rro) {
+			u32 intr = is_mt7996(&dev->mt76) ?
+				   MT_WFDMA0_RX_INT_SEL_RING6 :
+				   MT_WFDMA0_RX_INT_SEL_RING9 |
+				   MT_WFDMA0_RX_INT_SEL_RING5;
 			mt76_set(dev, MT_WFDMA0_RX_INT_PCIE_SEL + hif1_ofs,
-				 MT_WFDMA0_RX_INT_SEL_RING6);
-		else
+				 intr);
+		} else {
 			mt76_set(dev, MT_WFDMA0_RX_INT_PCIE_SEL,
 				 MT_WFDMA0_RX_INT_SEL_RING3);
+		}
 	}
 
 	mt7996_dma_start(dev, reset, true);
@@ -437,7 +525,7 @@ int mt7996_dma_rro_init(struct mt7996_dev *dev)
 	if (ret)
 		return ret;
 
-	if (mt7996_band_valid(dev, MT_BAND1)) {
+	if (mt7996_band_valid(dev, MT_BAND1) && is_mt7996(&dev->mt76)) {
 		/* rx msdu page queue for band1 */
 		mdev->q_rx[MT_RXQ_MSDU_PAGE_BAND1].flags =
 			MT_WED_RRO_Q_MSDU_PG(1) | MT_QFLAG_WED_RRO_EN;
@@ -560,7 +648,9 @@ int mt7996_dma_init(struct mt7996_dev *dev)
 		return ret;
 
 	/* tx free notify event from WA for band0 */
-	if (mtk_wed_device_active(wed) && !dev->has_rro) {
+	if (mtk_wed_device_active(wed) &&
+	    ((is_mt7996(&dev->mt76) && !dev->has_rro) ||
+	     (is_mt7992(&dev->mt76)))) {
 		dev->mt76.q_rx[MT_RXQ_MAIN_WA].flags = MT_WED_Q_TXFREE;
 		dev->mt76.q_rx[MT_RXQ_MAIN_WA].wed = wed;
 	}
@@ -604,6 +694,10 @@ int mt7996_dma_init(struct mt7996_dev *dev)
 	if (mt7996_band_valid(dev, MT_BAND2)) {
 		/* rx data queue for mt7996 band2 */
 		rx_base = MT_RXQ_RING_BASE(MT_RXQ_BAND2) + hif1_ofs;
+		if (mtk_wed_device_active(wed_hif2) && mtk_wed_get_rx_capa(wed_hif2)) {
+			dev->mt76.q_rx[MT_RXQ_BAND2].flags = MT_WED_Q_RX(0);
+			dev->mt76.q_rx[MT_RXQ_BAND2].wed = wed_hif2;
+		}
 		ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_BAND2],
 				       MT_RXQ_ID(MT_RXQ_BAND2),
 				       MT7996_RX_RING_SIZE,
@@ -630,6 +724,11 @@ int mt7996_dma_init(struct mt7996_dev *dev)
 	} else if (mt7996_band_valid(dev, MT_BAND1)) {
 		/* rx data queue for mt7992 band1 */
 		rx_base = MT_RXQ_RING_BASE(MT_RXQ_BAND1) + hif1_ofs;
+		if (mtk_wed_device_active(wed) && mtk_wed_get_rx_capa(wed)) {
+			dev->mt76.q_rx[MT_RXQ_BAND1].flags = MT_WED_Q_RX(1);
+			dev->mt76.q_rx[MT_RXQ_BAND1].wed = wed;
+		}
+
 		ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_BAND1],
 				       MT_RXQ_ID(MT_RXQ_BAND1),
 				       MT7996_RX_RING_SIZE,
@@ -641,6 +740,10 @@ int mt7996_dma_init(struct mt7996_dev *dev)
 		/* tx free notify event from WA for mt7992 band1 */
 		if (mt7996_has_wa(dev)) {
 			rx_base = MT_RXQ_RING_BASE(MT_RXQ_BAND1_WA) + hif1_ofs;
+			if (mtk_wed_device_active(wed_hif2)) {
+				dev->mt76.q_rx[MT_RXQ_BAND1_WA].flags = MT_WED_Q_TXFREE;
+				dev->mt76.q_rx[MT_RXQ_BAND1_WA].wed = wed_hif2;
+			}
 			ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_BAND1_WA],
 					       MT_RXQ_ID(MT_RXQ_BAND1_WA),
 					       MT7996_RX_MCU_RING_SIZE,
@@ -665,17 +768,30 @@ int mt7996_dma_init(struct mt7996_dev *dev)
 		if (ret)
 			return ret;
 
-		/* tx free notify event from WA for band0 */
-		dev->mt76.q_rx[MT_RXQ_TXFREE_BAND0].flags = MT_WED_Q_TXFREE;
-		dev->mt76.q_rx[MT_RXQ_TXFREE_BAND0].wed = wed;
+		if (is_mt7992(&dev->mt76)) {
+			dev->mt76.q_rx[MT_RXQ_RRO_BAND1].flags =
+				MT_WED_RRO_Q_DATA(1) | MT_QFLAG_WED_RRO_EN;
+			dev->mt76.q_rx[MT_RXQ_RRO_BAND1].wed = wed;
+			ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_RRO_BAND1],
+					       MT_RXQ_ID(MT_RXQ_RRO_BAND1),
+					       MT7996_RX_RING_SIZE,
+					       MT7996_RX_BUF_SIZE,
+					       MT_RXQ_RING_BASE(MT_RXQ_RRO_BAND1) + hif1_ofs);
+			if (ret)
+				return ret;
+		} else {
+			/* tx free notify event from WA for band0 */
+			dev->mt76.q_rx[MT_RXQ_TXFREE_BAND0].flags = MT_WED_Q_TXFREE;
+			dev->mt76.q_rx[MT_RXQ_TXFREE_BAND0].wed = wed;
 
-		ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_TXFREE_BAND0],
-				       MT_RXQ_ID(MT_RXQ_TXFREE_BAND0),
-				       MT7996_RX_MCU_RING_SIZE,
-				       MT7996_RX_BUF_SIZE,
-				       MT_RXQ_RING_BASE(MT_RXQ_TXFREE_BAND0));
-		if (ret)
-			return ret;
+			ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_TXFREE_BAND0],
+					       MT_RXQ_ID(MT_RXQ_TXFREE_BAND0),
+					       MT7996_RX_MCU_RING_SIZE,
+					       MT7996_RX_BUF_SIZE,
+					       MT_RXQ_RING_BASE(MT_RXQ_TXFREE_BAND0));
+			if (ret)
+				return ret;
+		}
 
 		if (mt7996_band_valid(dev, MT_BAND2)) {
 			/* rx rro data queue for band2 */
@@ -747,11 +863,23 @@ void mt7996_dma_reset(struct mt7996_dev *dev, bool force)
 	for (i = 0; i < __MT_MCUQ_MAX; i++)
 		mt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[i], true);
 
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER tx queue clean up done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
+
 	mt76_for_each_q_rx(&dev->mt76, i)
 		mt76_queue_rx_cleanup(dev, &dev->mt76.q_rx[i]);
 
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER rx queue clean up done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
+
 	mt76_tx_status_check(&dev->mt76, true);
 
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER mt76_tx_status_check done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
+
 	/* reset wfsys */
 	if (force)
 		mt7996_wfsys_reset(dev);
@@ -762,7 +890,15 @@ void mt7996_dma_reset(struct mt7996_dev *dev, bool force)
 	if (mtk_wed_device_active(&dev->mt76.mmio.wed))
 		mtk_wed_device_dma_reset(&dev->mt76.mmio.wed);
 
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER wed dma reset done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
+
 	mt7996_dma_disable(dev, force);
+
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER dma disable done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
 	mt76_wed_dma_reset(&dev->mt76);
 
 	/* reset hw queues */
@@ -774,24 +910,53 @@ void mt7996_dma_reset(struct mt7996_dev *dev, bool force)
 			mt76_dma_reset_tx_queue(&dev->mt76, phy3->q_tx[i]);
 	}
 
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER dma tx queue reset done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
+
 	for (i = 0; i < __MT_MCUQ_MAX; i++)
-		mt76_queue_reset(dev, dev->mt76.q_mcu[i]);
+		mt76_queue_reset(dev, dev->mt76.q_mcu[i], true);
 
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER mcu queue reset done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
 	mt76_for_each_q_rx(&dev->mt76, i) {
-		if (mtk_wed_device_active(&dev->mt76.mmio.wed))
+		if (mtk_wed_device_active(&dev->mt76.mmio.wed)) {
 			if (mt76_queue_is_wed_rro(&dev->mt76.q_rx[i]) ||
-			    mt76_queue_is_wed_tx_free(&dev->mt76.q_rx[i]))
+			    mt76_queue_is_wed_tx_free(&dev->mt76.q_rx[i])) {
+				if (force && mt76_queue_is_wed_rro_data(&dev->mt76.q_rx[i]))
+					mt76_queue_reset(dev, &dev->mt76.q_rx[i], false);
 				continue;
+			}
+		}
 
-		mt76_queue_reset(dev, &dev->mt76.q_rx[i]);
+		mt76_queue_reset(dev, &dev->mt76.q_rx[i], true);
 	}
 
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER rx queue reset done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
+
 	mt76_tx_status_check(&dev->mt76, true);
 
-	mt76_for_each_q_rx(&dev->mt76, i)
+	mt76_for_each_q_rx(&dev->mt76, i) {
+		if (mtk_wed_device_active(&dev->mt76.mmio.wed) && force &&
+		    (mt76_queue_is_wed_rro_ind(&dev->mt76.q_rx[i]) ||
+		     mt76_queue_is_wed_rro_msdu_pg(&dev->mt76.q_rx[i])))
+			continue;
+
 		mt76_queue_rx_reset(dev, i);
+	}
+
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER rx queue rx reset done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
 
 	mt7996_dma_enable(dev, !force);
+
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER dma enable done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
 }
 
 void mt7996_dma_cleanup(struct mt7996_dev *dev)
diff --git a/mt7996/eeprom.c b/mt7996/eeprom.c
index 87c6192b..72e8c9ec 100644
--- a/mt7996/eeprom.c
+++ b/mt7996/eeprom.c
@@ -6,6 +6,80 @@
 #include <linux/firmware.h>
 #include "mt7996.h"
 #include "eeprom.h"
+#include <linux/moduleparam.h>
+
+static bool testmode_enable;
+module_param(testmode_enable, bool, 0644);
+MODULE_PARM_DESC(testmode_enable, "Enable testmode");
+
+const struct ieee80211_channel dpd_2g_ch_list_bw20[] = {
+	CHAN2G(3, 2422),
+	CHAN2G(7, 2442),
+	CHAN2G(11, 2462)
+};
+
+const struct ieee80211_channel dpd_5g_skip_ch_list[] = {
+	CHAN5G(68, 5340),
+	CHAN5G(72, 5360),
+	CHAN5G(76, 5380),
+	CHAN5G(80, 5400),
+	CHAN5G(84, 5420),
+	CHAN5G(88, 5440),
+	CHAN5G(92, 5460),
+	CHAN5G(96, 5480)
+};
+
+const struct ieee80211_channel dpd_5g_ch_list_bw80[] = {
+	CHAN5G(42, 5210),
+	CHAN5G(58, 5290),
+	CHAN5G(106, 5530),
+	CHAN5G(122, 5610),
+	CHAN5G(138, 5690),
+	CHAN5G(155, 5775),
+	CHAN5G(171, 5855)
+};
+
+const struct ieee80211_channel dpd_5g_ch_list_bw160[] = {
+	CHAN5G(50, 5250),
+	CHAN5G(114, 5570),
+	CHAN5G(163, 5815)
+};
+
+const struct ieee80211_channel dpd_6g_ch_list_bw80[] = {
+	CHAN6G(7, 5985),
+	CHAN6G(23, 6065),
+	CHAN6G(39, 6145),
+	CHAN6G(55, 6225),
+	CHAN6G(71, 6305),
+	CHAN6G(87, 6385),
+	CHAN6G(103, 6465),
+	CHAN6G(119, 6545),
+	CHAN6G(135, 6625),
+	CHAN6G(151, 6705),
+	CHAN6G(167, 6785),
+	CHAN6G(183, 6865),
+	CHAN6G(199, 6945),
+	CHAN6G(215, 7025)
+};
+
+const struct ieee80211_channel dpd_6g_ch_list_bw160[] = {
+	CHAN6G(15, 6025),
+	CHAN6G(47, 6185),
+	CHAN6G(79, 6345),
+	CHAN6G(111, 6505),
+	CHAN6G(143, 6665),
+	CHAN6G(175, 6825),
+	CHAN6G(207, 6985)
+};
+
+const struct ieee80211_channel dpd_6g_ch_list_bw320[] = {
+	CHAN6G(31, 6105),
+	CHAN6G(63, 6265),
+	CHAN6G(95, 6425),
+	CHAN6G(127, 6585),
+	CHAN6G(159, 6745),
+	CHAN6G(191, 6905)
+};
 
 static int mt7996_check_eeprom(struct mt7996_dev *dev)
 {
@@ -24,7 +98,7 @@ static int mt7996_check_eeprom(struct mt7996_dev *dev)
 	}
 }
 
-static char *mt7996_eeprom_name(struct mt7996_dev *dev)
+const char *mt7996_eeprom_name(struct mt7996_dev *dev)
 {
 	switch (mt76_chip(&dev->mt76)) {
 	case MT7992_DEVICE_ID:
@@ -33,6 +107,8 @@ static char *mt7996_eeprom_name(struct mt7996_dev *dev)
 			if (dev->var.fem == MT7996_FEM_INT)
 				return MT7992_EEPROM_DEFAULT_23_INT;
 			return MT7992_EEPROM_DEFAULT_23;
+		case MT7992_VAR_TYPE_24:
+			return MT7992_EEPROM_DEFAULT_24;
 		case MT7992_VAR_TYPE_44:
 		default:
 			if (dev->var.fem == MT7996_FEM_INT)
@@ -52,6 +128,8 @@ static char *mt7996_eeprom_name(struct mt7996_dev *dev)
 			if (dev->var.fem == MT7996_FEM_INT)
 				return MT7996_EEPROM_DEFAULT_233_INT;
 			return MT7996_EEPROM_DEFAULT_233;
+		case MT7996_VAR_TYPE_404:
+			return MT7996_EEPROM_DEFAULT_404;
 		case MT7996_VAR_TYPE_444:
 		default:
 			if (dev->var.fem == MT7996_FEM_INT)
@@ -153,7 +231,10 @@ mt7996_eeprom_check_or_use_default(struct mt7996_dev *dev, bool use_default)
 
 	dev_warn(dev->mt76.dev, "eeprom load fail, use default bin\n");
 	memcpy(eeprom, fw->data, MT7996_EEPROM_SIZE);
+	dev->bin_file_mode = false;
 	dev->flash_mode = true;
+	dev->eeprom_mode = DEFAULT_BIN_MODE;
+	eeprom[MT_EE_TESTMODE_EN] = dev->testmode_enable;
 
 out:
 	release_firmware(fw);
@@ -161,20 +242,84 @@ out:
 	return ret;
 }
 
-static int mt7996_eeprom_load(struct mt7996_dev *dev)
+static int
+mt7996_eeprom_load_bin(struct mt7996_dev *dev)
 {
-	bool use_default = false;
+	u8 *eeprom = dev->mt76.eeprom.data;
+	const struct firmware *fw = NULL;
 	int ret;
 
-	ret = mt76_eeprom_init(&dev->mt76, MT7996_EEPROM_SIZE);
-	if (ret < 0)
+	ret = request_firmware(&fw, dev->mt76.bin_file_name, dev->mt76.dev);
+	if (ret)
 		return ret;
 
-	if (ret && !mt7996_check_eeprom(dev)) {
-		dev->flash_mode = true;
+	if (!fw || !fw->data) {
+		dev_err(dev->mt76.dev, "Invalid bin %s\n", dev->mt76.bin_file_name);
+		ret = -EINVAL;
 		goto out;
 	}
 
+	memcpy(eeprom, fw->data, MT7996_EEPROM_SIZE);
+	dev->flash_mode = true;
+
+out:
+	release_firmware(fw);
+	return ret;
+}
+
+static int mt7996_eeprom_load_flash(struct mt7996_dev *dev)
+{
+	int ret = 1;
+
+	/* return > 0 for load success, return 0 for load failed, return < 0 for no memory */
+	dev->bin_file_mode = mt76_check_bin_file_mode(&dev->mt76);
+	if (dev->bin_file_mode) {
+		dev->mt76.eeprom.size = MT7996_EEPROM_SIZE;
+		dev->mt76.eeprom.data = devm_kzalloc(dev->mt76.dev, dev->mt76.eeprom.size,
+						     GFP_KERNEL);
+		if (!dev->mt76.eeprom.data)
+			return -ENOMEM;
+
+		if (mt7996_eeprom_load_bin(dev))
+			return 0;
+	} else {
+		ret = mt76_eeprom_init(&dev->mt76, MT7996_EEPROM_SIZE);
+	}
+
+	if (mt7996_check_eeprom(dev))
+		return 0;
+
+	return ret;
+}
+
+int mt7996_eeprom_check_fw_mode(struct mt7996_dev *dev)
+{
+	u8 *eeprom;
+	int ret;
+
+	dev->testmode_enable = testmode_enable;
+
+	/* load eeprom in flash or bin file mode to determine fw mode */
+	ret = mt7996_eeprom_load_flash(dev);
+	if (ret <= 0)
+		goto out;
+
+	dev->flash_mode = true;
+	dev->eeprom_mode = dev->bin_file_mode ? BIN_FILE_MODE : FLASH_MODE;
+	eeprom = dev->mt76.eeprom.data;
+	/* testmode enable priority: eeprom field > module parameter */
+	dev->testmode_enable = eeprom[MT_EE_TESTMODE_EN];
+
+out:
+	return ret;
+}
+
+static int mt7996_eeprom_load(struct mt7996_dev *dev)
+{
+	bool use_default = false;
+	int ret;
+
+	/* flash or bin file mode eeprom is loaded before mcu init */
 	if (!dev->flash_mode) {
 		u32 eeprom_blk_size = MT7996_EEPROM_BLOCK_SIZE;
 		u32 block_num = DIV_ROUND_UP(MT7996_EEPROM_SIZE, eeprom_blk_size);
@@ -212,6 +357,7 @@ static int mt7996_eeprom_load(struct mt7996_dev *dev)
 				goto out;
 			}
 		}
+		dev->eeprom_mode = EFUSE_MODE;
 	}
 
 out:
@@ -232,6 +378,8 @@ static int mt7996_eeprom_parse_efuse_hw_cap(struct mt7996_phy *phy,
 	if (ret)
 		return ret;
 
+	/* for internal development */
+	dev->has_eht = true;
 	if (cap) {
 		u8 band_offs = phy->mt76->band_idx * 3;
 
@@ -321,14 +469,118 @@ int mt7996_eeprom_parse_hw_cap(struct mt7996_dev *dev, struct mt7996_phy *phy)
 	return mt7996_eeprom_parse_band_config(phy);
 }
 
+static int
+mt7996_eeprom_load_precal_binfile(struct mt7996_dev *dev, u32 offs, u32 size)
+{
+	const struct firmware *fw = NULL;
+	int ret;
+
+	ret = request_firmware(&fw, dev->mt76.bin_file_name, dev->mt76.dev);
+	if (ret)
+		return ret;
+
+	if (!fw || !fw->data) {
+		dev_err(dev->mt76.dev, "Invalid bin (bin file mode), load precal fail\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	memcpy(dev->cal, fw->data + offs, size);
+
+out:
+	release_firmware(fw);
+
+	return ret;
+}
+
+static void mt7996_eeprom_init_precal(struct mt7996_dev *dev)
+{
+#define MT76_CHANNELS_5GHZ_SIZE		36	/* ARRAY_SIZE(mt76_channels_5ghz) */
+#define MT76_CHANNELS_6GHZ_SIZE		59	/* ARRAY_SIZE(mt76_channels_6ghz) */
+
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW20_2G] = ARRAY_SIZE(dpd_2g_ch_list_bw20);
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW20_5G_SKIP] = ARRAY_SIZE(dpd_5g_skip_ch_list);
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW20_5G] = MT76_CHANNELS_5GHZ_SIZE -
+						   DPD_CH_NUM(BW20_5G_SKIP);
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW160_5G] = ARRAY_SIZE(dpd_5g_ch_list_bw160);
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW20_6G] = MT76_CHANNELS_6GHZ_SIZE;
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW160_6G] = ARRAY_SIZE(dpd_6g_ch_list_bw160);
+
+	switch (mt76_chip(&dev->mt76)) {
+	case MT7996_DEVICE_ID:
+		dev->prek.rev = mt7996_prek_rev;
+		if (dev->var.type == MT7996_VAR_TYPE_233)
+			dev->prek.rev = mt7996_prek_rev_233;
+		/* 5g & 6g bw 80 dpd channel list is not used */
+		dev->prek.dpd_ch_num[DPD_CH_NUM_BW320_6G] = ARRAY_SIZE(dpd_6g_ch_list_bw320);
+		break;
+	case MT7992_DEVICE_ID:
+		dev->prek.rev  = mt7992_prek_rev;
+		dev->prek.dpd_ch_num[DPD_CH_NUM_BW80_5G] = ARRAY_SIZE(dpd_5g_ch_list_bw80);
+		/* 6g is not used in current sku */
+		dev->prek.dpd_ch_num[DPD_CH_NUM_BW20_6G] = 0;
+		dev->prek.dpd_ch_num[DPD_CH_NUM_BW80_6G] = 0;
+		dev->prek.dpd_ch_num[DPD_CH_NUM_BW160_6G] = 0;
+		break;
+	default:
+		dev->prek.rev  = mt7996_prek_rev;
+		break;
+	}
+}
+
+static int mt7996_eeprom_load_precal(struct mt7996_dev *dev)
+{
+	struct mt76_dev *mdev = &dev->mt76;
+	u8 *eeprom = mdev->eeprom.data;
+	u32 val = eeprom[MT_EE_DO_PRE_CAL];
+	u32 size, offs = MT_EE_PRECAL;
+	int ret;
+
+	mt7996_eeprom_init_precal(dev);
+
+	if (!dev->flash_mode || !val)
+		return 0;
+
+	size = MT_EE_CAL_GROUP_SIZE + MT_EE_CAL_DPD_SIZE;
+
+	dev->cal = devm_kzalloc(mdev->dev, size, GFP_KERNEL);
+	if (!dev->cal) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	if (dev->bin_file_mode) {
+		ret = mt7996_eeprom_load_precal_binfile(dev, offs, size);
+		if (ret)
+			goto fail;
+	}
+
+	ret = mt76_get_of_data_from_mtd(mdev, dev->cal, offs, size);
+	if (!ret)
+		return 0;
+
+	ret = mt76_get_of_data_from_nvmem(mdev, dev->cal, "precal", size);
+	if (!ret)
+		return 0;
+
+fail:
+	dev_warn(dev->mt76.dev, "Failed to load precal data: %d\n", ret);
+	devm_kfree(dev->mt76.dev, dev->cal);
+	dev->cal = NULL;
+
+	return ret;
+}
+
 int mt7996_eeprom_init(struct mt7996_dev *dev)
 {
 	int ret;
 
 	ret = mt7996_eeprom_load(dev);
-	if (ret < 0)
+	if (ret)
 		return ret;
 
+	mt7996_eeprom_load_precal(dev);
+
 	ret = mt7996_eeprom_parse_hw_cap(dev, &dev->phy);
 	if (ret < 0)
 		return ret;
@@ -404,3 +656,37 @@ bool mt7996_eeprom_has_background_radar(struct mt7996_dev *dev)
 
 	return true;
 }
+
+const u8 mt7996_sku_group_len[] = {
+	[SKU_CCK] = 4,
+	[SKU_OFDM] = 8,
+	[SKU_HT20] = 8,
+	[SKU_HT40] = 9,
+	[SKU_VHT20] = 12,
+	[SKU_VHT40] = 12,
+	[SKU_VHT80] = 12,
+	[SKU_VHT160] = 12,
+	[SKU_HE26] = 12,
+	[SKU_HE52] = 12,
+	[SKU_HE106] = 12,
+	[SKU_HE242] = 12,
+	[SKU_HE484] = 12,
+	[SKU_HE996] = 12,
+	[SKU_HE2x996] = 12,
+	[SKU_EHT26] = 16,
+	[SKU_EHT52] = 16,
+	[SKU_EHT106] = 16,
+	[SKU_EHT242] = 16,
+	[SKU_EHT484] = 16,
+	[SKU_EHT996] = 16,
+	[SKU_EHT2x996] = 16,
+	[SKU_EHT4x996] = 16,
+	[SKU_EHT26_52] = 16,
+	[SKU_EHT26_106] = 16,
+	[SKU_EHT484_242] = 16,
+	[SKU_EHT996_484] = 16,
+	[SKU_EHT996_484_242] = 16,
+	[SKU_EHT2x996_484] = 16,
+	[SKU_EHT3x996] = 16,
+	[SKU_EHT3x996_484] = 16,
+};
diff --git a/mt7996/eeprom.h b/mt7996/eeprom.h
index 7a771ca2..0f10ef0b 100644
--- a/mt7996/eeprom.h
+++ b/mt7996/eeprom.h
@@ -14,6 +14,8 @@ enum mt7996_eeprom_field {
 	MT_EE_MAC_ADDR =	0x004,
 	MT_EE_MAC_ADDR2 =	0x00a,
 	MT_EE_WIFI_CONF =	0x190,
+	MT_EE_DO_PRE_CAL =	0x1a5,
+	MT_EE_TESTMODE_EN =	0x1af,
 	MT_EE_MAC_ADDR3 =	0x2c0,
 	MT_EE_RATE_DELTA_2G =	0x1400,
 	MT_EE_RATE_DELTA_5G =	0x147d,
@@ -23,12 +25,108 @@ enum mt7996_eeprom_field {
 	MT_EE_TX0_POWER_6G =	0x1310,
 
 	__MT_EE_MAX =	0x1dff,
+	/* 0x1e10 ~ 0x2d644 used to save group cal data */
+	MT_EE_PRECAL =		0x1e10,
 };
 
 #define MT_EE_WIFI_CONF0_TX_PATH		GENMASK(2, 0)
 #define MT_EE_WIFI_CONF0_BAND_SEL		GENMASK(2, 0)
 #define MT_EE_WIFI_CONF1_BAND_SEL		GENMASK(5, 3)
 #define MT_EE_WIFI_CONF2_BAND_SEL		GENMASK(2, 0)
+#define MT_EE_WIFI_PA_LNA_CONFIG		GENMASK(1, 0)
+
+#define MT_EE_WIFI_CAL_GROUP_2G			BIT(0)
+#define MT_EE_WIFI_CAL_GROUP_5G			BIT(1)
+#define MT_EE_WIFI_CAL_GROUP_6G			BIT(2)
+#define MT_EE_WIFI_CAL_GROUP			GENMASK(2, 0)
+#define MT_EE_WIFI_CAL_DPD_2G			BIT(3)
+#define MT_EE_WIFI_CAL_DPD_5G			BIT(4)
+#define MT_EE_WIFI_CAL_DPD_6G			BIT(5)
+#define MT_EE_WIFI_CAL_DPD			GENMASK(5, 3)
+
+#define MT_EE_CAL_UNIT				1024
+
+enum mt7996_prek_rev {
+	GROUP_SIZE_2G,
+	GROUP_SIZE_5G,
+	GROUP_SIZE_6G,
+	ADCDCOC_SIZE_2G,
+	ADCDCOC_SIZE_5G,
+	ADCDCOC_SIZE_6G,
+	DPD_LEGACY_SIZE,
+	DPD_MEM_SIZE,
+	DPD_OTFG0_SIZE,
+};
+
+static const u32 mt7996_prek_rev[] = {
+	[GROUP_SIZE_2G] =			4 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_5G] =			45 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_6G] =			125 * MT_EE_CAL_UNIT,
+	[ADCDCOC_SIZE_2G] =			4 * 4,
+	[ADCDCOC_SIZE_5G] =			4 * 4,
+	[ADCDCOC_SIZE_6G] =			4 * 5,
+	[DPD_LEGACY_SIZE] =			4 * MT_EE_CAL_UNIT,
+	[DPD_MEM_SIZE] =			13 * MT_EE_CAL_UNIT,
+	[DPD_OTFG0_SIZE] =			2 * MT_EE_CAL_UNIT,
+};
+
+static const u32 mt7996_prek_rev_233[] = {
+	[GROUP_SIZE_2G] =			4 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_5G] =			44 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_6G] =			125 * MT_EE_CAL_UNIT,
+	[ADCDCOC_SIZE_2G] =			4 * 4,
+	[ADCDCOC_SIZE_5G] =			4 * 4,
+	[ADCDCOC_SIZE_6G] =			4 * 5,
+	[DPD_LEGACY_SIZE] =			4 * MT_EE_CAL_UNIT,
+	[DPD_MEM_SIZE] =			13 * MT_EE_CAL_UNIT,
+	[DPD_OTFG0_SIZE] =			2 * MT_EE_CAL_UNIT,
+};
+
+/* kite 2/5g config */
+static const u32 mt7992_prek_rev[] = {
+	[GROUP_SIZE_2G] =			4 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_5G] =			110 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_6G] =			0,
+	[ADCDCOC_SIZE_2G] =			4 * 4,
+	[ADCDCOC_SIZE_5G] =			4 * 5,
+	[ADCDCOC_SIZE_6G] =			0,
+	[DPD_LEGACY_SIZE] =			5 * MT_EE_CAL_UNIT,
+	[DPD_MEM_SIZE] =			16 * MT_EE_CAL_UNIT,
+	[DPD_OTFG0_SIZE] =			2 * MT_EE_CAL_UNIT,
+};
+
+extern const struct ieee80211_channel dpd_2g_ch_list_bw20[];
+extern const struct ieee80211_channel dpd_5g_skip_ch_list[];
+extern const struct ieee80211_channel dpd_5g_ch_list_bw80[];
+extern const struct ieee80211_channel dpd_5g_ch_list_bw160[];
+extern const struct ieee80211_channel dpd_6g_ch_list_bw80[];
+extern const struct ieee80211_channel dpd_6g_ch_list_bw160[];
+extern const struct ieee80211_channel dpd_6g_ch_list_bw320[];
+
+#define PREK(id)				(dev->prek.rev[(id)])
+#define DPD_CH_NUM(_type)			(dev->prek.dpd_ch_num[DPD_CH_NUM_##_type])
+#define MT_EE_CAL_GROUP_SIZE			(PREK(GROUP_SIZE_2G) + PREK(GROUP_SIZE_5G) + \
+						 PREK(GROUP_SIZE_6G) + PREK(ADCDCOC_SIZE_2G) + \
+						 PREK(ADCDCOC_SIZE_5G) + PREK(ADCDCOC_SIZE_6G))
+#define DPD_PER_CH_BW20_SIZE			(PREK(DPD_LEGACY_SIZE) + PREK(DPD_OTFG0_SIZE))
+#define DPD_PER_CH_GT_BW20_SIZE			(PREK(DPD_MEM_SIZE) + PREK(DPD_OTFG0_SIZE))
+#define MT_EE_CAL_DPD_SIZE_2G			(DPD_CH_NUM(BW20_2G) * DPD_PER_CH_BW20_SIZE)
+#define MT_EE_CAL_DPD_SIZE_5G			(DPD_CH_NUM(BW20_5G) * DPD_PER_CH_BW20_SIZE + \
+						 DPD_CH_NUM(BW80_5G) * DPD_PER_CH_GT_BW20_SIZE + \
+						 DPD_CH_NUM(BW160_5G) * DPD_PER_CH_GT_BW20_SIZE)
+#define MT_EE_CAL_DPD_SIZE_6G			(DPD_CH_NUM(BW20_6G) * DPD_PER_CH_BW20_SIZE + \
+						 DPD_CH_NUM(BW80_6G) * DPD_PER_CH_GT_BW20_SIZE + \
+						 DPD_CH_NUM(BW160_6G) * DPD_PER_CH_GT_BW20_SIZE + \
+						 DPD_CH_NUM(BW320_6G) * DPD_PER_CH_GT_BW20_SIZE)
+#define MT_EE_CAL_DPD_SIZE			(MT_EE_CAL_DPD_SIZE_2G + MT_EE_CAL_DPD_SIZE_5G + \
+						 MT_EE_CAL_DPD_SIZE_6G)
+
+#define RF_DPD_FLAT_CAL				BIT(28)
+#define RF_PRE_CAL				BIT(29)
+#define RF_DPD_FLAT_5G_CAL			GENMASK(29, 28)
+#define RF_DPD_FLAT_5G_MEM_CAL			(BIT(30) | BIT(28))
+#define RF_DPD_FLAT_6G_CAL			GENMASK(30, 28)
+#define RF_DPD_FLAT_6G_MEM_CAL			(BIT(31) | BIT(28))
 
 #define MT_EE_WIFI_CONF1_TX_PATH_BAND0		GENMASK(5, 3)
 #define MT_EE_WIFI_CONF2_TX_PATH_BAND1		GENMASK(2, 0)
@@ -53,6 +151,13 @@ enum mt7996_eeprom_band {
 	MT_EE_BAND_SEL_6GHZ,
 };
 
+enum mt7915_eeprom_mode {
+	DEFAULT_BIN_MODE,
+	EFUSE_MODE,
+	FLASH_MODE,
+	BIN_FILE_MODE,
+};
+
 static inline int
 mt7996_get_channel_group_5g(int channel)
 {
@@ -76,4 +181,46 @@ mt7996_get_channel_group_6g(int channel)
 	return DIV_ROUND_UP(channel - 29, 32);
 }
 
+enum mt7996_sku_rate_group {
+	SKU_CCK,
+	SKU_OFDM,
+
+	SKU_HT20,
+	SKU_HT40,
+
+	SKU_VHT20,
+	SKU_VHT40,
+	SKU_VHT80,
+	SKU_VHT160,
+
+	SKU_HE26,
+	SKU_HE52,
+	SKU_HE106,
+	SKU_HE242,
+	SKU_HE484,
+	SKU_HE996,
+	SKU_HE2x996,
+
+	SKU_EHT26,
+	SKU_EHT52,
+	SKU_EHT106,
+	SKU_EHT242,
+	SKU_EHT484,
+	SKU_EHT996,
+	SKU_EHT2x996,
+	SKU_EHT4x996,
+	SKU_EHT26_52,
+	SKU_EHT26_106,
+	SKU_EHT484_242,
+	SKU_EHT996_484,
+	SKU_EHT996_484_242,
+	SKU_EHT2x996_484,
+	SKU_EHT3x996,
+	SKU_EHT3x996_484,
+
+	MAX_SKU_RATE_GROUP_NUM,
+};
+
+extern const u8 mt7996_sku_group_len[MAX_SKU_RATE_GROUP_NUM];
+
 #endif
diff --git a/mt7996/init.c b/mt7996/init.c
index 7eade530..33649db0 100644
--- a/mt7996/init.c
+++ b/mt7996/init.c
@@ -34,6 +34,7 @@ static const struct ieee80211_iface_combination if_comb_global = {
 			       BIT(NL80211_CHAN_WIDTH_40) |
 			       BIT(NL80211_CHAN_WIDTH_80) |
 			       BIT(NL80211_CHAN_WIDTH_160),
+	.beacon_int_min_gcd = 100,
 };
 
 static const struct ieee80211_iface_limit if_limits[] = {
@@ -63,21 +64,59 @@ static const struct ieee80211_iface_combination if_comb = {
 	.beacon_int_min_gcd = 100,
 };
 
-static const u8 if_types_ext_capa_ap[] = {
+static const struct ieee80211_iface_combination if_comb_7992 = {
+	.limits = if_limits,
+	.n_limits = ARRAY_SIZE(if_limits),
+	.max_interfaces = 16,
+	.num_different_channels = 1,
+	.beacon_int_infra_match = true,
+	.radar_detect_widths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |
+			       BIT(NL80211_CHAN_WIDTH_20) |
+			       BIT(NL80211_CHAN_WIDTH_40) |
+			       BIT(NL80211_CHAN_WIDTH_80) |
+			       BIT(NL80211_CHAN_WIDTH_160),
+	.beacon_int_min_gcd = 100,
+};
+
+static const u8 mt7996_if_types_ext_capa_ap[] = {
+	[0] = WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING,
+	[2] = WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT,
+	[4] = WLAN_EXT_CAPA5_QOS_MAP,
+	[6] = WLAN_EXT_CAPA7_SCS_SUPPORT,
+	[7] = WLAN_EXT_CAPA8_OPMODE_NOTIF,
+	[10] = WLAN_EXT_CAPA11_MIRRORED_SCS_SUPPORT,
+};
+
+static const u8 mt7996_if_types_ext_capa_sta[] = {
 	[0] = WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING,
 	[2] = WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT,
 	[7] = WLAN_EXT_CAPA8_OPMODE_NOTIF,
 };
 
-static const struct wiphy_iftype_ext_capab iftypes_ext_capa[] = {
+#define MT7996_NEG_TTLM_SUPPORT FIELD_PREP_CONST( \
+		IEEE80211_MLD_CAP_OP_TID_TO_LINK_MAP_NEG_SUPP, \
+		IEEE80211_MLD_CAP_OP_TID_TO_LINK_MAP_NEG_SUPP_DIFF)
+
+static const struct wiphy_iftype_ext_capab mt7996_iftypes_ext_capa[] = {
+	{
+		.iftype = NL80211_IFTYPE_STATION,
+		.extended_capabilities = mt7996_if_types_ext_capa_sta,
+		.extended_capabilities_mask = mt7996_if_types_ext_capa_sta,
+		.extended_capabilities_len = sizeof(mt7996_if_types_ext_capa_sta),
+		.mld_capa_and_ops = 2 | MT7996_NEG_TTLM_SUPPORT,
+	},
 	{
 		.iftype = NL80211_IFTYPE_AP,
-		.extended_capabilities = if_types_ext_capa_ap,
-		.extended_capabilities_mask = if_types_ext_capa_ap,
-		.extended_capabilities_len = sizeof(if_types_ext_capa_ap),
-		.mld_capa_and_ops =
-			FIELD_PREP_CONST(IEEE80211_MLD_CAP_OP_MAX_SIMUL_LINKS,
-					 MT7996_MAX_RADIOS - 1),
+		.extended_capabilities = mt7996_if_types_ext_capa_ap,
+		.extended_capabilities_mask = mt7996_if_types_ext_capa_ap,
+		.extended_capabilities_len = sizeof(mt7996_if_types_ext_capa_ap),
+		.eml_capabilities = IEEE80211_EML_CAP_EMLSR_SUPP,
+		.mld_capa_and_ops = 2 | MT7996_NEG_TTLM_SUPPORT,
+		/* the max number of simultaneous links is defined as the
+		 * maximum number of affiliated APs minus 1.
+		 * mt7996 could have 3 links in an MLD AP, so currently
+		 * hardcode it to 2.
+		 */
 	},
 };
 
@@ -339,7 +378,12 @@ static void __mt7996_init_txpower(struct mt7996_phy *phy,
 	int path_delta = mt76_tx_power_path_delta(n_chains);
 	int pwr_delta = mt7996_eeprom_get_power_delta(dev, sband->band);
 	struct mt76_power_limits limits;
+	struct mt76_power_path_limits limits_path;
+	struct device_node *np;
 
+	phy->sku_limit_en = true;
+	phy->sku_path_en = true;
+	np = mt76_find_power_limits_node(&dev->mt76);
 	for (i = 0; i < sband->n_channels; i++) {
 		struct ieee80211_channel *chan = &sband->channels[i];
 		int target_power = mt7996_eeprom_get_target_power(dev, chan);
@@ -347,11 +391,18 @@ static void __mt7996_init_txpower(struct mt7996_phy *phy,
 		target_power += pwr_delta;
 		target_power = mt76_get_rate_power_limits(phy->mt76, chan,
 							  &limits,
+							  &limits_path,
 							  target_power);
+		if (!limits_path.ofdm[0])
+			phy->sku_path_en = false;
+
 		target_power += path_delta;
 		target_power = DIV_ROUND_UP(target_power, 2);
-		chan->max_power = min_t(int, chan->max_reg_power,
-					target_power);
+		if (!np)
+			chan->max_power = min_t(int, chan->max_reg_power,
+						target_power);
+		else
+			chan->max_power = target_power;
 		phy->txpower = max(phy->txpower, chan->max_power);
 		chan->orig_mpwr = target_power;
 	}
@@ -359,15 +410,22 @@ static void __mt7996_init_txpower(struct mt7996_phy *phy,
 
 void mt7996_init_txpower(struct mt7996_phy *phy)
 {
+	struct mt7996_phy *phy_2g, *phy_5g, *phy_6g;
+
 	if (!phy)
 		return;
 
-	if (phy->mt76->cap.has_2ghz)
-		__mt7996_init_txpower(phy, &phy->mt76->sband_2g.sband);
-	if (phy->mt76->cap.has_5ghz)
-		__mt7996_init_txpower(phy, &phy->mt76->sband_5g.sband);
-	if (phy->mt76->cap.has_6ghz)
-		__mt7996_init_txpower(phy, &phy->mt76->sband_6g.sband);
+	/* FIXME refactor after single wiphy multiple radios merged */
+	phy_2g = mt7996_band_phy(phy->dev, NL80211_BAND_2GHZ);
+	phy_5g = mt7996_band_phy(phy->dev, NL80211_BAND_5GHZ);
+	phy_6g = mt7996_band_phy(phy->dev, NL80211_BAND_6GHZ);
+
+	if (phy_2g && phy_2g->mt76->cap.has_2ghz)
+		__mt7996_init_txpower(phy_2g, &phy_2g->mt76->sband_2g.sband);
+	if (phy_5g && phy_5g->mt76->cap.has_5ghz)
+		__mt7996_init_txpower(phy_5g, &phy_5g->mt76->sband_5g.sband);
+	if (phy_6g && phy_6g->mt76->cap.has_6ghz)
+		__mt7996_init_txpower(phy_6g, &phy_6g->mt76->sband_6g.sband);
 }
 
 static void
@@ -403,6 +461,7 @@ mt7996_init_wiphy_band(struct ieee80211_hw *hw, struct mt7996_phy *phy)
 	phy->slottime = 9;
 	phy->beacon_rate = -1;
 	phy->rxfilter = MT_WF_RFCR_DROP_OTHER_UC;
+	phy->muru_onoff = OFDMA_UL | OFDMA_DL | MUMIMO_DL | MUMIMO_UL;
 
 	if (phy->mt76->cap.has_2ghz) {
 		phy->mt76->sband_2g.sband.ht_cap.cap |=
@@ -429,7 +488,7 @@ mt7996_init_wiphy_band(struct ieee80211_hw *hw, struct mt7996_phy *phy)
 		freq->start_freq = 5000000;
 		freq->end_freq = 5900000;
 	} else if (phy->mt76->cap.has_6ghz) {
-		freq->start_freq = 5900000;
+		freq->start_freq = 5925000;
 		freq->end_freq = 7200000;
 	} else {
 		return;
@@ -438,8 +497,9 @@ mt7996_init_wiphy_band(struct ieee80211_hw *hw, struct mt7996_phy *phy)
 	dev->radio_phy[n_radios] = phy;
 	radio->freq_range = freq;
 	radio->n_freq_range = 1;
-	radio->iface_combinations = &if_comb;
+	radio->iface_combinations = is_mt7996(&dev->mt76) ? &if_comb : &if_comb_7992;
 	radio->n_iface_combinations = 1;
+	radio->antenna_mask = phy->mt76->chainmask;
 	hw->wiphy->n_radio++;
 
 	wiphy->available_antennas_rx |= phy->mt76->chainmask;
@@ -479,15 +539,11 @@ mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
 
 	wiphy->iface_combinations = &if_comb_global;
 	wiphy->n_iface_combinations = 1;
-
 	wiphy->radio = dev->radios;
 
 	wiphy->reg_notifier = mt7996_regd_notifier;
-	wiphy->flags |= WIPHY_FLAG_HAS_CHANNEL_SWITCH |
-			WIPHY_FLAG_SUPPORTS_MLO;
-	wiphy->mbssid_max_interfaces = 16;
-	wiphy->iftype_ext_capab = iftypes_ext_capa;
-	wiphy->num_iftype_ext_capab = ARRAY_SIZE(iftypes_ext_capa);
+	wiphy->flags |= WIPHY_FLAG_HAS_CHANNEL_SWITCH;
+	wiphy->mbssid_max_interfaces = is_mt7996(&dev->mt76) ? 48 : 32;
 	wiphy->max_ap_assoc_sta = mt7996_wtbl_size(dev) - MT7996_WTBL_BMC_SIZE - 1;
 
 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_BSS_COLOR);
@@ -501,7 +557,11 @@ mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT);
 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_CAN_REPLACE_PTK0);
 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER);
+	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_PUNCT);
+	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_STAS_COUNT);
 
+	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_OPERATING_CHANNEL_VALIDATION);
+	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_BEACON_PROTECTION);
 	if (mt7996_eeprom_has_background_radar(dev) &&
 	    (!mdev->dev->of_node ||
 	     !of_property_read_bool(mdev->dev->of_node,
@@ -514,6 +574,9 @@ mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
 	ieee80211_hw_set(hw, SUPPORTS_RX_DECAP_OFFLOAD);
 	ieee80211_hw_set(hw, NO_VIRTUAL_MONITOR);
 	ieee80211_hw_set(hw, SUPPORTS_MULTI_BSSID);
+	ieee80211_hw_set(hw, CHANCTX_STA_CSA);
+	ieee80211_hw_set(hw, CONNECTION_MONITOR);
+	ieee80211_hw_set(hw, HANDLES_QUIET_CSA);
 
 	hw->max_tx_fragments = 4;
 
@@ -526,6 +589,12 @@ mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
 	wiphy->max_scan_ssids = 4;
 	wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;
 
+	/* enable MLO support */
+	wiphy->flags |= WIPHY_FLAG_SUPPORTS_MLO;
+	wiphy->iftype_ext_capab = mt7996_iftypes_ext_capa;
+	wiphy->num_iftype_ext_capab = ARRAY_SIZE(mt7996_iftypes_ext_capa);
+	wiphy->features |= NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE;
+
 	mt7996_init_wiphy_band(hw, &dev->phy);
 }
 
@@ -560,11 +629,6 @@ mt7996_mac_init_band(struct mt7996_dev *dev, u8 band)
 	set = FIELD_PREP(MT_WTBLOFF_RSCR_RCPI_MODE, 0) |
 	      FIELD_PREP(MT_WTBLOFF_RSCR_RCPI_PARAM, 0x3);
 	mt76_rmw(dev, MT_WTBLOFF_RSCR(band), mask, set);
-
-	/* MT_TXD5_TX_STATUS_HOST (MPDU format) has higher priority than
-	 * MT_AGG_ACR_PPDU_TXS2H (PPDU format) even though ACR bit is set.
-	 */
-	mt76_set(dev, MT_AGG_ACR4(band), MT_AGG_ACR_PPDU_TXS2H);
 }
 
 static void mt7996_mac_init_basic_rates(struct mt7996_dev *dev)
@@ -585,7 +649,7 @@ static void mt7996_mac_init_basic_rates(struct mt7996_dev *dev)
 void mt7996_mac_init(struct mt7996_dev *dev)
 {
 #define HIF_TXD_V2_1	0x21
-	int i;
+	int i, rx_path_type, rro_bypass, txfree_path;
 
 	mt76_clear(dev, MT_MDP_DCR2, MT_MDP_DCR2_RX_TRANS_SHORT);
 
@@ -599,22 +663,52 @@ void mt7996_mac_init(struct mt7996_dev *dev)
 	}
 
 	/* rro module init */
-	if (is_mt7996(&dev->mt76))
-		mt7996_mcu_set_rro(dev, UNI_RRO_SET_PLATFORM_TYPE, 2);
-	else
-		mt7996_mcu_set_rro(dev, UNI_RRO_SET_PLATFORM_TYPE,
-				   dev->hif2 ? 7 : 0);
+	rx_path_type = is_mt7996(&dev->mt76) ? 2 : 7;
+	rro_bypass = is_mt7996(&dev->mt76) ? 1 : 2;
+	txfree_path = is_mt7996(&dev->mt76) ? 0: 1;
+
+	switch (dev->option_type) {
+	case 2:
+		if (is_mt7996(&dev->mt76)) {
+			/* eagle + 7988d */
+			rx_path_type = 3;
+			rro_bypass = 1;
+			txfree_path = 0;
+		}
+		break;
+	case 3:
+		/* Airoha */
+		if (is_mt7996(&dev->mt76)) {
+			rx_path_type = 6;
+			rro_bypass = 1;
+			txfree_path = 0;
+		} else {
+			rx_path_type = 8;
+			rro_bypass = 2;
+			txfree_path = 1;
+		}
+		break;
+	case 4:
+		if (is_mt7996(&dev->mt76)) {
+			/* Bollinger */
+			rx_path_type = 2;
+			rro_bypass = 1;
+			txfree_path = 0;
+		}
+		break;
+	default:
+		break;
+	}
+
+	mt7996_mcu_set_rro(dev, UNI_RRO_SET_PLATFORM_TYPE, dev->hif2 ? rx_path_type : 0);
+	mt7996_mcu_set_rro(dev, UNI_RRO_SET_BYPASS_MODE, dev->has_rro ? rro_bypass : 3);
+	mt7996_mcu_set_rro(dev, UNI_RRO_SET_TXFREE_PATH, dev->has_rro ? txfree_path : 1);
 
 	if (dev->has_rro) {
 		u16 timeout;
 
 		timeout = mt76_rr(dev, MT_HW_REV) == MT_HW_REV1 ? 512 : 128;
 		mt7996_mcu_set_rro(dev, UNI_RRO_SET_FLUSH_TIMEOUT, timeout);
-		mt7996_mcu_set_rro(dev, UNI_RRO_SET_BYPASS_MODE, 1);
-		mt7996_mcu_set_rro(dev, UNI_RRO_SET_TXFREE_PATH, 0);
-	} else {
-		mt7996_mcu_set_rro(dev, UNI_RRO_SET_BYPASS_MODE, 3);
-		mt7996_mcu_set_rro(dev, UNI_RRO_SET_TXFREE_PATH, 1);
 	}
 
 	mt7996_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(SET),
@@ -647,6 +741,37 @@ int mt7996_txbf_init(struct mt7996_dev *dev)
 	return mt7996_mcu_set_txbf(dev, BF_HW_EN_UPDATE);
 }
 
+static int mt7996_vow_init(struct mt7996_phy *phy)
+{
+	struct mt7996_vow_ctrl *vow = &phy->dev->vow;
+	int ret;
+
+	vow->atf_enable = true;
+	vow->watf_enable = false;
+	vow->max_deficit = 64;
+	vow->sch_type = VOW_SCH_TYPE_FOLLOW_POLICY;
+	vow->sch_policy = VOW_SCH_POLICY_SRR;
+
+	vow->drr_quantum[0] = VOW_DRR_QUANTUM_L0;
+	vow->drr_quantum[1] = VOW_DRR_QUANTUM_L1;
+	vow->drr_quantum[2] = VOW_DRR_QUANTUM_L2;
+	vow->drr_quantum[3] = VOW_DRR_QUANTUM_L3;
+	vow->drr_quantum[4] = VOW_DRR_QUANTUM_L4;
+	vow->drr_quantum[5] = VOW_DRR_QUANTUM_L5;
+	vow->drr_quantum[6] = VOW_DRR_QUANTUM_L6;
+	vow->drr_quantum[7] = VOW_DRR_QUANTUM_L7;
+
+	ret = mt7996_mcu_set_vow_drr_ctrl(phy, NULL, NULL, VOW_DRR_CTRL_AIRTIME_DEFICIT_BOUND);
+	if (ret)
+		return ret;
+
+	ret = mt7996_mcu_set_vow_drr_ctrl(phy, NULL, NULL, VOW_DRR_CTRL_AIRTIME_QUANTUM_ALL);
+	if (ret)
+		return ret;
+
+	return mt7996_mcu_set_vow_feature_ctrl(phy);
+}
+
 static int mt7996_register_phy(struct mt7996_dev *dev, enum mt76_band_id band)
 {
 	struct mt7996_phy *phy;
@@ -658,9 +783,23 @@ static int mt7996_register_phy(struct mt7996_dev *dev, enum mt76_band_id band)
 	if (!mt7996_band_valid(dev, band))
 		return 0;
 
-	if (is_mt7996(&dev->mt76) && band == MT_BAND2 && dev->hif2) {
-		hif1_ofs = MT_WFDMA0_PCIE1(0) - MT_WFDMA0(0);
-		wed = &dev->mt76.mmio.wed_hif2;
+	if (dev->hif2) {
+		switch (dev->option_type) {
+		case 2:
+			/* eagle + 7988d */
+			if (band == MT_BAND1) {
+				hif1_ofs = MT_WFDMA0_PCIE1(0) - MT_WFDMA0(0);
+				wed = &dev->mt76.mmio.wed_hif2;
+			}
+			break;
+		default:
+			if ((is_mt7996(&dev->mt76) && band == MT_BAND2) ||
+			    (is_mt7992(&dev->mt76) && band == MT_BAND1)) {
+				hif1_ofs = MT_WFDMA0_PCIE1(0) - MT_WFDMA0(0);
+				wed = &dev->mt76.mmio.wed_hif2;
+			}
+			break;
+		}
 	}
 
 	mphy = mt76_alloc_radio_phy(&dev->mt76, sizeof(*phy), band);
@@ -703,16 +842,24 @@ static int mt7996_register_phy(struct mt7996_dev *dev, enum mt76_band_id band)
 	if (ret)
 		goto error;
 
+#ifdef CONFIG_MTK_VENDOR
+	mt7996_vendor_register(phy);
+#endif
+
 	ret = mt76_register_phy(mphy, true, mt76_rates,
 				ARRAY_SIZE(mt76_rates));
 	if (ret)
 		goto error;
 
-	if (wed == &dev->mt76.mmio.wed_hif2 && mtk_wed_device_active(wed)) {
-		u32 irq_mask = dev->mt76.mmio.irqmask | MT_INT_TX_DONE_BAND2;
+	if (mt7996_vow_should_enable(dev)) {
+		ret = mt7996_vow_init(phy);
+		if (ret)
+			goto error;
+	}
 
-		mt76_wr(dev, MT_INT1_MASK_CSR, irq_mask);
-		mtk_wed_device_start(&dev->mt76.mmio.wed_hif2, irq_mask);
+	if (wed == &dev->mt76.mmio.wed_hif2 && mtk_wed_device_active(wed)) {
+		mt76_wr(dev, MT_INT_PCIE1_MASK_CSR, MT_INT_TX_RX_DONE_EXT);
+		mtk_wed_device_start(&dev->mt76.mmio.wed_hif2, MT_INT_TX_RX_DONE_EXT);
 	}
 
 	return 0;
@@ -722,11 +869,35 @@ error:
 	return ret;
 }
 
+#ifdef CONFIG_MTK_VENDOR
+static int mt7996_unregister_csi(struct mt7996_phy *phy)
+{
+	struct csi_data *c, *tmp_c;
+
+	spin_lock_bh(&phy->csi.lock);
+	phy->csi.enable = 0;
+
+	list_for_each_entry_safe(c, tmp_c, &phy->csi.list, node) {
+		list_del(&c->node);
+		kfree(c);
+	}
+	spin_unlock_bh(&phy->csi.lock);
+
+	return 0;
+}
+#endif
+
 static void
 mt7996_unregister_phy(struct mt7996_phy *phy)
 {
-	if (phy)
-		mt7996_unregister_thermal(phy);
+	if (!phy)
+		return;
+
+#ifdef CONFIG_MTK_VENDOR
+	mt7996_unregister_csi(phy);
+#endif
+
+	mt7996_unregister_thermal(phy);
 }
 
 static void mt7996_init_work(struct work_struct *work)
@@ -737,6 +908,9 @@ static void mt7996_init_work(struct work_struct *work)
 	mt7996_mcu_set_eeprom(dev);
 	mt7996_mac_init(dev);
 	mt7996_txbf_init(dev);
+
+	if (!is_mt7990(&dev->mt76))
+		mt7996_mcu_set_dup_wtbl(dev);
 }
 
 void mt7996_wfsys_reset(struct mt7996_dev *dev)
@@ -748,11 +922,96 @@ void mt7996_wfsys_reset(struct mt7996_dev *dev)
 	msleep(20);
 }
 
-static int mt7996_wed_rro_init(struct mt7996_dev *dev)
+void mt7996_rro_hw_init(struct mt7996_dev *dev)
 {
 #ifdef CONFIG_NET_MEDIATEK_SOC_WED
 	struct mtk_wed_device *wed = &dev->mt76.mmio.wed;
 	u32 reg = MT_RRO_ADDR_ELEM_SEG_ADDR0;
+	int i;
+
+	if (!dev->has_rro)
+		return;
+
+	if (is_mt7992(&dev->mt76)) {
+		/* set emul 3.0 function */
+		mt76_wr(dev, MT_RRO_3_0_EMU_CONF,
+			MT_RRO_3_0_EMU_CONF_EN_MASK);
+
+		mt76_wr(dev, MT_RRO_ADDR_ARRAY_BASE0,
+			dev->wed_rro.addr_elem[0].phy_addr);
+	} else {
+		INIT_LIST_HEAD(&dev->wed_rro.pg_addr_cache);
+		for (i = 0; i < MT7996_RRO_MSDU_PG_HASH_SIZE; i++)
+			INIT_LIST_HEAD(&dev->wed_rro.pg_hash_head[i]);
+
+		/* TODO: remove line after WM has set */
+		mt76_clear(dev, WF_RRO_AXI_MST_CFG, WF_RRO_AXI_MST_CFG_DIDX_OK);
+
+		/* setup BA bitmap cache address */
+		mt76_wr(dev, MT_RRO_BA_BITMAP_BASE0,
+			dev->wed_rro.ba_bitmap[0].phy_addr);
+		mt76_wr(dev, MT_RRO_BA_BITMAP_BASE1, 0);
+		mt76_wr(dev, MT_RRO_BA_BITMAP_BASE_EXT0,
+			dev->wed_rro.ba_bitmap[1].phy_addr);
+		mt76_wr(dev, MT_RRO_BA_BITMAP_BASE_EXT1, 0);
+
+		/* setup Address element address */
+		for (i = 0; i < ARRAY_SIZE(dev->wed_rro.addr_elem); i++) {
+			mt76_wr(dev, reg, dev->wed_rro.addr_elem[i].phy_addr >> 4);
+			reg += 4;
+		}
+
+		/* setup Address element address - separate address segment mode */
+		mt76_wr(dev, MT_RRO_ADDR_ARRAY_BASE1,
+			MT_RRO_ADDR_ARRAY_ELEM_ADDR_SEG_MODE);
+	}
+	wed->wlan.ind_cmd.win_size = ffs(MT7996_RRO_WINDOW_MAX_LEN) - 6;
+	if (is_mt7996(&dev->mt76))
+		wed->wlan.ind_cmd.particular_sid = MT7996_RRO_MAX_SESSION;
+	else
+		wed->wlan.ind_cmd.particular_sid = 1;
+	wed->wlan.ind_cmd.particular_se_phys = dev->wed_rro.session.phy_addr;
+	wed->wlan.ind_cmd.se_group_nums = MT7996_RRO_ADDR_ELEM_LEN;
+	wed->wlan.ind_cmd.ack_sn_addr = MT_RRO_ACK_SN_CTRL;
+
+	mt76_wr(dev, MT_RRO_IND_CMD_SIGNATURE_BASE0, 0x15010e00);
+	mt76_set(dev, MT_RRO_IND_CMD_SIGNATURE_BASE1,
+		 MT_RRO_IND_CMD_SIGNATURE_BASE1_EN);
+
+	/* particular session configure */
+	/* use max session idx + 1 as particular session id */
+	mt76_wr(dev, MT_RRO_PARTICULAR_CFG0, dev->wed_rro.session.phy_addr);
+
+	if (is_mt7992(&dev->mt76)) {
+		reg = MT_RRO_MSDU_PG_SEG_ADDR0;
+
+		mt76_set(dev, MT_RRO_3_1_GLOBAL_CONFIG,
+			 MT_RRO_3_1_GLOBAL_CONFIG_INTERLEAVE_EN);
+
+		/* setup Msdu page address */
+		for (i = 0; i < MT7996_RRO_MSDU_PG_CR_CNT; i++) {
+			mt76_wr(dev, reg, dev->wed_rro.msdu_pg[i].phy_addr >> 4);
+			reg += 4;
+		}
+		mt76_wr(dev, MT_RRO_PARTICULAR_CFG1,
+			MT_RRO_PARTICULAR_CONFG_EN |
+			FIELD_PREP(MT_RRO_PARTICULAR_SID, 1));
+	} else {
+		mt76_wr(dev, MT_RRO_PARTICULAR_CFG1,
+			MT_RRO_PARTICULAR_CONFG_EN |
+			FIELD_PREP(MT_RRO_PARTICULAR_SID, MT7996_RRO_MAX_SESSION));
+	}
+	/* interrupt enable */
+	mt76_wr(dev, MT_RRO_HOST_INT_ENA,
+		MT_RRO_HOST_INT_ENA_HOST_RRO_DONE_ENA);
+
+#endif
+}
+
+static int mt7996_wed_rro_init(struct mt7996_dev *dev)
+{
+#ifdef CONFIG_NET_MEDIATEK_SOC_WED
+	struct mtk_wed_device *wed = &dev->mt76.mmio.wed;
 	struct mt7996_wed_rro_addr *addr;
 	void *ptr;
 	int i;
@@ -798,6 +1057,17 @@ static int mt7996_wed_rro_init(struct mt7996_dev *dev)
 			dev->wed_rro.addr_elem[i].phy_addr;
 	}
 
+	for (i = 0; i < MT7996_RRO_MSDU_PG_CR_CNT; i++) {
+		ptr = dmam_alloc_coherent(dev->mt76.dma_dev, MT7996_RRO_MSDU_PG_SIZE_PER_CR,
+					  &dev->wed_rro.msdu_pg[i].phy_addr,
+					  GFP_KERNEL);
+		if (!ptr)
+			return -ENOMEM;
+		dev->wed_rro.msdu_pg[i].ptr = ptr;
+
+		memset(dev->wed_rro.msdu_pg[i].ptr, 0, MT7996_RRO_MSDU_PG_SIZE_PER_CR);
+	}
+
 	ptr = dmam_alloc_coherent(dev->mt76.dma_dev,
 				  MT7996_RRO_WINDOW_MAX_LEN * sizeof(*addr),
 				  &dev->wed_rro.session.phy_addr,
@@ -812,50 +1082,9 @@ static int mt7996_wed_rro_init(struct mt7996_dev *dev)
 		addr++;
 	}
 
-	/* rro hw init */
-	/* TODO: remove line after WM has set */
-	mt76_clear(dev, WF_RRO_AXI_MST_CFG, WF_RRO_AXI_MST_CFG_DIDX_OK);
-
-	/* setup BA bitmap cache address */
-	mt76_wr(dev, MT_RRO_BA_BITMAP_BASE0,
-		dev->wed_rro.ba_bitmap[0].phy_addr);
-	mt76_wr(dev, MT_RRO_BA_BITMAP_BASE1, 0);
-	mt76_wr(dev, MT_RRO_BA_BITMAP_BASE_EXT0,
-		dev->wed_rro.ba_bitmap[1].phy_addr);
-	mt76_wr(dev, MT_RRO_BA_BITMAP_BASE_EXT1, 0);
-
-	/* setup Address element address */
-	for (i = 0; i < ARRAY_SIZE(dev->wed_rro.addr_elem); i++) {
-		mt76_wr(dev, reg, dev->wed_rro.addr_elem[i].phy_addr >> 4);
-		reg += 4;
-	}
-
-	/* setup Address element address - separate address segment mode */
-	mt76_wr(dev, MT_RRO_ADDR_ARRAY_BASE1,
-		MT_RRO_ADDR_ARRAY_ELEM_ADDR_SEG_MODE);
-
-	wed->wlan.ind_cmd.win_size = ffs(MT7996_RRO_WINDOW_MAX_LEN) - 6;
-	wed->wlan.ind_cmd.particular_sid = MT7996_RRO_MAX_SESSION;
-	wed->wlan.ind_cmd.particular_se_phys = dev->wed_rro.session.phy_addr;
-	wed->wlan.ind_cmd.se_group_nums = MT7996_RRO_ADDR_ELEM_LEN;
-	wed->wlan.ind_cmd.ack_sn_addr = MT_RRO_ACK_SN_CTRL;
-
-	mt76_wr(dev, MT_RRO_IND_CMD_SIGNATURE_BASE0, 0x15010e00);
-	mt76_set(dev, MT_RRO_IND_CMD_SIGNATURE_BASE1,
-		 MT_RRO_IND_CMD_SIGNATURE_BASE1_EN);
-
-	/* particular session configure */
-	/* use max session idx + 1 as particular session id */
-	mt76_wr(dev, MT_RRO_PARTICULAR_CFG0, dev->wed_rro.session.phy_addr);
-	mt76_wr(dev, MT_RRO_PARTICULAR_CFG1,
-		MT_RRO_PARTICULAR_CONFG_EN |
-		FIELD_PREP(MT_RRO_PARTICULAR_SID, MT7996_RRO_MAX_SESSION));
-
-	/* interrupt enable */
-	mt76_wr(dev, MT_RRO_HOST_INT_ENA,
-		MT_RRO_HOST_INT_ENA_HOST_RRO_DONE_ENA);
-
 	/* rro ind cmd queue init */
+	mt7996_rro_hw_init(dev);
+
 	return mt7996_dma_rro_init(dev);
 #else
 	return 0;
@@ -894,6 +1123,16 @@ static void mt7996_wed_rro_free(struct mt7996_dev *dev)
 				   dev->wed_rro.addr_elem[i].phy_addr);
 	}
 
+	for (i = 0; i < ARRAY_SIZE(dev->wed_rro.msdu_pg); i++) {
+		if (!dev->wed_rro.msdu_pg[i].ptr)
+			continue;
+
+		dmam_free_coherent(dev->mt76.dma_dev,
+				   MT7996_RRO_MSDU_PG_SIZE_PER_CR,
+				   dev->wed_rro.msdu_pg[i].ptr,
+				   dev->wed_rro.msdu_pg[i].phy_addr);
+	}
+
 	if (!dev->wed_rro.session.ptr)
 		return;
 
@@ -971,7 +1210,7 @@ static int mt7996_variant_type_init(struct mt7996_dev *dev)
 		else if (u32_get_bits(val, MT_PAD_GPIO_ADIE_COMB_7992))
 			var_type = MT7992_VAR_TYPE_44;
 		else
-			return -EINVAL;
+			var_type = MT7992_VAR_TYPE_24;
 		break;
 	case MT7990_DEVICE_ID:
 		var_type = MT7990_VAR_TYPE_23;
@@ -1029,6 +1268,9 @@ static int mt7996_variant_fem_init(struct mt7996_dev *dev)
 static int mt7996_init_hardware(struct mt7996_dev *dev)
 {
 	int ret, idx;
+	struct device_node *np = dev->mt76.dev->of_node;
+
+	of_property_read_u32(np, "option_type", &dev->option_type);
 
 	mt76_wr(dev, MT_INT_SOURCE_CSR, ~0);
 	if (is_mt7992(&dev->mt76)) {
@@ -1051,6 +1293,10 @@ static int mt7996_init_hardware(struct mt7996_dev *dev)
 
 	set_bit(MT76_STATE_INITIALIZED, &dev->mphy.state);
 
+	ret = mt7996_eeprom_check_fw_mode(dev);
+	if (ret < 0)
+		return ret;
+
 	ret = mt7996_mcu_init(dev);
 	if (ret)
 		return ret;
@@ -1067,6 +1313,12 @@ static int mt7996_init_hardware(struct mt7996_dev *dev)
 	if (ret < 0)
 		return ret;
 
+	if (dev->cal) {
+		ret = mt7996_mcu_apply_group_cal(dev);
+		if (ret)
+			return ret;
+	}
+
 	/* Beacon and mgmt frames should occupy wcid 0 */
 	idx = mt76_wcid_alloc(dev->mt76.wcid_mask, MT7996_WTBL_STA);
 	if (idx)
@@ -1513,6 +1765,7 @@ int mt7996_register_device(struct mt7996_dev *dev)
 	dev->mt76.phy.priv = &dev->phy;
 	INIT_WORK(&dev->rc_work, mt7996_mac_sta_rc_work);
 	INIT_DELAYED_WORK(&dev->mphy.mac_work, mt7996_mac_work);
+	INIT_DELAYED_WORK(&dev->scs_work, mt7996_mcu_scs_sta_poll);
 	INIT_LIST_HEAD(&dev->sta_rc_list);
 	INIT_LIST_HEAD(&dev->twt_list);
 
@@ -1521,12 +1774,22 @@ int mt7996_register_device(struct mt7996_dev *dev)
 	INIT_WORK(&dev->dump_work, mt7996_mac_dump_work);
 	mutex_init(&dev->dump_mutex);
 
+	INIT_WORK(&dev->wmm_pbc_work, mt7996_mcu_wmm_pbc_work);
+
 	ret = mt7996_init_hardware(dev);
 	if (ret)
 		return ret;
 
 	mt7996_init_wiphy(hw, &dev->mt76.mmio.wed);
 
+#ifdef CONFIG_NL80211_TESTMODE
+	dev->mt76.test_ops = &mt7996_testmode_ops;
+#endif
+
+#ifdef CONFIG_MTK_VENDOR
+	mt7996_vendor_register(&dev->phy);
+#endif
+
 	ret = mt7996_register_phy(dev, MT_BAND1);
 	if (ret)
 		return ret;
@@ -1540,16 +1803,26 @@ int mt7996_register_device(struct mt7996_dev *dev)
 	if (ret)
 		return ret;
 
-	mt7996_for_each_phy(dev, phy)
+	ret = mt7996_init_dev_debugfs(&dev->phy);
+	if (ret)
+		goto error;
+
+	mt7996_for_each_phy(dev, phy) {
 		mt7996_thermal_init(phy);
+		ret = mt7996_init_band_debugfs(phy);
+		if (ret)
+			goto error;
+	}
 
 	ieee80211_queue_work(mt76_hw(dev), &dev->init_work);
 
 	dev->recovery.hw_init_done = true;
 
-	ret = mt7996_init_debugfs(dev);
-	if (ret)
-		goto error;
+	if (mt7996_vow_should_enable(dev)) {
+		ret = mt7996_vow_init(&dev->phy);
+		if (ret)
+			goto error;
+	}
 
 	ret = mt7996_coredump_register(dev);
 	if (ret)
diff --git a/mt7996/mac.c b/mt7996/mac.c
index 91869530..5d0d41cb 100644
--- a/mt7996/mac.c
+++ b/mt7996/mac.c
@@ -5,13 +5,14 @@
 
 #include <linux/etherdevice.h>
 #include <linux/timekeeping.h>
+#include <linux/minmax.h>
 #include "coredump.h"
 #include "mt7996.h"
 #include "../dma.h"
 #include "mac.h"
 #include "mcu.h"
-
-#define to_rssi(field, rcpi)	((FIELD_GET(field, rcpi) - 220) / 2)
+#include "vendor.h"
+#include "mt7996_trace.h"
 
 static const struct mt7996_dfs_radar_spec etsi_radar_specs = {
 	.pulse_th = { 110, -10, -80, 40, 5200, 128, 5200 },
@@ -91,6 +92,9 @@ static struct mt76_wcid *mt7996_rx_get_wcid(struct mt7996_dev *dev,
 		break;
 	}
 
+	if (!msta_link)
+		return wcid;
+
 	return &msta_link->wcid;
 }
 
@@ -111,128 +115,16 @@ u32 mt7996_mac_wtbl_lmac_addr(struct mt7996_dev *dev, u16 wcid, u8 dw)
 	return MT_WTBL_LMAC_OFFS(wcid, dw);
 }
 
-static void mt7996_mac_sta_poll(struct mt7996_dev *dev)
-{
-	static const u8 ac_to_tid[] = {
-		[IEEE80211_AC_BE] = 0,
-		[IEEE80211_AC_BK] = 1,
-		[IEEE80211_AC_VI] = 4,
-		[IEEE80211_AC_VO] = 6
-	};
-	struct mt7996_sta_link *msta_link;
-	struct mt76_vif_link *mlink;
-	struct ieee80211_sta *sta;
-	struct mt7996_sta *msta;
-	u32 tx_time[IEEE80211_NUM_ACS], rx_time[IEEE80211_NUM_ACS];
-	LIST_HEAD(sta_poll_list);
-	struct mt76_wcid *wcid;
-	int i;
-
-	spin_lock_bh(&dev->mt76.sta_poll_lock);
-	list_splice_init(&dev->mt76.sta_poll_list, &sta_poll_list);
-	spin_unlock_bh(&dev->mt76.sta_poll_lock);
-
-	rcu_read_lock();
-
-	while (true) {
-		bool clear = false;
-		u32 addr, val;
-		u16 idx;
-		s8 rssi[4];
-
-		spin_lock_bh(&dev->mt76.sta_poll_lock);
-		if (list_empty(&sta_poll_list)) {
-			spin_unlock_bh(&dev->mt76.sta_poll_lock);
-			break;
-		}
-		msta_link = list_first_entry(&sta_poll_list,
-					     struct mt7996_sta_link,
-					     wcid.poll_list);
-		msta = msta_link->sta;
-		wcid = &msta_link->wcid;
-		list_del_init(&wcid->poll_list);
-		spin_unlock_bh(&dev->mt76.sta_poll_lock);
-
-		idx = wcid->idx;
-
-		/* refresh peer's airtime reporting */
-		addr = mt7996_mac_wtbl_lmac_addr(dev, idx, 20);
-
-		for (i = 0; i < IEEE80211_NUM_ACS; i++) {
-			u32 tx_last = msta_link->airtime_ac[i];
-			u32 rx_last = msta_link->airtime_ac[i + 4];
-
-			msta_link->airtime_ac[i] = mt76_rr(dev, addr);
-			msta_link->airtime_ac[i + 4] = mt76_rr(dev, addr + 4);
-
-			tx_time[i] = msta_link->airtime_ac[i] - tx_last;
-			rx_time[i] = msta_link->airtime_ac[i + 4] - rx_last;
-
-			if ((tx_last | rx_last) & BIT(30))
-				clear = true;
-
-			addr += 8;
-		}
-
-		if (clear) {
-			mt7996_mac_wtbl_update(dev, idx,
-					       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);
-			memset(msta_link->airtime_ac, 0,
-			       sizeof(msta_link->airtime_ac));
-		}
-
-		if (!wcid->sta)
-			continue;
-
-		sta = container_of((void *)msta, struct ieee80211_sta,
-				   drv_priv);
-		for (i = 0; i < IEEE80211_NUM_ACS; i++) {
-			u8 q = mt76_connac_lmac_mapping(i);
-			u32 tx_cur = tx_time[q];
-			u32 rx_cur = rx_time[q];
-			u8 tid = ac_to_tid[i];
-
-			if (!tx_cur && !rx_cur)
-				continue;
-
-			ieee80211_sta_register_airtime(sta, tid, tx_cur, rx_cur);
-		}
-
-		/* get signal strength of resp frames (CTS/BA/ACK) */
-		addr = mt7996_mac_wtbl_lmac_addr(dev, idx, 34);
-		val = mt76_rr(dev, addr);
-
-		rssi[0] = to_rssi(GENMASK(7, 0), val);
-		rssi[1] = to_rssi(GENMASK(15, 8), val);
-		rssi[2] = to_rssi(GENMASK(23, 16), val);
-		rssi[3] = to_rssi(GENMASK(31, 14), val);
-
-		mlink = rcu_dereference(msta->vif->mt76.link[wcid->link_id]);
-		if (mlink) {
-			struct mt76_phy *mphy = mt76_vif_link_phy(mlink);
-
-			if (mphy)
-				msta_link->ack_signal =
-					mt76_rx_signal(mphy->antenna_mask,
-						       rssi);
-		}
-
-		ewma_avg_signal_add(&msta_link->avg_ack_signal,
-				    -msta_link->ack_signal);
-	}
-
-	rcu_read_unlock();
-}
-
 /* The HW does not translate the mac header to 802.3 for mesh point */
 static int mt7996_reverse_frag0_hdr_trans(struct sk_buff *skb, u16 hdr_gap)
 {
 	struct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;
 	struct ethhdr *eth_hdr = (struct ethhdr *)(skb->data + hdr_gap);
-	struct mt7996_sta *msta = (struct mt7996_sta *)status->wcid;
+	struct mt7996_sta_link *msta_link = (struct mt7996_sta_link *)status->wcid;
 	__le32 *rxd = (__le32 *)skb->data;
 	struct ieee80211_sta *sta;
 	struct ieee80211_vif *vif;
+	struct ieee80211_bss_conf *conf;
 	struct ieee80211_hdr hdr;
 	u16 frame_control;
 
@@ -243,11 +135,14 @@ static int mt7996_reverse_frag0_hdr_trans(struct sk_buff *skb, u16 hdr_gap)
 	if (!(le32_to_cpu(rxd[1]) & MT_RXD1_NORMAL_GROUP_4))
 		return -EINVAL;
 
-	if (!msta || !msta->vif)
+	if (!msta_link->sta || !msta_link->sta->vif)
 		return -EINVAL;
 
-	sta = container_of((void *)msta, struct ieee80211_sta, drv_priv);
-	vif = container_of((void *)msta->vif, struct ieee80211_vif, drv_priv);
+	sta = wcid_to_sta(status->wcid);
+	vif = container_of((void *)msta_link->sta->vif, struct ieee80211_vif, drv_priv);
+	conf = rcu_dereference(vif->link_conf[msta_link->wcid.link_id]);
+	if (unlikely(!conf))
+		return -ENOLINK;
 
 	/* store the info from RXD and ethhdr to avoid being overridden */
 	frame_control = le32_get_bits(rxd[8], MT_RXD8_FRAME_CONTROL);
@@ -260,7 +155,7 @@ static int mt7996_reverse_frag0_hdr_trans(struct sk_buff *skb, u16 hdr_gap)
 	switch (frame_control & (IEEE80211_FCTL_TODS |
 				 IEEE80211_FCTL_FROMDS)) {
 	case 0:
-		ether_addr_copy(hdr.addr3, vif->bss_conf.bssid);
+		ether_addr_copy(hdr.addr3, conf->bssid);
 		break;
 	case IEEE80211_FCTL_FROMDS:
 		ether_addr_copy(hdr.addr3, eth_hdr->h_source);
@@ -470,7 +365,13 @@ mt7996_mac_fill_rx(struct mt7996_dev *dev, enum mt76_rxq_id q,
 	int idx;
 	u8 hw_aggr = false;
 	struct mt7996_sta *msta = NULL;
+	struct mt7996_sta_link *msta_link = NULL;
 
+#ifdef CONFIG_MTK_DEBUG
+	if (dev->dbg.dump_rx_raw)
+		mt7996_packet_log_to_host(dev, skb->data, skb->len, PKT_BIN_DEBUG_RX_RAW, 0);
+	mt7996_dump_bmac_rxd_info(dev, rxd);
+#endif
 	hw_aggr = status->aggr;
 	memset(status, 0, sizeof(*status));
 
@@ -479,6 +380,8 @@ mt7996_mac_fill_rx(struct mt7996_dev *dev, enum mt76_rxq_id q,
 	phy = mphy->priv;
 	status->phy_idx = mphy->band_idx;
 
+	trace_mt7996_fill_rx(phy, skb->data, skb->len);
+
 	if (!test_bit(MT76_STATE_RUNNING, &mphy->state))
 		return -EINVAL;
 
@@ -498,8 +401,6 @@ mt7996_mac_fill_rx(struct mt7996_dev *dev, enum mt76_rxq_id q,
 	status->wcid = mt7996_rx_get_wcid(dev, idx, band_idx);
 
 	if (status->wcid) {
-		struct mt7996_sta_link *msta_link;
-
 		msta_link = container_of(status->wcid, struct mt7996_sta_link,
 					 wcid);
 		msta = msta_link->sta;
@@ -653,6 +554,10 @@ mt7996_mac_fill_rx(struct mt7996_dev *dev, enum mt76_rxq_id q,
 		return -EINVAL;
 
 	hdr_gap = (u8 *)rxd - skb->data + 2 * remove_pad;
+#ifdef CONFIG_MTK_DEBUG
+	if (dev->dbg.dump_rx_pkt)
+		mt7996_packet_log_to_host(dev, skb->data, skb->len, PKT_BIN_DEBUG_RX, hdr_gap);
+#endif
 	if (hdr_trans && ieee80211_has_morefrags(fc)) {
 		if (mt7996_reverse_frag0_hdr_trans(skb, hdr_gap))
 			return -EINVAL;
@@ -707,15 +612,47 @@ mt7996_mac_fill_rx(struct mt7996_dev *dev, enum mt76_rxq_id q,
 			 */
 			if (ieee80211_has_a4(fc) && is_mesh && status->amsdu)
 				*qos &= ~IEEE80211_QOS_CTL_A_MSDU_PRESENT;
+		} else if (ieee80211_is_beacon(fc)) {
+			struct ieee80211_hw *hw = phy->mt76->hw;
+			struct ieee80211_sta *sta;
+			struct mt7996_sta *msta;
+			unsigned int link_id = 0;
+
+			sta = ieee80211_find_sta_by_link_addrs(hw, hdr->addr2, NULL, &link_id);
+			if (!sta)
+				sta = ieee80211_find_sta_by_ifaddr(hw, hdr->addr2, NULL);
+
+			if (sta) {
+				msta = (struct mt7996_sta *)sta->drv_priv;
+				if (msta && msta->vif) {
+					msta->vif->beacon_received_time[band_idx] = jiffies;
+					/* FIXME: This is a temporary workaround.
+					 * Lost links should be resumed via TTLM or
+					 * link reconfig.
+					 */
+					if (msta->vif->lost_links & BIT(link_id)) {
+						msta->vif->lost_links &= ~BIT(link_id);
+						wiphy_info(hw->wiphy,
+							   "link %d: resume beacon monitoring\n",
+							   link_id);
+					}
+				}
+			}
 		}
 		skb_set_mac_header(skb, (unsigned char *)hdr - skb->data);
+
+#ifdef CONFIG_MTK_VENDOR
+		if (phy->amnt_ctrl.enable && !ieee80211_is_beacon(fc))
+			mt7996_vendor_amnt_fill_rx(phy, skb);
+#endif
 	} else {
 		status->flag |= RX_FLAG_8023;
-		mt7996_wed_check_ppe(dev, &dev->mt76.q_rx[q], msta, skb,
+		mt7996_wed_check_ppe(dev, &dev->mt76.q_rx[q], msta_link ? msta_link->sta : NULL, skb,
 				     *info);
 	}
 
-	if (rxv && !(status->flag & RX_FLAG_8023)) {
+	if (rxv && !(status->flag & RX_FLAG_8023) &&
+	    (mode >= MT_PHY_TYPE_HE_SU && mode < MT_PHY_TYPE_EHT_SU)) {
 		switch (status->encoding) {
 		case RX_ENC_EHT:
 			mt76_connac3_mac_decode_eht_radiotap(skb, rxv, mode);
@@ -728,6 +665,8 @@ mt7996_mac_fill_rx(struct mt7996_dev *dev, enum mt76_rxq_id q,
 		}
 	}
 
+	trace_mt7996_fill_rx_done(phy, status->seqno, hdr_gap);
+
 	if (!status->wcid || !ieee80211_is_data_qos(fc) || hw_aggr)
 		return 0;
 
@@ -782,6 +721,8 @@ mt7996_mac_write_txwi_80211(struct mt7996_dev *dev, __le32 *txwi,
 			    struct ieee80211_key_conf *key,
 			    struct mt76_wcid *wcid)
 {
+	struct mt76_phy *mphy =
+		mt76_dev_phy(&dev->mt76, le32_get_bits(txwi[1], MT_TXD1_TGID));
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
 	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
@@ -792,6 +733,14 @@ mt7996_mac_write_txwi_80211(struct mt7996_dev *dev, __le32 *txwi,
 	u8 fc_type, fc_stype;
 	u32 val;
 
+	if (ieee80211_is_cert_mode(mphy->hw) && ieee80211_is_deauth(fc)) {
+		/* In WPA3 cert TC-4.8.1, the deauth must be transmitted without
+		 * considering PSM bit
+		 */
+		txwi[0] &= ~cpu_to_le32(MT_TXD0_Q_IDX);
+		txwi[0] |= cpu_to_le32(FIELD_PREP(MT_TXD0_Q_IDX, MT_LMAC_ALTX0));
+	}
+
 	if (ieee80211_is_action(fc) &&
 	    mgmt->u.action.category == WLAN_CATEGORY_BACK &&
 	    mgmt->u.action.u.addba_req.action_code == WLAN_ACTION_ADDBA_REQ) {
@@ -862,7 +811,8 @@ mt7996_mac_write_txwi_80211(struct mt7996_dev *dev, __le32 *txwi,
 	}
 
 	if (ieee80211_vif_is_mld(info->control.vif) &&
-	    (multicast || unlikely(skb->protocol == cpu_to_be16(ETH_P_PAE))))
+	    (multicast || unlikely(skb->protocol == cpu_to_be16(ETH_P_PAE)) ||
+	     info->flags & IEEE80211_TX_CTL_INJECTED))
 		txwi[5] |= cpu_to_le32(MT_TXD5_FL);
 
 	if (ieee80211_is_nullfunc(fc) && ieee80211_has_a4(fc) &&
@@ -903,12 +853,8 @@ void mt7996_mac_write_txwi(struct mt7996_dev *dev, __le32 *txwi,
 				       IEEE80211_TX_CTRL_MLO_LINK);
 
 	mvif = vif ? (struct mt7996_vif *)vif->drv_priv : NULL;
-	if (mvif) {
-		if (wcid->offchannel)
-			mlink = rcu_dereference(mvif->mt76.offchannel_link);
-		if (!mlink)
-			mlink = rcu_dereference(mvif->mt76.link[link_id]);
-	}
+	if (mvif)
+		mlink = rcu_dereference(mvif->mt76.link[link_id]);
 
 	if (mlink) {
 		omac_idx = mlink->omac_idx;
@@ -961,7 +907,8 @@ void mt7996_mac_write_txwi(struct mt7996_dev *dev, __le32 *txwi,
 	txwi[5] = cpu_to_le32(val);
 
 	val = MT_TXD6_DAS;
-	if (q_idx >= MT_LMAC_ALTX0 && q_idx <= MT_LMAC_BCN0)
+	if ((q_idx >= MT_LMAC_ALTX0 && q_idx <= MT_LMAC_BCN0) ||
+	    unlikely(skb->protocol == cpu_to_be16(ETH_P_PAE)))
 		val |= MT_TXD6_DIS_MAT;
 
 	if (is_mt7996(&dev->mt76))
@@ -1025,28 +972,72 @@ int mt7996_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
 			  struct ieee80211_sta *sta,
 			  struct mt76_tx_info *tx_info)
 {
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx_info->skb->data;
 	struct mt7996_dev *dev = container_of(mdev, struct mt7996_dev, mt76);
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx_info->skb);
 	struct ieee80211_key_conf *key = info->control.hw_key;
 	struct ieee80211_vif *vif = info->control.vif;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_sta *msta;
+	struct mt7996_vif_link *mconf;
 	struct mt76_connac_txp_common *txp;
 	struct mt76_txwi_cache *t;
 	int id, i, pid, nbuf = tx_info->nbuf - 1;
 	bool is_8023 = info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP;
 	u8 *txwi = (u8 *)txwi_ptr;
+	u8 link_id;
 
-	if (unlikely(tx_info->skb->len <= ETH_HLEN))
+	if (unlikely(tx_info->skb->len <= ETH_HLEN)) {
+		mdev->tx_dbg_stats.tx_drop[MT_TX_DROP_INVALID_SKB]++;
 		return -EINVAL;
+	}
 
-	if (!wcid)
-		wcid = &dev->mt76.global_wcid;
+	if (WARN_ON(!wcid)) {
+		mdev->tx_dbg_stats.tx_drop[MT_TX_DROP_INVALID_WCID]++;
+		return -EINVAL;
+	}
+
+	msta = sta ? (struct mt7996_sta *)sta->drv_priv : &mvif->sta;
+	if ((is_8023 || ieee80211_is_data_qos(hdr->frame_control)) && sta && sta->mlo) {
+		if (unlikely(tx_info->skb->protocol == cpu_to_be16(ETH_P_PAE))) {
+			link_id = msta->deflink_id;
+		} else {
+			u8 tid = tx_info->skb->priority & IEEE80211_QOS_CTL_TID_MASK;
+
+			link_id = (tid % 2) ? msta->sec_link : msta->deflink_id;
+		}
+	} else {
+		link_id = u32_get_bits(info->control.flags, IEEE80211_TX_CTRL_MLO_LINK);
+
+		if (link_id == IEEE80211_LINK_UNSPECIFIED || (sta && !sta->mlo))
+			link_id = wcid->link_id;
+	}
+
+	if (link_id != wcid->link_id) {
+		struct mt7996_sta_link *msta_link = rcu_dereference(msta->link[link_id]);
+
+		if (msta_link)
+			wcid = &msta_link->wcid;
+	}
+
+	mconf = (struct mt7996_vif_link *)rcu_dereference(mvif->mt76.link[wcid->link_id]);
+	if (!mconf) {
+		mdev->tx_dbg_stats.tx_drop[MT_TX_DROP_INVALID_LINK]++;
+		return -ENOLINK;
+	}
 
 	t = (struct mt76_txwi_cache *)(txwi + mdev->drv->txwi_size);
 	t->skb = tx_info->skb;
+	t->wcid = wcid->idx;
 
 	id = mt76_token_consume(mdev, &t);
-	if (id < 0)
+	if (id < 0) {
+		mdev->tx_dbg_stats.tx_drop[MT_TX_DROP_GET_TOKEN_FAIL]++;
 		return id;
+	}
+#ifdef CONFIG_MTK_DEBUG
+	t->jiffies = jiffies;
+#endif
 
 	pid = mt76_tx_status_skb_add(mdev, wcid, tx_info->skb);
 	memset(txwi_ptr, 0, MT_TXD_SIZE);
@@ -1055,6 +1046,43 @@ int mt7996_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
 		mt7996_mac_write_txwi(dev, txwi_ptr, tx_info->skb, wcid, key,
 				      pid, qid, 0);
 
+	/* Since the rules of HW MLD address translation are not fully compatible
+	 * with 802.11 EAPOL frame, we do the translation by software
+	 */
+	if (unlikely(tx_info->skb->protocol == cpu_to_be16(ETH_P_PAE)) && sta->mlo) {
+		struct ieee80211_bss_conf *conf;
+		struct ieee80211_link_sta *link_sta;
+		__le16 fc = hdr->frame_control;
+
+		conf = rcu_dereference(vif->link_conf[wcid->link_id]);
+		link_sta = rcu_dereference(sta->link[wcid->link_id]);
+		if (!conf || !link_sta) {
+			mdev->tx_dbg_stats.tx_drop[MT_TX_DROP_INVALID_LINK]++;
+			return -ENOLINK;
+		}
+
+		dma_sync_single_for_cpu(mdev->dma_dev, tx_info->buf[1].addr,
+					tx_info->buf[1].len, DMA_TO_DEVICE);
+
+		memcpy(hdr->addr1, link_sta->addr, ETH_ALEN);
+		memcpy(hdr->addr2, conf->addr, ETH_ALEN);
+
+		/* EAPOL's SA/DA need to be MLD address in MLO */
+		if (ieee80211_has_a4(fc)) {
+			memcpy(hdr->addr3, sta->addr, ETH_ALEN);
+			memcpy(hdr->addr4, vif->addr, ETH_ALEN);
+		} else if (ieee80211_has_tods(fc)) {
+			memcpy(hdr->addr3, sta->addr, ETH_ALEN);
+		} else if (ieee80211_has_fromds(fc)) {
+			memcpy(hdr->addr3, vif->addr, ETH_ALEN);
+		}
+
+		dma_sync_single_for_device(mdev->dma_dev, tx_info->buf[1].addr,
+					   tx_info->buf[1].len, DMA_TO_DEVICE);
+
+		pr_info("EAPOL: a1=%pM, a2=%pM, a3=%pM\n", hdr->addr1, hdr->addr2, hdr->addr3);
+	}
+
 	txp = (struct mt76_connac_txp_common *)(txwi + MT_TXD_SIZE);
 	for (i = 0; i < nbuf; i++) {
 		u16 len;
@@ -1081,18 +1109,7 @@ int mt7996_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
 	if (!is_8023 && mt7996_tx_use_mgmt(dev, tx_info->skb))
 		txp->fw.flags |= cpu_to_le16(MT_CT_INFO_MGMT_FRAME);
 
-	if (vif) {
-		struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-		struct mt76_vif_link *mlink = NULL;
-
-		if (wcid->offchannel)
-			mlink = rcu_dereference(mvif->mt76.offchannel_link);
-		if (!mlink)
-			mlink = rcu_dereference(mvif->mt76.link[wcid->link_id]);
-
-		txp->fw.bss_idx = mlink ? mlink->idx : mvif->deflink.mt76.idx;
-	}
-
+	txp->fw.bss_idx = mconf->mt76.idx;
 	txp->fw.token = cpu_to_le16(id);
 	txp->fw.rept_wds_wcid = cpu_to_le16(sta ? wcid->idx : 0xfff);
 
@@ -1103,6 +1120,15 @@ int mt7996_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
 	tx_info->buf[1].skip_unmap = true;
 	tx_info->nbuf = MT_CT_DMA_BUF_NUM;
 
+#ifdef CONFIG_MTK_DEBUG
+	if (dev->dbg.dump_txd)
+		mt7996_packet_log_to_host(dev, txwi, MT_TXD_SIZE, PKT_BIN_DEBUG_TXD, 0);
+	if (dev->dbg.dump_tx_pkt)
+		mt7996_packet_log_to_host(dev, t->skb->data, t->skb->len, PKT_BIN_DEBUG_TX, 0);
+	mt7996_dump_bmac_txd_info(NULL, dev, (__le32 *)txwi, true, false);
+#endif
+	trace_mt7996_tx_prepare(dev, wcid, qid, txwi, t->skb->data, t->skb->len);
+
 	return 0;
 }
 
@@ -1133,6 +1159,9 @@ static void
 mt7996_tx_check_aggr(struct ieee80211_link_sta *link_sta,
 		     struct mt76_wcid *wcid, struct sk_buff *skb)
 {
+	struct mt7996_sta *msta;
+	struct mt7996_sta_link *msta_link;
+	struct ieee80211_link_sta *link_sta;
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	bool is_8023 = info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP;
 	u16 fc, tid;
@@ -1141,8 +1170,6 @@ mt7996_tx_check_aggr(struct ieee80211_link_sta *link_sta,
 		return;
 
 	tid = skb->priority & IEEE80211_QOS_CTL_TID_MASK;
-	if (tid >= 6) /* skip VO queue */
-		return;
 
 	if (is_8023) {
 		fc = IEEE80211_FTYPE_DATA |
@@ -1210,6 +1237,7 @@ mt7996_mac_tx_free(struct mt7996_dev *dev, void *data, int len)
 	struct mt76_phy *phy2 = mdev->phys[MT_BAND1];
 	struct mt76_phy *phy3 = mdev->phys[MT_BAND2];
 	struct ieee80211_link_sta *link_sta = NULL;
+	struct mt7996_phy *mphy;
 	struct mt76_txwi_cache *txwi;
 	struct mt76_wcid *wcid = NULL;
 	LIST_HEAD(free_list);
@@ -1217,7 +1245,12 @@ mt7996_mac_tx_free(struct mt7996_dev *dev, void *data, int len)
 	void *end = data + len;
 	bool wake = false;
 	u16 total, count = 0;
-	u8 ver;
+	u8 ver, status = 0;
+	u8 reason = 0;
+	enum {
+		INVALID_WLAN_ID,
+		INVALID_MSDU_ID,
+	};
 
 	/* clean DMA queues and unmap buffers first */
 	mt76_queue_tx_cleanup(dev, dev->mphy.q_tx[MT_TXQ_PSD], false);
@@ -1240,18 +1273,30 @@ mt7996_mac_tx_free(struct mt7996_dev *dev, void *data, int len)
 		u32 msdu, info;
 		u8 i;
 
-		if (WARN_ON_ONCE((void *)cur_info >= end))
+		if ((void *)cur_info >= end) {
+		        dev_info(mdev->dev, "txfree: count=%u total=%u\n", count, total);
 			return;
+		}
 		/* 1'b1: new wcid pair.
 		 * 1'b0: msdu_id with the same 'wcid pair' as above.
 		 */
 		info = le32_to_cpu(*cur_info);
 		if (info & MT_TXFREE_INFO_PAIR) {
 			struct ieee80211_sta *sta;
+			struct mt7996_sta *msta;
+			unsigned long valid_links;
+			unsigned int link_id;
 			u16 idx;
 
 			idx = FIELD_GET(MT_TXFREE_INFO_WLAN_ID, info);
+			if (idx >= mt7996_wtbl_size(dev)) {
+				trace_mt7996_mac_tx_free(dev, INVALID_WLAN_ID,
+							 data, len, idx, 0);
+				return;
+			}
+
 			wcid = mt76_wcid_ptr(dev, idx);
+
 			sta = wcid_to_sta(wcid);
 			if (!sta) {
 				link_sta = NULL;
@@ -1262,7 +1307,19 @@ mt7996_mac_tx_free(struct mt7996_dev *dev, void *data, int len)
 			if (!link_sta)
 				goto next;
 
-			mt76_wcid_add_poll(&dev->mt76, wcid);
+			// mt76_wcid_add_poll(&dev->mt76, wcid);
+			valid_links = sta->valid_links ?: BIT(0);
+			msta = (struct mt7996_sta *)sta->drv_priv;
+			/* for MLD STA, add all link's wcid to sta_poll_list */
+			spin_lock_bh(&mdev->sta_poll_lock);
+			for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+				struct mt7996_sta_link *msta_link =
+					rcu_dereference(msta->link[link_id]);
+
+				if (msta_link && list_empty(&msta_link->wcid.poll_list))
+					list_add_tail(&msta_link->wcid.poll_list, &mdev->sta_poll_list);
+			}
+			spin_unlock_bh(&mdev->sta_poll_lock);
 next:
 			/* ver 7 has a new DW with pair = 1, skip it */
 			if (ver == 7 && ((void *)(cur_info + 1) < end) &&
@@ -1270,38 +1327,42 @@ next:
 				cur_info++;
 			continue;
 		} else if (info & MT_TXFREE_INFO_HEADER) {
-			u32 tx_retries = 0, tx_failed = 0;
-
-			if (!wcid)
-				continue;
-
-			tx_retries =
-				FIELD_GET(MT_TXFREE_INFO_COUNT, info) - 1;
-			tx_failed = tx_retries +
-				!!FIELD_GET(MT_TXFREE_INFO_STAT, info);
-
-			wcid->stats.tx_retries += tx_retries;
-			wcid->stats.tx_failed += tx_failed;
+			status = FIELD_GET(MT_TXFREE_INFO_STAT, info);
+			reason = is_mt7990(&dev->mt76) ?
+				  FIELD_GET(MT_TXFREE_INFO_REASON, info) : 0;
 			continue;
 		}
 
 		for (i = 0; i < 2; i++) {
+			u8 phy_idx;
+
 			msdu = (info >> (15 * i)) & MT_TXFREE_INFO_MSDU_ID;
 			if (msdu == MT_TXFREE_INFO_MSDU_ID)
 				continue;
 
 			count++;
 			txwi = mt76_token_release(mdev, msdu, &wake);
+
+			if (!txwi && (!mtk_wed_device_active(&dev->mt76.mmio.wed) ||
+				      !in_range(msdu, 0, dev->mt76.mmio.wed.wlan.nbuf)))
+				trace_mt7996_mac_tx_free(dev, INVALID_MSDU_ID,
+							 data, len,
+							 wcid ? wcid->idx : 0,
+							 msdu);
+			phy_idx = txwi ? txwi->phy_idx : (wcid ? wcid->phy_idx : 0);
+			mphy = __mt7996_phy(dev, phy_idx);
+			if (mphy && status)
+				mphy->hw_drop[status][reason]++;
+
 			if (!txwi)
 				continue;
 
 			mt7996_txwi_free(dev, txwi, link_sta, wcid,
 					 &free_list);
+			txwi->jiffies = 0;
 		}
 	}
 
-	mt7996_mac_sta_poll(dev);
-
 	if (wake)
 		mt76_set_tx_blocked(&dev->mt76, false);
 
@@ -1336,6 +1397,11 @@ mt7996_mac_add_txs_skb(struct mt7996_dev *dev, struct mt76_wcid *wcid,
 	if (le32_get_bits(txs_data[0], MT_TXS0_TXS_FORMAT) == 0) {
 		skb = mt76_tx_status_skb_get(mdev, wcid, pid, &list);
 		if (skb) {
+			struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+			struct mt7996_sta_link *msta_link =
+				container_of(wcid, struct mt7996_sta_link, wcid);
+			struct mt7996_vif *mvif;
+
 			info = IEEE80211_SKB_CB(skb);
 			if (!(txs & MT_TXS0_ACK_ERROR_MASK))
 				info->flags |= IEEE80211_TX_STAT_ACK;
@@ -1345,16 +1411,38 @@ mt7996_mac_add_txs_skb(struct mt7996_dev *dev, struct mt76_wcid *wcid,
 				!!(info->flags & IEEE80211_TX_STAT_ACK);
 
 			info->status.rates[0].idx = -1;
+
+			/* connection monitoring */
+			if (msta_link && msta_link->sta)
+				mvif = msta_link->sta->vif;
+			if (ieee80211_is_nullfunc(hdr->frame_control) && mvif &&
+			    mvif->probe[wcid->phy_idx] == (void *)skb &&
+			    info->flags & IEEE80211_TX_STAT_ACK) {
+				/* reset beacon monitoring */
+				mvif->probe[wcid->phy_idx] = NULL;
+				mvif->beacon_received_time[wcid->phy_idx] = jiffies;
+				mvif->probe_send_count[wcid->phy_idx] = 0;
+			}
 		}
 	}
 
-	if (mtk_wed_device_active(&dev->mt76.mmio.wed) && wcid->sta) {
-		struct ieee80211_sta *sta;
-		u8 tid;
+	if (mtk_wed_device_active(&dev->mt76.mmio.wed) && wcid->sta &&
+	    (wcid->tx_info & MT_WCID_TX_INFO_SET)) {
+		/* Do not check TX BA status for mgmt frames which are sent at a
+		 * fixed rate
+		 */
+		if (!le32_get_bits(txs_data[3], MT_TXS3_FIXED_RATE)) {
+			struct ieee80211_sta *sta = wcid_to_sta(wcid);
+			struct ieee80211_link_sta *link_sta =
+				rcu_dereference(sta->link[wcid->link_id]);
+			struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
 
-		sta = wcid_to_sta(wcid);
-		tid = FIELD_GET(MT_TXS0_TID, txs);
-		ieee80211_refresh_tx_agg_session_timer(sta, tid);
+			if (!link_sta)
+				goto unlock;
+
+			mt7996_check_tx_ba_status(link_sta, &msta->deflink.wcid,
+						  FIELD_GET(MT_TXS0_TID, txs));
+		}
 	}
 
 	txrate = FIELD_GET(MT_TXS0_TX_RATE, txs);
@@ -1532,9 +1620,11 @@ void mt7996_queue_rx_skb(struct mt76_dev *mdev, enum mt76_rxq_id q,
 			 struct sk_buff *skb, u32 *info)
 {
 	struct mt7996_dev *dev = container_of(mdev, struct mt7996_dev, mt76);
+	struct mt76_phy *phy;
 	__le32 *rxd = (__le32 *)skb->data;
 	__le32 *end = (__le32 *)&skb->data[skb->len];
 	enum rx_pkt_type type;
+	u8 band_idx;
 
 	type = le32_get_bits(rxd[0], MT_RXD0_PKT_TYPE);
 	if (type != PKT_TYPE_NORMAL) {
@@ -1569,12 +1659,23 @@ void mt7996_queue_rx_skb(struct mt76_dev *mdev, enum mt76_rxq_id q,
 		dev_kfree_skb(skb);
 		break;
 	case PKT_TYPE_NORMAL:
+		band_idx = le32_get_bits(rxd[1], MT_RXD1_NORMAL_BAND_IDX);
+		phy = mt76_dev_phy(mdev, band_idx);
+		spin_lock_bh(&phy->rx_dbg_stats.lock);
+		phy->rx_dbg_stats.rx_from_hw++;
+		spin_unlock_bh(&phy->rx_dbg_stats.lock);
+
 		if (!mt7996_mac_fill_rx(dev, q, skb, info)) {
 			mt76_rx(&dev->mt76, q, skb);
 			return;
 		}
 		fallthrough;
 	default:
+		band_idx = le32_get_bits(rxd[1], MT_RXD1_NORMAL_BAND_IDX);
+		phy = mt76_dev_phy(mdev, band_idx);
+		spin_lock_bh(&phy->rx_dbg_stats.lock);
+		phy->rx_dbg_stats.rx_drop[MT_RX_DROP_RXD_ERR]++;
+		spin_unlock_bh(&phy->rx_dbg_stats.lock);
 		dev_kfree_skb(skb);
 		break;
 	}
@@ -1711,7 +1812,6 @@ mt7996_update_vif_beacon(void *priv, u8 *mac, struct ieee80211_vif *vif)
 	struct mt7996_dev *dev = phy->dev;
 	unsigned int link_id;
 
-
 	switch (vif->type) {
 	case NL80211_IFTYPE_MESH_POINT:
 	case NL80211_IFTYPE_ADHOC:
@@ -1728,7 +1828,8 @@ mt7996_update_vif_beacon(void *priv, u8 *mac, struct ieee80211_vif *vif)
 		if (!link || link->phy != phy)
 			continue;
 
-		mt7996_mcu_add_beacon(dev->mt76.hw, vif, link_conf);
+		mt7996_mcu_add_beacon(dev->mt76.hw, vif, link_conf,
+				      link_conf->enable_beacon);
 	}
 }
 
@@ -1855,6 +1956,31 @@ mt7996_mac_restart(struct mt7996_dev *dev)
 	if (ret)
 		goto out;
 
+	if (mtk_wed_device_active(&dev->mt76.mmio.wed) && dev->has_rro) {
+		u32 wed_irq_mask = dev->mt76.mmio.irqmask |
+				   MT_INT_RRO_RX_DONE |
+				   MT_INT_TX_DONE_BAND2;
+
+		mt7996_rro_hw_init(dev);
+		mt76_for_each_q_rx(&dev->mt76, i) {
+			if (mt76_queue_is_wed_rro_ind(&dev->mt76.q_rx[i]) ||
+			    mt76_queue_is_wed_rro_msdu_pg(&dev->mt76.q_rx[i]))
+				mt76_queue_rx_reset(dev, i);
+		}
+
+		mt76_wr(dev, MT_INT_MASK_CSR, wed_irq_mask);
+		mtk_wed_device_start_hw_rro(&dev->mt76.mmio.wed, wed_irq_mask, false);
+		mt7996_irq_enable(dev, wed_irq_mask);
+		mt7996_irq_disable(dev, 0);
+	}
+
+	if (mtk_wed_device_active(&dev->mt76.mmio.wed_hif2)) {
+		mt76_wr(dev, MT_INT_PCIE1_MASK_CSR,
+			MT_INT_TX_RX_DONE_EXT);
+		mtk_wed_device_start(&dev->mt76.mmio.wed_hif2,
+				     MT_INT_TX_RX_DONE_EXT);
+	}
+
 	/* set the necessary init items */
 	ret = mt7996_mcu_set_eeprom(dev);
 	if (ret)
@@ -1911,19 +2037,31 @@ mt7996_mac_full_reset(struct mt7996_dev *dev)
 	phy3 = mt7996_phy3(dev);
 	dev->recovery.hw_full_reset = true;
 
-	wake_up(&dev->mt76.mcu.wait);
 	ieee80211_stop_queues(mt76_hw(dev));
 	if (phy2)
 		ieee80211_stop_queues(phy2->mt76->hw);
 	if (phy3)
 		ieee80211_stop_queues(phy3->mt76->hw);
 
+	set_bit(MT76_RESET, &dev->mphy.state);
+	set_bit(MT76_MCU_RESET, &dev->mphy.state);
+	wake_up(&dev->mt76.mcu.wait);
+	if (phy2) {
+		set_bit(MT76_RESET, &phy2->mt76->state);
+		set_bit(MT76_MCU_RESET, &phy2->mt76->state);
+	}
+	if (phy3) {
+		set_bit(MT76_RESET, &phy3->mt76->state);
+		set_bit(MT76_MCU_RESET, &phy3->mt76->state);
+	}
+
 	cancel_work_sync(&dev->wed_rro.work);
 	cancel_delayed_work_sync(&dev->mphy.mac_work);
 	if (phy2)
 		cancel_delayed_work_sync(&phy2->mt76->mac_work);
 	if (phy3)
 		cancel_delayed_work_sync(&phy3->mt76->mac_work);
+	cancel_delayed_work_sync(&dev->scs_work);
 
 	mutex_lock(&dev->mt76.mutex);
 	for (i = 0; i < 10; i++) {
@@ -1959,6 +2097,7 @@ mt7996_mac_full_reset(struct mt7996_dev *dev)
 		ieee80211_queue_delayed_work(phy3->mt76->hw,
 					     &phy3->mt76->mac_work,
 					     MT7996_WATCHDOG_TIME);
+	ieee80211_queue_delayed_work(mt76_hw(dev), &dev->scs_work, HZ);
 }
 
 void mt7996_mac_reset_work(struct work_struct *work)
@@ -1999,6 +2138,7 @@ void mt7996_mac_reset_work(struct work_struct *work)
 	if (!(READ_ONCE(dev->recovery.state) & MT_MCU_CMD_STOP_DMA))
 		return;
 
+	dev->recovery.l1_reset_last = dev->recovery.l1_reset;
 	dev_info(dev->mt76.dev,"\n%s L1 SER recovery start.",
 		 wiphy_name(dev->mt76.hw->wiphy));
 
@@ -2008,21 +2148,22 @@ void mt7996_mac_reset_work(struct work_struct *work)
 	if (phy3)
 		ieee80211_stop_queues(phy3->mt76->hw);
 
+	dev_info(dev->mt76.dev,"%s L1 SER queue stop done.",
+		 wiphy_name(dev->mt76.hw->wiphy));
+
 	set_bit(MT76_RESET, &dev->mphy.state);
 	set_bit(MT76_MCU_RESET, &dev->mphy.state);
-	wake_up(&dev->mt76.mcu.wait);
-
-	cancel_work_sync(&dev->wed_rro.work);
-	cancel_delayed_work_sync(&dev->mphy.mac_work);
-	if (phy2) {
+	if (phy2)
 		set_bit(MT76_RESET, &phy2->mt76->state);
-		cancel_delayed_work_sync(&phy2->mt76->mac_work);
-	}
-	if (phy3) {
+	if (phy3)
 		set_bit(MT76_RESET, &phy3->mt76->state);
-		cancel_delayed_work_sync(&phy3->mt76->mac_work);
-	}
+	wake_up(&dev->mt76.mcu.wait);
+
 	mt76_worker_disable(&dev->mt76.tx_worker);
+
+	dev_info(dev->mt76.dev,"%s L1 SER disable tx_work done.",
+		 wiphy_name(dev->mt76.hw->wiphy));
+
 	mt76_for_each_q_rx(&dev->mt76, i) {
 		if (mtk_wed_device_active(&dev->mt76.mmio.wed) &&
 		    mt76_queue_is_wed_rro(&dev->mt76.q_rx[i]))
@@ -2032,16 +2173,30 @@ void mt7996_mac_reset_work(struct work_struct *work)
 	}
 	napi_disable(&dev->mt76.tx_napi);
 
-	mutex_lock(&dev->mt76.mutex);
+	dev_info(dev->mt76.dev,"%s L1 SER napi disable done.",
+		 wiphy_name(dev->mt76.hw->wiphy));
 
 	mt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_DMA_STOPPED);
 
+	dev_info(dev->mt76.dev,"%s L1 SER dma stop done.",
+		 wiphy_name(dev->mt76.hw->wiphy));
+
 	if (mt7996_wait_reset_state(dev, MT_MCU_CMD_RESET_DONE)) {
 		mt7996_dma_reset(dev, false);
 
+		dev_info(dev->mt76.dev,"%s L1 SER dma reset done.",
+			wiphy_name(dev->mt76.hw->wiphy));
+
 		mt7996_tx_token_put(dev);
+
+		dev_info(dev->mt76.dev,"%s L1 SER token put done.",
+			wiphy_name(dev->mt76.hw->wiphy));
+
 		idr_init(&dev->mt76.token);
 
+		dev_info(dev->mt76.dev,"%s L1 SER idr init done.",
+			wiphy_name(dev->mt76.hw->wiphy));
+
 		mt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_DMA_INIT);
 		mt7996_wait_reset_state(dev, MT_MCU_CMD_RECOVERY_DONE);
 	}
@@ -2052,6 +2207,9 @@ void mt7996_mac_reset_work(struct work_struct *work)
 	/* enable DMA Tx/Tx and interrupt */
 	mt7996_dma_start(dev, false, false);
 
+	dev_info(dev->mt76.dev,"%s L1 SER dma start done.",
+		 wiphy_name(dev->mt76.hw->wiphy));
+
 	if (mtk_wed_device_active(&dev->mt76.mmio.wed)) {
 		u32 wed_irq_mask = MT_INT_RRO_RX_DONE | MT_INT_TX_DONE_BAND2 |
 				   dev->mt76.mmio.irqmask;
@@ -2061,8 +2219,13 @@ void mt7996_mac_reset_work(struct work_struct *work)
 
 		mt76_wr(dev, MT_INT_MASK_CSR, wed_irq_mask);
 
+		if (is_mt7992(&dev->mt76) && dev->has_rro)
+			mt76_wr(dev, MT_RRO_3_0_EMU_CONF,
+				MT_RRO_3_0_EMU_CONF_EN_MASK);
+
 		mtk_wed_device_start_hw_rro(&dev->mt76.mmio.wed, wed_irq_mask,
 					    true);
+
 		mt7996_irq_enable(dev, wed_irq_mask);
 		mt7996_irq_disable(dev, 0);
 	}
@@ -2073,6 +2236,9 @@ void mt7996_mac_reset_work(struct work_struct *work)
 				     MT_INT_TX_RX_DONE_EXT);
 	}
 
+	dev_info(dev->mt76.dev,"%s L1 SER wed start done.",
+		 wiphy_name(dev->mt76.hw->wiphy));
+
 	clear_bit(MT76_MCU_RESET, &dev->mphy.state);
 	clear_bit(MT76_RESET, &dev->mphy.state);
 	if (phy2)
@@ -2106,47 +2272,32 @@ void mt7996_mac_reset_work(struct work_struct *work)
 	if (phy3)
 		ieee80211_wake_queues(phy3->mt76->hw);
 
-	mutex_unlock(&dev->mt76.mutex);
-
 	mt7996_update_beacons(dev);
 
-	ieee80211_queue_delayed_work(mt76_hw(dev), &dev->mphy.mac_work,
-				     MT7996_WATCHDOG_TIME);
-	if (phy2)
-		ieee80211_queue_delayed_work(phy2->mt76->hw,
-					     &phy2->mt76->mac_work,
-					     MT7996_WATCHDOG_TIME);
-	if (phy3)
-		ieee80211_queue_delayed_work(phy3->mt76->hw,
-					     &phy3->mt76->mac_work,
-					     MT7996_WATCHDOG_TIME);
 	dev_info(dev->mt76.dev,"\n%s L1 SER recovery completed.",
 		 wiphy_name(dev->mt76.hw->wiphy));
 }
 
 /* firmware coredump */
-void mt7996_mac_dump_work(struct work_struct *work)
+void mt7996_mac_fw_coredump(struct mt7996_dev *dev, u8 type)
 {
 	const struct mt7996_mem_region *mem_region;
 	struct mt7996_crash_data *crash_data;
-	struct mt7996_dev *dev;
 	struct mt7996_mem_hdr *hdr;
 	size_t buf_len;
 	int i;
 	u32 num;
 	u8 *buf;
 
-	dev = container_of(work, struct mt7996_dev, dump_work);
-
 	mutex_lock(&dev->dump_mutex);
 
-	crash_data = mt7996_coredump_new(dev);
+	crash_data = mt7996_coredump_new(dev, type);
 	if (!crash_data) {
 		mutex_unlock(&dev->dump_mutex);
-		goto skip_coredump;
+		return;
 	}
 
-	mem_region = mt7996_coredump_get_mem_layout(dev, &num);
+	mem_region = mt7996_coredump_get_mem_layout(dev, type, &num);
 	if (!mem_region || !crash_data->memdump_buf_len) {
 		mutex_unlock(&dev->dump_mutex);
 		goto skip_memdump;
@@ -2156,6 +2307,9 @@ void mt7996_mac_dump_work(struct work_struct *work)
 	buf_len = crash_data->memdump_buf_len;
 
 	/* dumping memory content... */
+	dev_info(dev->mt76.dev, "%s start coredump for %s\n",
+		 wiphy_name(dev->mt76.hw->wiphy),
+		 ((type == MT7996_RAM_TYPE_WA) ? "WA" : "WM"));
 	memset(buf, 0, buf_len);
 	for (i = 0; i < num; i++) {
 		if (mem_region->len > buf_len) {
@@ -2172,6 +2326,7 @@ void mt7996_mac_dump_work(struct work_struct *work)
 		mt7996_memcpy_fromio(dev, buf, mem_region->start,
 				     mem_region->len);
 
+		strscpy(hdr->name, mem_region->name, sizeof(hdr->name));
 		hdr->start = mem_region->start;
 		hdr->len = mem_region->len;
 
@@ -2188,13 +2343,49 @@ void mt7996_mac_dump_work(struct work_struct *work)
 	mutex_unlock(&dev->dump_mutex);
 
 skip_memdump:
-	mt7996_coredump_submit(dev);
-skip_coredump:
-	queue_work(dev->mt76.wq, &dev->reset_work);
+	mt7996_coredump_submit(dev, type);
 }
 
+void mt7996_mac_dump_work(struct work_struct *work)
+{
+	struct mt7996_dev *dev;
+
+	dev = container_of(work, struct mt7996_dev, dump_work);
+	if (dev->dump_state == MT7996_COREDUMP_MANUAL_WA ||
+	    READ_ONCE(dev->recovery.state) & MT_MCU_CMD_WA_WDT)
+		mt7996_mac_fw_coredump(dev, MT7996_RAM_TYPE_WA);
+
+	if (dev->dump_state == MT7996_COREDUMP_MANUAL_WM ||
+	    READ_ONCE(dev->recovery.state) & MT_MCU_CMD_WM_WDT)
+		mt7996_mac_fw_coredump(dev, MT7996_RAM_TYPE_WM);
+
+	if (READ_ONCE(dev->recovery.state) & MT_MCU_CMD_WDT_MASK)
+		queue_work(dev->mt76.wq, &dev->reset_work);
+
+	dev->dump_state = MT7996_COREDUMP_IDLE;
+}
+
+void mt7996_coredump(struct mt7996_dev *dev, u8 state)
+{
+	if (state == MT7996_COREDUMP_IDLE ||
+	    state >= __MT7996_COREDUMP_TYPE_MAX)
+		return;
+
+	if (dev->dump_state != MT7996_COREDUMP_IDLE)
+		return;
+
+	dev->dump_state = state;
+	dev_info(dev->mt76.dev, "%s attempting grab coredump\n",
+		 wiphy_name(dev->mt76.hw->wiphy));
+
+	queue_work(dev->mt76.wq, &dev->dump_work);
+ }
+
 void mt7996_reset(struct mt7996_dev *dev)
 {
+	dev_info(dev->mt76.dev, "%s SER recovery state: 0x%08x\n",
+		 wiphy_name(dev->mt76.hw->wiphy), READ_ONCE(dev->recovery.state));
+
 	if (!dev->recovery.hw_init_done)
 		return;
 
@@ -2210,9 +2401,13 @@ void mt7996_reset(struct mt7996_dev *dev)
 
 		mt7996_irq_disable(dev, MT_INT_MCU_CMD);
 		queue_work(dev->mt76.wq, &dev->dump_work);
+		mt7996_coredump(dev, MT7996_COREDUMP_AUTO);
 		return;
 	}
 
+	if ((READ_ONCE(dev->recovery.state) & MT_MCU_CMD_STOP_DMA))
+		dev->recovery.l1_reset++;
+
 	queue_work(dev->mt76.wq, &dev->reset_work);
 	wake_up(&dev->reset_wait);
 }
@@ -2221,10 +2416,19 @@ void mt7996_mac_update_stats(struct mt7996_phy *phy)
 {
 	struct mt76_mib_stats *mib = &phy->mib;
 	struct mt7996_dev *dev = phy->dev;
+	struct mt76_mib_stats *main_mib = &dev->phy.mib;
 	u8 band_idx = phy->mt76->band_idx;
 	u32 cnt;
 	int i;
 
+	/* Update per-dev structures */
+	for (i = 0; i < ARRAY_SIZE(main_mib->tx_amsdu); i++) {
+		cnt = mt76_rr(dev, MT_PLE_AMSDU_PACK_MSDU_CNT(i));
+		main_mib->tx_amsdu[i] += cnt;
+		main_mib->tx_amsdu_cnt += cnt;
+	}
+
+	/* Update per-phy structures */
 	cnt = mt76_rr(dev, MT_MIB_RSCR1(band_idx));
 	mib->fcs_err_cnt += cnt;
 
@@ -2330,12 +2534,6 @@ void mt7996_mac_update_stats(struct mt7996_phy *phy)
 	cnt = mt76_rr(dev, MT_MIB_BSCR17(band_idx));
 	mib->tx_bf_fb_cpl_cnt += cnt;
 
-	for (i = 0; i < ARRAY_SIZE(mib->tx_amsdu); i++) {
-		cnt = mt76_rr(dev, MT_PLE_AMSDU_PACK_MSDU_CNT(i));
-		mib->tx_amsdu[i] += cnt;
-		mib->tx_amsdu_cnt += cnt;
-	}
-
 	/* rts count */
 	cnt = mt76_rr(dev, MT_MIB_BTSCR5(band_idx));
 	mib->rts_cnt += cnt;
@@ -2358,6 +2556,14 @@ void mt7996_mac_update_stats(struct mt7996_phy *phy)
 	}
 }
 
+void mt7996_set_wireless_amsdu(struct ieee80211_hw *hw, u8 en)
+{
+	if (en)
+		ieee80211_hw_set(hw, SUPPORTS_AMSDU_IN_AMPDU);
+	else
+		ieee80211_hw_clear(hw, SUPPORTS_AMSDU_IN_AMPDU);
+}
+
 void mt7996_mac_sta_rc_work(struct work_struct *work)
 {
 	struct mt7996_dev *dev = container_of(work, struct mt7996_dev, rc_work);
@@ -2405,29 +2611,52 @@ void mt7996_mac_work(struct work_struct *work)
 {
 	struct mt7996_phy *phy;
 	struct mt76_phy *mphy;
+	struct mt76_dev *mdev;
 
 	mphy = (struct mt76_phy *)container_of(work, struct mt76_phy,
 					       mac_work.work);
 	phy = mphy->priv;
+	mdev = mphy->dev;
 
-	mutex_lock(&mphy->dev->mutex);
+	mutex_lock(&mdev->mutex);
 
 	mt76_update_survey(mphy);
-	if (++mphy->mac_work_count == 5) {
-		mphy->mac_work_count = 0;
+	if (++mphy->mac_work_count % 5 == 0) {
+		int i;
 
 		mt7996_mac_update_stats(phy);
 
-		mt7996_mcu_get_all_sta_info(phy, UNI_ALL_STA_TXRX_RATE);
-		if (mtk_wed_device_active(&phy->dev->mt76.mmio.wed)) {
-			mt7996_mcu_get_all_sta_info(phy, UNI_ALL_STA_TXRX_ADM_STAT);
-			mt7996_mcu_get_all_sta_info(phy, UNI_ALL_STA_TXRX_MSDU_COUNT);
+		/* Update DEV-wise information only in
+		 * the MAC work of the first band running.
+		 */
+		for (i = MT_BAND0; i <= mphy->band_idx; ++i) {
+			if (i == mphy->band_idx) {
+				mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_TXRX_RATE);
+				mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_TXRX_AIR_TIME);
+				mt7996_mcu_get_rssi(mdev);
+				// if (mtk_wed_device_active(&mdev->mmio.wed)) {
+					mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_TXRX_ADM_STAT);
+					mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_TXRX_MSDU_COUNT);
+				// }
+
+				if (mt7996_mcu_wa_cmd(phy->dev, MCU_WA_PARAM_CMD(QUERY), MCU_WA_PARAM_BSS_ACQ_PKT_CNT,
+				                      BSS_ACQ_PKT_CNT_BSS_BITMAP_ALL | BSS_ACQ_PKT_CNT_READ_CLR, 0))
+					dev_err(mdev->dev, "Failed to query per-AC-queue packet counts.\n");
+
+				if (mphy->mac_work_count == 100) {
+					if (phy->dev->idxlog_enable && mt7996_mcu_fw_time_sync(mdev))
+						dev_err(mdev->dev, "Failed to synchronize time with FW.\n");
+					mphy->mac_work_count = 0;
+				}
+			} else if (mt7996_band_valid(phy->dev, i) &&
+			           test_bit(MT76_STATE_RUNNING, &mdev->phys[i]->state))
+				break;
 		}
 	}
 
-	mutex_unlock(&mphy->dev->mutex);
+	mutex_unlock(&mdev->mutex);
 
-	mt76_tx_status_check(mphy->dev, false);
+	mt76_tx_status_check(mdev, false);
 
 	ieee80211_queue_delayed_work(mphy->hw, &mphy->mac_work,
 				     MT7996_WATCHDOG_TIME);
@@ -2694,6 +2923,7 @@ void mt7996_mac_add_twt_setup(struct ieee80211_hw *hw,
 		goto out;
 
 	mutex_lock(&dev->mt76.mutex);
+	msta_link = mt76_dereference(msta->link[0], &dev->mt76);
 
 	if (dev->twt.n_agrt == MT7996_MAX_TWT_AGRT)
 		goto unlock;
@@ -2792,3 +3022,175 @@ void mt7996_mac_twt_teardown_flow(struct mt7996_dev *dev,
 	dev->twt.table_mask &= ~BIT(flow->table_id);
 	dev->twt.n_agrt--;
 }
+
+static int
+mt7996_beacon_mon_send_probe(struct mt7996_phy *phy, struct mt7996_vif *mvif,
+			     struct ieee80211_bss_conf *conf, unsigned int link_id)
+{
+	struct ieee80211_vif *vif = container_of((void *)mvif, struct ieee80211_vif, drv_priv);
+	struct ieee80211_hw *hw = phy->mt76->hw;
+	struct mt7996_sta_link *msta_link;
+	struct ieee80211_tx_info *info;
+	struct sk_buff *skb;
+	int ret = 0, band_idx = phy->mt76->band_idx;
+	int band;
+
+	rcu_read_lock();
+
+	msta_link = rcu_dereference(mvif->sta.link[link_id]);
+	if (!msta_link || msta_link->wcid.phy_idx != band_idx) {
+		ret = -EINVAL;
+		goto unlock;
+	}
+
+	if (!ieee80211_hw_check(hw, REPORTS_TX_ACK_STATUS)) {
+		/* probe request is not supported yet */
+		ret = -EOPNOTSUPP;
+		goto unlock;
+	}
+
+	/* FIXME: bss conf should not be all-zero before beacon mon work is canecled */
+	if (!is_valid_ether_addr(conf->bssid) ||
+	    !is_valid_ether_addr(conf->addr)) {
+		/* invalid address */
+		ret = -EINVAL;
+		goto unlock;
+	}
+
+	skb = ieee80211_nullfunc_get(hw, vif, link_id, false);
+	if (!skb) {
+		ret = -ENOMEM;
+		goto unlock;
+	}
+
+	info = IEEE80211_SKB_CB(skb);
+	/* frame injected by driver */
+	info->flags |= (IEEE80211_TX_CTL_REQ_TX_STATUS |
+			IEEE80211_TX_CTL_INJECTED |
+			IEEE80211_TX_CTL_NO_PS_BUFFER);
+	if (ieee80211_vif_is_mld(vif))
+		info->control.flags |= u32_encode_bits(link_id, IEEE80211_TX_CTRL_MLO_LINK);
+
+	if (phy->mt76->chanctx)
+		band = phy->mt76->chanctx->chandef.chan->band;
+	else
+		band = phy->mt76->chandef.chan->band;
+
+	skb_set_queue_mapping(skb, IEEE80211_AC_VO);
+	if (!ieee80211_tx_prepare_skb(hw, vif, skb, band, NULL)) {
+		rcu_read_unlock();
+		ieee80211_free_txskb(hw, skb);
+		return -EINVAL;
+	}
+
+	local_bh_disable();
+	mt76_tx(phy->mt76, NULL, &msta_link->wcid, skb);
+	local_bh_enable();
+
+	mvif->probe[band_idx] = (void *)skb;
+	mvif->probe_send_count[band_idx]++;
+	mvif->probe_send_time[band_idx] = jiffies;
+
+unlock:
+	rcu_read_unlock();
+	return ret;
+}
+
+void mt7996_beacon_mon_work(struct work_struct *work)
+{
+	struct mt7996_vif *mvif = container_of(work, struct mt7996_vif, beacon_mon_work.work);
+	struct ieee80211_vif *vif = container_of((void *)mvif, struct ieee80211_vif, drv_priv);
+	struct mt7996_dev *dev = mvif->dev;
+	struct ieee80211_hw *hw = mt76_hw(dev);
+	unsigned long next_time = ULONG_MAX, valid_links = vif->valid_links ?: BIT(0);
+	unsigned int link_id;
+	enum monitor_state {
+		MON_STATE_BEACON_MON,
+		MON_STATE_SEND_PROBE,
+		MON_STATE_LINK_LOST,
+		MON_STATE_DISCONN,
+	};
+
+	mutex_lock(&dev->mt76.mutex);
+
+	for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		struct ieee80211_bss_conf *conf;
+		struct mt7996_vif_link *mconf;
+		struct mt7996_phy *phy;
+		unsigned long timeout, loss_duration;
+		int band_idx;
+		enum monitor_state state = MON_STATE_BEACON_MON;
+
+		conf = link_conf_dereference_protected(vif, link_id);
+		mconf = mt7996_vif_link(dev, vif, link_id);
+		if (!conf || !mconf)
+			continue;
+
+		/* skip lost links */
+		if (mvif->lost_links & BIT(link_id))
+			continue;
+
+		phy = mconf->phy;
+		band_idx = phy->mt76->band_idx;
+		if (mvif->probe[band_idx]) {
+			loss_duration = msecs_to_jiffies(MT7996_MAX_PROBE_TIMEOUT);
+			timeout = mvif->probe_send_time[band_idx] + loss_duration;
+			if (time_after_eq(jiffies, timeout)) {
+				if (mvif->probe_send_count[band_idx] == MT7996_MAX_PROBE_TRIES)
+					state = MON_STATE_LINK_LOST;
+				else
+					state = MON_STATE_SEND_PROBE;
+			}
+		} else {
+			loss_duration = msecs_to_jiffies(MT7996_MAX_BEACON_LOSS *
+							 conf->beacon_int);
+			timeout = mvif->beacon_received_time[band_idx] + loss_duration;
+			if (time_after_eq(jiffies, timeout)) {
+				wiphy_info(hw->wiphy, "link %d: detect %d beacon loss\n",
+					   link_id, MT7996_MAX_BEACON_LOSS);
+				state = MON_STATE_SEND_PROBE;
+			}
+		}
+
+		switch (state) {
+		case MON_STATE_BEACON_MON:
+			break;
+		case MON_STATE_SEND_PROBE:
+			if (!mt7996_beacon_mon_send_probe(phy, mvif, conf, link_id)) {
+				timeout = MT7996_MAX_PROBE_TIMEOUT +
+					  mvif->probe_send_time[band_idx];
+				wiphy_info(hw->wiphy,
+					   "link %d: send nullfunc to AP %pM, try %d/%d\n",
+					   link_id, conf->bssid,
+					   mvif->probe_send_count[band_idx],
+					   MT7996_MAX_PROBE_TRIES);
+				break;
+			}
+			fallthrough;
+		case MON_STATE_LINK_LOST:
+			mvif->lost_links |= BIT(link_id);
+			wiphy_info(hw->wiphy,
+				   "link %d: %s to AP %pM, stop monitoring the lost link\n",
+				   link_id,
+				   state == MON_STATE_LINK_LOST ? "No ack for nullfunc frame" :
+								  "Failed to send nullfunc frame",
+				   conf->bssid);
+			mvif->probe[band_idx] = NULL;
+			mvif->probe_send_count[band_idx] = 0;
+			/* TODO: disable single link TX via TTLM/link reconfig for MLD */
+			if (mvif->lost_links != valid_links)
+				break;
+			fallthrough;
+		case MON_STATE_DISCONN:
+		default:
+			mutex_unlock(&dev->mt76.mutex);
+			wiphy_info(hw->wiphy, "all links are lost, disconnecting\n");
+			ieee80211_connection_loss(vif);
+			return;
+		}
+		next_time = min(next_time, timeout - jiffies);
+	}
+	mutex_unlock(&dev->mt76.mutex);
+
+	ieee80211_queue_delayed_work(hw, &mvif->beacon_mon_work, next_time);
+}
diff --git a/mt7996/main.c b/mt7996/main.c
index 36b85e44..38b674ca 100644
--- a/mt7996/main.c
+++ b/mt7996/main.c
@@ -6,6 +6,25 @@
 #include "mt7996.h"
 #include "mcu.h"
 #include "mac.h"
+#ifdef CONFIG_MTK_DEBUG
+#include "mtk_mcu.h"
+#endif
+
+unsigned int mt7996_debug_mask = 0x1f;
+module_param(mt7996_debug_mask, uint, 0644);
+MODULE_PARM_DESC(mt7996_debug_mask, "Debugging mask");
+
+static void mt7996_testmode_disable_all(struct mt7996_dev *dev)
+{
+	struct mt7996_phy *phy;
+	int i;
+
+	for (i = 0; i < __MT_MAX_BAND; i++) {
+		phy = __mt7996_phy(dev, i);
+		if (phy)
+			mt76_testmode_set_state(phy->mt76, MT76_TM_STATE_OFF);
+	}
+}
 
 int mt7996_run(struct mt7996_phy *phy)
 {
@@ -22,7 +41,12 @@ int mt7996_run(struct mt7996_phy *phy)
 	if (ret)
 		return ret;
 
-	ret = mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_RX_PATH);
+	ret = mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_RX_PATH, false);
+	if (ret)
+		return ret;
+
+	/* set a parking channel */
+	ret = mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_SWITCH, false);
 	if (ret)
 		return ret;
 
@@ -34,6 +58,28 @@ int mt7996_run(struct mt7996_phy *phy)
 	if (ret)
 		return ret;
 
+	ret = mt7996_mcu_set_scs(phy, SCS_ENABLE);
+	if (ret)
+		return ret;
+
+#ifdef CONFIG_MTK_DEBUG
+	phy->sr_enable = true;
+	phy->enhanced_sr_enable = true;
+	phy->thermal_protection_enable = true;
+	ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_SKU_POWER_LIMIT_CTRL,
+					   dev->dbg.sku_disable ? 0 : phy->sku_limit_en);
+
+	ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL,
+					   dev->dbg.sku_disable ? 0 : phy->sku_path_en);
+#else
+	ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_SKU_POWER_LIMIT_CTRL,
+					   phy->sku_limit_en);
+	ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL,
+					   phy->sku_path_en);
+#endif
+	if (ret)
+		return ret;
+
 	set_bit(MT76_STATE_RUNNING, &phy->mt76->state);
 
 	ieee80211_queue_delayed_work(dev->mphy.hw, &phy->mt76->mac_work,
@@ -60,9 +106,18 @@ static int mt7996_start(struct ieee80211_hw *hw)
 		u8 queue = mt76_connac_lmac_mapping(IEEE80211_AC_VI);
 
 		ret = mt7996_mcu_cp_support(dev, queue);
+#ifdef CONFIG_MTK_DEBUG
+		dev->sr_pp_enable = is_mt7990(&dev->mt76) ? dev->pwr_boost_cap : true;
+		dev->uba_enable = true;
+#endif
 	}
+
+	mt7996_testmode_disable_all(dev);
+
 	mutex_unlock(&dev->mt76.mutex);
 
+	ieee80211_queue_delayed_work(hw, &dev->scs_work, HZ);
+
 	return ret;
 }
 
@@ -88,11 +143,16 @@ static void mt7996_stop_phy(struct mt7996_phy *phy)
 
 static void mt7996_stop(struct ieee80211_hw *hw, bool suspend)
 {
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+
+	cancel_delayed_work_sync(&dev->scs_work);
 }
 
-static inline int get_free_idx(u32 mask, u8 start, u8 end)
+static inline int get_free_idx(u64 mask, u8 start, u8 end)
 {
-	return ffs(~mask & GENMASK(end, start));
+	if (~mask & GENMASK_ULL(end, start))
+		return __ffs64(~mask & GENMASK_ULL(end, start)) + 1;
+	return 0;
 }
 
 static int get_omac_idx(enum nl80211_iftype type, u64 mask)
@@ -179,164 +239,72 @@ mt7996_init_bitrate_mask(struct ieee80211_vif *vif, struct mt7996_vif_link *mlin
 	}
 }
 
-static int
-mt7996_set_hw_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
-		  struct ieee80211_vif *vif, struct ieee80211_sta *sta,
-		  struct ieee80211_key_conf *key)
-{
-	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	int idx = key->keyidx;
-	unsigned int link_id;
-	unsigned long links;
-
-	if (key->link_id >= 0)
-		links = BIT(key->link_id);
-	else if (sta && sta->valid_links)
-		links = sta->valid_links;
-	else if (vif->valid_links)
-		links = vif->valid_links;
-	else
-		links = BIT(0);
-
-	for_each_set_bit(link_id, &links, IEEE80211_MLD_MAX_NUM_LINKS) {
-		struct mt7996_sta_link *msta_link;
-		struct mt7996_vif_link *link;
-		u8 *wcid_keyidx;
-		int err;
-
-		link = mt7996_vif_link(dev, vif, link_id);
-		if (!link)
-			continue;
-
-		if (sta) {
-			struct mt7996_sta *msta;
-
-			msta = (struct mt7996_sta *)sta->drv_priv;
-			msta_link = mt76_dereference(msta->link[link_id],
-						     &dev->mt76);
-			if (!msta_link)
-				continue;
-
-			if (!msta_link->wcid.sta)
-				return -EOPNOTSUPP;
-		} else {
-			msta_link = &link->msta_link;
-		}
-		wcid_keyidx = &msta_link->wcid.hw_key_idx;
-
-		switch (key->cipher) {
-		case WLAN_CIPHER_SUITE_AES_CMAC:
-		case WLAN_CIPHER_SUITE_BIP_CMAC_256:
-		case WLAN_CIPHER_SUITE_BIP_GMAC_128:
-		case WLAN_CIPHER_SUITE_BIP_GMAC_256:
-			if (key->keyidx == 6 || key->keyidx == 7) {
-				wcid_keyidx = &msta_link->wcid.hw_key_idx2;
-				key->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIE;
-			}
-			break;
-		default:
-			break;
-		}
-
-		if (cmd == SET_KEY && !sta && !link->mt76.cipher) {
-			struct ieee80211_bss_conf *link_conf;
-
-			link_conf = link_conf_dereference_protected(vif,
-								    link_id);
-			if (!link_conf)
-				link_conf = &vif->bss_conf;
-
-			link->mt76.cipher =
-				mt76_connac_mcu_get_cipher(key->cipher);
-			mt7996_mcu_add_bss_info(link->phy, vif, link_conf,
-						&link->mt76, msta_link, true);
-		}
-
-		if (cmd == SET_KEY) {
-			*wcid_keyidx = idx;
-		} else {
-			if (idx == *wcid_keyidx)
-				*wcid_keyidx = -1;
-			continue;
-		}
-
-		mt76_wcid_key_setup(&dev->mt76, &msta_link->wcid, key);
-
-		if (key->keyidx == 6 || key->keyidx == 7) {
-			err = mt7996_mcu_bcn_prot_enable(dev, link,
-							 msta_link, key);
-			if (err)
-				return err;
-		}
-
-		err = mt7996_mcu_add_key(&dev->mt76, vif, key,
-					 MCU_WMWA_UNI_CMD(STA_REC_UPDATE),
-					 &msta_link->wcid, cmd);
-		if (err)
-			return err;
-	}
-
-	return 0;
-}
-
-static void
-mt7996_key_iter(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
-		struct ieee80211_sta *sta, struct ieee80211_key_conf *key,
-		void *data)
-{
-	if (sta)
-		return;
-
-	WARN_ON(mt7996_set_hw_key(hw, SET_KEY, vif, NULL, key));
-}
-
 int mt7996_vif_link_add(struct mt76_phy *mphy, struct ieee80211_vif *vif,
 			struct ieee80211_bss_conf *link_conf,
 			struct mt76_vif_link *mlink)
 {
-	struct mt7996_vif_link *link = container_of(mlink, struct mt7996_vif_link, mt76);
+	struct mt7996_vif_link *link;
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_sta_link *msta_link = &link->msta_link;
+	struct mt7996_sta_link *msta_link;
 	struct mt7996_phy *phy = mphy->priv;
 	struct mt7996_dev *dev = phy->dev;
 	u8 band_idx = phy->mt76->band_idx;
 	struct mt76_txq *mtxq;
 	int idx, ret;
+	u8 link_id = link_conf->link_id;
 
-	mlink->idx = __ffs64(~dev->mt76.vif_mask);
-	if (mlink->idx >= mt7996_max_interface_num(dev))
-		return -ENOSPC;
-
-	idx = get_omac_idx(vif->type, phy->omac_mask);
-	if (idx < 0)
-		return -ENOSPC;
-
-	if (!dev->mld_idx_mask) { /* first link in the group */
-		mvif->mld_group_idx = get_own_mld_idx(dev->mld_idx_mask, true);
-		mvif->mld_remap_idx = get_free_idx(dev->mld_remap_idx_mask,
-						   0, 15);
+	if (rcu_access_pointer(mvif->mt76.link[link_id]))
+		return 0;
+	if (link_conf != &vif->bss_conf) {
+		link = kzalloc(sizeof(*link), GFP_KERNEL);
+		if (!link)
+			return -ENOMEM;
+	} else {
+		link = &mvif->deflink;
 	}
-	link->mld_idx = get_own_mld_idx(dev->mld_idx_mask, false);
-	if (link->mld_idx < 0)
-		return -ENOSPC;
 
+	mlink = &link->mt76;
+	msta_link = &link->msta_link;
+	if (!dev->testmode_enable) {
+		mlink->idx = __ffs64(~dev->mt76.vif_mask);
+		if (mlink->idx >= mt7996_max_interface_num(dev)) {
+			ret = -ENOSPC;
+			goto error;
+		}
+		idx = get_omac_idx(vif->type, phy->omac_mask);
+		if (idx < 0) {
+			ret = -ENOSPC;
+			goto error;
+		}
+	} else {
+		/* bss idx & omac idx should be set to band idx for ibf cal */
+		if (dev->mt76.vif_mask & BIT_ULL(band_idx) ||
+		    phy->omac_mask & BIT_ULL(band_idx)) {
+			ret = -ENOSPC;
+			goto error;
+		}
+		mlink->idx = band_idx;
+		idx = band_idx;
+	}
 	link->phy = phy;
 	mlink->omac_idx = idx;
+
+	idx = get_own_mld_idx(dev->mld_idx_mask, false);
+	if (idx < 0) {
+		ret = -ENOSPC;
+		goto error;
+	}
+	link->mld_idx = idx;
+
 	mlink->band_idx = band_idx;
 	mlink->wmm_idx = vif->type == NL80211_IFTYPE_AP ? 0 : 3;
 	mlink->wcid = &msta_link->wcid;
-	mlink->wcid->offchannel = mlink->offchannel;
 
 	ret = mt7996_mcu_add_dev_info(phy, vif, link_conf, mlink, true);
 	if (ret)
-		return ret;
+		goto error;
 
 	dev->mt76.vif_mask |= BIT_ULL(mlink->idx);
-	if (!dev->mld_idx_mask) {
-		dev->mld_idx_mask |= BIT_ULL(mvif->mld_group_idx);
-		dev->mld_remap_idx_mask |= BIT_ULL(mvif->mld_remap_idx);
-	}
-	dev->mld_idx_mask |= BIT_ULL(link->mld_idx);
 	phy->omac_mask |= BIT_ULL(mlink->omac_idx);
 
 	idx = MT7996_WTBL_RESERVED - mlink->idx;
@@ -347,14 +315,26 @@ int mt7996_vif_link_add(struct mt76_phy *mphy, struct ieee80211_vif *vif,
 	msta_link->wcid.tx_info |= MT_WCID_TX_INFO_SET;
 	mt76_wcid_init(&msta_link->wcid, band_idx);
 
+	link->bpcc = 0;
+	memset(link->tsf_offset, 0, sizeof(link->tsf_offset));
+	mlink->mvif = &mvif->mt76;
+	mvif->mt76.valid_links |= BIT(link_id);
+	INIT_DELAYED_WORK(&link->sta_chsw_work, mt7996_sta_chsw_work);
+
+	dev->mld_idx_mask |= BIT_ULL(link->mld_idx);
+
+	rcu_assign_pointer(msta_link->wcid.def_wcid, &mvif->sta.deflink.wcid);
+	msta_link->wcid.link_valid = ieee80211_vif_is_mld(vif);
+	msta_link->sta = &mvif->sta;
+	msta_link->sta->vif = mvif;
+
 	mt7996_mac_wtbl_update(dev, idx,
 			       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);
 
-	if (vif->txq) {
+	if (vif->txq && hweight16(vif->valid_links) <= 1) {
 		mtxq = (struct mt76_txq *)vif->txq->drv_priv;
 		mtxq->wcid = idx;
 	}
-
 	if (vif->type != NL80211_IFTYPE_AP &&
 	    (!mlink->omac_idx || mlink->omac_idx > 3))
 		vif->offload_flags = 0;
@@ -371,16 +351,22 @@ int mt7996_vif_link_add(struct mt76_phy *mphy, struct ieee80211_vif *vif,
 	 * interface, since firmware only records BSSID when the entry is new
 	 */
 	if (vif->type != NL80211_IFTYPE_STATION)
-		mt7996_mcu_add_sta(dev, link_conf, NULL, link, NULL,
+		mt7996_mcu_add_sta(dev, vif, link_conf, NULL, link, msta_link,
 				   CONN_STATE_PORT_SECURE, true);
 	rcu_assign_pointer(dev->mt76.wcid[idx], &msta_link->wcid);
+	rcu_assign_pointer(mvif->mt76.link[link_id], &link->mt76);
+	rcu_assign_pointer(mvif->sta.link[link_id], msta_link);
 
-	ieee80211_iter_keys(mphy->hw, vif, mt7996_key_iter, NULL);
-
-	if (mvif->mt76.deflink_id == IEEE80211_LINK_UNSPECIFIED)
-		mvif->mt76.deflink_id = link_conf->link_id;
+	if (link_conf->nontransmitted && link_conf->bssid_index != 0 &&
+	    link_conf->bssid_index < MT7996_MAX_MBSSID) {
+		rcu_assign_pointer(phy->mbssid_conf[link_conf->bssid_index], link);
+		link->mbssid_idx = link_conf->bssid_index;
+	}
 
 	return 0;
+error:
+	mt7996_vif_link_remove(mphy, vif, link_conf, mlink);
+	return ret;
 }
 
 void mt7996_vif_link_remove(struct mt76_phy *mphy, struct ieee80211_vif *vif,
@@ -390,39 +376,40 @@ void mt7996_vif_link_remove(struct mt76_phy *mphy, struct ieee80211_vif *vif,
 	struct mt7996_vif_link *link = container_of(mlink, struct mt7996_vif_link, mt76);
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_sta_link *msta_link = &link->msta_link;
-	struct mt7996_phy *phy = mphy->priv;
-	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_phy *phy = link->phy;
+	struct mt7996_dev *dev;
 	int idx = msta_link->wcid.idx;
+	int link_id = msta_link->wcid.link_id;
+
+	if (!phy || !mlink->wcid)
+		goto out;
+
+	dev = phy->dev;
+
+	mt76_dbg(&dev->mt76, MT76_DBG_BSS,
+		 "%s: band=%u, bss_idx=%u, link_id=%u, wcid=%u\n",
+		 __func__, phy->mt76->band_idx, mlink->idx, link_id, idx);
 
-	mt7996_mcu_add_sta(dev, link_conf, NULL, link, NULL,
+	cancel_delayed_work(&link->sta_chsw_work);
+
+	mt7996_mcu_add_sta(dev, vif, link_conf, NULL, link, NULL,
 			   CONN_STATE_DISCONNECT, false);
 	mt7996_mcu_add_bss_info(phy, vif, link_conf, mlink, msta_link, false);
-
 	mt7996_mcu_add_dev_info(phy, vif, link_conf, mlink, false);
 
 	rcu_assign_pointer(dev->mt76.wcid[idx], NULL);
-
-	if (mvif->mt76.deflink_id == link_conf->link_id) {
-		struct ieee80211_bss_conf *iter;
-		unsigned int link_id;
-
-		mvif->mt76.deflink_id = IEEE80211_LINK_UNSPECIFIED;
-		for_each_vif_active_link(vif, iter, link_id) {
-			if (link_id != IEEE80211_LINK_UNSPECIFIED) {
-				mvif->mt76.deflink_id = link_id;
-				break;
-			}
-		}
+	rcu_assign_pointer(mvif->mt76.link[link_id], NULL);
+	rcu_assign_pointer(mvif->sta.link[link_id], NULL);
+	if (link->mbssid_idx != 0 && link->mbssid_idx < MT7996_MAX_MBSSID) {
+		rcu_assign_pointer(phy->mbssid_conf[link->mbssid_idx], NULL);
+		link->mbssid_idx = 0;
 	}
 
 	dev->mt76.vif_mask &= ~BIT_ULL(mlink->idx);
-	dev->mld_idx_mask &= ~BIT_ULL(link->mld_idx);
 	phy->omac_mask &= ~BIT_ULL(mlink->omac_idx);
-	if (!(dev->mld_idx_mask & ~BIT_ULL(mvif->mld_group_idx))) {
-		/* last link */
-		dev->mld_idx_mask &= ~BIT_ULL(mvif->mld_group_idx);
-		dev->mld_remap_idx_mask &= ~BIT_ULL(mvif->mld_remap_idx);
-	}
+
+	mvif->mt76.valid_links &= ~BIT(link_id);
+	dev->mld_idx_mask &= ~BIT_ULL(link->mld_idx);
 
 	spin_lock_bh(&dev->mt76.sta_poll_lock);
 	if (!list_empty(&msta_link->wcid.poll_list))
@@ -430,6 +417,9 @@ void mt7996_vif_link_remove(struct mt76_phy *mphy, struct ieee80211_vif *vif,
 	spin_unlock_bh(&dev->mt76.sta_poll_lock);
 
 	mt76_wcid_cleanup(&dev->mt76, &msta_link->wcid);
+out:
+	if (link != &mvif->deflink)
+		kfree_rcu(link, mt76.rcu_head);
 }
 
 static void mt7996_phy_set_rxfilter(struct mt7996_phy *phy)
@@ -485,29 +475,55 @@ static int mt7996_add_interface(struct ieee80211_hw *hw,
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct wireless_dev *wdev = ieee80211_vif_to_wdev(vif);
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy;
 	int i, err = 0;
 
 	mutex_lock(&dev->mt76.mutex);
+	if (dev->testmode_enable && vif->type != NL80211_IFTYPE_MONITOR) {
+		mutex_unlock(&dev->mt76.mutex);
+		dev_err(dev->mt76.dev, "Only monitor interface is allowed in testmode\n");
+		return -EINVAL;
+	}
 
 	for (i = 0; i < MT7996_MAX_RADIOS; i++) {
-		struct mt7996_phy *phy = dev->radio_phy[i];
+		/* FIXME: only set the required radio temporarily for testmode.
+		 * The TX speed of testmode will be affected if the unused radio is enabled.
+		 * Normal mode should also skip enabling the unused radio once the
+		 * real single wiphy codebase is stable.
+		 */
+		if (dev->testmode_enable && !(wdev->radio_mask & BIT(i)))
+			continue;
+
+		phy = dev->radio_phy[i];
 
-		if (!phy || !(wdev->radio_mask & BIT(i)) ||
-		    test_bit(MT76_STATE_RUNNING, &phy->mt76->state))
+		if (phy && !mvif->deflink.phy && (wdev->radio_mask & BIT(i)))
+			mvif->deflink.phy = phy;
+
+		if (!phy || test_bit(MT76_STATE_RUNNING, &phy->mt76->state))
 			continue;
 
 		err = mt7996_run(phy);
 		if (err)
 			goto out;
 
-		if (vif->type == NL80211_IFTYPE_MONITOR)
+		if (vif->type == NL80211_IFTYPE_MONITOR) {
 			mt7996_set_monitor(phy, true);
+			phy->mt76->monitor_vif = vif;
+		}
 	}
 
-	mt76_vif_init(vif, &mvif->mt76);
-
 	vif->offload_flags |= IEEE80211_OFFLOAD_ENCAP_4ADDR;
-	mvif->mt76.deflink_id = IEEE80211_LINK_UNSPECIFIED;
+
+	INIT_DELAYED_WORK(&mvif->beacon_mon_work, mt7996_beacon_mon_work);
+	mvif->dev = dev;
+	mvif->sta.vif = mvif;
+	/* TODO: temporaily set this to prevent some crashes */
+	mvif->deflink.mt76.mvif = &mvif->mt76;
+	memset(mvif->mt76.band_to_link, IEEE80211_LINK_UNSPECIFIED,
+	       sizeof(mvif->mt76.band_to_link));
+
+	if (vif->type == NL80211_IFTYPE_STATION && mvif->deflink.phy)
+		err = mt7996_vif_link_add(mvif->deflink.phy->mt76, vif, &vif->bss_conf, NULL);
 
 out:
 	mutex_unlock(&dev->mt76.mutex);
@@ -533,20 +549,51 @@ static void mt7996_remove_iter(void *data, u8 *mac, struct ieee80211_vif *vif)
 static void mt7996_remove_interface(struct ieee80211_hw *hw,
 				    struct ieee80211_vif *vif)
 {
+	struct ieee80211_bss_conf *conf;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_vif_link *mconf;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy = &dev->phy;
 	struct mt7996_radio_data rdata = {};
 	int i;
 
 	ieee80211_iterate_active_interfaces_mtx(hw, 0, mt7996_remove_iter,
 						&rdata);
-	mt76_vif_cleanup(&dev->mt76, vif);
+
+	cancel_delayed_work(&mvif->beacon_mon_work);
+
+	mutex_lock(&dev->mt76.mutex);
+
+	conf = link_conf_dereference_protected(vif, 0);
+	mconf = mt7996_vif_link(dev, vif, 0);
+	if (!mconf || !conf)
+		goto out;
+
+	mt7996_vif_link_remove(mconf->phy->mt76, vif, NULL, &mconf->mt76);
 
 	for (i = 0; i < MT7996_MAX_RADIOS; i++) {
-		struct mt7996_phy *phy = dev->radio_phy[i];
+		phy = dev->radio_phy[i];
+		if (!phy || (rdata.active_mask & BIT(i)))
+			continue;
+
+		if (vif == phy->mt76->monitor_vif) {
+			phy->mt76->monitor_vif = NULL;
 
+			if (dev->testmode_enable)
+				kfree(phy->mt76->lists);
+		}
+	}
+
+out:
+	mutex_unlock(&dev->mt76.mutex);
+
+	for (i = 0; i < MT7996_MAX_RADIOS; i++) {
+		phy = dev->radio_phy[i];
 		if (!phy)
 			continue;
-		if (!(rdata.monitor_mask & BIT(i)))
+
+		if (vif->type == NL80211_IFTYPE_MONITOR &&
+		    !(rdata.monitor_mask & BIT(i)))
 			mt7996_set_monitor(phy, false);
 		if (!(rdata.active_mask & BIT(i)))
 			mt7996_stop_phy(phy);
@@ -558,9 +605,6 @@ int mt7996_set_channel(struct mt76_phy *mphy)
 	struct mt7996_phy *phy = mphy->priv;
 	int ret;
 
-	if (mphy->offchannel)
-		mt7996_mac_update_beacons(phy);
-
 	ret = mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_SWITCH);
 	if (ret)
 		goto out;
@@ -578,8 +622,6 @@ int mt7996_set_channel(struct mt76_phy *mphy)
 
 	mt7996_mac_reset_counters(phy);
 	phy->noise = 0;
-	if (!mphy->offchannel)
-		mt7996_mac_update_beacons(phy);
 
 out:
 	ieee80211_queue_delayed_work(mphy->hw, &mphy->mac_work,
@@ -594,51 +636,93 @@ static int mt7996_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	int err;
+	struct mt7996_sta *msta = sta ? (struct mt7996_sta *)sta->drv_priv :
+				  &mvif->sta;
+	struct mt7996_vif_link *mconf;
+	struct mt7996_sta_link *msta_link;
+	struct ieee80211_bss_conf *conf;
+	u8 *wcid_keyidx;
+	int idx = key->keyidx;
+	int err = 0;
+	unsigned long add;
+	unsigned int link_id;
 
-	/* The hardware does not support per-STA RX GTK, fallback
-	 * to software mode for these.
-	 */
-	if ((vif->type == NL80211_IFTYPE_ADHOC ||
-	     vif->type == NL80211_IFTYPE_MESH_POINT) &&
-	    (key->cipher == WLAN_CIPHER_SUITE_TKIP ||
-	     key->cipher == WLAN_CIPHER_SUITE_CCMP) &&
-	    !(key->flags & IEEE80211_KEY_FLAG_PAIRWISE))
-		return -EOPNOTSUPP;
-
-	/* fall back to sw encryption for unsupported ciphers */
-	switch (key->cipher) {
-	case WLAN_CIPHER_SUITE_TKIP:
-	case WLAN_CIPHER_SUITE_CCMP:
-	case WLAN_CIPHER_SUITE_CCMP_256:
-	case WLAN_CIPHER_SUITE_GCMP:
-	case WLAN_CIPHER_SUITE_GCMP_256:
-	case WLAN_CIPHER_SUITE_SMS4:
-		break;
-	case WLAN_CIPHER_SUITE_AES_CMAC:
-	case WLAN_CIPHER_SUITE_BIP_CMAC_256:
-	case WLAN_CIPHER_SUITE_BIP_GMAC_128:
-	case WLAN_CIPHER_SUITE_BIP_GMAC_256:
-		if (key->keyidx == 6 || key->keyidx == 7)
-			break;
-		fallthrough;
-	case WLAN_CIPHER_SUITE_WEP40:
-	case WLAN_CIPHER_SUITE_WEP104:
-	default:
-		return -EOPNOTSUPP;
+	if (key->link_id >= 0) {
+		add = BIT(key->link_id);
+	} else {
+		if (sta)
+			add = sta->valid_links ?: BIT(0);
+		else
+			add = vif->valid_links ?: BIT(0);
 	}
-
-	if (!mt7996_vif_link_phy(&mvif->deflink))
-		return 0; /* defer until after link add */
+	// print_hex_dump(KERN_INFO , "", DUMP_PREFIX_OFFSET, 16, 1, key->key, key->keylen, false);
 
 	mutex_lock(&dev->mt76.mutex);
-	err = mt7996_set_hw_key(hw, cmd, vif, sta, key);
+
+	for_each_set_bit(link_id, &add, IEEE80211_MLD_MAX_NUM_LINKS) {
+		conf = link_conf_dereference_protected(vif, link_id);
+		mconf = mt7996_vif_link(dev, vif, link_id);
+		msta_link = mt76_dereference(msta->link[link_id], &dev->mt76);
+		wcid_keyidx = &msta_link->wcid.hw_key_idx;
+
+		if (!conf || !mconf || !msta_link)
+			continue;
+
+		/* fall back to sw encryption for unsupported ciphers */
+		switch (key->cipher) {
+		case WLAN_CIPHER_SUITE_TKIP:
+		case WLAN_CIPHER_SUITE_CCMP:
+		case WLAN_CIPHER_SUITE_CCMP_256:
+		case WLAN_CIPHER_SUITE_GCMP:
+		case WLAN_CIPHER_SUITE_GCMP_256:
+		case WLAN_CIPHER_SUITE_SMS4:
+			break;
+		case WLAN_CIPHER_SUITE_AES_CMAC:
+		case WLAN_CIPHER_SUITE_BIP_CMAC_256:
+		case WLAN_CIPHER_SUITE_BIP_GMAC_128:
+		case WLAN_CIPHER_SUITE_BIP_GMAC_256:
+			if (key->keyidx == 6 || key->keyidx == 7) {
+				wcid_keyidx = &msta_link->wcid.hw_key_idx2;
+				key->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIE;
+				break;
+			}
+			fallthrough;
+		case WLAN_CIPHER_SUITE_WEP40:
+		case WLAN_CIPHER_SUITE_WEP104:
+		default:
+			mutex_unlock(&dev->mt76.mutex);
+			return -EOPNOTSUPP;
+		}
+
+		if (cmd == SET_KEY && !sta && !mconf->mt76.cipher) {
+			mconf->mt76.cipher = mt76_connac_mcu_get_cipher(key->cipher);
+			mt7996_mcu_add_bss_info(mconf->phy, vif, conf, &mconf->mt76, msta_link, true);
+		}
+
+		if (cmd == SET_KEY) {
+			*wcid_keyidx = idx;
+		} else {
+			if (idx == *wcid_keyidx)
+				*wcid_keyidx = -1;
+			goto out;
+		}
+
+		mt76_wcid_key_setup(&dev->mt76, &msta_link->wcid, key);
+
+		if (key->keyidx == 6 || key->keyidx == 7)
+			err = mt7996_mcu_bcn_prot_enable(dev, mconf, msta_link, key);
+		else
+			err = mt7996_mcu_add_key(&dev->mt76, mconf, key,
+						 MCU_WMWA_UNI_CMD(STA_REC_UPDATE),
+						 &msta_link->wcid, cmd);
+	}
+out:
 	mutex_unlock(&dev->mt76.mutex);
 
 	return err;
 }
 
-static int mt7996_config(struct ieee80211_hw *hw, u32 changed)
+static int mt7996_config(struct ieee80211_hw *hw, int radio_idx, u32 changed)
 {
 	return 0;
 }
@@ -649,7 +733,7 @@ mt7996_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	       const struct ieee80211_tx_queue_params *params)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt7996_vif_link *mlink = mt7996_vif_link(dev, vif, link_id);
+	struct mt7996_vif_link *mlink;
 	static const u8 mq_to_aci[] = {
 		[IEEE80211_AC_VO] = 3,
 		[IEEE80211_AC_VI] = 2,
@@ -657,10 +741,19 @@ mt7996_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		[IEEE80211_AC_BK] = 1,
 	};
 
+	mutex_lock(&dev->mt76.mutex);
+	mlink = mt7996_vif_link(dev, vif, link_id);
+	if (!mlink) {
+		mutex_unlock(&dev->mt76.mutex);
+		return -EINVAL;
+	}
+
 	/* firmware uses access class index */
 	mlink->queue_params[mq_to_aci[queue]] = *params;
 	/* no need to update right away, we'll get BSS_CHANGED_QOS */
 
+	mutex_unlock(&dev->mt76.mutex);
+
 	return 0;
 }
 
@@ -718,28 +811,27 @@ static int
 mt7996_get_txpower(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		   unsigned int link_id, int *dbm)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_phy *phy = mt7996_vif_link_phy(&mvif->deflink);
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct wireless_dev *wdev;
-	int n_chains, delta, i;
-
-	if (!phy) {
-		wdev = ieee80211_vif_to_wdev(vif);
-		for (i = 0; i < hw->wiphy->n_radio; i++)
-			if (wdev->radio_mask & BIT(i))
-				phy = dev->radio_phy[i];
+	struct mt7996_vif_link *mconf;
+	struct mt76_phy *mphy;
+	int delta;
 
-		if (!phy)
-			return -EINVAL;
+	mutex_lock(&dev->mt76.mutex);
+	mconf = mt7996_vif_link(dev, vif, link_id);
+	if (!mconf || !mconf->phy) {
+		*dbm = 0;
+		goto out;
 	}
 
-	n_chains = hweight16(phy->mt76->chainmask);
-	delta = mt76_tx_power_path_delta(n_chains);
-	*dbm = DIV_ROUND_UP(phy->mt76->txpower_cur + delta, 2);
-
+	mphy = mconf->phy->mt76;
+	delta = mt76_tx_power_path_delta(hweight16(mphy->chainmask));
+	*dbm = DIV_ROUND_UP(mphy->txpower_cur + delta, 2);
+out:
+	mutex_unlock(&dev->mt76.mutex);
 	return 0;
 }
+
+
 static u8
 mt7996_get_rates_table(struct mt7996_phy *phy, struct ieee80211_bss_conf *conf,
 		       bool beacon, bool mcast)
@@ -752,6 +844,11 @@ mt7996_get_rates_table(struct mt7996_phy *phy, struct ieee80211_bss_conf *conf,
 	rate = mt76_connac2_mac_tx_rate_val(phy->mt76, conf, beacon, mcast);
 
 	if (beacon) {
+		/* For WFA Cert TGax T/C 4.73.1 */
+		if (dev->cert_mode && phy->mt76->band_idx == MT_BAND2 &&
+		    conf->he_support && !conf->eht_support)
+			rate = 0x0200;
+
 		/* odd index for driver, even index for firmware */
 		idx = MT7996_BEACON_RATES_TBL + 2 * phy->mt76->band_idx;
 		if (phy->beacon_rate != rate)
@@ -849,7 +946,7 @@ mt7996_link_info_changed(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	    (changed & BSS_CHANGED_BEACON_ENABLED && info->enable_beacon)) {
 		mt7996_mcu_add_bss_info(phy, vif, info, &link->mt76,
 					&link->msta_link, true);
-		mt7996_mcu_add_sta(dev, info, NULL, link, NULL,
+		mt7996_mcu_add_sta(dev, vif, info, NULL, link, &link->msta_link,
 				   CONN_STATE_PORT_SECURE,
 				   !!(changed & BSS_CHANGED_BSSID));
 	}
@@ -891,7 +988,7 @@ mt7996_link_info_changed(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		link->mt76.beacon_rates_idx =
 			mt7996_get_rates_table(phy, info, true, false);
 
-		mt7996_mcu_add_beacon(hw, vif, info);
+		mt7996_mcu_add_beacon(hw, vif, info, info->enable_beacon);
 	}
 
 	if (changed & (BSS_CHANGED_UNSOL_BCAST_PROBE_RESP |
@@ -901,11 +998,8 @@ mt7996_link_info_changed(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	if (changed & BSS_CHANGED_MU_GROUPS)
 		mt7996_update_mu_group(hw, link, info);
 
-	if (changed & BSS_CHANGED_TXPOWER &&
-	    info->txpower != phy->txpower) {
-		phy->txpower = info->txpower;
-		mt7996_mcu_set_txpower_sku(phy);
-	}
+	if (changed & BSS_CHANGED_TXPOWER)
+		mt7996_mcu_set_txpower_sku(phy, info);
 
 out:
 	mutex_unlock(&dev->mt76.mutex);
@@ -917,12 +1011,44 @@ mt7996_channel_switch_beacon(struct ieee80211_hw *hw,
 			     struct cfg80211_chan_def *chandef)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_phy *phy = mt7996_band_phy(dev, chandef->chan->band);
+	struct ieee80211_bss_conf *conf;
+	struct mt7996_vif_link *mconf;
+	u16 valid_links = vif->valid_links ?: BIT(0);
+	unsigned int link_id;
 
 	mutex_lock(&dev->mt76.mutex);
-	mt7996_mcu_add_beacon(hw, vif, &vif->bss_conf);
+	for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		struct mt7996_vif_link *mconf =
+			mt7996_vif_link(dev, vif, link_id);
+		struct ieee80211_bss_conf *conf =
+			link_conf_dereference_protected(vif, link_id);
+
+		if (!mconf || phy != mconf->phy)
+			continue;
+
+		mt7996_mcu_add_beacon(hw, vif, conf, true);
+	}
 	mutex_unlock(&dev->mt76.mutex);
 }
 
+static int
+mt7996_post_channel_switch(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			   struct ieee80211_bss_conf *link_conf)
+{
+	struct cfg80211_chan_def *chandef = &link_conf->chanreq.oper;
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy = mt7996_band_phy(dev, chandef->chan->band);
+	int ret;
+
+	ret = cfg80211_chandef_dfs_required(hw->wiphy, chandef, NL80211_IFTYPE_AP);
+	if (ret <= 0)
+		return ret;
+
+	return mt76_set_channel(phy->mt76, chandef, false);
+}
+
 static int
 mt7996_mac_sta_init_link(struct mt7996_dev *dev,
 			 struct ieee80211_bss_conf *link_conf,
@@ -1209,10 +1335,17 @@ static void
 mt7996_mac_sta_remove(struct mt7996_dev *dev, struct ieee80211_vif *vif,
 		      struct ieee80211_sta *sta)
 {
-	unsigned long links = sta->valid_links ? sta->valid_links : BIT(0);
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	unsigned long rem = sta->valid_links ?: BIT(0);
 
+	cancel_delayed_work(&msta->vif->beacon_mon_work);
 	mutex_lock(&dev->mt76.mutex);
-	mt7996_mac_sta_remove_links(dev, vif, sta, links);
+
+#ifdef CONFIG_MTK_VENDOR
+	mt7996_mcu_set_csi(&dev->phy, 2, 8, 1, 0, sta->addr);
+#endif
+	mt7996_mac_sta_remove_links(dev, vif, sta, rem | msta->valid_links);
+
 	mutex_unlock(&dev->mt76.mutex);
 }
 
@@ -1247,96 +1380,132 @@ mt7996_sta_state(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	return mt7996_mac_sta_event(dev, vif, sta, ev);
 }
 
+static void
+mt7996_sta_pre_rcu_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			  struct ieee80211_sta *sta)
+{
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	unsigned long rem = sta->valid_links ?: BIT(0);
+	unsigned int link_id;
+
+	mutex_lock(&dev->mt76.mutex);
+	spin_lock_bh(&dev->mt76.status_lock);
+	for_each_set_bit(link_id, &rem, IEEE80211_MLD_MAX_NUM_LINKS) {
+		struct mt7996_sta_link *msta_link =
+			mt76_dereference(msta->link[link_id], &dev->mt76);
+
+		if (!msta_link)
+			continue;
+		rcu_assign_pointer(dev->mt76.wcid[msta_link->wcid.idx], NULL);
+	}
+	spin_unlock_bh(&dev->mt76.status_lock);
+	mutex_unlock(&dev->mt76.mutex);
+}
+
 static void mt7996_tx(struct ieee80211_hw *hw,
 		      struct ieee80211_tx_control *control,
 		      struct sk_buff *skb)
 {
-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+	struct mt76_phy *mphy;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct ieee80211_sta *sta = control->sta;
-	struct mt7996_sta *msta = sta ? (void *)sta->drv_priv : NULL;
-	struct mt76_phy *mphy = hw->priv;
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	struct ieee80211_vif *vif = info->control.vif;
-	struct mt7996_vif *mvif = vif ? (void *)vif->drv_priv : NULL;
-	struct mt76_wcid *wcid = &dev->mt76.global_wcid;
-	u8 link_id = u32_get_bits(info->control.flags,
-				  IEEE80211_TX_CTRL_MLO_LINK);
-
-	rcu_read_lock();
-
-	/* Use primary link_id if the value from mac80211 is set to
-	 * IEEE80211_LINK_UNSPECIFIED.
-	 */
-	if (link_id == IEEE80211_LINK_UNSPECIFIED) {
-		if (msta)
-			link_id = msta->deflink_id;
-		else if (mvif)
-			link_id = mvif->mt76.deflink_id;
+	struct mt76_wcid *wcid;
+	struct mt7996_vif *mvif;
+	struct mt7996_sta *msta;
+	bool addr_trans_success = false;
+
+	if (control->sta) {
+		msta = (struct mt7996_sta *)control->sta->drv_priv;
+		mvif = msta->vif;
+	} else if (vif) {
+		mvif = (struct mt7996_vif *)vif->drv_priv;
+		msta = &mvif->sta;
 	}
 
-	if (ieee80211_vif_is_mld(vif)) {
-		struct ieee80211_bss_conf *link_conf;
-
-		if (msta) {
-			struct ieee80211_link_sta *link_sta;
+	rcu_read_lock();
+	if (mvif && msta) {
+		struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+		struct mt7996_vif_link *mconf;
+		struct mt7996_sta_link *msta_link;
+		u8 link_id = u32_get_bits(info->control.flags,
+					  IEEE80211_TX_CTRL_MLO_LINK);
+		struct ieee80211_sta *sta = ieee80211_find_sta(vif, hdr->addr1);
+
+		if (link_id >= IEEE80211_LINK_UNSPECIFIED) {
+			if (sta) {
+				struct mt7996_sta *peer;
+
+				peer = (struct mt7996_sta *)sta->drv_priv;
+				link_id = peer->deflink_id;
+			} else {
+				link_id = mvif->mt76.deflink_id;
+			}
+		}
 
-			link_sta = rcu_dereference(sta->link[link_id]);
-			if (!link_sta)
-				link_sta = rcu_dereference(sta->link[msta->deflink_id]);
+		/* translate mld addr to link addr */
+		if (ieee80211_vif_is_mld(vif)) {
+			struct ieee80211_bss_conf *conf;
+			if (sta) {
+				struct ieee80211_link_sta *link_sta =
+					rcu_dereference(sta->link[link_id]);
+
+				if (!link_sta) {
+					mt76_dbg(&dev->mt76, MT76_DBG_TXRX,
+						 "%s, request TX on invalid link_id=%u, use primary link (id=%u) instead.\n",
+						 __func__, link_id, msta->deflink_id);
+					link_id = msta->deflink_id;
+					link_sta = rcu_dereference(sta->link[link_id]);
+
+					if (!link_sta) {
+						mt76_dbg(&dev->mt76, MT76_DBG_TXRX,
+							 "%s, primary link became invalid, give up the TX\n",
+							 __func__);
+						goto unlock;
+					}
+				}
 
-			if (link_sta) {
 				memcpy(hdr->addr1, link_sta->addr, ETH_ALEN);
 				if (ether_addr_equal(sta->addr, hdr->addr3))
 					memcpy(hdr->addr3, link_sta->addr, ETH_ALEN);
 			}
-		}
 
-		link_conf = rcu_dereference(vif->link_conf[link_id]);
-		if (link_conf) {
-			memcpy(hdr->addr2, link_conf->addr, ETH_ALEN);
+			conf = rcu_dereference(vif->link_conf[link_id]);
+			if (unlikely(!conf))
+				goto unlock;
+
+			memcpy(hdr->addr2, conf->addr, ETH_ALEN);
 			if (ether_addr_equal(vif->addr, hdr->addr3))
-				memcpy(hdr->addr3, link_conf->addr, ETH_ALEN);
+				memcpy(hdr->addr3, conf->addr, ETH_ALEN);
 		}
-	}
 
-	if (mvif) {
-		struct mt76_vif_link *mlink = &mvif->deflink.mt76;
-
-		if (link_id < IEEE80211_LINK_UNSPECIFIED)
-			mlink = rcu_dereference(mvif->mt76.link[link_id]);
-
-		if (mlink->wcid)
-			wcid = mlink->wcid;
+		mconf = (struct mt7996_vif_link *)rcu_dereference(mvif->mt76.link[link_id]);
+		msta_link = rcu_dereference(msta->link[link_id]);
 
-		if (mvif->mt76.roc_phy &&
-		    (info->flags & IEEE80211_TX_CTL_TX_OFFCHAN)) {
-			mphy = mvif->mt76.roc_phy;
-			if (mphy->roc_link)
-				wcid = mphy->roc_link->wcid;
-		} else {
-			mphy = mt76_vif_link_phy(mlink);
-		}
-	}
+		if (!mconf || !msta_link)
+			goto unlock;
 
-	if (!mphy) {
-		ieee80211_free_txskb(hw, skb);
-		goto unlock;
+		mphy = mconf->phy->mt76;
+		wcid = &msta_link->wcid;
+	} else {
+		mphy = hw->priv;
+		wcid = &dev->mt76.global_wcid;
 	}
 
-	if (msta && link_id < IEEE80211_LINK_UNSPECIFIED) {
-		struct mt7996_sta_link *msta_link;
-
-		msta_link = rcu_dereference(msta->link[link_id]);
-		if (msta_link)
-			wcid = &msta_link->wcid;
-	}
+	addr_trans_success = true;
 	mt76_tx(mphy, control->sta, wcid, skb);
 unlock:
+	if (!addr_trans_success) {
+		spin_lock_bh(&dev->mt76.tx_dbg_stats.lock);
+		dev->mt76.tx_dbg_stats.tx_drop[MT_TX_DROP_ADDR_TRANS_FAIL]++;
+		spin_unlock_bh(&dev->mt76.tx_dbg_stats.lock);
+	}
 	rcu_read_unlock();
 }
 
-static int mt7996_set_rts_threshold(struct ieee80211_hw *hw, u32 val)
+static int mt7996_set_rts_threshold(struct ieee80211_hw *hw, int radio_idx,
+				    u32 value)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	int i, ret = 0;
@@ -1346,7 +1515,7 @@ static int mt7996_set_rts_threshold(struct ieee80211_hw *hw, u32 val)
 	for (i = 0; i < hw->wiphy->n_radio; i++) {
 		struct mt7996_phy *phy = dev->radio_phy[i];
 
-		ret = mt7996_mcu_set_rts_thresh(phy, val);
+		ret = mt7996_mcu_set_rts_thresh(phy, value);
 		if (ret)
 			break;
 	}
@@ -1472,12 +1641,22 @@ u64 __mt7996_get_tsf(struct ieee80211_hw *hw, struct mt7996_vif_link *link)
 static u64
 mt7996_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	u64 ret;
+	struct mt7996_vif_link *mconf;
+	u64 ret = -1ULL;
+	int i;
 
 	mutex_lock(&dev->mt76.mutex);
-	ret = __mt7996_get_tsf(hw, &mvif->deflink);
+	/* FIXME workaround for preventing kernel crash during ACS
+	 * (i.e., link 0 is doing ACS while link 1 queries tsf)
+	 */
+	for (i = 0; i < IEEE80211_MLD_MAX_NUM_LINKS; i++) {
+		mconf = mt7996_vif_link(dev, vif, i);
+		if (mconf)
+			break;
+	}
+	if (mconf)
+		ret = __mt7996_get_tsf(hw, mconf);
 	mutex_unlock(&dev->mt76.mutex);
 
 	return ret;
@@ -1556,7 +1735,8 @@ unlock:
 }
 
 static void
-mt7996_set_coverage_class(struct ieee80211_hw *hw, s16 coverage_class)
+mt7996_set_coverage_class(struct ieee80211_hw *hw, int radio_idx,
+			  s16 coverage_class)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt7996_phy *phy;
@@ -1570,7 +1750,7 @@ mt7996_set_coverage_class(struct ieee80211_hw *hw, s16 coverage_class)
 }
 
 static int
-mt7996_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)
+mt7996_set_antenna(struct ieee80211_hw *hw, int radio_idx, u32 tx_ant, u32 rx_ant)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	int i;
@@ -1599,7 +1779,6 @@ mt7996_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)
 		mt76_set_stream_caps(phy->mt76, true);
 		mt7996_set_stream_vht_txbf_caps(phy);
 		mt7996_set_stream_he_eht_caps(phy);
-		mt7996_mcu_set_txpower_sku(phy);
 	}
 
 	mutex_unlock(&dev->mt76.mutex);
@@ -1614,9 +1793,16 @@ static void mt7996_sta_statistics(struct ieee80211_hw *hw,
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
-	struct mt7996_sta_link *msta_link = &msta->deflink;
-	struct rate_info *txrate = &msta_link->wcid.rate;
+	struct mt7996_sta_link *msta_link;
+	struct rate_info *txrate;
+
+	/* TODO: support per-link rate report */
+	mutex_lock(&dev->mt76.mutex);
+	msta_link = mt76_dereference(msta->link[msta->deflink_id], &dev->mt76);
+	if (!msta_link)
+		goto out;
 
+	txrate = &msta_link->wcid.rate;
 	if (txrate->legacy || txrate->flags) {
 		if (txrate->legacy) {
 			sinfo->txrate.legacy = txrate->legacy;
@@ -1644,46 +1830,120 @@ static void mt7996_sta_statistics(struct ieee80211_hw *hw,
 	sinfo->ack_signal = (s8)msta_link->ack_signal;
 	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL);
 
-	sinfo->avg_ack_signal =
-		-(s8)ewma_avg_signal_read(&msta_link->avg_ack_signal);
+	sinfo->avg_ack_signal = -(s8)ewma_avg_signal_read(&msta_link->avg_ack_signal);
 	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL_AVG);
 
-	if (mtk_wed_device_active(&dev->mt76.mmio.wed)) {
-		sinfo->tx_bytes = msta_link->wcid.stats.tx_bytes;
-		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BYTES64);
+	sinfo->tx_bytes = msta_link->wcid.stats.tx_bytes;
+	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BYTES64);
 
-		sinfo->rx_bytes = msta_link->wcid.stats.rx_bytes;
-		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BYTES64);
+	sinfo->rx_bytes = msta_link->wcid.stats.rx_bytes;
+	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BYTES64);
 
-		sinfo->tx_packets = msta_link->wcid.stats.tx_packets;
-		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_PACKETS);
+	sinfo->tx_packets = msta_link->wcid.stats.tx_packets;
+	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_PACKETS);
 
-		sinfo->rx_packets = msta_link->wcid.stats.rx_packets;
-		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_PACKETS);
-	}
+	sinfo->rx_packets = msta_link->wcid.stats.rx_packets;
+	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_PACKETS);
+out:
+	mutex_unlock(&dev->mt76.mutex);
 }
 
-static void mt7996_link_rate_ctrl_update(void *data, struct ieee80211_sta *sta)
+static void mt7996_link_sta_statistics(struct ieee80211_hw *hw,
+				       struct ieee80211_vif *vif,
+				       struct ieee80211_link_sta *link_sta,
+				       struct link_station_info *link_sinfo)
+{
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_sta *msta = (struct mt7996_sta *)link_sta->sta->drv_priv;
+	struct mt7996_sta_link *msta_link;
+	struct mt7996_vif_link *mconf;
+	struct mt76_sta_stats *stats;
+	u8 link_id = link_sta->link_id;
+	int i;
+
+	mutex_lock(&dev->mt76.mutex);
+	msta_link = mt76_dereference(msta->link[link_id], &dev->mt76);
+	if (!msta_link)
+		goto out;
+	stats = &msta_link->wcid.stats;
+
+	mconf = mt7996_vif_link(dev, vif, link_id);
+	if (!mconf)
+		goto out;
+
+	link_sinfo->signal = (s8)msta_link->signal;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);
+
+	link_sinfo->chains = mt7996_rx_chainmask(mconf->phy);
+	memcpy(link_sinfo->chain_signal, msta_link->chain_signal, IEEE80211_MAX_CHAINS);
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL);
+
+	link_sinfo->signal_avg = -(s8)ewma_avg_signal_read(&msta_link->signal_avg);
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL_AVG);
+
+	for (i = 0; i < IEEE80211_MAX_CHAINS; ++i)
+		link_sinfo->chain_signal_avg[i] = -(s8)ewma_avg_signal_read(msta_link->chain_signal_avg + i);
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL_AVG);
+
+	link_sinfo->ack_signal = (s8)msta_link->ack_signal;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL);
+
+	link_sinfo->avg_ack_signal = -(s8)ewma_avg_signal_read(&msta_link->avg_ack_signal);
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL_AVG);
+
+	link_sinfo->txrate = msta_link->wcid.rate;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);
+
+	link_sinfo->rxrate = msta_link->wcid.rx_rate;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BITRATE);
+
+	link_sinfo->tx_bytes = stats->tx_bytes;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BYTES64);
+
+	link_sinfo->rx_bytes = stats->rx_bytes;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BYTES64);
+
+	link_sinfo->tx_failed = stats->tx_failed;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_FAILED);
+
+	link_sinfo->tx_retries = stats->tx_retries;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_RETRIES);
+
+	link_sinfo->rx_mpdu_count = stats->rx_mpdus;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_MPDUS);
+
+	link_sinfo->fcs_err_count = stats->rx_fcs_err;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_FCS_ERROR_COUNT);
+
+	link_sinfo->tx_duration = stats->tx_airtime;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_DURATION);
+
+	link_sinfo->rx_duration = stats->rx_airtime;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_DURATION);
+out:
+	mutex_unlock(&dev->mt76.mutex);
+}
+
+static void mt7996_sta_rc_work(void *data, struct ieee80211_sta *sta)
 {
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
-	struct mt7996_dev *dev = msta->vif->deflink.phy->dev;
 	struct mt7996_sta_link *msta_link;
-	u32 *changed = data;
+	struct mt7996_dev *dev = msta->vif->dev;
+	struct mt7996_sta_rc_work_data *wd = data;
 
 	rcu_read_lock();
+	msta_link = rcu_dereference(msta->link[wd->link_id]);
 
-	msta_link = rcu_dereference(msta->link[msta->deflink_id]);
 	if (!msta_link)
-		goto out;
+		goto unlock;
 
 	spin_lock_bh(&dev->mt76.sta_poll_lock);
-
-	msta_link->changed |= *changed;
+	msta_link->changed |= wd->changed;
 	if (list_empty(&msta_link->rc_list))
 		list_add_tail(&msta_link->rc_list, &dev->sta_rc_list);
-
 	spin_unlock_bh(&dev->mt76.sta_poll_lock);
-out:
+
+unlock:
 	rcu_read_unlock();
 }
 
@@ -1692,22 +1952,46 @@ static void mt7996_link_sta_rc_update(struct ieee80211_hw *hw,
 				      struct ieee80211_link_sta *link_sta,
 				      u32 changed)
 {
-	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct ieee80211_sta *sta = link_sta->sta;
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_sta_rc_work_data data = {
+		.link_id = msta->deflink_id,
+		.changed = changed,
+	};
+
+	if (!msta->vif) {
+		dev_warn(dev->mt76.dev, "Un-initialized STA %pM wcid %d in rc_work\n",
+			 sta->addr, msta->deflink.wcid.idx);
+		return;
+	}
 
-	mt7996_link_rate_ctrl_update(&changed, sta);
+	mt7996_sta_rc_work(&data, sta);
 	ieee80211_queue_work(hw, &dev->rc_work);
 }
 
 static int
 mt7996_set_bitrate_mask(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
-			const struct cfg80211_bitrate_mask *mask)
+			const struct cfg80211_bitrate_mask *mask,
+			unsigned int link_id)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	u32 changed = IEEE80211_RC_SUPP_RATES_CHANGED;
+	struct mt7996_vif_link *mconf;
+	struct mt7996_sta_rc_work_data data = {
+		.link_id = link_id,
+		.changed = IEEE80211_RC_SUPP_RATES_CHANGED,
+	};
+
+	mutex_lock(&dev->mt76.mutex);
+	mconf = mt7996_vif_link(dev, vif, link_id);
+
+	if (!mconf) {
+		mutex_unlock(&dev->mt76.mutex);
+		return -EINVAL;
+	}
 
-	mvif->deflink.bitrate_mask = *mask;
+	mconf->bitrate_mask = *mask;
+	mutex_unlock(&dev->mt76.mutex);
 
 	/* if multiple rates across different preambles are given we can
 	 * reconfigure this info with all peers using sta_rec command with
@@ -1717,8 +2001,7 @@ mt7996_set_bitrate_mask(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	 * - multiple rates: if it's not in range format i.e 0-{7,8,9} for VHT
 	 * then multiple MCS setting (MCS 4,5,6) is not supported.
 	 */
-	ieee80211_iterate_stations_atomic(hw, mt7996_link_rate_ctrl_update,
-					  &changed);
+	ieee80211_iterate_stations_atomic(hw, mt7996_sta_rc_work, &data);
 	ieee80211_queue_work(hw, &dev->rc_work);
 
 	return 0;
@@ -1731,12 +2014,12 @@ static void mt7996_sta_set_4addr(struct ieee80211_hw *hw,
 {
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct ieee80211_link_sta *link_sta;
+	unsigned long valid_links = vif->valid_links ?: BIT(0);
 	unsigned int link_id;
 
 	mutex_lock(&dev->mt76.mutex);
 
-	for_each_sta_active_link(vif, sta, link_sta, link_id) {
+	for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
 		struct mt7996_sta_link *msta_link;
 		struct mt7996_vif_link *link;
 
@@ -1769,12 +2052,12 @@ static void mt7996_sta_set_decap_offload(struct ieee80211_hw *hw,
 {
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct ieee80211_link_sta *link_sta;
+	unsigned long valid_links = vif->valid_links ?: BIT(0);
 	unsigned int link_id;
 
 	mutex_lock(&dev->mt76.mutex);
 
-	for_each_sta_active_link(vif, sta, link_sta, link_id) {
+	for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
 		struct mt7996_sta_link *msta_link;
 		struct mt7996_vif_link *link;
 
@@ -1931,9 +2214,15 @@ static void mt7996_ethtool_worker(void *wi_data, struct ieee80211_sta *sta)
 {
 	struct mt76_ethtool_worker_info *wi = wi_data;
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
-	struct mt7996_sta_link *msta_link = &msta->deflink;
+	struct mt7996_vif *mvif = msta->vif;
+	struct mt7996_sta_link *msta_link;
+	struct mt7996_vif_link *mconf;
+	struct ieee80211_vif *vif = container_of((void *)mvif, struct ieee80211_vif, drv_priv);
 
-	if (msta->vif->deflink.mt76.idx != wi->idx)
+	msta_link = mt76_dereference(msta->link[msta->deflink_id], &mvif->dev->mt76);
+	mconf = mt7996_vif_link(mvif->dev, vif, msta->deflink_id);
+
+	if (mconf->mt76.idx != wi->idx)
 		return;
 
 	mt76_ethtool_worker(wi, &msta_link->wcid.stats, true);
@@ -1945,12 +2234,12 @@ void mt7996_get_et_stats(struct ieee80211_hw *hw,
 			 struct ethtool_stats *stats, u64 *data)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy = &dev->phy;
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_phy *phy = mt7996_vif_link_phy(&mvif->deflink);
+	struct mt7996_vif_link *mconf;
 	struct mt76_mib_stats *mib = &phy->mib;
 	struct mt76_ethtool_worker_info wi = {
 		.data = data,
-		.idx = mvif->deflink.mt76.idx,
 	};
 	/* See mt7996_ampdu_stat_read_phy, etc */
 	int i, ei = 0;
@@ -1959,6 +2248,8 @@ void mt7996_get_et_stats(struct ieee80211_hw *hw,
 		return;
 
 	mutex_lock(&dev->mt76.mutex);
+	mconf = mt7996_vif_link(dev, vif, mvif->mt76.deflink_id);
+	wi.idx = mconf->mt76.idx,
 
 	mt7996_mac_update_stats(phy);
 
@@ -2040,30 +2331,82 @@ mt7996_twt_teardown_request(struct ieee80211_hw *hw,
 			    u8 flowid)
 {
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
-	struct mt7996_sta_link *msta_link = &msta->deflink;
-	struct mt7996_vif_link *link = &msta->vif->deflink;
+	struct mt7996_sta_link *msta_link;
+	struct mt7996_vif_link *link;
+	struct ieee80211_vif *vif = container_of((void *)msta->vif, struct ieee80211_vif, drv_priv);
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 
 	mutex_lock(&dev->mt76.mutex);
+	msta_link = mt76_dereference(msta->link[0], &dev->mt76);
+	link = mt7996_vif_link(dev, vif, 0);
 	mt7996_mac_twt_teardown_flow(dev, link, msta_link, flowid);
 	mutex_unlock(&dev->mt76.mutex);
 }
 
+static void
+mt7996_background_radar_handle_7975_ifem(struct ieee80211_hw *hw,
+					 struct cfg80211_chan_def *user_chandef,
+					 struct cfg80211_chan_def *fw_chandef)
+{
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct cfg80211_chan_def *c = user_chandef;
+	struct ieee80211_channel *first_chan;
+	bool is_ifem_adie, expand = false;
+
+	switch (mt76_chip(&dev->mt76)) {
+	case MT7996_DEVICE_ID:
+		is_ifem_adie = dev->var.fem == MT7996_FEM_INT &&
+			       dev->var.type != MT7996_VAR_TYPE_233;
+		break;
+	case MT7992_DEVICE_ID:
+		is_ifem_adie = dev->var.type == MT7992_VAR_TYPE_44 &&
+			       dev->var.fem != MT7996_FEM_EXT;
+		break;
+	default:
+		return;
+	}
+
+	if (!user_chandef || !is_ifem_adie)
+		goto out;
+
+	if (user_chandef->width == NL80211_CHAN_WIDTH_160) {
+		first_chan = ieee80211_get_channel(hw->wiphy, user_chandef->center_freq1 - 70);
+		if (dev->bg_nxt_freq)
+			goto out;
+
+		if (first_chan->flags & IEEE80211_CHAN_RADAR)
+			dev->bg_nxt_freq = first_chan->center_freq;
+		else
+			c = fw_chandef;
+
+		c->chan = ieee80211_get_channel(hw->wiphy, first_chan->center_freq + 80);
+	} else {
+		if (!dev->bg_nxt_freq)
+			goto out;
+
+		c->chan = ieee80211_get_channel(hw->wiphy, dev->bg_nxt_freq);
+		dev->bg_nxt_freq = 0;
+		expand = true;
+	}
+	c->width = NL80211_CHAN_WIDTH_80;
+	c->center_freq1 = c->chan->center_freq + 30;
+
+	if (c == user_chandef)
+		cfg80211_background_radar_update_channel(hw->wiphy, c, expand);
+	return;
+out:
+	dev->bg_nxt_freq = 0;
+}
+
 static int
 mt7996_set_radar_background(struct ieee80211_hw *hw,
 			    struct cfg80211_chan_def *chandef)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt7996_phy *phy;
+	struct mt7996_phy *phy = mt7996_band_phy(dev, NL80211_BAND_5GHZ);
 	int ret = -EINVAL;
 	bool running;
-
-	if (chandef)
-		phy = mt7996_band_phy(dev, chandef->chan->band);
-	else
-		phy = dev->rdd2_phy;
-	if (!phy)
-	    return -EINVAL;
+	struct cfg80211_chan_def ifem_chandef = {};
 
 	mutex_lock(&dev->mt76.mutex);
 
@@ -2076,13 +2419,14 @@ mt7996_set_radar_background(struct ieee80211_hw *hw,
 		goto out;
 	}
 
+	mt7996_background_radar_handle_7975_ifem(hw, chandef, &ifem_chandef);
+
 	/* rdd2 already configured on a radar channel */
 	running = dev->rdd2_phy &&
 		  cfg80211_chandef_valid(&dev->rdd2_chandef) &&
 		  !!(dev->rdd2_chandef.chan->flags & IEEE80211_CHAN_RADAR);
 
-	if (!chandef || running ||
-	    !(chandef->chan->flags & IEEE80211_CHAN_RADAR)) {
+	if (!chandef || running) {
 		ret = mt7996_mcu_rdd_background_enable(phy, NULL);
 		if (ret)
 			goto out;
@@ -2091,7 +2435,9 @@ mt7996_set_radar_background(struct ieee80211_hw *hw,
 			goto update_phy;
 	}
 
-	ret = mt7996_mcu_rdd_background_enable(phy, chandef);
+	ret = mt7996_mcu_rdd_background_enable(phy,
+					       ifem_chandef.chan ?
+					       &ifem_chandef : chandef);
 	if (ret)
 		goto out;
 
@@ -2118,9 +2464,7 @@ mt7996_net_fill_forward_path(struct ieee80211_hw *hw,
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mtk_wed_device *wed = &dev->mt76.mmio.wed;
 	struct mt7996_sta_link *msta_link;
-	struct mt7996_vif_link *link;
 	struct mt76_vif_link *mlink;
-	struct mt7996_phy *phy;
 
 	mlink = rcu_dereference(mvif->mt76.link[msta->deflink_id]);
 	if (!mlink)
@@ -2133,13 +2477,20 @@ mt7996_net_fill_forward_path(struct ieee80211_hw *hw,
 	if (!msta_link->wcid.sta || msta_link->wcid.idx > MT7996_WTBL_STA)
 		return -EIO;
 
-	link = (struct mt7996_vif_link *)mlink;
-	phy = mt7996_vif_link_phy(link);
-	if (!phy)
-		return -ENODEV;
-
-	if (phy != &dev->phy && phy->mt76->band_idx == MT_BAND2)
-		wed = &dev->mt76.mmio.wed_hif2;
+	if (dev->hif2) {
+		switch (dev->option_type) {
+		case 2:
+			/* eagle + 7988d */
+			if (msta_link->wcid.phy_idx == MT_BAND1)
+				wed = &dev->mt76.mmio.wed_hif2;
+			break;
+		default:
+			if ((is_mt7996(&dev->mt76) && msta_link->wcid.phy_idx == MT_BAND2) ||
+			    (is_mt7992(&dev->mt76) && msta_link->wcid.phy_idx == MT_BAND1))
+				wed = &dev->mt76.mmio.wed_hif2;
+			break;
+		}
+	}
 
 	if (!mtk_wed_device_active(wed))
 		return -ENODEV;
@@ -2151,7 +2502,12 @@ mt7996_net_fill_forward_path(struct ieee80211_hw *hw,
 	path->mtk_wdma.queue = 0;
 	path->mtk_wdma.wcid = msta_link->wcid.idx;
 
-	path->mtk_wdma.amsdu = mtk_wed_is_amsdu_supported(wed);
+	if (ieee80211_hw_check(hw, SUPPORTS_AMSDU_IN_AMPDU) &&
+	    mtk_wed_is_amsdu_supported(wed))
+		path->mtk_wdma.amsdu = msta_link->wcid.amsdu;
+	else
+		path->mtk_wdma.amsdu = 0;
+
 	ctx->dev = NULL;
 
 	return 0;
@@ -2164,7 +2520,117 @@ mt7996_change_vif_links(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			u16 old_links, u16 new_links,
 			struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS])
 {
-	return 0;
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy = &dev->phy;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	unsigned long rem = old_links & ~new_links;
+	unsigned int link_id;
+	int ret = 0;
+
+	if (old_links == new_links)
+		return 0;
+
+	mutex_lock(&dev->mt76.mutex);
+
+	/* remove first */
+	for_each_set_bit(link_id, &rem, IEEE80211_MLD_MAX_NUM_LINKS) {
+		struct mt7996_vif_link *mconf =
+			mt7996_vif_link(dev, vif, link_id);
+
+		if (!mconf)
+			continue;
+	}
+
+	if (!old_links) {
+		struct mt7996_vif_link *mconf =
+			mt7996_vif_link(dev, vif, link_id);
+		int idx;
+
+		if (ieee80211_vif_is_mld(vif) && mconf == &mvif->deflink)
+			mt7996_vif_link_remove(mconf->phy->mt76, vif, NULL, &mconf->mt76);
+
+		idx = get_own_mld_idx(dev->mld_idx_mask, true);
+		if (idx < 0) {
+			ret = -ENOSPC;
+			goto out;
+		}
+		mvif->mld_group_idx = idx;
+		dev->mld_idx_mask |= BIT_ULL(mvif->mld_group_idx);
+
+		idx = get_free_idx(dev->mld_remap_idx_mask, 0, 15) - 1;
+		if (idx < 0) {
+			ret = -ENOSPC;
+			goto out;
+		}
+		mvif->mld_remap_idx = idx;
+		dev->mld_remap_idx_mask |= BIT_ULL(mvif->mld_remap_idx);
+	}
+
+	/* fallback to non-MLO interface */
+	if (!new_links) {
+		ret = mt7996_vif_link_add(phy->mt76, vif, &vif->bss_conf, NULL);
+		dev->mld_id_mask &= ~BIT_ULL(mvif->mld_group_idx);
+		dev->mld_remap_id_mask &= ~BIT_ULL(mvif->mld_remap_idx);
+	}
+
+	mutex_unlock(&dev->mt76.mutex);
+
+	return ret;
+}
+
+static void
+mt7996_event_callback(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		      const struct ieee80211_event *event)
+{
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	int i;
+
+	switch (event->type) {
+	case MLME_EVENT:
+		if (event->u.mlme.data == ASSOC_EVENT &&
+		    event->u.mlme.status == MLME_SUCCESS) {
+			struct ieee80211_bss_conf *conf;
+			struct mt7996_vif_link *mconf;
+			struct mt7996_phy *phy;
+			unsigned long cur, valid_links = vif->valid_links ?: BIT(0);
+			unsigned int link_id;
+			int next_time = INT_MAX;
+
+			mutex_lock(&dev->mt76.mutex);
+			cur = jiffies;
+			for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+				conf = link_conf_dereference_protected(vif, link_id);
+				mconf = mt7996_vif_link(dev, vif, link_id);
+
+				if (!conf || !mconf)
+					continue;
+
+				phy = mconf->phy;
+				mvif->beacon_received_time[phy->mt76->band_idx] = cur;
+				next_time = min(next_time,
+						MT7996_MAX_BEACON_LOSS *
+						conf->beacon_int);
+			}
+
+			ieee80211_queue_delayed_work(hw, &mvif->beacon_mon_work,
+						     msecs_to_jiffies(next_time));
+			mutex_unlock(&dev->mt76.mutex);
+			break;
+		}
+
+		mutex_lock(&dev->mt76.mutex);
+		memset(mvif->probe_send_count, 0, sizeof(mvif->probe_send_count));
+		for (i = 0; i < __MT_MAX_BAND; i++)
+			mvif->probe[i] = NULL;
+		mvif->lost_links = 0;
+		mutex_unlock(&dev->mt76.mutex);
+
+		cancel_delayed_work(&mvif->beacon_mon_work);
+		break;
+	default:
+		break;
+	}
 }
 
 const struct ieee80211_ops mt7996_ops = {
@@ -2185,7 +2651,7 @@ const struct ieee80211_ops mt7996_ops = {
 	.vif_cfg_changed = mt7996_vif_cfg_changed,
 	.link_info_changed = mt7996_link_info_changed,
 	.sta_state = mt7996_sta_state,
-	.sta_pre_rcu_remove = mt76_sta_pre_rcu_remove,
+	.sta_pre_rcu_remove = mt7996_sta_pre_rcu_remove,
 	.link_sta_rc_update = mt7996_link_sta_rc_update,
 	.set_key = mt7996_set_key,
 	.ampdu_action = mt7996_ampdu_action,
@@ -2198,6 +2664,7 @@ const struct ieee80211_ops mt7996_ops = {
 	.release_buffered_frames = mt76_release_buffered_frames,
 	.get_txpower = mt7996_get_txpower,
 	.channel_switch_beacon = mt7996_channel_switch_beacon,
+	.post_channel_switch = mt7996_post_channel_switch,
 	.get_stats = mt7996_get_stats,
 	.get_et_sset_count = mt7996_get_et_sset_count,
 	.get_et_stats = mt7996_get_et_stats,
@@ -2211,18 +2678,25 @@ const struct ieee80211_ops mt7996_ops = {
 	.set_bitrate_mask = mt7996_set_bitrate_mask,
 	.set_coverage_class = mt7996_set_coverage_class,
 	.sta_statistics = mt7996_sta_statistics,
+	.link_sta_statistics = mt7996_link_sta_statistics,
 	.sta_set_4addr = mt7996_sta_set_4addr,
 	.sta_set_decap_offload = mt7996_sta_set_decap_offload,
 	.add_twt_setup = mt7996_mac_add_twt_setup,
 	.twt_teardown_request = mt7996_twt_teardown_request,
+	CFG80211_TESTMODE_CMD(mt76_testmode_cmd)
+	CFG80211_TESTMODE_DUMP(mt76_testmode_dump)
 #ifdef CONFIG_MAC80211_DEBUGFS
 	.sta_add_debugfs = mt7996_sta_add_debugfs,
+	.link_sta_add_debugfs = mt7996_link_sta_add_debugfs,
+	// .link_add_debugfs = mt7996_link_add_debugfs,
+	.vif_add_debugfs = mt7996_vif_add_debugfs,
 #endif
 	.set_radar_background = mt7996_set_radar_background,
 #ifdef CONFIG_NET_MEDIATEK_SOC_WED
 	.net_fill_forward_path = mt7996_net_fill_forward_path,
 	.net_setup_tc = mt76_wed_net_setup_tc,
 #endif
+	.event_callback = mt7996_event_callback,
 	.change_vif_links = mt7996_change_vif_links,
 	.change_sta_links = mt7996_mac_sta_change_links,
 };
diff --git a/mt7996/mcu.c b/mt7996/mcu.c
index ce4c2bfd..d613fab2 100644
--- a/mt7996/mcu.c
+++ b/mt7996/mcu.c
@@ -9,6 +9,7 @@
 #include "mcu.h"
 #include "mac.h"
 #include "eeprom.h"
+#include "mt7996_trace.h"
 
 #define fw_name(_dev, name, ...)	({			\
 	char *_fw;						\
@@ -18,6 +19,9 @@
 		case MT7992_VAR_TYPE_23:			\
 			_fw = MT7992_##name##_23;		\
 			break;					\
+		case MT7992_VAR_TYPE_24:			\
+			_fw = MT7992_##name##_24;		\
+			break;					\
 		default:					\
 			_fw = MT7992_##name;			\
 		}						\
@@ -255,6 +259,14 @@ mt7996_mcu_send_message(struct mt76_dev *mdev, struct sk_buff *skb,
 	u32 val;
 	u8 seq;
 
+	if (dev->recovery.l1_reset_last != dev->recovery.l1_reset) {
+		dev_info(dev->mt76.dev,"\n%s L1 SER recovery overlap, drop message %08x.",
+			 wiphy_name(dev->mt76.hw->wiphy), cmd);
+
+		dev_kfree_skb(skb);
+		return -EPERM;
+	}
+
 	mdev->mcu.timeout = 20 * HZ;
 
 	seq = ++dev->mt76.mcu.msg_seq & 0xf;
@@ -304,6 +316,9 @@ mt7996_mcu_send_message(struct mt76_dev *mdev, struct sk_buff *skb,
 		else if (cmd & __MCU_CMD_FIELD_WM)
 			uni_txd->s2d_index = MCU_S2D_H2N;
 
+		trace_mt7996_mcu_cmd(dev, 1, uni_txd->cid, 0,
+				    skb->data, skb->len);
+
 		goto exit;
 	}
 
@@ -331,7 +346,13 @@ mt7996_mcu_send_message(struct mt76_dev *mdev, struct sk_buff *skb,
 	else
 		mcu_txd->s2d_index = MCU_S2D_H2N;
 
+	trace_mt7996_mcu_cmd(dev, 0, mcu_txd->cid, mcu_txd->ext_cid,
+			    skb->data, skb->len);
 exit:
+#ifdef CONFIG_MTK_DEBUG
+	if (dev->dbg.dump_mcu_pkt)
+		mt7996_packet_log_to_host(dev, skb->data, skb->len, PKT_BIN_DEBUG_MCU, 0);
+#endif
 	if (wait_seq)
 		*wait_seq = seq;
 
@@ -369,10 +390,21 @@ int mt7996_mcu_wa_cmd(struct mt7996_dev *dev, int cmd, u32 a1, u32 a2, u32 a3)
 static void
 mt7996_mcu_csa_finish(void *priv, u8 *mac, struct ieee80211_vif *vif)
 {
-	if (!vif->bss_conf.csa_active || vif->type == NL80211_IFTYPE_STATION)
+	struct mt76_phy *mphy = (struct mt76_phy *)priv;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct ieee80211_bss_conf *link_conf;
+	int link_id, band_idx = mphy->band_idx;
+
+	link_id = mvif->mt76.band_to_link[band_idx];
+	if (link_id == IEEE80211_LINK_UNSPECIFIED)
+		return;
+
+	link_conf = rcu_dereference(vif->link_conf[link_id]);
+
+	if (!link_conf || !link_conf->csa_active || vif->type == NL80211_IFTYPE_STATION)
 		return;
 
-	ieee80211_csa_finish(vif, 0);
+	ieee80211_csa_finish(vif, link_id);
 }
 
 static void
@@ -404,10 +436,11 @@ mt7996_mcu_rx_radar_detected(struct mt7996_dev *dev, struct sk_buff *skb)
 		return;
 
 	if (r->rdd_idx == MT_RDD_IDX_BACKGROUND)
+		dev->bg_nxt_freq = 0;
 		cfg80211_background_radar_event(mphy->hw->wiphy,
 						&dev->rdd2_chandef,
 						GFP_ATOMIC);
-	else
+	} else
 		ieee80211_radar_detected(mphy->hw, NULL);
 	dev->hw_pattern++;
 }
@@ -416,6 +449,7 @@ static void
 mt7996_mcu_rx_log_message(struct mt7996_dev *dev, struct sk_buff *skb)
 {
 #define UNI_EVENT_FW_LOG_FORMAT 0
+#define UNI_EVENT_FW_LOG_MEMORY	1
 	struct mt7996_mcu_rxd *rxd = (struct mt7996_mcu_rxd *)skb->data;
 	const char *data = (char *)&rxd[1] + 4, *type;
 	struct tlv *tlv = (struct tlv *)data;
@@ -427,7 +461,8 @@ mt7996_mcu_rx_log_message(struct mt7996_dev *dev, struct sk_buff *skb)
 		goto out;
 	}
 
-	if (le16_to_cpu(tlv->tag) != UNI_EVENT_FW_LOG_FORMAT)
+	if (le16_to_cpu(tlv->tag) != UNI_EVENT_FW_LOG_FORMAT &&
+	    le16_to_cpu(tlv->tag) != UNI_EVENT_FW_LOG_MEMORY)
 		return;
 
 	data += sizeof(*tlv) + 4;
@@ -455,10 +490,21 @@ out:
 static void
 mt7996_mcu_cca_finish(void *priv, u8 *mac, struct ieee80211_vif *vif)
 {
-	if (!vif->bss_conf.color_change_active || vif->type == NL80211_IFTYPE_STATION)
+	struct mt76_phy *mphy = (struct mt76_phy *)priv;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct ieee80211_bss_conf *link_conf;
+	u8 link_id;
+
+	link_id = mvif->mt76.band_to_link[mphy->band_idx];
+	if (link_id == IEEE80211_LINK_UNSPECIFIED)
+		return;
+
+	link_conf = rcu_dereference(vif->link_conf[link_id]);
+	if (!link_conf || !link_conf->color_change_active ||
+	    vif->type == NL80211_IFTYPE_STATION)
 		return;
 
-	ieee80211_color_change_finish(vif, 0);
+	ieee80211_color_change_finish(vif, link_id);
 }
 
 static void
@@ -489,12 +535,12 @@ mt7996_mcu_ie_countdown(struct mt7996_dev *dev, struct sk_buff *skb)
 		case UNI_EVENT_IE_COUNTDOWN_CSA:
 			ieee80211_iterate_active_interfaces_atomic(mphy->hw,
 					IEEE80211_IFACE_ITER_RESUME_ALL,
-					mt7996_mcu_csa_finish, mphy->hw);
+					mt7996_mcu_csa_finish, mphy);
 			break;
 		case UNI_EVENT_IE_COUNTDOWN_BCC:
 			ieee80211_iterate_active_interfaces_atomic(mphy->hw,
 					IEEE80211_IFACE_ITER_RESUME_ALL,
-					mt7996_mcu_cca_finish, mphy->hw);
+					mt7996_mcu_cca_finish, mphy);
 			break;
 		}
 
@@ -540,6 +586,30 @@ mt7996_mcu_update_tx_gi(struct rate_info *rate, struct all_sta_trx_rate *mcu_rat
 	return 0;
 }
 
+static inline void __mt7996_stat_to_netdev(struct mt76_phy *mphy,
+					   struct mt76_wcid *wcid,
+					   u32 tx_bytes, u32 rx_bytes,
+					   u32 tx_packets, u32 rx_packets)
+{
+	struct mt7996_sta_link *msta_link;
+	struct ieee80211_vif *vif;
+	struct wireless_dev *wdev;
+
+	if (wiphy_ext_feature_isset(mphy->hw->wiphy,
+				    NL80211_EXT_FEATURE_STAS_COUNT)) {
+		msta_link = container_of(wcid, struct mt7996_sta_link, wcid);
+		vif = container_of((void *)msta_link->sta->vif, struct ieee80211_vif,
+				   drv_priv);
+		wdev = ieee80211_vif_to_wdev(vif);
+
+		if (vif->type == NL80211_IFTYPE_MONITOR)
+			return;
+
+		dev_sw_netstats_tx_add(wdev->netdev, tx_packets, tx_bytes);
+		__dev_sw_netstats_rx_add(wdev->netdev, rx_packets, rx_bytes);
+	}
+}
+
 static void
 mt7996_mcu_rx_all_sta_info_event(struct mt7996_dev *dev, struct sk_buff *skb)
 {
@@ -552,8 +622,13 @@ mt7996_mcu_rx_all_sta_info_event(struct mt7996_dev *dev, struct sk_buff *skb)
 
 	for (i = 0; i < le16_to_cpu(res->sta_num); i++) {
 		u8 ac;
+		bool v1;
 		u16 wlan_idx;
 		struct mt76_wcid *wcid;
+		struct mt76_phy *mphy;
+		struct ieee80211_sta *sta;
+		u32 tx_bytes, rx_bytes, tx_bytes_failed = 0, tx_airtime, rx_airtime,
+		    tx_packets, rx_packets;
 
 		switch (le16_to_cpu(res->tag)) {
 		case UNI_ALL_STA_TXRX_RATE:
@@ -567,17 +642,41 @@ mt7996_mcu_rx_all_sta_info_event(struct mt7996_dev *dev, struct sk_buff *skb)
 				dev_err(dev->mt76.dev, "Failed to update TX GI\n");
 			break;
 		case UNI_ALL_STA_TXRX_ADM_STAT:
-			wlan_idx = le16_to_cpu(res->adm_stat[i].wlan_idx);
+			v1 = le16_to_cpu(res->len) == UNI_EVENT_SIZE_ADM_STAT_V1;
+			if (v1)
+				wlan_idx = le16_to_cpu(res->adm_stat_v1[i].wlan_idx);
+			else
+				wlan_idx = le16_to_cpu(res->adm_stat_v2[i].wlan_idx);
 			wcid = mt76_wcid_ptr(dev, wlan_idx);
 
 			if (!wcid)
 				break;
 
-			for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
-				wcid->stats.tx_bytes +=
-					le32_to_cpu(res->adm_stat[i].tx_bytes[ac]);
-				wcid->stats.rx_bytes +=
-					le32_to_cpu(res->adm_stat[i].rx_bytes[ac]);
+			mphy = mt76_dev_phy(&dev->mt76, wcid->phy_idx);
+			for (ac = IEEE80211_AC_VO; ac < IEEE80211_NUM_ACS; ac++) {
+				u8 lmac_ac = mt76_connac_lmac_mapping(ac);
+				if (v1) {
+					tx_bytes = le32_to_cpu(res->adm_stat_v1[i].tx_bytes[lmac_ac]);
+					rx_bytes = le32_to_cpu(res->adm_stat_v1[i].rx_bytes[lmac_ac]);
+				} else {
+					tx_bytes = le32_to_cpu(res->adm_stat_v2[i].tx_bytes[lmac_ac]);
+					rx_bytes = le32_to_cpu(res->adm_stat_v2[i].rx_bytes[lmac_ac]);
+					tx_bytes_failed = le32_to_cpu(res->adm_stat_v2[i].tx_bytes_failed[lmac_ac]);
+				}
+
+				wcid->stats.tx_bytes_per_ac[ac] += tx_bytes;
+				wcid->stats.rx_bytes_per_ac[ac] += rx_bytes;
+				wcid->stats.tx_bytes_failed_per_ac[ac] += tx_bytes_failed;
+
+				wcid->stats.tx_bytes += tx_bytes;
+				wcid->stats.rx_bytes += rx_bytes;
+				wcid->stats.tx_bytes_failed += tx_bytes_failed;
+
+				__mt7996_stat_to_netdev(mphy, wcid,
+							tx_bytes, rx_bytes, 0, 0);
+
+				ieee80211_tpt_led_trig_tx(mphy->hw, tx_bytes);
+				ieee80211_tpt_led_trig_rx(mphy->hw, rx_bytes);
 			}
 			break;
 		case UNI_ALL_STA_TXRX_MSDU_COUNT:
@@ -587,14 +686,295 @@ mt7996_mcu_rx_all_sta_info_event(struct mt7996_dev *dev, struct sk_buff *skb)
 			if (!wcid)
 				break;
 
-			wcid->stats.tx_packets +=
-				le32_to_cpu(res->msdu_cnt[i].tx_msdu_cnt);
-			wcid->stats.rx_packets +=
-				le32_to_cpu(res->msdu_cnt[i].rx_msdu_cnt);
+			mphy = mt76_dev_phy(&dev->mt76, wcid->phy_idx);
+
+			tx_packets = le32_to_cpu(res->msdu_cnt[i].tx_msdu_cnt);
+			rx_packets = le32_to_cpu(res->msdu_cnt[i].rx_msdu_cnt);
+
+			wcid->stats.tx_packets += tx_packets;
+			wcid->stats.rx_packets += rx_packets;
+
+			__mt7996_stat_to_netdev(mphy, wcid, 0, 0,
+						tx_packets, rx_packets);
+			break;
+		case UNI_ALL_STA_TXRX_AIR_TIME:
+			wlan_idx = le16_to_cpu(res->airtime[i].wlan_idx);
+			wcid = rcu_dereference(dev->mt76.wcid[wlan_idx]);
+			sta = wcid_to_sta(wcid);
+			if (!sta)
+				continue;
+
+			for (ac = IEEE80211_AC_VO; ac < IEEE80211_NUM_ACS; ++ac) {
+				u8 lmac_ac = mt76_connac_lmac_mapping(ac);
+				tx_airtime = le32_to_cpu(res->airtime[i].tx[lmac_ac]);
+				rx_airtime = le32_to_cpu(res->airtime[i].rx[lmac_ac]);
+
+				wcid->stats.tx_airtime += tx_airtime;
+				wcid->stats.rx_airtime += rx_airtime;
+				ieee80211_sta_register_airtime(sta, mt76_ac_to_tid(ac),
+				                               tx_airtime, rx_airtime);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+static int
+csi_integrate_segment_data(struct mt7996_phy *phy, struct csi_data *csi)
+{
+	struct csi_data *csi_temp = NULL;
+
+	if (csi->segment_num == 0 && csi->remain_last == 0)
+		return CSI_CHAIN_COMPLETE;
+	else if (csi->segment_num == 0 && csi->remain_last == 1) {
+		memcpy(&phy->csi.buffered_csi,
+		       csi, sizeof(struct csi_data));
+
+		return CSI_CHAIN_SEGMENT_FIRST;
+	} else if (csi->segment_num != 0) {
+		csi_temp = &phy->csi.buffered_csi;
+		if (csi->chain_info != csi_temp->chain_info ||
+		csi->segment_num != (csi_temp->segment_num + 1))
+			return CSI_CHAIN_SEGMENT_ERR;
+
+		memcpy(&csi_temp->data_i[csi_temp->data_num],
+		       csi->data_i, csi->data_num * sizeof(s16));
+
+		memcpy(&csi_temp->data_q[csi_temp->data_num],
+		       csi->data_q, csi->data_num * sizeof(s16));
+
+		csi_temp->data_num += csi->data_num;
+		csi_temp->segment_num = csi->segment_num;
+		csi_temp->remain_last = csi->remain_last;
+
+		if (csi->remain_last == 0)
+			return CSI_CHAIN_SEGMENT_LAST;
+		else if (csi->remain_last == 1)
+			return CSI_CHAIN_SEGMENT_MIDDLE;
+	}
+
+	return CSI_CHAIN_ERR;
+}
+
+static int
+mt7996_mcu_csi_report_data(struct mt7996_phy *phy, u8 *tlv_buf, u32 len)
+{
+	int ret, i;
+	struct csi_data *current_csi;
+	struct csi_data *target_csi;
+	struct csi_tlv *tlv_data;
+	u8 *buf_tmp;
+	u32 rx_info, tx_rx_idx;
+	u32 buf_len_last, offset;
+
+	buf_tmp = tlv_buf;
+	buf_len_last = len;
+	offset = sizeof(((struct csi_tlv *)0)->basic);
+
+	current_csi = kzalloc(sizeof(*current_csi), GFP_KERNEL);
+	if (!current_csi)
+		return -ENOMEM;
+
+	while (buf_len_last >= offset) {
+		u32 tag, len;
+		s16 *data_tmp = NULL;
+
+		tlv_data = (struct csi_tlv *)buf_tmp;
+		tag = le32_to_cpu(tlv_data->basic.tag);
+		len = le32_to_cpu(tlv_data->basic.len);
+
+		switch (tag) {
+		case CSI_EVENT_FW_VER:
+			current_csi->fw_ver = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_CBW:
+			current_csi->ch_bw = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_RSSI:
+			current_csi->rssi = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_SNR:
+			current_csi->snr = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_BAND:
+			current_csi->band = le32_to_cpu(tlv_data->info);
+
+			if (current_csi->band != phy->mt76->band_idx) {
+				kfree(current_csi);
+				return -EINVAL;
+			}
+
+			break;
+		case CSI_EVENT_CSI_NUM:
+			current_csi->data_num = le32_to_cpu(tlv_data->info);
+
+			if (current_csi->data_num > CSI_BW80_DATA_COUNT) {
+				kfree(current_csi);
+				return -EINVAL;
+			}
+
+			break;
+		case CSI_EVENT_CSI_I_DATA:
+			if (len != sizeof(s16) * current_csi->data_num) {
+				kfree(current_csi);
+				return -EINVAL;
+			}
+
+			data_tmp = tlv_data->data;
+			for (i = 0; i < current_csi->data_num; i++)
+				current_csi->data_i[i] = le16_to_cpu(*(data_tmp + i));
+			break;
+		case CSI_EVENT_CSI_Q_DATA:
+			if (len != sizeof(s16) * current_csi->data_num) {
+				kfree(current_csi);
+				return -EINVAL;
+			}
+
+			data_tmp = tlv_data->data;
+			for (i = 0; i < current_csi->data_num; i++)
+				current_csi->data_q[i] = le16_to_cpu(*(data_tmp + i));
+			break;
+		case CSI_EVENT_DBW:
+			current_csi->data_bw = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_CH_IDX:
+			current_csi->pri_ch_idx = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_TA:
+			memcpy(current_csi->ta, tlv_data->mac, ETH_ALEN);
+			break;
+		case CSI_EVENT_EXTRA_INFO:
+			current_csi->ext_info = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_RX_MODE:
+			rx_info = le32_to_cpu(tlv_data->info);
+			current_csi->rx_mode = u32_get_bits(rx_info, GENMASK(15, 0));
+			current_csi->rx_rate = u32_get_bits(rx_info, GENMASK(31, 16));
+			break;
+		case CSI_EVENT_H_IDX:
+			current_csi->chain_info = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_TX_RX_IDX:
+			tx_rx_idx = le32_to_cpu(tlv_data->info);
+			current_csi->tx_idx = u32_get_bits(tx_rx_idx, GENMASK(31, 16));
+			current_csi->rx_idx = u32_get_bits(tx_rx_idx, GENMASK(15, 0));
+			break;
+		case CSI_EVENT_TS:
+			current_csi->ts = le32_to_cpu(tlv_data->info);
+
+			if (phy->csi.interval &&
+				current_csi->ts < phy->csi.last_record + phy->csi.interval) {
+				kfree(current_csi);
+				return 0;
+			}
+
+			break;
+		case CSI_EVENT_PKT_SN:
+			current_csi->pkt_sn = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_BW_SEG:
+			current_csi->segment_num = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_REMAIN_LAST:
+			current_csi->remain_last = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_TR_STREAM:
+			current_csi->tr_stream = le32_to_cpu(tlv_data->info);
+			break;
+		default:
+			break;
+		};
+
+		buf_len_last -= (offset + len);
+
+		if (buf_len_last >= offset)
+			buf_tmp += (offset + len);
+	}
+
+	/* integret the bw80 segment */
+	if (current_csi->ch_bw >= CSI_BW80) {
+		ret = csi_integrate_segment_data(phy, current_csi);
+
+		switch (ret) {
+		case CSI_CHAIN_ERR:
+		case CSI_CHAIN_SEGMENT_ERR:
+			kfree(current_csi);
+			return -EINVAL;
+			break;
+		case CSI_CHAIN_SEGMENT_FIRST:
+		case CSI_CHAIN_SEGMENT_MIDDLE:
+			kfree(current_csi);
+			return 0;
+			break;
+		case CSI_CHAIN_COMPLETE:
+			target_csi = current_csi;
+			break;
+		case CSI_CHAIN_SEGMENT_LAST:
+			target_csi = current_csi;
+			memcpy(target_csi, &phy->csi.buffered_csi, sizeof(struct csi_data));
+			memset(&phy->csi.buffered_csi, 0, sizeof(struct csi_data));
 			break;
 		default:
 			break;
 		}
+	} else {
+		target_csi = current_csi;
+	}
+
+	/* put the csi data into list */
+	INIT_LIST_HEAD(&target_csi->node);
+	spin_lock_bh(&phy->csi.lock);
+
+	if (!phy->csi.enable) {
+		kfree(target_csi);
+		goto out;
+	}
+
+	list_add_tail(&target_csi->node, &phy->csi.list);
+	phy->csi.count++;
+
+	if (phy->csi.count > CSI_MAX_BUF_NUM) {
+		struct csi_data *old;
+
+		old = list_first_entry(&phy->csi.list,
+				       struct csi_data, node);
+
+		list_del(&old->node);
+		kfree(old);
+		phy->csi.count--;
+	}
+
+	if (target_csi->chain_info & BIT(15)) /* last chain */
+		phy->csi.last_record = target_csi->ts;
+
+out:
+	spin_unlock_bh(&phy->csi.lock);
+	return 0;
+}
+
+void
+mt7996_mcu_csi_report_event(struct mt7996_dev *dev, struct sk_buff *skb)
+{
+	struct mt7996_mcu_csi_event *event;
+	struct mt76_phy *mphy;
+	struct mt7996_phy *phy;
+
+	event = (struct mt7996_mcu_csi_event *)skb->data;
+
+	mphy = dev->mt76.phys[event->band_idx];
+	if (!mphy)
+		return;
+
+	phy = mphy->priv;
+
+	switch (le16_to_cpu(event->tag)) {
+	case UNI_EVENT_CSI_DATA:
+		mt7996_mcu_csi_report_data(phy, event->tlv_buf, le16_to_cpu(event->len) - 4);
+		break;
+	default:
+		break;
 	}
 }
 
@@ -625,6 +1005,82 @@ mt7996_mcu_rx_thermal_notify(struct mt7996_dev *dev, struct sk_buff *skb)
 	phy->throttle_state = n->duty_percent;
 }
 
+void mt7996_mcu_wmm_pbc_work(struct work_struct *work)
+{
+#define WMM_PBC_QUEUE_NUM	5
+#define WMM_PBC_BSS_ALL		0xff
+#define WMM_PBC_WLAN_IDX_ALL	0xffff
+#define WMM_PBC_BOUND_DEFAULT	0xffff
+#define WMM_PBC_LOW_BOUND_VO	1900
+#define WMM_PBC_LOW_BOUND_VI	1900
+#define WMM_PBC_LOW_BOUND_BE	1500
+#define WMM_PBC_LOW_BOUND_BK	900
+#define WMM_PBC_LOW_BOUND_MGMT	32
+	struct mt7996_dev *dev = container_of(work, struct mt7996_dev, wmm_pbc_work);
+	struct {
+		u8 bss_idx;
+		u8 queue_num;
+		__le16 wlan_idx;
+		u8 band_idx;
+		u8 __rsv[3];
+		struct {
+			__le16 low;
+			__le16 up;
+		} __packed bound[WMM_PBC_QUEUE_NUM];
+	} __packed req = {
+		.bss_idx = WMM_PBC_BSS_ALL,
+		.queue_num = WMM_PBC_QUEUE_NUM,
+		.wlan_idx = cpu_to_le16(WMM_PBC_WLAN_IDX_ALL),
+		.band_idx = dev->mphy.band_idx,
+	};
+	int i, ret;
+
+#define pbc_acq_low_bound_config(_ac, _bound)								\
+	req.bound[mt76_connac_lmac_mapping(_ac)].low = dev->wmm_pbc_enable ? cpu_to_le16(_bound) : 0
+	pbc_acq_low_bound_config(IEEE80211_AC_VO, WMM_PBC_LOW_BOUND_VO);
+	pbc_acq_low_bound_config(IEEE80211_AC_VI, WMM_PBC_LOW_BOUND_VI);
+	pbc_acq_low_bound_config(IEEE80211_AC_BE, WMM_PBC_LOW_BOUND_BE);
+	pbc_acq_low_bound_config(IEEE80211_AC_BK, WMM_PBC_LOW_BOUND_BK);
+	req.bound[4].low = dev->wmm_pbc_enable
+	                   ? cpu_to_le16(WMM_PBC_LOW_BOUND_MGMT) : 0;
+
+	for (i = 0; i < WMM_PBC_QUEUE_NUM; ++i)
+		req.bound[i].up = cpu_to_le16(WMM_PBC_BOUND_DEFAULT);
+
+	ret = mt76_mcu_send_msg(&dev->mt76, MCU_WA_EXT_CMD(PKT_BUDGET_CTRL),
+	                        &req, sizeof(req), true);
+	if (ret)
+		dev_err(dev->mt76.dev, "Failed to configure WMM PBC.\n");
+}
+
+static void
+mt7996_mcu_rx_bss_acq_pkt_cnt(struct mt7996_dev *dev, struct sk_buff *skb)
+{
+	struct mt7996_mcu_bss_acq_pkt_cnt_event *event = (struct mt7996_mcu_bss_acq_pkt_cnt_event *)skb->data;
+	u32 bitmap = le32_to_cpu(event->bss_bitmap);
+	u64 sum[IEEE80211_NUM_ACS] = {0};
+	u8 ac_cnt = 0;
+	int i, j;
+
+	for (i = 0; (i < BSS_ACQ_PKT_CNT_BSS_NUM) && (bitmap & (1 << i)); ++i) {
+		for (j = IEEE80211_AC_VO; j < IEEE80211_NUM_ACS; ++j)
+			sum[j] += le32_to_cpu(event->bss[i].cnt[mt76_connac_lmac_mapping(j)]);
+	}
+
+	for (i = IEEE80211_AC_VO; i < IEEE80211_NUM_ACS; ++i) {
+		if (sum[i] > WMM_PKT_THRESHOLD)
+			++ac_cnt;
+	}
+
+	if (ac_cnt > 1 && !dev->wmm_pbc_enable) {
+		dev->wmm_pbc_enable = true;
+		queue_work(dev->mt76.wq, &dev->wmm_pbc_work);
+	} else if (ac_cnt <= 1 && dev->wmm_pbc_enable) {
+		dev->wmm_pbc_enable = false;
+		queue_work(dev->mt76.wq, &dev->wmm_pbc_work);
+	}
+}
+
 static void
 mt7996_mcu_rx_ext_event(struct mt7996_dev *dev, struct sk_buff *skb)
 {
@@ -634,6 +1090,8 @@ mt7996_mcu_rx_ext_event(struct mt7996_dev *dev, struct sk_buff *skb)
 	case MCU_EXT_EVENT_FW_LOG_2_HOST:
 		mt7996_mcu_rx_log_message(dev, skb);
 		break;
+	case MCU_EXT_EVENT_BSS_ACQ_PKT_CNT:
+		mt7996_mcu_rx_bss_acq_pkt_cnt(dev, skb);
 	default:
 		break;
 	}
@@ -723,6 +1181,10 @@ mt7996_mcu_uni_rx_unsolicited_event(struct mt7996_dev *dev, struct sk_buff *skb)
 {
 	struct mt7996_mcu_rxd *rxd = (struct mt7996_mcu_rxd *)skb->data;
 
+#ifdef CONFIG_MTK_DEBUG
+	if (dev->dbg.dump_mcu_event)
+		mt7996_packet_log_to_host(dev, skb->data, skb->len, PKT_BIN_DEBUG_MCU_EVENT, 0);
+#endif
 	switch (rxd->eid) {
 	case MCU_UNI_EVENT_FW_LOG_2_HOST:
 		mt7996_mcu_rx_log_message(dev, skb);
@@ -739,6 +1201,29 @@ mt7996_mcu_uni_rx_unsolicited_event(struct mt7996_dev *dev, struct sk_buff *skb)
 	case MCU_UNI_EVENT_WED_RRO:
 		mt7996_mcu_wed_rro_event(dev, skb);
 		break;
+#ifdef CONFIG_MTK_DEBUG
+	case MCU_UNI_EVENT_SR:
+		mt7996_mcu_rx_sr_event(dev, skb);
+		break;
+#endif
+	case MCU_UNI_EVENT_THERMAL:
+		mt7996_mcu_rx_thermal_notify(dev, skb);
+		break;
+#ifdef CONFIG_NL80211_TESTMODE
+	case MCU_UNI_EVENT_TESTMODE_CTRL:
+		mt7996_tm_rf_test_event(dev, skb);
+		break;
+#endif
+#if defined CONFIG_NL80211_TESTMODE || defined CONFIG_MTK_DEBUG
+	case MCU_UNI_EVENT_BF:
+		mt7996_mcu_rx_bf_event(dev, skb);
+		break;
+#endif
+#ifdef CONFIG_MTK_VENDOR
+	case MCU_UNI_EVENT_CSI_REPORT:
+		mt7996_mcu_csi_report_event(dev, skb);
+		break;
+#endif
 	default:
 		break;
 	}
@@ -749,6 +1234,8 @@ void mt7996_mcu_rx_event(struct mt7996_dev *dev, struct sk_buff *skb)
 {
 	struct mt7996_mcu_rxd *rxd = (struct mt7996_mcu_rxd *)skb->data;
 
+	trace_mt7996_mcu_event(dev, rxd->option & MCU_UNI_CMD_UNSOLICITED_EVENT,
+			      rxd->eid, rxd->ext_eid, skb->data, skb->len);
 	if (rxd->option & MCU_UNI_CMD_UNSOLICITED_EVENT) {
 		mt7996_mcu_uni_rx_unsolicited_event(dev, skb);
 		return;
@@ -920,6 +1407,9 @@ mt7996_mcu_bss_mld_tlv(struct sk_buff *skb,
 		mld->group_mld_id = 0xff;
 		mld->remap_idx = 0xff;
 	}
+
+	pr_info("%s: group_mld_id=%d own_mld_id=%d remap_idx=%d mld->addr[%pM]\n",
+		__func__, mld->group_mld_id,  mld->own_mld_id, mld->remap_idx, mld->mac_addr);
 }
 
 static void
@@ -1021,13 +1511,16 @@ mt7996_mcu_bss_basic_tlv(struct sk_buff *skb,
 	case NL80211_IFTYPE_STATION:
 		if (enable) {
 			rcu_read_lock();
-			sta = ieee80211_find_sta(vif, vif->bss_conf.bssid);
+			if (!sta)
+				sta = ieee80211_find_sta(vif, link_conf->bssid);
 			/* TODO: enable BSS_INFO_UAPSD & BSS_INFO_PM */
 			if (sta) {
-				struct mt76_wcid *wcid;
+				struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+				struct mt7996_sta_link *msta_link;
 
-				wcid = (struct mt76_wcid *)sta->drv_priv;
-				sta_wlan_idx = wcid->idx;
+				msta_link = rcu_dereference(msta->link[link_conf->link_id]);
+				if (msta_link)
+					sta_wlan_idx = msta_link->wcid.idx;
 			}
 			rcu_read_unlock();
 		}
@@ -1044,8 +1537,6 @@ mt7996_mcu_bss_basic_tlv(struct sk_buff *skb,
 	tlv = mt7996_mcu_add_uni_tlv(skb, UNI_BSS_INFO_BASIC, sizeof(*bss));
 
 	bss = (struct mt76_connac_bss_basic_tlv *)tlv;
-	bss->bcn_interval = cpu_to_le16(link_conf->beacon_int);
-	bss->dtim_period = link_conf->dtim_period;
 	bss->bmc_tx_wlan_idx = cpu_to_le16(wlan_idx);
 	bss->sta_idx = cpu_to_le16(sta_wlan_idx);
 	bss->conn_type = cpu_to_le32(type);
@@ -1059,16 +1550,22 @@ mt7996_mcu_bss_basic_tlv(struct sk_buff *skb,
 	bss->hw_bss_idx = idx;
 
 	if (vif->type == NL80211_IFTYPE_MONITOR) {
-		memcpy(bss->bssid, phy->macaddr, ETH_ALEN);
+		struct mt76_testmode_data *td = &phy->test;
+
+		if (!td->bf_en)
+			memcpy(bss->bssid, phy->macaddr, ETH_ALEN);
+		else
+			memcpy(bss->bssid, td->addr[2], ETH_ALEN);
 		return 0;
 	}
 
 	memcpy(bss->bssid, link_conf->bssid, ETH_ALEN);
+
 	bss->bcn_interval = cpu_to_le16(link_conf->beacon_int);
-	bss->dtim_period = vif->bss_conf.dtim_period;
+	bss->dtim_period = link_conf->dtim_period;
 	bss->phymode = mt76_connac_get_phy_mode(phy, vif,
 						chandef->chan->band, NULL);
-	bss->phymode_ext = mt76_connac_get_phy_mode_ext(phy, &vif->bss_conf,
+	bss->phymode_ext = mt76_connac_get_phy_mode_ext(phy, link_conf,
 							chandef->chan->band);
 
 	return 0;
@@ -1126,7 +1623,7 @@ int mt7996_mcu_add_bss_info(struct mt7996_phy *phy, struct ieee80211_vif *vif,
 		mt7996_mcu_bss_txcmd_tlv(skb, true);
 		mt7996_mcu_bss_ifs_timing_tlv(skb, phy);
 
-		if (vif->bss_conf.he_support)
+		if (link_conf->he_support)
 			mt7996_mcu_bss_he_tlv(skb, vif, link_conf, phy);
 
 		/* this tag is necessary no matter if the vif is MLD */
@@ -1255,7 +1752,7 @@ int mt7996_mcu_add_rx_ba(struct mt7996_dev *dev,
 }
 
 static void
-mt7996_mcu_sta_he_tlv(struct sk_buff *skb,
+mt7996_mcu_sta_he_tlv(struct sk_buff *skb, struct ieee80211_bss_conf *conf,
 		      struct ieee80211_link_sta *link_sta,
 		      struct mt7996_vif_link *link)
 {
@@ -1277,6 +1774,11 @@ mt7996_mcu_sta_he_tlv(struct sk_buff *skb,
 		he->he_phy_cap[i] = elem->phy_cap_info[i];
 	}
 
+	if (conf->vif->type == NL80211_IFTYPE_AP &&
+	    (elem->phy_cap_info[1] & IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD))
+		u8p_replace_bits(&he->he_phy_cap[1], conf->he_ldpc,
+				 IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD);
+
 	mcs_map = link_sta->he_cap.he_mcs_nss_supp;
 	switch (link_sta->bandwidth) {
 	case IEEE80211_STA_RX_BW_160:
@@ -1382,6 +1884,10 @@ mt7996_mcu_sta_vht_tlv(struct sk_buff *skb, struct ieee80211_link_sta *link_sta)
 {
 	struct sta_rec_vht *vht;
 	struct tlv *tlv;
+#ifdef CONFIG_MTK_VENDOR
+	struct mt7996_sta *msta = (struct mt7996_sta *)link_sta->sta->drv_priv;
+	struct mt7996_phy *phy = (struct mt7996_phy *)msta->vif->deflink.phy;
+#endif
 
 	/* For 6G band, this tlv is necessary to let hw work normally */
 	if (!link_sta->he_6ghz_capa.capa && !link_sta->vht_cap.vht_supported)
@@ -1393,6 +1899,9 @@ mt7996_mcu_sta_vht_tlv(struct sk_buff *skb, struct ieee80211_link_sta *link_sta)
 	vht->vht_cap = cpu_to_le32(link_sta->vht_cap.cap);
 	vht->vht_rx_mcs_map = link_sta->vht_cap.vht_mcs.rx_mcs_map;
 	vht->vht_tx_mcs_map = link_sta->vht_cap.vht_mcs.tx_mcs_map;
+#ifdef CONFIG_MTK_VENDOR
+	vht->rts_bw_sig = phy->rts_bw_sig;
+#endif
 }
 
 static void
@@ -1421,6 +1930,8 @@ mt7996_mcu_sta_amsdu_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 	switch (link_sta->agg.max_amsdu_len) {
 	case IEEE80211_MAX_MPDU_LEN_VHT_11454:
 		amsdu->max_mpdu_size =
+			(msta_link->wcid.phy_idx == MT_BAND0 && !link_sta->sta->mlo) ?
+			IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991:
 			IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454;
 		return;
 	case IEEE80211_MAX_MPDU_LEN_HT_7935:
@@ -1436,8 +1947,10 @@ mt7996_mcu_sta_amsdu_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 static void
 mt7996_mcu_sta_muru_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 			struct ieee80211_bss_conf *link_conf,
+			struct mt7996_vif_link *mconf,
 			struct ieee80211_link_sta *link_sta)
 {
+	struct mt7996_phy *phy = mconf->phy;
 	struct ieee80211_he_cap_elem *elem = &link_sta->he_cap.he_cap_elem;
 	struct sta_rec_muru *muru;
 	struct tlv *tlv;
@@ -1449,11 +1962,14 @@ mt7996_mcu_sta_muru_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 	tlv = mt76_connac_mcu_add_tlv(skb, STA_REC_MURU, sizeof(*muru));
 
 	muru = (struct sta_rec_muru *)tlv;
-	muru->cfg.mimo_dl_en = link_conf->eht_mu_beamformer ||
-			       link_conf->he_mu_beamformer ||
-			       link_conf->vht_mu_beamformer ||
-			       link_conf->vht_mu_beamformee;
-	muru->cfg.ofdma_dl_en = true;
+	muru->cfg.mimo_dl_en = (link_conf->eht_mu_beamformer ||
+				link_conf->he_mu_beamformer ||
+				link_conf->vht_mu_beamformer ||
+				link_conf->vht_mu_beamformee) &&
+			       !!(phy->muru_onoff & MUMIMO_DL);
+	muru->cfg.mimo_ul_en = !!(phy->muru_onoff & MUMIMO_UL);
+	muru->cfg.ofdma_dl_en = !!(phy->muru_onoff & OFDMA_DL);
+	muru->cfg.ofdma_ul_en = !!(phy->muru_onoff & OFDMA_UL);
 
 	if (link_sta->vht_cap.vht_supported)
 		muru->mimo_dl.vht_mu_bfee =
@@ -1791,7 +2307,6 @@ mt7996_mcu_sta_bfer_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 	bf->bf_cap = ebf ? EBF_MODE : (dev->ibf ? IBF_MODE : 0);
 	if (is_mt7992(&dev->mt76) && tx_ant == 4)
 		bf->bf_cap |= IBF_MODE;
-
 	bf->bw = link_sta->bandwidth;
 	bf->ibf_dbw = link_sta->bandwidth;
 	bf->ibf_nrow = tx_ant;
@@ -1886,14 +2401,14 @@ mt7996_mcu_sta_hdr_trans_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 	hdr_trans = (struct sta_rec_hdr_trans *)tlv;
 	hdr_trans->dis_rx_hdr_tran = true;
 
+	if (!wcid->sta)
+		return;
+
 	if (vif->type == NL80211_IFTYPE_STATION)
 		hdr_trans->to_ds = true;
 	else
 		hdr_trans->from_ds = true;
 
-	if (!wcid)
-		return;
-
 	hdr_trans->dis_rx_hdr_tran = !test_bit(MT_WCID_FLAG_HDR_TRANS, &wcid->flags);
 	if (test_bit(MT_WCID_FLAG_4ADDR, &wcid->flags)) {
 		hdr_trans->to_ds = true;
@@ -2288,7 +2803,7 @@ int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev, struct mt7996_sta *msta,
 	 * update sta_rec_he here.
 	 */
 	if (changed)
-		mt7996_mcu_sta_he_tlv(skb, link_sta, link);
+		mt7996_mcu_sta_he_tlv(skb, link_conf, link_sta, link);
 
 	/* sta_rec_ra accommodates BW, NSS and only MCS range format
 	 * i.e 0-{7,8,9} for VHT.
@@ -2310,38 +2825,41 @@ error_unlock:
 	return ret;
 }
 
+#if 0
 static int
-mt7996_mcu_add_group(struct mt7996_dev *dev, struct ieee80211_vif *vif,
-		     struct ieee80211_sta *sta)
+mt7996_mcu_sta_init_vow(struct mt7996_vif_link *mconf,
+			struct mt7996_sta_link *msta_link)
 {
-#define MT_STA_BSS_GROUP		1
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_sta_link *msta_link;
-	struct mt7996_sta *msta;
-	struct {
-		u8 __rsv1[4];
+	struct mt7996_phy *phy = mconf->phy;
+	struct mt7996_vow_sta_ctrl *vow = &msta_link->vow;
+	u8 omac_idx = mconf->mt76.omac_idx;
+	int ret;
 
-		__le16 tag;
-		__le16 len;
-		__le16 wlan_idx;
-		u8 __rsv2[2];
-		__le32 action;
-		__le32 val;
-		u8 __rsv3[8];
-	} __packed req = {
-		.tag = cpu_to_le16(UNI_VOW_DRR_CTRL),
-		.len = cpu_to_le16(sizeof(req) - 4),
-		.action = cpu_to_le32(MT_STA_BSS_GROUP),
-		.val = cpu_to_le32(mvif->deflink.mt76.idx % 16),
-	};
+	/* Assignment of STA BSS group index aligns FW.
+	 * Each band has its own BSS group bitmap space.
+	 * 0: BSS 0
+	 * 4..18: BSS 0x11..0x1f
+	 */
+	vow->bss_grp_idx = (omac_idx <= HW_BSSID_MAX)
+	                   ? omac_idx
+	                   : HW_BSSID_MAX + omac_idx - EXT_BSSID_START;
+	vow->paused = false;
+	vow->drr_quantum[IEEE80211_AC_VO] = VOW_DRR_QUANTUM_IDX0;
+	vow->drr_quantum[IEEE80211_AC_VI] = VOW_DRR_QUANTUM_IDX1;
+	vow->drr_quantum[IEEE80211_AC_BE] = VOW_DRR_QUANTUM_IDX2;
+	vow->drr_quantum[IEEE80211_AC_BK] = VOW_DRR_QUANTUM_IDX2;
+
+	ret = mt7996_mcu_set_vow_drr_ctrl(phy, mconf, msta_link, VOW_DRR_CTRL_STA_BSS_GROUP);
+	if (ret)
+		return ret;
 
-	msta = sta ? (struct mt7996_sta *)sta->drv_priv : NULL;
-	msta_link = msta ? &msta->deflink : &mvif->deflink.msta_link;
-	req.wlan_idx = cpu_to_le16(msta_link->wcid.idx);
+	ret = mt7996_mcu_set_vow_drr_ctrl(phy, mconf, msta_link, VOW_DRR_CTRL_STA_PAUSE);
+	if (ret)
+		return ret;
 
-	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(VOW), &req,
-				 sizeof(req), true);
+	return mt7996_mcu_set_vow_drr_ctrl(phy, mconf, msta_link, VOW_DRR_CTRL_STA_ALL);
 }
+#endif
 
 static void
 mt7996_mcu_sta_mld_setup_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
@@ -2370,9 +2888,9 @@ mt7996_mcu_sta_mld_setup_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 	mld_setup->setup_wcid = cpu_to_le16(msta_link->wcid.idx);
 	mld_setup->primary_id = cpu_to_le16(msta_link->wcid.idx);
 
-	if (nlinks > 1) {
-		link_id = __ffs(sta->valid_links & ~BIT(msta->deflink_id));
-		msta_link = mt76_dereference(msta->link[link_id], &dev->mt76);
+	if (msta->sec_link != msta->deflink_id) {
+		msta_link = mt76_dereference(msta->link[msta->sec_link],
+					     &dev->mt76);
 		if (!msta_link)
 			return;
 	}
@@ -2380,6 +2898,11 @@ mt7996_mcu_sta_mld_setup_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 	mld_setup->link_num = nlinks;
 
 	mld_setup_link = (struct mld_setup_link *)mld_setup->link_info;
+	mt76_dbg(&dev->mt76, MT76_DBG_STA,
+		 "%s: STA %pM pri_link=%u, pri_wcid=%u, sec_link=%u, sec_wcid=%u\n",
+		 __func__, sta->addr, msta->deflink_id,
+		 le16_to_cpu(mld_setup->primary_id),
+		 msta->sec_link, le16_to_cpu(mld_setup->seconed_id));
 	for_each_sta_active_link(vif, sta, link_sta, link_id) {
 		struct mt7996_vif_link *link;
 
@@ -2393,6 +2916,12 @@ mt7996_mcu_sta_mld_setup_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 
 		mld_setup_link->wcid = cpu_to_le16(msta_link->wcid.idx);
 		mld_setup_link->bss_idx = link->mt76.idx;
+
+		mt76_dbg(&dev->mt76, MT76_DBG_STA,
+			 "%s: link_id(%d) wcid(%d) bss_idx(%d)\n",
+			 __func__, link_id, mld_setup_link->wcid,
+			 mld_setup_link->bss_idx);
+
 		mld_setup_link++;
 	}
 }
@@ -2410,6 +2939,8 @@ mt7996_mcu_sta_eht_mld_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 
 	for (i = 0; i < ARRAY_SIZE(eht_mld->str_cap); i++)
 		eht_mld->str_cap[i] = 0x7;
+
+	eht_mld->eml_cap = cpu_to_le16(sta->eml_cap);
 }
 
 int mt7996_mcu_add_sta(struct mt7996_dev *dev,
@@ -2422,7 +2953,7 @@ int mt7996_mcu_add_sta(struct mt7996_dev *dev,
 	struct mt76_wcid *wcid = msta_link ? &msta_link->wcid : link->mt76.wcid;
 	struct ieee80211_sta *sta = link_sta ? link_sta->sta : NULL;
 	struct sk_buff *skb;
-	int ret;
+	// int ret;
 
 	skb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &link->mt76, wcid,
 					      MT7996_STA_UPDATE_MAX_SIZE);
@@ -2463,13 +2994,13 @@ int mt7996_mcu_add_sta(struct mt7996_dev *dev,
 		mt7996_mcu_sta_amsdu_tlv(dev, skb, link_conf->vif, link_sta,
 					 msta_link);
 		/* starec he */
-		mt7996_mcu_sta_he_tlv(skb, link_sta, link);
+		mt7996_mcu_sta_he_tlv(skb, link_conf, link_sta, link);
 		/* starec he 6g*/
 		mt7996_mcu_sta_he_6g_tlv(skb, link_sta);
 		/* starec eht */
 		mt7996_mcu_sta_eht_tlv(skb, link_sta);
 		/* starec muru */
-		mt7996_mcu_sta_muru_tlv(dev, skb, link_conf, link_sta);
+		mt7996_mcu_sta_muru_tlv(dev, skb, link_conf, link, link_sta);
 
 		if (sta->mlo) {
 			mt7996_mcu_sta_mld_setup_tlv(dev, skb, link_conf->vif,
@@ -2478,11 +3009,13 @@ int mt7996_mcu_add_sta(struct mt7996_dev *dev,
 		}
 	}
 
-	ret = mt7996_mcu_add_group(dev, link_conf->vif, sta);
+#if 0
+	ret = mt7996_mcu_sta_init_vow(mconf, msta_link);
 	if (ret) {
 		dev_kfree_skb(skb);
 		return ret;
 	}
+#endif
 out:
 	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
 				     MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);
@@ -2551,16 +3084,15 @@ mt7996_mcu_sta_key_tlv(struct mt76_wcid *wcid,
 	return 0;
 }
 
-int mt7996_mcu_add_key(struct mt76_dev *dev, struct ieee80211_vif *vif,
+int mt7996_mcu_add_key(struct mt76_dev *dev, struct mt7996_vif_link *mconf,
 		       struct ieee80211_key_conf *key, int mcu_cmd,
 		       struct mt76_wcid *wcid, enum set_key_cmd cmd)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
 	struct sk_buff *skb;
 	int ret;
 
-	skb = __mt76_connac_mcu_alloc_sta_req(dev, mvif, wcid,
-					      MT7996_STA_UPDATE_MAX_SIZE);
+	skb = __mt76_connac_mcu_alloc_sta_req(dev, (struct mt76_vif_link *)mconf,
+					      wcid, MT7996_STA_UPDATE_MAX_SIZE);
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
 
@@ -2659,7 +3191,6 @@ int mt7996_mcu_bcn_prot_enable(struct mt7996_dev *dev,
 	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
 				     MCU_WMWA_UNI_CMD(BSS_INFO_UPDATE), true);
 }
-
 int mt7996_mcu_add_dev_info(struct mt7996_phy *phy, struct ieee80211_vif *vif,
 			    struct ieee80211_bss_conf *link_conf,
 			    struct mt76_vif_link *mlink, bool enable)
@@ -2795,10 +3326,15 @@ mt7996_mcu_beacon_cont(struct mt7996_dev *dev,
 			      BSS_CHANGED_BEACON);
 
 	memcpy(buf + MT_TXD_SIZE, skb->data, skb->len);
+
+	if (dev->dbg.dump_txd)
+		mt7996_packet_log_to_host(dev, (__le32 *)buf, MT_TXD_SIZE, PKT_BIN_DEBUG_TXD, 0);
+	if (dev->dbg.dump_tx_pkt)
+		mt7996_packet_log_to_host(dev, skb->data, skb->len, PKT_BIN_DEBUG_TX, 0);
 }
 
 int mt7996_mcu_add_beacon(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
-			  struct ieee80211_bss_conf *link_conf)
+			  struct ieee80211_bss_conf *link_conf, int en)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt7996_vif_link *link = mt7996_vif_conf_link(dev, vif, link_conf);
@@ -2809,7 +3345,7 @@ int mt7996_mcu_add_beacon(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	struct tlv *tlv;
 	struct bss_bcn_content_tlv *bcn;
 	int len, extra_len = 0;
-	bool enabled = link_conf->enable_beacon;
+	bool enabled = en;
 
 	if (link_conf->nontransmitted)
 		return 0;
@@ -2817,9 +3353,6 @@ int mt7996_mcu_add_beacon(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	if (!mlink)
 		return -EINVAL;
 
-	if (link->phy && link->phy->mt76->offchannel)
-		enabled = false;
-
 	rskb = __mt7996_mcu_alloc_bss_req(&dev->mt76, mlink,
 					  MT7996_MAX_BSS_OFFLOAD_SIZE);
 	if (IS_ERR(rskb))
@@ -2878,7 +3411,7 @@ int mt7996_mcu_beacon_inband_discov(struct mt7996_dev *dev,
 	struct cfg80211_chan_def *chandef;
 	enum nl80211_band band;
 	struct tlv *tlv;
-	u8 *buf, interval;
+	u8 *buf, interval = 0;
 	int len;
 
 	if (!phy)
@@ -2931,7 +3464,7 @@ int mt7996_mcu_beacon_inband_discov(struct mt7996_dev *dev,
 	discov->tx_type = !!(changed & BSS_CHANGED_FILS_DISCOVERY);
 	discov->tx_interval = interval;
 	discov->prob_rsp_len = cpu_to_le16(MT_TXD_SIZE + skb->len);
-	discov->enable = true;
+	discov->enable = !!(interval);
 	discov->wcid = cpu_to_le16(MT7996_WTBL_RESERVED);
 
 	buf = (u8 *)tlv + sizeof(*discov);
@@ -3009,6 +3542,8 @@ static int mt7996_load_patch(struct mt7996_dev *dev)
 
 	dev_info(dev->mt76.dev, "HW/SW Version: 0x%x, Build Time: %.16s\n",
 		 be32_to_cpu(hdr->hw_sw_ver), hdr->build_date);
+	strscpy(dev->patch_build_date, hdr->build_date,
+		sizeof(hdr->build_date));
 
 	for (i = 0; i < be32_to_cpu(hdr->desc.n_region); i++) {
 		struct mt7996_patch_sec *sec;
@@ -3135,6 +3670,9 @@ static int __mt7996_load_ram(struct mt7996_dev *dev, const char *fw_type,
 	}
 
 	hdr = (const void *)(fw->data + fw->size - sizeof(*hdr));
+	strscpy(dev->ram_build_date[ram_type],
+		hdr->build_date,
+		sizeof(hdr->build_date));
 	dev_info(dev->mt76.dev, "%s Firmware Version: %.10s, Build Time: %.15s\n",
 		 fw_type, hdr->fw_ver, hdr->build_date);
 
@@ -3158,8 +3696,12 @@ static int mt7996_load_ram(struct mt7996_dev *dev)
 {
 	int ret;
 
-	ret = __mt7996_load_ram(dev, "WM", fw_name(dev, FIRMWARE_WM),
-				MT7996_RAM_TYPE_WM);
+	if (dev->testmode_enable)
+		ret = __mt7996_load_ram(dev, "WM_TM", fw_name(dev, FIRMWARE_WM_TM),
+					MT7996_RAM_TYPE_WM_TM);
+	else
+		ret = __mt7996_load_ram(dev, "WM", fw_name(dev, FIRMWARE_WM),
+					MT7996_RAM_TYPE_WM);
 	if (ret)
 		return ret;
 
@@ -3290,6 +3832,36 @@ int mt7996_mcu_fw_dbg_ctrl(struct mt7996_dev *dev, u32 module, u8 level)
 				 sizeof(data), false);
 }
 
+int mt7996_mcu_fw_time_sync(struct mt76_dev *dev)
+{
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+		__le32 sec;
+		__le32 usec;
+	} data = {
+		.tag = cpu_to_le16(UNI_WSYS_CONFIG_FW_TIME_SYNC),
+		.len = cpu_to_le16(sizeof(data) - 4),
+	};
+	struct timespec64 ts;
+	struct tm tm;
+
+	ktime_get_real_ts64(&ts);
+	data.sec = cpu_to_le32((u32)ts.tv_sec);
+	data.usec = cpu_to_le32((u32)(ts.tv_nsec / 1000));
+
+	/* Dump synchronized time for ConsysPlanet to parse. */
+	time64_to_tm(ts.tv_sec, 0, &tm);
+	dev_info(dev->dev, "%ld-%02d-%02d %02d:%02d:%02d.%ld UTC\n",
+	        tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+	        tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec / 1000);
+
+	return mt76_mcu_send_msg(dev, MCU_WM_UNI_CMD(WSYS_CONFIG), &data,
+	                         sizeof(data), true);
+}
+
 static int mt7996_mcu_set_mwds(struct mt7996_dev *dev, bool enabled)
 {
 	struct {
@@ -3368,12 +3940,12 @@ int mt7996_mcu_init_firmware(struct mt7996_dev *dev)
 		return ret;
 
 	set_bit(MT76_STATE_MCU_RUNNING, &dev->mphy.state);
-	ret = mt7996_mcu_fw_log_2_host(dev, MCU_FW_LOG_WM, 0);
+	ret = mt7996_mcu_fw_log_2_host(dev, MCU_FW_LOG_WM, 1);
 	if (ret)
 		return ret;
 
 	if (mt7996_has_wa(dev)) {
-		ret = mt7996_mcu_fw_log_2_host(dev, MCU_FW_LOG_WA, 0);
+		ret = mt7996_mcu_fw_log_2_host(dev, MCU_FW_LOG_WA, 1);
 		if (ret)
 			return ret;
 
@@ -3386,13 +3958,14 @@ int mt7996_mcu_init_firmware(struct mt7996_dev *dev)
 	if (ret)
 		return ret;
 
-	return mt7996_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(SET),
-				 MCU_WA_PARAM_RED, 0, 0);
+	return mt7996_mcu_red_config(dev,
+			mtk_wed_device_active(&dev->mt76.mmio.wed));
 }
 
 int mt7996_mcu_init(struct mt7996_dev *dev)
 {
 	static const struct mt76_mcu_ops mt7996_mcu_ops = {
+		.max_retry = 3,
 		.headroom = sizeof(struct mt76_connac2_mcu_txd), /* reuse */
 		.mcu_skb_send_msg = mt7996_mcu_send_message,
 		.mcu_parse_response = mt7996_mcu_parse_response,
@@ -3419,40 +3992,121 @@ out:
 	skb_queue_purge(&dev->mt76.mcu.res_q);
 }
 
-int mt7996_mcu_set_hdr_trans(struct mt7996_dev *dev, bool hdr_trans)
+static int mt7996_mcu_wa_red_config(struct mt7996_dev *dev)
 {
+#define RED_TOKEN_SRC_CNT	4
+#define RED_TOKEN_CONFIG	2
 	struct {
-		u8 __rsv[4];
-	} __packed hdr = {};
-	struct hdr_trans_blacklist *req_blacklist;
-	struct hdr_trans_en *req_en;
-	struct sk_buff *skb;
-	struct tlv *tlv;
-	int len = MT7996_HDR_TRANS_MAX_SIZE + sizeof(hdr);
+		__le32 arg0;
+		__le32 arg1;
+		__le32 arg2;
 
-	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL, len);
-	if (!skb)
-		return -ENOMEM;
+		u8 mode;
+		u8 version;
+		u8 _rsv[4];
+		__le16 len;
 
-	skb_put_data(skb, &hdr, sizeof(hdr));
+		__le16 tcp_offset;
+		__le16 priority_offset;
+		__le16 token_per_src[RED_TOKEN_SRC_CNT];
+		__le16 token_thr_per_src[RED_TOKEN_SRC_CNT];
 
-	tlv = mt7996_mcu_add_uni_tlv(skb, UNI_HDR_TRANS_EN, sizeof(*req_en));
-	req_en = (struct hdr_trans_en *)tlv;
-	req_en->enable = hdr_trans;
+		u8 _rsv2[604];
+	} __packed req = {
+		.arg0 = cpu_to_le32(MCU_WA_PARAM_RED_CONFIG),
 
-	tlv = mt7996_mcu_add_uni_tlv(skb, UNI_HDR_TRANS_VLAN,
-				     sizeof(struct hdr_trans_vlan));
+		.mode = RED_TOKEN_CONFIG,
+		.len = cpu_to_le16(sizeof(req) - sizeof(__le32) * 3),
 
-	if (hdr_trans) {
-		tlv = mt7996_mcu_add_uni_tlv(skb, UNI_HDR_TRANS_BLACKLIST,
-					     sizeof(*req_blacklist));
-		req_blacklist = (struct hdr_trans_blacklist *)tlv;
-		req_blacklist->enable = 1;
-		req_blacklist->type = cpu_to_le16(ETH_P_PAE);
+		.tcp_offset = cpu_to_le16(200),
+		.priority_offset = cpu_to_le16(255),
+	};
+	u8 i;
+
+	for (i = 0; i < RED_TOKEN_SRC_CNT; i++) {
+		req.token_per_src[i] = cpu_to_le16(MT7996_TOKEN_SIZE);
+		req.token_thr_per_src[i] = cpu_to_le16(MT7996_TOKEN_SIZE);
 	}
 
-	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
-				     MCU_WM_UNI_CMD(RX_HDR_TRANS), true);
+	if (!mtk_wed_device_active(&dev->mt76.mmio.wed))
+		req.token_per_src[RED_TOKEN_SRC_CNT - 1] =
+			cpu_to_le16(MT7996_SW_TOKEN_SIZE);
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WA_PARAM_CMD(SET),
+				 &req, sizeof(req), false);
+}
+
+int mt7996_mcu_red_config(struct mt7996_dev *dev, bool enable)
+{
+#define RED_DISABLE		0
+#define RED_BY_WA_ENABLE	2
+	struct {
+		u8 __rsv1[4];
+
+		__le16 tag;
+		__le16 len;
+		u8 enable;
+		u8 __rsv2[3];
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_VOW_RED_ENABLE),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.enable = enable ? RED_BY_WA_ENABLE : RED_DISABLE,
+	};
+	int ret;
+
+	ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(VOW), &req,
+				 sizeof(req), true);
+
+	if (ret)
+		return ret;
+
+#ifdef CONFIG_MTK_DEBUG
+	dev->red_enable = enable;
+#endif
+
+	ret = mt7996_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(SET),
+				MCU_WA_PARAM_RED_EN, enable, 0);
+
+	if (ret || !enable)
+		return ret;
+
+	return mt7996_mcu_wa_red_config(dev);
+}
+
+int mt7996_mcu_set_hdr_trans(struct mt7996_dev *dev, bool hdr_trans)
+{
+	struct {
+		u8 __rsv[4];
+	} __packed hdr = {};
+	struct hdr_trans_blacklist *req_blacklist;
+	struct hdr_trans_en *req_en;
+	struct sk_buff *skb;
+	struct tlv *tlv;
+	int len = MT7996_HDR_TRANS_MAX_SIZE + sizeof(hdr);
+
+	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL, len);
+	if (!skb)
+		return -ENOMEM;
+
+	skb_put_data(skb, &hdr, sizeof(hdr));
+
+	tlv = mt7996_mcu_add_uni_tlv(skb, UNI_HDR_TRANS_EN, sizeof(*req_en));
+	req_en = (struct hdr_trans_en *)tlv;
+	req_en->enable = hdr_trans;
+
+	tlv = mt7996_mcu_add_uni_tlv(skb, UNI_HDR_TRANS_VLAN,
+				     sizeof(struct hdr_trans_vlan));
+
+	if (hdr_trans) {
+		tlv = mt7996_mcu_add_uni_tlv(skb, UNI_HDR_TRANS_BLACKLIST,
+					     sizeof(*req_blacklist));
+		req_blacklist = (struct hdr_trans_blacklist *)tlv;
+		req_blacklist->enable = 1;
+		req_blacklist->type = cpu_to_le16(ETH_P_PAE);
+	}
+
+	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
+				     MCU_WM_UNI_CMD(RX_HDR_TRANS), true);
 }
 
 int mt7996_mcu_set_tx(struct mt7996_dev *dev, struct ieee80211_vif *vif,
@@ -3773,7 +4427,8 @@ int mt7996_mcu_set_chan_info(struct mt7996_phy *phy, u16 tag)
 	if (phy->mt76->hw->conf.flags & IEEE80211_CONF_MONITOR)
 		req.switch_reason = CH_SWITCH_NORMAL;
 	else if (phy->mt76->offchannel ||
-		 phy->mt76->hw->conf.flags & IEEE80211_CONF_IDLE)
+		 phy->mt76->hw->conf.flags & IEEE80211_CONF_IDLE ||
+		 phy->scan_chan)
 		req.switch_reason = CH_SWITCH_SCAN_BYPASS_DPD;
 	else if (!cfg80211_reg_can_beacon(phy->mt76->hw->wiphy, chandef,
 					  NL80211_IFTYPE_AP))
@@ -3794,7 +4449,151 @@ int mt7996_mcu_set_chan_info(struct mt7996_phy *phy, u16 tag)
 				 &req, sizeof(req), true);
 }
 
-static int mt7996_mcu_set_eeprom_flash(struct mt7996_dev *dev)
+static int mt7996_mcu_set_cal_free_data(struct mt7996_dev *dev)
+{
+#define MT_EE_CAL_FREE_MAX_SIZE		30
+#define MT_EE_7977BN_OFFSET		(0x1200 - 0x500)
+#define MT_EE_END_OFFSET		0xffff
+	enum adie_type {
+		ADIE_7975,
+		ADIE_7976,
+		ADIE_7977,
+		ADIE_7978,
+		ADIE_7979,
+	};
+	static const u16 adie_offs_list[][MT_EE_CAL_FREE_MAX_SIZE] = {
+		[ADIE_7975] = {0x5cd, 0x5cf, 0x5d1, 0x5d3, 0x6c0, 0x6c1, 0x6c2, 0x6c3,
+			       0x7a1, 0x7a6, 0x7a8, 0x7aa, -1},
+		[ADIE_7976] = {0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x53, 0x55, 0x57, 0x59,
+			       0x70, 0x71, 0x790, 0x791, 0x794, 0x795, 0x7a6, 0x7a8, 0x7aa, -1},
+		[ADIE_7977] = {0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x53, 0x55, 0x57, 0x59,
+			       0x69, 0x6a, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, -1},
+		[ADIE_7978] = {0x91, 0x95, 0x100, 0x102, 0x104, 0x106, 0x107,
+			       0x108, 0x109, 0x10a, 0x10b, 0x10c, 0x10e, 0x110, -1},
+		[ADIE_7979] = {0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x53, 0x55, 0x57, 0x59,
+			       0x69, 0x6a, 0x7a, 0x7b, 0x7c, 0x7e, 0x80, -1},
+	};
+	static const u16 eep_offs_list[][MT_EE_CAL_FREE_MAX_SIZE] = {
+		[ADIE_7975] = {0x451, 0x453, 0x455, 0x457, 0x44c, 0x44d, 0x44e, 0x44f,
+			       0xba1, 0xba6, 0xba8, 0xbaa, -1},
+		[ADIE_7976] = {0x44c, 0x44d, 0x44e, 0x44f, 0x450,
+			       0x451, 0x453, 0x455, 0x457, 0x459,
+			       0x470, 0x471, 0xb90, 0xb91, 0xb94, 0xb95,
+			       0xba6, 0xba8, 0xbaa, -1},
+		[ADIE_7977] = {0x124c, 0x124d, 0x124e, 0x124f, 0x1250,
+			       0x1251, 0x1253, 0x1255, 0x1257, 0x1259,
+			       0x1269, 0x126a, 0x127a, 0x127b, 0x127c, 0x127d, 0x127e, -1},
+		[ADIE_7978] = {0xb91, 0xb95, 0x480, 0x482, 0x484, 0x486, 0x487, 0x488, 0x489,
+			       0x48a, 0x48b, 0x48c, 0x48e, 0x490, -1},
+		[ADIE_7979] = {0x124c, 0x124d, 0x124e, 0x124f, 0x1250, 0x1251,
+			       0x1253, 0x1255, 0x1257, 0x1259, 0x1269, 0x126a,
+			       0x127a, 0x127b, 0x127c, 0x127e, 0x1280, -1},
+	};
+	static const u16 adie_base_7996[] = {
+		0x400, 0x1e00, 0x1200
+	};
+	static const u16 adie_base_7992[] = {
+		0x400, 0x1200, 0x0
+	};
+	static const u16 *adie_offs[__MT_MAX_BAND];
+	static const u16 *eep_offs[__MT_MAX_BAND];
+	static const u16 *adie_base;
+	int adie_id, band, i, ret;
+
+	switch (mt76_chip(&dev->mt76)) {
+	case MT7996_DEVICE_ID:
+		adie_base = adie_base_7996;
+		/* adie 0 */
+		if (dev->var.fem == MT7996_FEM_INT && dev->var.type != MT7996_VAR_TYPE_233)
+			adie_id = ADIE_7975;
+		else
+			adie_id = ADIE_7976;
+		adie_offs[0] = adie_offs_list[adie_id];
+		eep_offs[0] = eep_offs_list[adie_id];
+
+		/* adie 1 */
+		if (dev->var.type == MT7996_VAR_TYPE_444) {
+			adie_offs[1] = adie_offs_list[ADIE_7977];
+			eep_offs[1] = eep_offs_list[ADIE_7977];
+		}
+
+		/* adie 2 */
+		adie_offs[2] = adie_offs_list[ADIE_7977];
+		eep_offs[2] = eep_offs_list[ADIE_7977];
+		break;
+	case MT7992_DEVICE_ID:
+		adie_base = adie_base_7992;
+		/* adie 0 */
+		if (dev->var.type == MT7992_VAR_TYPE_44 &&
+		    dev->var.fem != MT7996_FEM_EXT)
+			adie_id = ADIE_7975;
+		else if (dev->var.type == MT7992_VAR_TYPE_24)
+			adie_id = ADIE_7978;
+		else
+			adie_id = ADIE_7976;
+		adie_offs[0] = adie_offs_list[adie_id];
+		eep_offs[0] = eep_offs_list[adie_id];
+
+		/* adie 1 */
+		if (dev->var.type == MT7992_VAR_TYPE_44 &&
+		    dev->var.fem != MT7996_FEM_INT)
+			adie_id = ADIE_7977;
+		else if (dev->var.type != MT7992_VAR_TYPE_23)
+			adie_id = ADIE_7979;
+		else
+			break;
+		adie_offs[1] = adie_offs_list[adie_id];
+		eep_offs[1] = eep_offs_list[adie_id];
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	for (band = 0; band < __MT_MAX_BAND; band++) {
+		struct {
+			/* fixed field */
+			u8 __rsv[4];
+
+			__le16 tag;
+			__le16 len;
+			__le16 adie_offset;
+			__le16 eep_offset;
+			__le16 count;
+			u8 rsv[2];
+		} __packed req = {
+			.tag = cpu_to_le16(UNI_EFUSE_PATCH),
+			.len = cpu_to_le16(sizeof(req) - 4),
+			.count = cpu_to_le16(1),
+		};
+		u16 adie_offset, eep_offset;
+
+		if (!adie_offs[band])
+			continue;
+
+		for (i = 0; i < MT_EE_CAL_FREE_MAX_SIZE; i++) {
+			adie_offset = adie_offs[band][i] + adie_base[band];
+			eep_offset = eep_offs[band][i];
+
+			if (adie_offs[band][i] == MT_EE_END_OFFSET)
+				break;
+
+			if (is_mt7996(&dev->mt76) && dev->var.type == MT7996_VAR_TYPE_444 &&
+			    band == MT_BAND1)
+				eep_offset -= MT_EE_7977BN_OFFSET;
+
+			req.eep_offset = cpu_to_le16(eep_offset);
+			req.adie_offset = cpu_to_le16(adie_offset);
+			ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(EFUSE_CTRL),
+						&req, sizeof(req), true);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
+int mt7996_mcu_set_eeprom_flash(struct mt7996_dev *dev)
 {
 #define MAX_PAGE_IDX_MASK	GENMASK(7, 5)
 #define PAGE_IDX_MASK		GENMASK(4, 2)
@@ -3847,25 +4646,22 @@ int mt7996_mcu_set_eeprom(struct mt7996_dev *dev)
 		.buffer_mode = EE_MODE_EFUSE,
 		.format = EE_FORMAT_WHOLE
 	};
+	int ret;
 
 	if (dev->flash_mode)
-		return mt7996_mcu_set_eeprom_flash(dev);
+		ret = mt7996_mcu_set_eeprom_flash(dev);
+	else
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(EFUSE_CTRL),
+					&req, sizeof(req), true);
+	if (ret)
+		return ret;
 
-	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(EFUSE_CTRL),
-				 &req, sizeof(req), true);
+	return mt7996_mcu_set_cal_free_data(dev);
 }
 
 int mt7996_mcu_get_eeprom(struct mt7996_dev *dev, u32 offset, u8 *buf, u32 buf_len)
 {
-	struct {
-		u8 _rsv[4];
-
-		__le16 tag;
-		__le16 len;
-		__le32 addr;
-		__le32 valid;
-		u8 data[16];
-	} __packed req = {
+	struct mt7996_mcu_eeprom_info req = {
 		.tag = cpu_to_le16(UNI_EFUSE_ACCESS),
 		.len = cpu_to_le16(sizeof(req) - 4),
 		.addr = cpu_to_le32(round_down(offset,
@@ -3887,6 +4683,7 @@ int mt7996_mcu_get_eeprom(struct mt7996_dev *dev, u32 offset, u8 *buf, u32 buf_l
 
 		if (!buf)
 			buf = (u8 *)dev->mt76.eeprom.data + addr;
+
 		if (!buf_len || buf_len > MT7996_EEPROM_BLOCK_SIZE)
 			buf_len = MT7996_EEPROM_BLOCK_SIZE;
 
@@ -3931,6 +4728,192 @@ int mt7996_mcu_get_eeprom_free_block(struct mt7996_dev *dev, u8 *block_num)
 	return 0;
 }
 
+static int mt7996_mcu_set_pre_cal(struct mt7996_dev *dev, u32 idx,
+				  u8 *cal, u32 len, u32 cal_id)
+{
+#define PRECAL_CMD_PRE_CAL_RESULT	0x0
+	struct {
+		/* fixed field */
+		u8 action;
+		u8 dest;
+		u8 attribute;
+		u8 tag_num;
+
+		__le16 tag;
+		__le16 len;
+
+		__le32 cal_id;
+		s8 precal;
+		u8 band;
+		u8 rsv[2];
+		__le32 idx;
+		__le32 cal_len;
+	} req = {
+		.tag = cpu_to_le16(PRECAL_CMD_PRE_CAL_RESULT),
+		.len = cpu_to_le16(sizeof(req) - 4 + len),
+		.cal_id = cpu_to_le32(cal_id),
+		.idx = cpu_to_le32(idx),
+		.cal_len = cpu_to_le32(len),
+	};
+	struct sk_buff *skb;
+
+	if (!len)
+		return 0;
+
+	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL, sizeof(req) + len);
+	if (!skb)
+		return -ENOMEM;
+
+	skb_put_data(skb, &req, sizeof(req));
+	skb_put_data(skb, cal, len);
+
+	return mt76_mcu_skb_send_msg(&dev->mt76, skb, MCU_WM_UNI_CMD(PRECAL_RESULT), false);
+}
+
+int mt7996_mcu_apply_group_cal(struct mt7996_dev *dev)
+{
+	u8 *cal = dev->cal, *eeprom = dev->mt76.eeprom.data;
+	u32 idx = 0, total_idx = MT_EE_CAL_GROUP_SIZE / MT_EE_CAL_UNIT;
+	u32 offs = MT_EE_DO_PRE_CAL;
+	int ret = 0;
+
+	if (!(eeprom[offs] & MT_EE_WIFI_CAL_GROUP))
+		return 0;
+
+	for (idx = 0; idx < total_idx; idx++, cal += MT_EE_CAL_UNIT) {
+		ret = mt7996_mcu_set_pre_cal(dev, idx, cal, MT_EE_CAL_UNIT, RF_PRE_CAL);
+		if (ret)
+			goto out;
+	}
+
+	ret = mt7996_mcu_set_pre_cal(dev, total_idx, cal,
+				     MT_EE_CAL_GROUP_SIZE % MT_EE_CAL_UNIT, RF_PRE_CAL);
+
+out:
+	return ret;
+}
+
+int mt7996_mcu_apply_tx_dpd(struct mt7996_phy *phy)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_phy *mphy = phy->mt76;
+	struct cfg80211_chan_def *chandef = &phy->mt76->chandef;
+	enum nl80211_band band = chandef->chan->band;
+	enum nl80211_chan_width bw = chandef->width;
+	const struct ieee80211_channel *chan_list;
+	u32 cal_id, chan_list_size, base_offset = 0, offs = MT_EE_DO_PRE_CAL;
+	u32 per_chan_size = DPD_PER_CH_BW20_SIZE;
+	u16 channel = ieee80211_frequency_to_channel(chandef->center_freq1);
+	u8 dpd_mask, *cal = dev->cal, *eeprom = dev->mt76.eeprom.data;
+	int idx, i, ret;
+	bool has_skip_ch = (band == NL80211_BAND_5GHZ);
+
+	switch (band) {
+	case NL80211_BAND_2GHZ:
+		dpd_mask = MT_EE_WIFI_CAL_DPD_2G;
+		/* channel 14 don't need DPD cal */
+		if (channel >= 1 && channel <= 4)
+			channel = 3;
+		else if (channel >= 5 && channel <= 9)
+			channel = 7;
+		else if (channel >= 10 && channel <= 13)
+			channel = 11;
+		else
+			return 0;
+		cal_id = RF_DPD_FLAT_CAL;
+		chan_list = dpd_2g_ch_list_bw20;
+		chan_list_size = DPD_CH_NUM(BW20_2G);
+		break;
+	case NL80211_BAND_5GHZ:
+		dpd_mask = MT_EE_WIFI_CAL_DPD_5G;
+		cal_id = RF_DPD_FLAT_5G_CAL;
+		chan_list = mphy->sband_5g.sband.channels;
+		chan_list_size = mphy->sband_5g.sband.n_channels;
+		base_offset += MT_EE_CAL_DPD_SIZE_2G;
+		if (bw == NL80211_CHAN_WIDTH_160) {
+			base_offset += DPD_CH_NUM(BW20_5G) * DPD_PER_CH_BW20_SIZE +
+				       DPD_CH_NUM(BW80_5G) * DPD_PER_CH_GT_BW20_SIZE;
+			per_chan_size = DPD_PER_CH_GT_BW20_SIZE;
+			cal_id = RF_DPD_FLAT_5G_MEM_CAL;
+			chan_list = dpd_5g_ch_list_bw160;
+			chan_list_size = DPD_CH_NUM(BW160_5G);
+			has_skip_ch = false;
+		} else if (is_mt7992(&dev->mt76) && bw == NL80211_CHAN_WIDTH_80) {
+			base_offset += DPD_CH_NUM(BW20_5G) * DPD_PER_CH_BW20_SIZE;
+			per_chan_size = DPD_PER_CH_GT_BW20_SIZE;
+			cal_id = RF_DPD_FLAT_5G_MEM_CAL;
+			chan_list = dpd_5g_ch_list_bw80;
+			chan_list_size = DPD_CH_NUM(BW80_5G);
+			has_skip_ch = false;
+		} else if (bw > NL80211_CHAN_WIDTH_20) {
+			/* apply (center channel - 2)'s dpd cal data for bw 40/80 channels */
+			channel -= 2;
+		}
+		if (channel >= dpd_5g_skip_ch_list[0].hw_value &&
+		    channel <= dpd_5g_skip_ch_list[DPD_CH_NUM(BW20_5G_SKIP) - 1].hw_value)
+			return 0;
+		break;
+	case NL80211_BAND_6GHZ:
+		dpd_mask = MT_EE_WIFI_CAL_DPD_6G;
+		cal_id = RF_DPD_FLAT_6G_CAL;
+		chan_list = mphy->sband_6g.sband.channels;
+		chan_list_size = mphy->sband_6g.sband.n_channels;
+		base_offset += MT_EE_CAL_DPD_SIZE_2G + MT_EE_CAL_DPD_SIZE_5G;
+		if (bw == NL80211_CHAN_WIDTH_160) {
+			base_offset += mphy->sband_6g.sband.n_channels * DPD_PER_CH_BW20_SIZE;
+			per_chan_size = DPD_PER_CH_GT_BW20_SIZE;
+			cal_id = RF_DPD_FLAT_6G_MEM_CAL;
+			chan_list = dpd_6g_ch_list_bw160;
+			chan_list_size = DPD_CH_NUM(BW160_6G);
+		} else if (is_mt7996(&dev->mt76) && bw == NL80211_CHAN_WIDTH_320) {
+			base_offset += mphy->sband_6g.sband.n_channels * DPD_PER_CH_BW20_SIZE +
+				       DPD_CH_NUM(BW80_6G) * DPD_PER_CH_GT_BW20_SIZE +
+				       DPD_CH_NUM(BW160_6G) * DPD_PER_CH_GT_BW20_SIZE;
+			per_chan_size = DPD_PER_CH_GT_BW20_SIZE;
+			cal_id = RF_DPD_FLAT_6G_MEM_CAL;
+			chan_list = dpd_6g_ch_list_bw320;
+			chan_list_size = DPD_CH_NUM(BW320_6G);
+		} else if (is_mt7992(&dev->mt76) && bw == NL80211_CHAN_WIDTH_80) {
+			base_offset += mphy->sband_6g.sband.n_channels * DPD_PER_CH_BW20_SIZE;
+			per_chan_size = DPD_PER_CH_GT_BW20_SIZE;
+			cal_id = RF_DPD_FLAT_6G_MEM_CAL;
+			chan_list = dpd_6g_ch_list_bw80;
+			chan_list_size = DPD_CH_NUM(BW80_6G);
+		} else if (bw > NL80211_CHAN_WIDTH_20) {
+			/* apply (center channel - 2)'s dpd cal data for bw 40/80 channels */
+			channel -= 2;
+		}
+		break;
+	default:
+		dpd_mask = 0;
+		break;
+	}
+
+	if (!(eeprom[offs] & dpd_mask))
+		return 0;
+
+	for (idx = 0; idx < chan_list_size; idx++)
+		if (channel == chan_list[idx].hw_value)
+			break;
+	if (idx == chan_list_size)
+		return -EINVAL;
+
+	if (has_skip_ch && channel > dpd_5g_skip_ch_list[DPD_CH_NUM(BW20_5G_SKIP) - 1].hw_value)
+		idx -= DPD_CH_NUM(BW20_5G_SKIP);
+
+	cal += MT_EE_CAL_GROUP_SIZE + base_offset + idx * per_chan_size;
+
+	for (i = 0; i < per_chan_size / MT_EE_CAL_UNIT; i++) {
+		ret = mt7996_mcu_set_pre_cal(dev, i, cal, MT_EE_CAL_UNIT, cal_id);
+		if (ret)
+			return ret;
+
+		cal += MT_EE_CAL_UNIT;
+	}
+
+	return ret;
+}
+
 int mt7996_mcu_get_chip_config(struct mt7996_dev *dev, u32 *cap)
 {
 #define NIC_CAP	3
@@ -4199,6 +5182,8 @@ int mt7996_mcu_set_ser(struct mt7996_dev *dev, u8 action, u8 val, u8 band)
 	};
 
 	switch (action) {
+	case UNI_CMD_SER_QUERY:
+		break;
 	case UNI_CMD_SER_SET:
 		req.set.mask = cpu_to_le32(val);
 		break;
@@ -4217,7 +5202,6 @@ int mt7996_mcu_set_ser(struct mt7996_dev *dev, u8 action, u8 val, u8 band)
 int mt7996_mcu_set_txbf(struct mt7996_dev *dev, u8 action)
 {
 #define MT7996_BF_MAX_SIZE	sizeof(union bf_tag_tlv)
-#define BF_PROCESSING	4
 	struct uni_header hdr;
 	struct sk_buff *skb;
 	struct tlv *tlv;
@@ -4568,7 +5552,7 @@ int mt7996_mcu_set_rts_thresh(struct mt7996_phy *phy, u32 val)
 				 &req, sizeof(req), true);
 }
 
-int mt7996_mcu_set_radio_en(struct mt7996_phy *phy, bool enable)
+int mt7996_mcu_set_band_confg(struct mt7996_phy *phy, u16 option, bool enable)
 {
 	struct {
 		u8 band_idx;
@@ -4576,11 +5560,11 @@ int mt7996_mcu_set_radio_en(struct mt7996_phy *phy, bool enable)
 
 		__le16 tag;
 		__le16 len;
-		u8 enable;
+		bool enable;
 		u8 _rsv2[3];
 	} __packed req = {
 		.band_idx = phy->mt76->band_idx,
-		.tag = cpu_to_le16(UNI_BAND_CONFIG_RADIO_ENABLE),
+		.tag = cpu_to_le16(option),
 		.len = cpu_to_le16(sizeof(req) - 4),
 		.enable = enable,
 	};
@@ -4589,20 +5573,30 @@ int mt7996_mcu_set_radio_en(struct mt7996_phy *phy, bool enable)
 				 &req, sizeof(req), true);
 }
 
-int mt7996_mcu_rdd_cmd(struct mt7996_dev *dev, int cmd, u8 rdd_idx, u8 val)
+int mt7996_mcu_set_radio_en(struct mt7996_phy *phy, bool enable)
 {
 	struct {
-		u8 _rsv[4];
+		u8 band_idx;
+		u8 _rsv[3];
 
 		__le16 tag;
 		__le16 len;
-
-		u8 ctrl;
-		u8 rdd_idx;
-		u8 rdd_rx_sel;
-		u8 val;
-		u8 rsv[4];
+		u8 enable;
+		u8 _rsv2[3];
 	} __packed req = {
+		.band_idx = phy->mt76->band_idx,
+		.tag = cpu_to_le16(UNI_BAND_CONFIG_RADIO_ENABLE),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.enable = enable,
+	};
+
+	return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(BAND_CONFIG),
+				 &req, sizeof(req), true);
+}
+
+int mt7996_mcu_rdd_cmd(struct mt7996_dev *dev, int cmd, u8 rdd_idx, u8 val)
+{
+	struct mt7996_rdd_ctrl req = {
 		.tag = cpu_to_le16(UNI_RDD_CTRL_PARM),
 		.len = cpu_to_le16(sizeof(req) - 4),
 		.ctrl = cmd,
@@ -4614,6 +5608,37 @@ int mt7996_mcu_rdd_cmd(struct mt7996_dev *dev, int cmd, u8 rdd_idx, u8 val)
 				 &req, sizeof(req), true);
 }
 
+int mt7996_mcu_rdd_background_disable_timer(struct mt7996_dev *dev, bool disable_timer)
+{
+	struct mt7996_rdd_ctrl req = {
+		.tag = cpu_to_le16(UNI_RDD_CTRL_PARM),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.ctrl = RDD_DISABLE_ZW_TIMER,
+		.rdd_idx = MT_RX_SEL2,
+		.disable_timer = disable_timer,
+	};
+
+	if (!is_mt7996(&dev->mt76) ||
+	    (mt76_get_field(dev, MT_PAD_GPIO, MT_PAD_GPIO_ADIE_COMB) % 2))
+		return 0;
+
+	switch (dev->mt76.region) {
+	case NL80211_DFS_ETSI:
+		req.val = 0;
+		break;
+	case NL80211_DFS_JP:
+		req.val = 2;
+		break;
+	case NL80211_DFS_FCC:
+	default:
+		req.val = 1;
+		break;
+	}
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(RDD_CTRL),
+				 &req, sizeof(req), true);
+}
+
 int mt7996_mcu_wtbl_update_hdr_trans(struct mt7996_dev *dev,
 				     struct ieee80211_vif *vif,
 				     struct mt7996_vif_link *link,
@@ -4770,41 +5795,167 @@ int mt7996_mcu_set_rro(struct mt7996_dev *dev, u16 tag, u16 val)
 				 sizeof(req), true);
 }
 
-int mt7996_mcu_get_all_sta_info(struct mt7996_phy *phy, u16 tag)
+int mt7996_mcu_get_per_sta_info(struct mt76_dev *dev, u16 tag,
+	                        u16 sta_num, u16 *sta_list)
 {
-	struct mt7996_dev *dev = phy->dev;
+#define PER_STA_INFO_MAX_NUM	90
+	struct mt7996_mcu_per_sta_info_event *res;
+	struct mt76_wcid *wcid;
+	struct sk_buff *skb;
+	u16 wlan_idx;
+	int i, ret;
 	struct {
-		u8 _rsv[4];
+		u8 __rsv1;
+		u8 unsolicit;
+		u8 __rsv2[2];
 
 		__le16 tag;
 		__le16 len;
+		__le16 sta_num;
+		u8 __rsv3[2];
+		__le16 sta_list[PER_STA_INFO_MAX_NUM];
 	} __packed req = {
+		.unsolicit = 0,
 		.tag = cpu_to_le16(tag),
 		.len = cpu_to_le16(sizeof(req) - 4),
+		.sta_num = cpu_to_le16(sta_num)
 	};
 
-	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(ALL_STA_INFO),
-				 &req, sizeof(req), false);
-}
+	if (sta_num > PER_STA_INFO_MAX_NUM)
+		return -EINVAL;
 
-int mt7996_mcu_wed_rro_reset_sessions(struct mt7996_dev *dev, u16 id)
-{
-	struct {
-		u8 __rsv[4];
+	for (i = 0; i < sta_num; ++i)
+		req.sta_list[i] = cpu_to_le16(sta_list[i]);
 
-		__le16 tag;
-		__le16 len;
-		__le16 session_id;
-		u8 pad[4];
-	} __packed req = {
-		.tag = cpu_to_le16(UNI_RRO_DEL_BA_SESSION),
-		.len = cpu_to_le16(sizeof(req) - 4),
-		.session_id = cpu_to_le16(id),
-	};
+	ret = mt76_mcu_send_and_get_msg(dev, MCU_WM_UNI_CMD(PER_STA_INFO),
+	                                &req, sizeof(req), true, &skb);
+	if (ret)
+		return ret;
 
-	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(RRO), &req,
-				 sizeof(req), true);
-}
+	res = (struct mt7996_mcu_per_sta_info_event *)skb->data;
+	if (le16_to_cpu(res->tag) != tag) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	rcu_read_lock();
+	switch (tag) {
+	case UNI_PER_STA_RSSI:
+		for (i = 0; i < sta_num; ++i) {
+			struct mt7996_sta_link *msta_link;
+			struct mt76_phy *phy;
+			s8 rssi[4];
+			u8 *rcpi;
+
+			wlan_idx = le16_to_cpu(res->rssi[i].wlan_idx);
+			wcid = rcu_dereference(dev->wcid[wlan_idx]);
+			if (wcid) {
+				rcpi = res->rssi[i].rcpi;
+				rssi[0] = to_rssi(MT_PRXV_RCPI0, rcpi[0]);
+				rssi[1] = to_rssi(MT_PRXV_RCPI0, rcpi[1]);
+				rssi[2] = to_rssi(MT_PRXV_RCPI0, rcpi[2]);
+				rssi[3] = to_rssi(MT_PRXV_RCPI0, rcpi[3]);
+
+				msta_link = container_of(wcid, struct mt7996_sta_link, wcid);
+				phy = dev->phys[wcid->phy_idx];
+				msta_link->ack_signal = mt76_rx_signal(phy->antenna_mask, rssi);
+				ewma_avg_signal_add(&msta_link->avg_ack_signal, -msta_link->ack_signal);
+			}
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		dev_err(dev->dev, "Unknown UNI_PER_STA_INFO_TAG: %d\n", tag);
+	}
+	rcu_read_unlock();
+out:
+	dev_kfree_skb(skb);
+	return ret;
+}
+
+int mt7996_mcu_get_rssi(struct mt76_dev *dev)
+{
+	u16 sta_list[PER_STA_INFO_MAX_NUM];
+	LIST_HEAD(sta_poll_list);
+	struct mt7996_sta_link *msta_link;
+	int i, ret;
+	bool empty = false;
+
+	spin_lock_bh(&dev->sta_poll_lock);
+	list_splice_init(&dev->sta_poll_list, &sta_poll_list);
+	spin_unlock_bh(&dev->sta_poll_lock);
+
+	while (!empty) {
+		for (i = 0; i < PER_STA_INFO_MAX_NUM; ++i) {
+			spin_lock_bh(&dev->sta_poll_lock);
+			if (list_empty(&sta_poll_list)) {
+				spin_unlock_bh(&dev->sta_poll_lock);
+
+				if (i == 0)
+					return 0;
+
+				empty = true;
+				break;
+			}
+			msta_link = list_first_entry(&sta_poll_list,
+			                        struct mt7996_sta_link,
+			                        wcid.poll_list);
+			list_del_init(&msta_link->wcid.poll_list);
+			spin_unlock_bh(&dev->sta_poll_lock);
+
+			sta_list[i] = msta_link->wcid.idx;
+		}
+
+		ret = mt7996_mcu_get_per_sta_info(dev, UNI_PER_STA_RSSI,
+		                                  i, sta_list);
+		if (ret) {
+			/* Add STAs, whose RSSI has not been updated,
+			 * back to polling list.
+			 */
+			spin_lock_bh(&dev->sta_poll_lock);
+			list_splice(&sta_poll_list, &dev->sta_poll_list);
+			spin_unlock_bh(&dev->sta_poll_lock);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+int mt7996_mcu_get_all_sta_info(struct mt76_dev *dev, u16 tag)
+{
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+	} __packed req = {
+		.tag = cpu_to_le16(tag),
+		.len = cpu_to_le16(sizeof(req) - 4),
+	};
+
+	return mt76_mcu_send_msg(dev, MCU_WM_UNI_CMD(ALL_STA_INFO),
+				 &req, sizeof(req), false);
+}
+
+int mt7996_mcu_wed_rro_reset_sessions(struct mt7996_dev *dev, u16 id)
+{
+	struct {
+		u8 __rsv[4];
+
+		__le16 tag;
+		__le16 len;
+		__le16 session_id;
+		u8 pad[4];
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_RRO_DEL_BA_SESSION),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.session_id = cpu_to_le16(id),
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(RRO), &req,
+				 sizeof(req), true);
+}
 
 int mt7996_mcu_set_sniffer_mode(struct mt7996_phy *phy, bool enabled)
 {
@@ -4822,16 +5973,39 @@ int mt7996_mcu_set_sniffer_mode(struct mt7996_phy *phy, bool enabled)
 		.len = cpu_to_le16(sizeof(req) - 4),
 		.enable = enabled,
 	};
-
 	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(SNIFFER), &req,
 				 sizeof(req), true);
 }
 
-int mt7996_mcu_set_txpower_sku(struct mt7996_phy *phy)
+static void
+mt7996_update_max_txpower_cur(struct mt7996_phy *phy, int tx_power)
+{
+	struct mt76_phy *mphy = phy->mt76;
+	struct ieee80211_channel *chan = mphy->main_chandef.chan;
+	int e2p_power_limit = 0;
+
+	if (chan == NULL) {
+		mphy->txpower_cur = tx_power;
+		return;
+	}
+
+	e2p_power_limit = mt7996_eeprom_get_target_power(phy->dev, chan);
+	e2p_power_limit += mt7996_eeprom_get_power_delta(phy->dev, chan->band);
+
+	if (phy->sku_limit_en)
+		mphy->txpower_cur = min_t(int, e2p_power_limit, tx_power);
+	else
+		mphy->txpower_cur = e2p_power_limit;
+}
+
+int mt7996_mcu_set_txpower_sku(struct mt7996_phy *phy,
+			       struct ieee80211_bss_conf *conf)
 {
 #define TX_POWER_LIMIT_TABLE_RATE	0
+#define TX_POWER_LIMIT_TABLE_PATH	1
 	struct mt7996_dev *dev = phy->dev;
 	struct mt76_phy *mphy = phy->mt76;
+	struct ieee80211_hw *hw = mphy->hw;
 	struct tx_power_limit_table_ctrl {
 		u8 __rsv1[4];
 
@@ -4848,13 +6022,22 @@ int mt7996_mcu_set_txpower_sku(struct mt7996_phy *phy)
 		.band_idx = phy->mt76->band_idx,
 	};
 	struct mt76_power_limits la = {};
+	struct mt76_power_path_limits la_path = {};
 	struct sk_buff *skb;
-	int i, tx_power;
+	int i, ret, txpower_limit;
 
-	tx_power = mt76_get_power_bound(mphy, phy->txpower);
-	tx_power = mt76_get_rate_power_limits(mphy, mphy->chandef.chan,
-					      &la, tx_power);
-	mphy->txpower_cur = tx_power;
+	if (hw->conf.power_level == INT_MIN)
+		hw->conf.power_level = 127;
+	txpower_limit = mt7996_get_power_bound(phy, conf->txpower);
+
+	if (phy->sku_limit_en) {
+		txpower_limit = mt76_get_rate_power_limits(mphy, mphy->chandef.chan,
+							   &la, &la_path, txpower_limit);
+		mt7996_update_max_txpower_cur(phy, txpower_limit);
+	} else {
+		mt7996_update_max_txpower_cur(phy, txpower_limit);
+		return 0;
+	}
 
 	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL,
 				 sizeof(req) + MT7996_SKU_PATH_NUM);
@@ -4884,6 +6067,34 @@ int mt7996_mcu_set_txpower_sku(struct mt7996_phy *phy)
 	/* padding */
 	skb_put_zero(skb, MT7996_SKU_PATH_NUM - MT7996_SKU_RATE_NUM);
 
+	ret = mt76_mcu_skb_send_msg(&dev->mt76, skb,
+				    MCU_WM_UNI_CMD(TXPOWER), true);
+	if (ret)
+		return ret;
+
+	/* only set per-path power table when it's configured */
+	if (!phy->sku_path_en)
+		return 0;
+
+	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL,
+				 sizeof(req) + MT7996_SKU_PATH_NUM);
+	if (!skb)
+		return -ENOMEM;
+	req.power_limit_type = TX_POWER_LIMIT_TABLE_PATH;
+
+	skb_put_data(skb, &req, sizeof(req));
+	skb_put_data(skb, &la_path.cck, sizeof(la_path.cck));
+	skb_put_data(skb, &la_path.ofdm, sizeof(la_path.ofdm));
+	skb_put_data(skb, &la_path.ofdm_bf, sizeof(la_path.ofdm_bf));
+
+	for (i = 0; i < 32; i++) {
+		bool bf = i % 2;
+		u8 idx = i / 2;
+		s8 *buf = bf ? la_path.ru_bf[idx] : la_path.ru[idx];
+
+		skb_put_data(skb, buf, sizeof(la_path.ru[0]));
+	}
+
 	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
 				     MCU_WM_UNI_CMD(TXPOWER), true);
 }
@@ -4919,3 +6130,676 @@ int mt7996_mcu_cp_support(struct mt7996_dev *dev, u8 mode)
 	return mt76_mcu_send_msg(&dev->mt76, MCU_WA_EXT_CMD(CP_SUPPORT),
 				 &cp_mode, sizeof(cp_mode), true);
 }
+
+int mt7996_mcu_set_pp_en(struct mt7996_phy *phy, u8 mode, u16 bitmap)
+{
+	struct mt7996_dev *dev = phy->dev;
+	bool pp_auto = (mode == PP_FW_MODE);
+	struct {
+		u8 _rsv1[4];
+
+		__le16 tag;
+		__le16 len;
+		u8 mgmt_mode;
+		u8 band_idx;
+		u8 force_bitmap_ctrl;
+		u8 auto_mode;
+		__le16 bitmap;
+		u8 _rsv2[2];
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_CMD_PP_EN_CTRL),
+		.len = cpu_to_le16(sizeof(req) - 4),
+
+		.mgmt_mode = !pp_auto,
+		.band_idx = phy->mt76->band_idx,
+		.force_bitmap_ctrl = (mode == PP_USR_MODE) ? 2 : 0,
+		.auto_mode = pp_auto,
+		.bitmap = cpu_to_le16(bitmap),
+	};
+
+	if (phy->mt76->chanctx->chandef.chan->band == NL80211_BAND_2GHZ ||
+	    mode > PP_USR_MODE)
+		return 0;
+
+	if (bitmap && phy->punct_bitmap == bitmap)
+		return 0;
+
+	phy->punct_bitmap = bitmap;
+	phy->pp_mode = mode;
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(PP),
+				 &req, sizeof(req), false);
+}
+
+int mt7996_mcu_set_tx_power_ctrl(struct mt7996_phy *phy, u8 power_ctrl_id, u8 data)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct tx_power_ctrl req = {
+		.tag = cpu_to_le16(power_ctrl_id),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.power_ctrl_id = power_ctrl_id,
+		.band_idx = phy->mt76->band_idx,
+	};
+
+	switch (power_ctrl_id) {
+	case UNI_TXPOWER_SKU_POWER_LIMIT_CTRL:
+		req.sku_enable = !!data;
+		break;
+	case UNI_TXPOWER_PERCENTAGE_CTRL:
+		req.percentage_ctrl_enable = !!data;
+		break;
+	case UNI_TXPOWER_PERCENTAGE_DROP_CTRL:
+		req.power_drop_level = data;
+		break;
+	case UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL:
+		req.bf_backoff_enable = !!data;
+		break;
+	case UNI_TXPOWER_ATE_MODE_CTRL:
+		req.ate_mode_enable = !!data;
+		break;
+	default:
+		req.sku_enable = !!data;
+	}
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TXPOWER),
+				 &req, sizeof(req), false);
+}
+
+int mt7996_mcu_set_scs_stats(struct mt7996_phy *phy)
+{
+	struct mt7996_scs_ctrl ctrl = phy->scs_ctrl;
+	struct {
+		u8 band_idx;
+		u8 _rsv[3];
+
+		__le16 tag;
+		__le16 len;
+
+		u8 _rsv2[6];
+		s8 min_rssi;
+		u8 _rsv3;
+	} __packed req = {
+		.band_idx = phy->mt76->band_idx,
+		.tag = cpu_to_le16(UNI_CMD_SCS_SEND_DATA),
+		.len = cpu_to_le16(sizeof(req) - 4),
+
+		.min_rssi = ctrl.sta_min_rssi,
+	};
+
+	return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(SCS),
+				 &req, sizeof(req), false);
+}
+
+void mt7996_sta_rssi_work(void *data, struct ieee80211_sta *sta)
+{
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_phy *poll_phy = (struct mt7996_phy *)data;
+	struct mt7996_vif *mvif = msta->vif;
+	struct ieee80211_link_sta *link_sta;
+	struct ieee80211_vif *vif;
+	unsigned int link_id;
+
+	vif = container_of((void *)mvif, struct ieee80211_vif, drv_priv);
+
+	rcu_read_lock();
+	for_each_sta_active_link(vif, sta, link_sta, link_id) {
+		struct mt7996_sta_link *msta_link;
+
+		msta_link = rcu_dereference(msta->link[link_id]);
+		if (!msta_link)
+			continue;
+
+		if (msta_link->wcid.phy_idx != poll_phy->mt76->band_idx)
+			continue;
+
+		if (poll_phy->scs_ctrl.sta_min_rssi > msta_link->ack_signal)
+			poll_phy->scs_ctrl.sta_min_rssi = msta_link->ack_signal;
+
+		break;
+	}
+	rcu_read_unlock();
+}
+
+void mt7996_mcu_scs_sta_poll(struct work_struct *work)
+{
+	struct mt7996_dev *dev = container_of(work, struct mt7996_dev,
+				 scs_work.work);
+	bool scs_enable_flag = false;
+	u8 i;
+
+	for (i = 0; i < __MT_MAX_BAND; i++) {
+		struct mt7996_phy *phy;
+
+		switch (i) {
+		case MT_BAND0:
+			phy = dev->mphy.priv;
+			break;
+		case MT_BAND1:
+			phy = mt7996_phy2(dev);
+			break;
+		case MT_BAND2:
+			phy = mt7996_phy3(dev);
+			break;
+		default:
+			phy = NULL;
+			break;
+		}
+
+		if (!phy || !test_bit(MT76_STATE_RUNNING, &phy->mt76->state) ||
+		    !phy->scs_ctrl.scs_enable)
+			continue;
+
+		ieee80211_iterate_stations_atomic(phy->mt76->hw,
+						  mt7996_sta_rssi_work, phy);
+
+		scs_enable_flag = true;
+		if (mt7996_mcu_set_scs_stats(phy))
+			dev_err(dev->mt76.dev, "Failed to send scs mcu cmd\n");
+		phy->scs_ctrl.sta_min_rssi = 0;
+	}
+
+	if (scs_enable_flag)
+		ieee80211_queue_delayed_work(mt76_hw(dev), &dev->scs_work, HZ);
+}
+
+
+int mt7996_mcu_set_scs(struct mt7996_phy *phy, u8 enable)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct {
+		u8 band_idx;
+		u8 _rsv[3];
+
+		__le16 tag;
+		__le16 len;
+
+		u8 scs_enable;
+		u8 _rsv2[3];
+	} __packed req = {
+		.band_idx = phy->mt76->band_idx,
+		.tag = cpu_to_le16(UNI_CMD_SCS_ENABLE),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.scs_enable = enable,
+	};
+
+	phy->scs_ctrl.scs_enable = enable;
+
+	if (enable == SCS_ENABLE)
+		ieee80211_queue_delayed_work(mt76_hw(dev), &dev->scs_work, HZ);
+
+	return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(SCS),
+				 &req, sizeof(req), false);
+}
+
+int mt7996_mcu_set_vow_drr_ctrl(struct mt7996_phy *phy,
+				struct mt7996_vif_link *mconf,
+				struct mt7996_sta_link *msta_link,
+				enum vow_drr_ctrl_id id)
+{
+	struct mt7996_vow_sta_ctrl *vow = msta_link ? &msta_link->vow : NULL;
+	u32 val = 0;
+	struct {
+		u8 __rsv1[4];
+
+		__le16 tag;
+		__le16 len;
+		__le16 wlan_idx;
+		u8 band_idx;
+		u8 wmm_idx;
+		__le32 ctrl_id;
+
+		union {
+			__le32 val;
+			u8 drr_quantum[VOW_DRR_QUANTUM_NUM];
+		};
+
+		u8 __rsv2[3];
+		u8 omac_idx;
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_VOW_DRR_CTRL),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.wlan_idx = cpu_to_le16(msta_link ? msta_link->wcid.idx : 0),
+		.band_idx = phy->mt76->band_idx,
+		.wmm_idx = msta_link ? mconf->mt76.wmm_idx : 0,
+		.ctrl_id = cpu_to_le32(id),
+		.omac_idx = msta_link ? mconf->mt76.omac_idx : 0
+	};
+
+	switch (id) {
+	case VOW_DRR_CTRL_STA_ALL:
+		val |= FIELD_PREP(MT7996_DRR_STA_BSS_GRP_MASK, vow->bss_grp_idx);
+		val |= FIELD_PREP(MT7996_DRR_STA_AC0_QNTM_MASK, vow->drr_quantum[IEEE80211_AC_BK]);
+		val |= FIELD_PREP(MT7996_DRR_STA_AC1_QNTM_MASK, vow->drr_quantum[IEEE80211_AC_BE]);
+		val |= FIELD_PREP(MT7996_DRR_STA_AC2_QNTM_MASK, vow->drr_quantum[IEEE80211_AC_VI]);
+		val |= FIELD_PREP(MT7996_DRR_STA_AC3_QNTM_MASK, vow->drr_quantum[IEEE80211_AC_VO]);
+		req.val = cpu_to_le32(val);
+		break;
+	case VOW_DRR_CTRL_STA_BSS_GROUP:
+		req.val = cpu_to_le32(vow->bss_grp_idx);
+		break;
+	case VOW_DRR_CTRL_AIRTIME_DEFICIT_BOUND:
+		req.val = cpu_to_le32(phy->dev->vow.max_deficit);
+		break;
+	case VOW_DRR_CTRL_AIRTIME_QUANTUM_ALL:
+		memcpy(req.drr_quantum, phy->dev->vow.drr_quantum, VOW_DRR_QUANTUM_NUM);
+		break;
+	case VOW_DRR_CTRL_STA_PAUSE:
+		req.val = cpu_to_le32(vow->paused);
+		break;
+	default:
+		dev_err(phy->dev->mt76.dev, "Unknown VoW DRR Control ID: %u\n", id);
+		return -EINVAL;
+	}
+
+	return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(VOW),
+	                         &req, sizeof(req), true);
+}
+
+int mt7996_mcu_set_vow_feature_ctrl(struct mt7996_phy *phy)
+{
+	struct mt7996_vow_ctrl *vow = &phy->dev->vow;
+	struct {
+		u8 __rsv1[4];
+
+		__le16 tag;
+		__le16 len;
+
+		/* DW0 */
+		__le16 apply_bwc_enable_per_grp;
+		__le16 apply_bwc_refill_period		: 1;
+		__le16 __rsv2				: 3;
+		__le16 apply_band1_search_rule		: 1;
+		__le16 apply_band0_search_rule		: 1;
+		__le16 __rsv3				: 3;
+		__le16 apply_watf_enable		: 1;
+		__le16 __rsv4				: 2;
+		__le16 apply_grp_no_change_in_txop	: 1;
+		__le16 apply_atf_enable			: 1;
+		__le16 apply_bwc_token_refill_enable	: 1;
+		__le16 apply_bwc_enable			: 1;
+
+		/* DW1 */
+		__le16 apply_bwc_check_time_token_per_grp;
+		__le16 __rsv5;
+
+		/* DW2 */
+		__le16 apply_bwc_check_len_token_per_grp;
+		__le16 __rsv6;
+
+		/* DW3 */
+		u8 band_idx;
+		u8 __rsv7[3];
+
+		/* DW4 */
+		__le32 __rsv8;
+
+		/* DW5 */
+		__le16 bwc_enable_per_grp;
+		__le16 bwc_refill_period	: 3;
+		__le16 __rsv9			: 1;
+		__le16 band1_search_rule	: 1;
+		__le16 band0_search_rule	: 1;
+		__le16 __rsv10			: 3;
+		__le16 watf_enable		: 1;
+		__le16 __rsv11			: 2;
+		__le16 grp_no_change_in_txop	: 1;
+		__le16 atf_enable		: 1;
+		__le16 bwc_token_refill_enable	: 1;
+		__le16 bwc_enable		: 1;
+
+		/* DW6 */
+		__le16 bwc_check_time_token_per_grp;
+		__le16 __rsv12;
+
+		/* DW7 */
+		__le16 bwc_check_len_token_per_grp;
+		__le16 __rsv13;
+
+		/* DW8 */
+		__le32 apply_atf_rts_sta_lock		: 1;
+		__le32 atf_rts_sta_lock			: 1;
+		__le32 apply_atf_keep_quantum		: 1;
+		__le32 atf_keep_quantum			: 1;
+		__le32 apply_tx_cnt_mode_ctrl		: 1;
+		__le32 tx_cnt_mode_ctrl			: 4;
+		__le32 apply_tx_measure_mode_enable	: 1;
+		__le32 tx_measure_mode_enable		: 1;
+		__le32 apply_backoff_ctrl		: 1;
+		__le32 backoff_bound_enable		: 1;
+		__le32 backoff_bound			: 5;
+		__le32 apply_atf_rts_fail_charge	: 1;
+		__le32 atf_rts_fail_charge		: 1;
+		__le32 apply_zero_eifs			: 1;
+		__le32 zero_eifs			: 1;
+		__le32 apply_rx_rifs_enable		: 1;
+		__le32 rx_rifs_enable			: 1;
+		__le32 apply_vow_ctrl			: 1;
+		__le32 vow_ctrl_val			: 1;
+		__le32 vow_ctrl_bit			: 5;
+		__le32 __rsv14				: 1;
+
+		/* DW9 */
+		__le32 apply_spl_sta_num	: 1;
+		__le32 spl_sta_num		: 3;
+		__le32 dbg_lvl			: 2;
+		__le32 apply_atf_sch_ctrl	: 1;
+		__le32 atf_sch_type		: 2;
+		__le32 atf_sch_policy		: 2;
+		__le32 __rsv15			: 21;
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_VOW_FEATURE_CTRL),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		/* DW0 */
+		.apply_bwc_enable_per_grp = cpu_to_le16(0xffff),
+		.apply_bwc_refill_period = true,
+		.apply_band1_search_rule = true,
+		.apply_band0_search_rule = true,
+		.apply_watf_enable = true,
+		.apply_grp_no_change_in_txop = true,
+		.apply_atf_enable = true,
+		.apply_bwc_token_refill_enable = true,
+		.apply_bwc_enable = true,
+		/* DW1 */
+		.apply_bwc_check_time_token_per_grp = cpu_to_le16(0xffff),
+		/* DW2 */
+		.apply_bwc_check_len_token_per_grp = cpu_to_le16(0xffff),
+		/* DW3 */
+		.band_idx = phy->mt76->band_idx,
+		/* DW5 */
+		.bwc_enable_per_grp = cpu_to_le16(0xffff),
+		.bwc_refill_period = VOW_REFILL_PERIOD_32US,
+		.band1_search_rule = VOW_SEARCH_WMM_FIRST,
+		.band0_search_rule = VOW_SEARCH_WMM_FIRST,
+		.watf_enable = vow->watf_enable,
+		.grp_no_change_in_txop = true,
+		.atf_enable = vow->atf_enable,
+		.bwc_token_refill_enable = true,
+		.bwc_enable = false,
+		/* DW6 */
+		.bwc_check_time_token_per_grp = cpu_to_le16(0x0),
+		/* DW7 */
+		.bwc_check_len_token_per_grp = cpu_to_le16(0x0),
+		/* DW8 */
+		.apply_atf_rts_sta_lock = false,
+		.apply_atf_keep_quantum = true,
+		.atf_keep_quantum = true,
+		.apply_tx_cnt_mode_ctrl = false,
+		.apply_tx_measure_mode_enable = false,
+		.apply_backoff_ctrl = false,
+		.apply_atf_rts_fail_charge = false,
+		.apply_zero_eifs = false,
+		.apply_rx_rifs_enable = false,
+		.apply_vow_ctrl = true,
+		.vow_ctrl_val = true,
+		/* Reset DRR table when SER occurs. */
+		.vow_ctrl_bit = 26,
+		/* DW9 */
+		.apply_spl_sta_num = false,
+		.dbg_lvl = 0,
+		.apply_atf_sch_ctrl = true,
+		.atf_sch_type = vow->sch_type,
+		.atf_sch_policy = vow->sch_policy
+	};
+
+	return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(VOW),
+	                         &req, sizeof(req), true);
+}
+
+#ifdef CONFIG_MTK_VENDOR
+void mt7996_set_wireless_vif(void *data, u8 *mac, struct ieee80211_vif *vif)
+{
+	u8 mode, val, band_idx;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_phy *phy;
+	struct mt76_phy *mphy;
+
+	mode = FIELD_GET(RATE_CFG_MODE, *((u32 *)data));
+	val = FIELD_GET(RATE_CFG_VAL, *((u32 *)data));
+	band_idx = FIELD_GET(RATE_CFG_BAND_IDX, *((u32 *)data));
+
+	if (!mt7996_band_valid(mvif->dev, band_idx))
+		goto error;
+
+	mphy = mvif->dev->mt76.phys[band_idx];
+	if (!mphy)
+		goto error;
+
+	phy = (struct mt7996_phy *)mphy->priv;
+
+	switch (mode) {
+	case RATE_PARAM_FIXED_OFDMA:
+		if (val == 3)
+			phy->muru_onoff |= OFDMA_DL;
+		else
+			phy->muru_onoff |= val;
+		break;
+	case RATE_PARAM_FIXED_MIMO:
+		if (val == 0)
+			phy->muru_onoff |= MUMIMO_DL_CERT | MUMIMO_DL;
+		else
+			phy->muru_onoff |= MUMIMO_UL;
+		break;
+	case RATE_PARAM_AUTO_MU:
+		phy->muru_onoff = val & GENMASK(3, 0);
+		break;
+	}
+
+	return;
+error:
+	dev_err(mvif->dev->mt76.dev, "Invalid band_idx to config\n");
+	return;
+}
+
+void mt7996_set_beacon_vif(struct ieee80211_vif *vif, u8 val)
+{
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct ieee80211_hw *hw = mvif->deflink.phy->mt76->hw;
+
+	vif->bss_conf.enable_beacon = val;
+
+	mt7996_mcu_add_beacon(hw, vif, &vif->bss_conf, val);
+}
+
+static int mt7996_mcu_set_csi_enable(struct mt7996_phy *phy, u16 tag)
+{
+	struct {
+		u8 band;
+		u8 rsv1[3];
+
+		__le16 tag;
+		__le16 len;
+	} __packed req = {
+		.band = phy->mt76->band_idx,
+		.tag = cpu_to_le16(tag),
+		.len = cpu_to_le16(sizeof(req) - 4),
+	};
+
+	return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(CSI_CTRL), &req,
+				sizeof(req), false);
+}
+
+static int mt7996_mcu_set_csi_frame_type(struct mt7996_phy *phy, u16 tag, u8 type_idx, u32 type)
+{
+	struct {
+		u8 band;
+		u8 rsv1[3];
+
+		__le16 tag;
+		__le16 len;
+		u8 frame_type_idx;
+		u8 frame_type;
+		u8 rsv2[2];
+	} __packed req = {
+		.band = phy->mt76->band_idx,
+		.tag = cpu_to_le16(tag),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.frame_type_idx = type_idx,
+		.frame_type = type,
+	};
+
+	return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(CSI_CTRL), &req,
+				sizeof(req), false);
+}
+
+static int mt7996_mcu_set_csi_chain_filter(struct mt7996_phy *phy, u16 tag, u8 func, u32 value)
+{
+	struct {
+		u8 band;
+		u8 rsv1[3];
+
+		__le16 tag;
+		__le16 len;
+		u8 function;
+		u8 chain_value;
+		u8 rsv2[2];
+	} __packed req = {
+		.band = phy->mt76->band_idx,
+		.tag = cpu_to_le16(tag),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.function = func,
+		.chain_value = value,
+	};
+
+	return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(CSI_CTRL), &req,
+				sizeof(req), false);
+}
+
+static int mt7996_mcu_set_csi_sta_filter(struct mt7996_phy *phy, u16 tag, u32 op, u8 *sta_mac)
+{
+	struct {
+		u8 band;
+		u8 rsv1[3];
+
+		__le16 tag;
+		__le16 len;
+		u8 operation;
+		u8 rsv2[1];
+		u8 mac[6];
+	} __packed req = {
+		.band = phy->mt76->band_idx,
+		.tag = cpu_to_le16(tag),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.operation = op,
+	};
+
+	memcpy(req.mac, sta_mac, ETH_ALEN);
+
+	return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(CSI_CTRL), &req,
+				sizeof(req), false);
+}
+
+static int mt7996_mcu_set_csi_active_mode(struct mt7996_phy *phy, u16 tag,
+					  u32 interval, u8 frame_idx, u8 subframe_idx, u32 bitmap)
+{
+	struct {
+		u8 band;
+		u8 rsv1[3];
+
+		__le16 tag;
+		__le16 len;
+		__le16 interval; /* uint: ms */
+		u8 frame_type_idx;
+		u8 subframe_type_idx;
+		__le32 bitmap; /* sta wcid bitmap */
+		u8 rsv2[4];
+	} __packed req = {
+		.band = phy->mt76->band_idx,
+		.tag = cpu_to_le16(tag),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.interval = cpu_to_le16(interval),
+		.frame_type_idx = frame_idx,
+		.subframe_type_idx = subframe_idx,
+		.bitmap = cpu_to_le32(bitmap),
+	};
+
+	return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(CSI_CTRL), &req,
+				sizeof(req), false);
+}
+
+void mt7996_csi_wcid_bitmap_update(void *data, struct ieee80211_sta *sta)
+{
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_phy *phy = msta->vif->deflink.phy;
+	struct csi_bitmap_info_update *sta_info = (struct csi_bitmap_info_update *)data;
+	u16 wcid = 0;
+
+#define CSI_ACTIVE_MODE_ADD 1
+#define CSI_ACTIVE_MODE_REMOVE 0
+
+	if (!memcmp(sta_info->addr, sta->addr, ETH_ALEN)) {
+		wcid = msta->deflink.wcid.idx;
+
+		/* active mode: only support station with wcid less than 32 */
+		if (wcid > 32)
+			return;
+
+		if (sta_info->action == CSI_ACTIVE_MODE_ADD)
+			phy->csi.active_bitmap |= BIT(wcid);
+		else if (sta_info->action == CSI_ACTIVE_MODE_REMOVE)
+			phy->csi.active_bitmap &= ~(BIT(wcid));
+	}
+}
+
+int mt7996_mcu_set_csi(struct mt7996_phy *phy, u8 mode,
+			u8 cfg, u8 v1, u32 v2, u8 *mac_addr)
+{
+	switch (mode) {
+	case CSI_CONTROL_MODE_STOP:
+		return mt7996_mcu_set_csi_enable(phy, UNI_CMD_CSI_STOP);
+	case CSI_CONTROL_MODE_START:
+		return mt7996_mcu_set_csi_enable(phy, UNI_CMD_CSI_START);
+	case CSI_CONTROL_MODE_SET:
+		switch (cfg) {
+		case CSI_CONFIG_FRAME_TYPE:
+			if (v2 > 255)
+				return -EINVAL;
+
+			return mt7996_mcu_set_csi_frame_type(phy,
+					UNI_CMD_CSI_SET_FRAME_TYPE, v1, v2);
+		case CSI_CONFIG_CHAIN_FILTER:
+			if (v2 > 255)
+				return -EINVAL;
+
+			return mt7996_mcu_set_csi_chain_filter(phy,
+					UNI_CMD_CSI_SET_CHAIN_FILTER, v1, v2);
+		case CSI_CONFIG_STA_FILTER:
+			if (!is_valid_ether_addr(mac_addr))
+				return -EINVAL;
+
+			if (v2 > 255)
+				return -EINVAL;
+
+			return mt7996_mcu_set_csi_sta_filter(phy,
+					UNI_CMD_CSI_SET_STA_FILTER, v2, mac_addr);
+		case CSI_CONFIG_ACTIVE_MODE:
+			if (is_valid_ether_addr(mac_addr)) {
+				struct csi_bitmap_info_update sta_info;
+
+				if (v2 > 255)
+					return -EINVAL;
+
+				memcpy(sta_info.addr, mac_addr, ETH_ALEN);
+				sta_info.action = v2;
+
+				ieee80211_iterate_stations_atomic(phy->mt76->hw,
+								mt7996_csi_wcid_bitmap_update, &sta_info);
+				return 0;
+			} else {
+				u8 frame_type = v1 & 0x3;
+				u8 frame_subtype = (v1 & 0x3c) >> 2;
+
+					/* active mode: max interval is 3000ms */
+					if (v2 > 3000)
+						return -EINVAL;
+
+				return mt7996_mcu_set_csi_active_mode(phy, UNI_CMD_CSI_SET_ACTIVE_MODE,
+						v2, frame_type, frame_subtype, phy->csi.active_bitmap);
+			}
+		default:
+			return -EINVAL;
+		}
+	default:
+		return -EINVAL;
+	}
+}
+#endif
diff --git a/mt7996/mcu.h b/mt7996/mcu.h
index c6848694..9aea42e0 100644
--- a/mt7996/mcu.h
+++ b/mt7996/mcu.h
@@ -119,6 +119,20 @@ struct mt7996_mcu_rdd_report {
 	} hw_pulse[32];
 } __packed;
 
+struct mt7996_rdd_ctrl {
+	u8 _rsv[4];
+
+	__le16 tag;
+	__le16 len;
+
+	u8 ctrl;
+	u8 rdd_idx;
+	u8 rdd_rx_sel;
+	u8 val;
+	u8 disable_timer;
+	u8 rsv[3];
+} __packed;
+
 struct mt7996_mcu_background_chain_ctrl {
 	u8 _rsv[4];
 
@@ -157,6 +171,16 @@ struct mt7996_mcu_eeprom {
 	__le16 buf_len;
 } __packed;
 
+struct mt7996_mcu_eeprom_info {
+	u8 _rsv[4];
+
+	__le16 tag;
+	__le16 len;
+	__le32 addr;
+	__le32 valid;
+	u8 data[MT7996_EEPROM_BLOCK_SIZE];
+} __packed;
+
 struct mt7996_mcu_phy_rx_info {
 	u8 category;
 	u8 rate;
@@ -175,6 +199,23 @@ struct mt7996_mcu_mib {
 	__le64 data;
 } __packed;
 
+struct per_sta_rssi {
+	__le16 wlan_idx;
+	u8 __rsv[2];
+	u8 rcpi[4];
+} __packed;
+
+struct mt7996_mcu_per_sta_info_event {
+	u8 __rsv[4];
+
+	__le16 tag;
+	__le16 len;
+
+	union {
+		struct per_sta_rssi rssi[0];
+	};
+} __packed;
+
 struct all_sta_trx_rate {
 	__le16 wlan_idx;
 	u8 __rsv1[2];
@@ -196,6 +237,8 @@ struct all_sta_trx_rate {
 	u8 __rsv2;
 } __packed;
 
+#define UNI_EVENT_SIZE_ADM_STAT_V1	1452
+
 struct mt7996_mcu_all_sta_info_event {
 	u8 rsv[4];
 	__le16 tag;
@@ -212,7 +255,15 @@ struct mt7996_mcu_all_sta_info_event {
 			u8 rsv[2];
 			__le32 tx_bytes[IEEE80211_NUM_ACS];
 			__le32 rx_bytes[IEEE80211_NUM_ACS];
-		} __packed, adm_stat);
+		} __packed, adm_stat_v1);
+
+		DECLARE_FLEX_ARRAY(struct {
+			__le16 wlan_idx;
+			u8 rsv[2];
+			__le32 tx_bytes[IEEE80211_NUM_ACS];
+			__le32 rx_bytes[IEEE80211_NUM_ACS];
+			__le32 tx_bytes_failed[IEEE80211_NUM_ACS];
+		} __packed, adm_stat_v2);
 
 		DECLARE_FLEX_ARRAY(struct {
 			__le16 wlan_idx;
@@ -220,6 +271,13 @@ struct mt7996_mcu_all_sta_info_event {
 			__le32 tx_msdu_cnt;
 			__le32 rx_msdu_cnt;
 		} __packed, msdu_cnt);
+
+		DECLARE_FLEX_ARRAY(struct {
+			__le16 wlan_idx;
+			u8 rsv[2];
+			__le32 tx[IEEE80211_NUM_ACS];
+			__le32 rx[IEEE80211_NUM_ACS];
+		} __packed, airtime);
 	} __packed;
 } __packed;
 
@@ -249,7 +307,9 @@ struct mt7996_mcu_wed_rro_ba_delete_event {
 	__le16 len;
 
 	__le16 session_id;
-	u8 __rsv2[2];
+	__le16 mld_id;
+	u8 tid;
+	u8 __rsv[3];
 } __packed;
 
 enum  {
@@ -301,7 +361,8 @@ enum {
 	MCU_FW_LOG_WM,
 	MCU_FW_LOG_WA,
 	MCU_FW_LOG_TO_HOST,
-	MCU_FW_LOG_RELAY = 16
+	MCU_FW_LOG_RELAY = 16,
+	MCU_FW_LOG_RELAY_IDX = 40
 };
 
 enum {
@@ -319,11 +380,27 @@ enum {
 	MCU_WA_PARAM_CMD_DEBUG,
 };
 
+#define BSS_ACQ_PKT_CNT_BSS_NUM		24
+#define BSS_ACQ_PKT_CNT_BSS_BITMAP_ALL	0x00ffffff
+#define BSS_ACQ_PKT_CNT_READ_CLR	BIT(31)
+#define WMM_PKT_THRESHOLD		100
+
+struct mt7996_mcu_bss_acq_pkt_cnt_event {
+	struct mt7996_mcu_rxd rxd;
+
+	__le32 bss_bitmap;
+	struct {
+		__le32 cnt[IEEE80211_NUM_ACS];
+	} __packed bss[BSS_ACQ_PKT_CNT_BSS_NUM];
+} __packed;
+
 enum {
 	MCU_WA_PARAM_PDMA_RX = 0x04,
 	MCU_WA_PARAM_CPU_UTIL = 0x0b,
-	MCU_WA_PARAM_RED = 0x0e,
+	MCU_WA_PARAM_RED_EN = 0x0e,
+	MCU_WA_PARAM_BSS_ACQ_PKT_CNT = 0x12,
 	MCU_WA_PARAM_HW_PATH_HIF_VER = 0x2f,
+	MCU_WA_PARAM_RED_CONFIG = 0x40,
 };
 
 enum mcu_mmps_mode {
@@ -507,6 +584,13 @@ struct sta_rec_ba_uni {
 	u8 __rsv[3];
 } __packed;
 
+struct sta_rec_tx_cap {
+	__le16 tag;
+	__le16 len;
+	u8 ampdu_limit_en;
+	u8 rsv[3];
+} __packed;
+
 struct sta_rec_eht {
 	__le16 tag;
 	__le16 len;
@@ -705,6 +789,22 @@ struct bf_sounding_on {
 	__le32 snd_period;
 } __packed;
 
+enum sounding_mode {
+	SU_SOUNDING,
+	MU_SOUNDING,
+	SU_PERIODIC_SOUNDING,
+	MU_PERIODIC_SOUNDING,
+	BF_PROCESSING,
+	TXCMD_NONTB_SU_SOUNDING,
+	TXCMD_VHT_MU_SOUNDING,
+	TXCMD_TB_PER_BRP_SOUNDING,
+	TXCMD_TB_SOUNDING,
+
+	/* keep last */
+	NUM_SOUNDING_MODE,
+	SOUNDING_MODE_MAX = NUM_SOUNDING_MODE - 1,
+};
+
 struct bf_hw_en_status_update {
 	__le16 tag;
 	__le16 len;
@@ -730,6 +830,25 @@ union bf_tag_tlv {
 	struct bf_mod_en_ctrl bf_mod_en;
 };
 
+enum {
+	BF_SOUNDING_OFF = 0,
+	BF_SOUNDING_ON = 1,
+	BF_DATA_PACKET_APPLY = 2,
+	BF_PFMU_TAG_READ = 5,
+	BF_PFMU_TAG_WRITE = 6,
+	BF_STA_REC_READ = 11,
+	BF_PHASE_CALIBRATION = 12,
+	BF_IBF_PHASE_COMP = 13,
+	BF_PROFILE_WRITE_20M_ALL = 15,
+	BF_HW_EN_UPDATE = 17,
+	BF_MOD_EN_CTRL = 20,
+	BF_FBRPT_DBG_INFO_READ = 23,
+	BF_TXSND_INFO = 24,
+	BF_CMD_TXCMD = 27,
+	BF_CFG_PHY = 28,
+	BF_PROFILE_WRITE_20M_ALL_5X5 = 30,
+};
+
 struct ra_rate {
 	__le16 wlan_idx;
 	u8 mode;
@@ -774,13 +893,23 @@ enum {
 	RATE_PARAM_FIXED_MCS,
 	RATE_PARAM_FIXED_GI = 11,
 	RATE_PARAM_AUTO = 20,
+#ifdef CONFIG_MTK_VENDOR
+	RATE_PARAM_FIXED_MIMO = 30,
+	RATE_PARAM_FIXED_OFDMA = 31,
+	RATE_PARAM_AUTO_MU = 32,
+#endif
 };
 
-enum {
-	BF_SOUNDING_ON = 1,
-	BF_HW_EN_UPDATE = 17,
-	BF_MOD_EN_CTRL = 20,
-};
+#define RATE_CFG_BAND_IDX	GENMASK(17, 16)
+#define RATE_CFG_MODE	GENMASK(15, 8)
+#define RATE_CFG_VAL	GENMASK(7, 0)
+
+/* MURU */
+#define OFDMA_DL                       BIT(0)
+#define OFDMA_UL                       BIT(1)
+#define MUMIMO_DL                      BIT(2)
+#define MUMIMO_UL                      BIT(3)
+#define MUMIMO_DL_CERT                 BIT(4)
 
 enum {
 	CMD_BAND_NONE,
@@ -831,6 +960,7 @@ enum {
 					 sizeof(struct sta_rec_mld_setup) +	\
 					 sizeof(struct mld_setup_link) * 3 +	\
 					 sizeof(struct sta_rec_eht_mld) +	\
+					 sizeof(struct sta_rec_tx_cap) +	\
 					 sizeof(struct tlv))
 
 #define MT7996_BEACON_UPDATE_SIZE	(sizeof(struct bss_req_hdr) +		\
@@ -844,12 +974,18 @@ enum {
 
 enum {
 	UNI_BAND_CONFIG_RADIO_ENABLE,
+	UNI_BAND_CONFIG_EDCCA_ENABLE = 0x05,
+	UNI_BAND_CONFIG_EDCCA_THRESHOLD = 0x06,
 	UNI_BAND_CONFIG_RTS_THRESHOLD = 0x08,
+	UNI_BAND_CONFIG_RTS_SIGTA_EN = 0x09,
+	UNI_BAND_CONFIG_DIS_SECCH_CCA_DET = 0x0a,
 };
 
 enum {
 	UNI_WSYS_CONFIG_FW_LOG_CTRL,
 	UNI_WSYS_CONFIG_FW_DBG_CTRL,
+	UNI_CMD_CERT_CFG = 6,
+	UNI_WSYS_CONFIG_FW_TIME_SYNC, /* UNI_CMD_FW_TIME_SYNC in FW */
 };
 
 enum {
@@ -862,12 +998,15 @@ enum {
 	UNI_EFUSE_BUFFER_MODE,
 	UNI_EFUSE_FREE_BLOCK,
 	UNI_EFUSE_BUFFER_RD,
+	UNI_EFUSE_PATCH,
 };
 
 enum {
 	UNI_VOW_DRR_CTRL,
+	UNI_VOW_FEATURE_CTRL,
 	UNI_VOW_RX_AT_AIRTIME_EN = 0x0b,
 	UNI_VOW_RX_AT_AIRTIME_CLR_EN = 0x0e,
+	UNI_VOW_RED_ENABLE = 0x18,
 };
 
 enum {
@@ -893,6 +1032,14 @@ enum {
 	UNI_RRO_SET_FLUSH_TIMEOUT
 };
 
+enum {
+	UNI_MEC_READ_INFO = 0,
+	UNI_MEC_AMSDU_ALGO_EN_STA,
+	UNI_MEC_AMSDU_PARA_STA,
+	UNI_MEC_AMSDU_ALGO_THRESHOLD,
+	UNI_MEC_IFAC_SPEED,
+};
+
 enum{
 	UNI_CMD_SR_ENABLE = 0x1,
 	UNI_CMD_SR_ENABLE_SD,
@@ -910,8 +1057,33 @@ enum {
 	UNI_CMD_THERMAL_PROTECT_DUTY_CONFIG,
 };
 
+struct tx_power_ctrl {
+	u8 _rsv[4];
+
+	__le16 tag;
+	__le16 len;
+
+	u8 power_ctrl_id;
+	union {
+		bool sku_enable;
+		bool ate_mode_enable;
+		bool percentage_ctrl_enable;
+		bool bf_backoff_enable;
+		u8 show_info_category;
+		u8 power_drop_level;
+	};
+	u8 band_idx;
+	u8 rsv[1];
+} __packed;
+
 enum {
+	UNI_TXPOWER_SKU_POWER_LIMIT_CTRL = 0,
+	UNI_TXPOWER_PERCENTAGE_CTRL = 1,
+	UNI_TXPOWER_PERCENTAGE_DROP_CTRL = 2,
+	UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL = 3,
 	UNI_TXPOWER_POWER_LIMIT_TABLE_CTRL = 4,
+	UNI_TXPOWER_ATE_MODE_CTRL = 6,
+	UNI_TXPOWER_SHOW_INFO = 7,
 };
 
 enum {
@@ -931,7 +1103,11 @@ enum {
 	UNI_CMD_SER_SET_RECOVER_L4_MDP,
 	UNI_CMD_SER_SET_RECOVER_FROM_ETH,
 	UNI_CMD_SER_SET_RECOVER_FULL = 8,
+	/* fw assert */
 	UNI_CMD_SER_SET_SYSTEM_ASSERT,
+	/* coredump */
+	UNI_CMD_SER_FW_COREDUMP_WA,
+	UNI_CMD_SER_FW_COREDUMP_WM,
 	/*hw bit detect only*/
 	UNI_CMD_SER_SET_HW_BIT_DETECT_ONLY,
 	/* action */
@@ -953,6 +1129,42 @@ enum {
 	MT7996_SEC_MODE_MAX,
 };
 
+enum {
+	UNI_CMD_PP_EN_CTRL,
+};
+
+enum pp_mode {
+	PP_DISABLE = 0,
+	PP_FW_MODE,
+	PP_USR_MODE,
+};
+
+enum {
+	UNI_CMD_SCS_SEND_DATA,
+	UNI_CMD_SCS_SET_PD_THR_RANGE = 2,
+	UNI_CMD_SCS_ENABLE,
+};
+
+enum {
+	UNI_CMD_MLO_AGC_TX = 4,
+	UNI_CMD_MLO_AGC_TRIG = 5,
+};
+
+struct mt7996_mlo_agc_set {
+	u8 rsv[4];
+
+	__le16 tag;
+	__le16 len;
+
+	u8 mld_id;
+	u8 link_id;
+	u8 ac;
+	u8 disp_pol;
+	u8 ratio;
+	u8 order;
+	__le16 mgf;
+} __packed;
+
 #define MT7996_PATCH_SEC		GENMASK(31, 24)
 #define MT7996_PATCH_SCRAMBLE_KEY	GENMASK(15, 8)
 #define MT7996_PATCH_AES_KEY		GENMASK(7, 0)
@@ -981,4 +1193,109 @@ struct fixed_rate_table_ctrl {
 	u8 _rsv2;
 } __packed;
 
+#ifdef CONFIG_MTK_VENDOR
+struct mt7996_mcu_csi_event {
+	struct mt7996_mcu_rxd rxd;
+
+	u8 band_idx;
+	u8 _rsv[3];
+
+	__le16 tag;
+	__le16 len;
+	u8 tlv_buf[0];
+};
+
+enum UNI_EVENT_CSI_TAG_T {
+	UNI_EVENT_CSI_DATA = 0,
+	UNI_EVENT_CSI_MAX_NUM
+};
+
+struct csi_tlv {
+	struct {
+		__le32 tag;
+		__le32 len;
+	} basic;
+	union {
+		u8 mac[ETH_ALEN];
+		__le32 info;
+		s16 data[0];
+	};
+} __packed;
+
+struct csi_bitmap_info_update {
+	u8 action;
+	u8 addr[ETH_ALEN];
+};
+
+#define CSI_MAX_BUF_NUM	3000
+
+enum CSI_EVENT_TLV_TAG {
+	CSI_EVENT_FW_VER,
+	CSI_EVENT_CBW,
+	CSI_EVENT_RSSI,
+	CSI_EVENT_SNR,
+	CSI_EVENT_BAND,
+	CSI_EVENT_CSI_NUM,
+	CSI_EVENT_CSI_I_DATA,
+	CSI_EVENT_CSI_Q_DATA,
+	CSI_EVENT_DBW,
+	CSI_EVENT_CH_IDX,
+	CSI_EVENT_TA,
+	CSI_EVENT_EXTRA_INFO,
+	CSI_EVENT_RX_MODE,
+	CSI_EVENT_RSVD1,
+	CSI_EVENT_RSVD2,
+	CSI_EVENT_RSVD3,
+	CSI_EVENT_RSVD4,
+	CSI_EVENT_H_IDX,
+	CSI_EVENT_TX_RX_IDX,
+	CSI_EVENT_TS,
+	CSI_EVENT_PKT_SN,
+	CSI_EVENT_BW_SEG,
+	CSI_EVENT_REMAIN_LAST,
+	CSI_EVENT_TR_STREAM,
+	CSI_EVENT_TLV_TAG_NUM,
+};
+
+enum CSI_CHAIN_TYPE {
+	CSI_CHAIN_ERR,
+	CSI_CHAIN_COMPLETE,
+	CSI_CHAIN_SEGMENT_FIRST,
+	CSI_CHAIN_SEGMENT_MIDDLE,
+	CSI_CHAIN_SEGMENT_LAST,
+	CSI_CHAIN_SEGMENT_ERR,
+};
+
+enum CSI_CONTROL_MODE_T {
+	CSI_CONTROL_MODE_STOP,
+	CSI_CONTROL_MODE_START,
+	CSI_CONTROL_MODE_SET,
+	CSI_CONTROL_MODE_NUM
+};
+
+enum CSI_CONFIG_ITEM_T {
+	CSI_CONFIG_RSVD1,
+	CSI_CONFIG_WF,
+	CSI_CONFIG_RSVD2,
+	CSI_CONFIG_FRAME_TYPE,
+	CSI_CONFIG_TX_PATH,
+	CSI_CONFIG_OUTPUT_FORMAT,
+	CSI_CONFIG_INFO,
+	CSI_CONFIG_CHAIN_FILTER,
+	CSI_CONFIG_STA_FILTER,
+	CSI_CONFIG_ACTIVE_MODE,
+	CSI_CONFIG_ITEM_NUM
+};
+
+/* CSI config Tag */
+enum UNI_CMD_CSI_TAG_T {
+	UNI_CMD_CSI_STOP = 0,
+	UNI_CMD_CSI_START = 1,
+	UNI_CMD_CSI_SET_FRAME_TYPE = 2,
+	UNI_CMD_CSI_SET_CHAIN_FILTER = 3,
+	UNI_CMD_CSI_SET_STA_FILTER = 4,
+	UNI_CMD_CSI_SET_ACTIVE_MODE = 5,
+};
+#endif
+
 #endif
diff --git a/mt7996/mmio.c b/mt7996/mmio.c
index 216d19da..cda4e962 100644
--- a/mt7996/mmio.c
+++ b/mt7996/mmio.c
@@ -14,7 +14,7 @@
 #include "../trace.h"
 #include "../dma.h"
 
-static bool wed_enable;
+static bool wed_enable = true;
 module_param(wed_enable, bool, 0644);
 
 static const struct __base mt7996_reg_base[] = {
@@ -466,7 +466,8 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
 
 	dev->has_rro = true;
 
-	hif1_ofs = MT_WFDMA0_PCIE1(0) - MT_WFDMA0(0);
+	if (dev->hif2)
+		hif1_ofs = MT_WFDMA0_PCIE1(0) - MT_WFDMA0(0);
 
 	if (hif2)
 		wed = &dev->mt76.mmio.wed_hif2;
@@ -491,10 +492,16 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
 					     MT_TXQ_RING_BASE(0) +
 					     MT7996_TXQ_BAND2 * MT_RING_SIZE;
 		if (dev->has_rro) {
+			u8 rxq_id = is_mt7996(&dev->mt76) ?
+				    MT7996_RXQ_TXFREE2 : MT7996_RXQ_MCU_WA_EXT;
+
 			wed->wlan.wpdma_txfree = wed->wlan.phy_base + hif1_ofs +
 						 MT_RXQ_RING_BASE(0) +
-						 MT7996_RXQ_TXFREE2 * MT_RING_SIZE;
-			wed->wlan.txfree_tbit = ffs(MT_INT_RX_TXFREE_EXT) - 1;
+						 rxq_id * MT_RING_SIZE;
+			if (is_mt7996(&dev->mt76))
+				wed->wlan.txfree_tbit = ffs(MT_INT_RX_TXFREE_EXT) - 1;
+			else
+				wed->wlan.txfree_tbit = ffs(MT_INT_RX_TXFREE_BAND1_EXT) - 1;
 		} else {
 			wed->wlan.wpdma_txfree = wed->wlan.phy_base + hif1_ofs +
 						 MT_RXQ_RING_BASE(0) +
@@ -503,9 +510,9 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
 		}
 
 		wed->wlan.wpdma_rx_glo = wed->wlan.phy_base + hif1_ofs + MT_WFDMA0_GLO_CFG;
-		wed->wlan.wpdma_rx = wed->wlan.phy_base + hif1_ofs +
-				     MT_RXQ_RING_BASE(MT7996_RXQ_BAND0) +
-				     MT7996_RXQ_BAND0 * MT_RING_SIZE;
+		wed->wlan.wpdma_rx[0] = wed->wlan.phy_base + hif1_ofs +
+				     MT_RXQ_RING_BASE(MT7996_RXQ_BAND2) +
+				     MT7996_RXQ_BAND2 * MT_RING_SIZE;
 
 		wed->wlan.id = MT7996_DEVICE_ID_2;
 		wed->wlan.tx_tbit[0] = ffs(MT_INT_TX_DONE_BAND2) - 1;
@@ -518,16 +525,26 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
 
 		wed->wlan.wpdma_rx_glo = wed->wlan.phy_base + MT_WFDMA0_GLO_CFG;
 
-		wed->wlan.wpdma_rx = wed->wlan.phy_base +
+		wed->wlan.wpdma_rx[0] = wed->wlan.phy_base +
 				     MT_RXQ_RING_BASE(MT7996_RXQ_BAND0) +
 				     MT7996_RXQ_BAND0 * MT_RING_SIZE;
 
 		wed->wlan.wpdma_rx_rro[0] = wed->wlan.phy_base +
 					    MT_RXQ_RING_BASE(MT7996_RXQ_RRO_BAND0) +
 					    MT7996_RXQ_RRO_BAND0 * MT_RING_SIZE;
-		wed->wlan.wpdma_rx_rro[1] = wed->wlan.phy_base + hif1_ofs +
-					    MT_RXQ_RING_BASE(MT7996_RXQ_RRO_BAND2) +
-					    MT7996_RXQ_RRO_BAND2 * MT_RING_SIZE;
+		if (is_mt7996(&dev->mt76)) {
+			wed->wlan.wpdma_rx_rro[1] = wed->wlan.phy_base + hif1_ofs +
+						    MT_RXQ_RING_BASE(MT7996_RXQ_RRO_BAND2) +
+						    MT7996_RXQ_RRO_BAND2 * MT_RING_SIZE;
+		} else {
+			wed->wlan.wpdma_rx_rro[1] = wed->wlan.phy_base + hif1_ofs +
+						    MT_RXQ_RING_BASE(MT7996_RXQ_RRO_BAND1) +
+						    MT7996_RXQ_RRO_BAND1 * MT_RING_SIZE;
+			wed->wlan.wpdma_rx[1] = wed->wlan.phy_base + hif1_ofs +
+						MT_RXQ_RING_BASE(MT7996_RXQ_BAND1) +
+						MT7996_RXQ_BAND1 * MT_RING_SIZE;
+		}
+
 		wed->wlan.wpdma_rx_pg = wed->wlan.phy_base +
 					MT_RXQ_RING_BASE(MT7996_RXQ_MSDU_PG_BAND0) +
 					MT7996_RXQ_MSDU_PG_BAND0 * MT_RING_SIZE;
@@ -537,10 +554,14 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
 		wed->wlan.rx_size = SKB_WITH_OVERHEAD(MT_RX_BUF_SIZE);
 
 		wed->wlan.rx_tbit[0] = ffs(MT_INT_RX_DONE_BAND0) - 1;
-		wed->wlan.rx_tbit[1] = ffs(MT_INT_RX_DONE_BAND2) - 1;
-
 		wed->wlan.rro_rx_tbit[0] = ffs(MT_INT_RX_DONE_RRO_BAND0) - 1;
-		wed->wlan.rro_rx_tbit[1] = ffs(MT_INT_RX_DONE_RRO_BAND2) - 1;
+		if (is_mt7996(&dev->mt76)) {
+			wed->wlan.rx_tbit[1] = ffs(MT_INT_RX_DONE_BAND2) - 1;
+			wed->wlan.rro_rx_tbit[1] = ffs(MT_INT_RX_DONE_RRO_BAND2) - 1;
+		} else {
+			wed->wlan.rx_tbit[1] = ffs(MT_INT_RX_DONE_BAND1) - 1;
+			wed->wlan.rro_rx_tbit[1] = ffs(MT_INT_RX_DONE_RRO_BAND1) - 1;
+		}
 
 		wed->wlan.rx_pg_tbit[0] = ffs(MT_INT_RX_DONE_MSDU_PG_BAND0) - 1;
 		wed->wlan.rx_pg_tbit[1] = ffs(MT_INT_RX_DONE_MSDU_PG_BAND1) - 1;
@@ -548,20 +569,28 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
 
 		wed->wlan.tx_tbit[0] = ffs(MT_INT_TX_DONE_BAND0) - 1;
 		wed->wlan.tx_tbit[1] = ffs(MT_INT_TX_DONE_BAND1) - 1;
-		if (dev->has_rro) {
-			wed->wlan.wpdma_txfree = wed->wlan.phy_base + MT_RXQ_RING_BASE(0) +
-						 MT7996_RXQ_TXFREE0 * MT_RING_SIZE;
-			wed->wlan.txfree_tbit = ffs(MT_INT_RX_TXFREE_MAIN) - 1;
+		if (is_mt7996(&dev->mt76)) {
+			if (dev->has_rro) {
+				wed->wlan.wpdma_txfree = wed->wlan.phy_base + MT_RXQ_RING_BASE(0) +
+							 MT7996_RXQ_TXFREE0 * MT_RING_SIZE;
+				wed->wlan.txfree_tbit = ffs(MT_INT_RX_TXFREE_MAIN) - 1;
+			} else {
+				wed->wlan.txfree_tbit = ffs(MT_INT_RX_DONE_WA_MAIN) - 1;
+				wed->wlan.wpdma_txfree = wed->wlan.phy_base + MT_RXQ_RING_BASE(0) +
+							 MT7996_RXQ_MCU_WA_MAIN * MT_RING_SIZE;
+			}
 		} else {
 			wed->wlan.txfree_tbit = ffs(MT_INT_RX_DONE_WA_MAIN) - 1;
 			wed->wlan.wpdma_txfree = wed->wlan.phy_base + MT_RXQ_RING_BASE(0) +
-						  MT7996_RXQ_MCU_WA_MAIN * MT_RING_SIZE;
+						 MT7996_RXQ_MCU_WA_MAIN * MT_RING_SIZE;
 		}
 		dev->mt76.rx_token_size = MT7996_TOKEN_SIZE + wed->wlan.rx_npkt;
+		if(dev->hif2 && is_mt7992(&dev->mt76))
+			wed->wlan.id = 0x7992;
 	}
 
-	wed->wlan.nbuf = MT7996_HW_TOKEN_SIZE;
-	wed->wlan.token_start = MT7996_TOKEN_SIZE - wed->wlan.nbuf;
+	wed->wlan.nbuf = MT7996_TOKEN_SIZE;
+	wed->wlan.token_start = 0;
 
 	wed->wlan.amsdu_max_subframes = 8;
 	wed->wlan.amsdu_max_len = 1536;
@@ -585,6 +614,8 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
 	*irq = wed->irq;
 	dev->mt76.dma_dev = wed->dev;
 
+	dev->mt76.token_size = MT7996_SW_TOKEN_SIZE;
+
 	return 1;
 #else
 	return 0;
@@ -658,10 +689,9 @@ void mt7996_dual_hif_set_irq_mask(struct mt7996_dev *dev, bool write_reg,
 		if (mtk_wed_device_active(&mdev->mmio.wed)) {
 			mtk_wed_device_irq_set_mask(&mdev->mmio.wed,
 						    mdev->mmio.irqmask);
-			if (mtk_wed_device_active(&mdev->mmio.wed_hif2)) {
+			if (mtk_wed_device_active(&mdev->mmio.wed_hif2))
 				mtk_wed_device_irq_set_mask(&mdev->mmio.wed_hif2,
 							    mdev->mmio.irqmask);
-			}
 		} else {
 			mt76_wr(dev, MT_INT_MASK_CSR, mdev->mmio.irqmask);
 			mt76_wr(dev, MT_INT1_MASK_CSR, mdev->mmio.irqmask);
@@ -693,12 +723,18 @@ static void mt7996_irq_tasklet(struct tasklet_struct *t)
 					       dev->mt76.mmio.irqmask);
 		if (intr1 & MT_INT_RX_TXFREE_EXT)
 			napi_schedule(&dev->mt76.napi[MT_RXQ_TXFREE_BAND2]);
+
+		if (intr1 & MT_INT_RX_DONE_BAND2_EXT)
+			napi_schedule(&dev->mt76.napi[MT_RXQ_BAND2]);
+
+		if (is_mt7992(&dev->mt76) && (intr1 & MT_INT_RX_TXFREE_BAND1_EXT))
+			napi_schedule(&dev->mt76.napi[MT_RXQ_BAND1_WA]);
 	}
 
 	if (mtk_wed_device_active(wed)) {
 		mtk_wed_device_irq_set_mask(wed, 0);
 		intr = mtk_wed_device_irq_get(wed, dev->mt76.mmio.irqmask);
-		intr |= (intr1 & ~MT_INT_RX_TXFREE_EXT);
+		intr |= (intr1 & ~MT_INT_TX_RX_DONE_EXT);
 	} else {
 		mt76_wr(dev, MT_INT_MASK_CSR, 0);
 		if (dev->hif2)
diff --git a/mt7996/mt7996.h b/mt7996/mt7996.h
index 6723df6d..aacf90a5 100644
--- a/mt7996/mt7996.h
+++ b/mt7996/mt7996.h
@@ -8,6 +8,7 @@
 
 #include <linux/interrupt.h>
 #include <linux/ktime.h>
+#include <linux/pci.h>
 #include "../mt76_connac.h"
 #include "regs.h"
 
@@ -43,23 +44,33 @@
 #define MT7996_FIRMWARE_WA		"mediatek/mt7996/mt7996_wa.bin"
 #define MT7996_FIRMWARE_WM		"mediatek/mt7996/mt7996_wm.bin"
 #define MT7996_FIRMWARE_DSP		"mediatek/mt7996/mt7996_dsp.bin"
+#define MT7996_FIRMWARE_WM_TM		"mediatek/mt7996/mt7996_wm_tm.bin"
 #define MT7996_ROM_PATCH		"mediatek/mt7996/mt7996_rom_patch.bin"
 
 #define MT7996_FIRMWARE_WA_233		"mediatek/mt7996/mt7996_wa_233.bin"
 #define MT7996_FIRMWARE_WM_233		"mediatek/mt7996/mt7996_wm_233.bin"
 #define MT7996_FIRMWARE_DSP_233		MT7996_FIRMWARE_DSP
+#define MT7996_FIRMWARE_WM_TM_233	"mediatek/mt7996/mt7996_wm_tm_233.bin"
 #define MT7996_ROM_PATCH_233		"mediatek/mt7996/mt7996_rom_patch_233.bin"
 
 #define MT7992_FIRMWARE_WA		"mediatek/mt7996/mt7992_wa.bin"
 #define MT7992_FIRMWARE_WM		"mediatek/mt7996/mt7992_wm.bin"
 #define MT7992_FIRMWARE_DSP		"mediatek/mt7996/mt7992_dsp.bin"
+#define MT7992_FIRMWARE_WM_TM		"mediatek/mt7996/mt7992_wm_tm.bin"
 #define MT7992_ROM_PATCH		"mediatek/mt7996/mt7992_rom_patch.bin"
 
 #define MT7992_FIRMWARE_WA_23		"mediatek/mt7996/mt7992_wa_23.bin"
 #define MT7992_FIRMWARE_WM_23		"mediatek/mt7996/mt7992_wm_23.bin"
 #define MT7992_FIRMWARE_DSP_23		"mediatek/mt7996/mt7992_dsp_23.bin"
+#define MT7992_FIRMWARE_WM_TM_23	"mediatek/mt7996/mt7992_wm_tm_23.bin"
 #define MT7992_ROM_PATCH_23		"mediatek/mt7996/mt7992_rom_patch_23.bin"
 
+#define MT7992_FIRMWARE_WA_24		"mediatek/mt7996/mt7992_wa_24.bin"
+#define MT7992_FIRMWARE_WM_24		"mediatek/mt7996/mt7992_wm_24.bin"
+#define MT7992_FIRMWARE_DSP_24		"mediatek/mt7996/mt7992_dsp_24.bin"
+#define MT7992_FIRMWARE_WM_TM_24	"mediatek/mt7996/mt7992_wm_tm_24.bin"
+#define MT7992_ROM_PATCH_24		"mediatek/mt7996/mt7992_rom_patch_24.bin"
+
 #define MT7990_FIRMWARE_WA		""
 #define MT7990_FIRMWARE_WM		"mediatek/mt7996/mt7990_wm.bin"
 #define MT7990_FIRMWARE_DSP		""
@@ -69,12 +80,14 @@
 #define MT7996_EEPROM_DEFAULT_INT	"mediatek/mt7996/mt7996_eeprom_2i5i6i.bin"
 #define MT7996_EEPROM_DEFAULT_233	"mediatek/mt7996/mt7996_eeprom_233.bin"
 #define MT7996_EEPROM_DEFAULT_233_INT	"mediatek/mt7996/mt7996_eeprom_233_2i5i6i.bin"
+#define MT7996_EEPROM_DEFAULT_404	"mediatek/mt7996/mt7996_eeprom_dual_404.bin"
 
 #define MT7992_EEPROM_DEFAULT		"mediatek/mt7996/mt7992_eeprom.bin"
 #define MT7992_EEPROM_DEFAULT_INT	"mediatek/mt7996/mt7992_eeprom_2i5i.bin"
 #define MT7992_EEPROM_DEFAULT_MIX	"mediatek/mt7996/mt7992_eeprom_2i5e.bin"
 #define MT7992_EEPROM_DEFAULT_23	"mediatek/mt7996/mt7992_eeprom_23.bin"
 #define MT7992_EEPROM_DEFAULT_23_INT	"mediatek/mt7996/mt7992_eeprom_23_2i5i.bin"
+#define MT7992_EEPROM_DEFAULT_24	"mediatek/mt7996/mt7992_eeprom_24_2i5i.bin"
 
 #define MT7990_EEPROM_DEFAULT		"mediatek/mt7996/mt7990_eeprom.bin"
 #define MT7990_EEPROM_DEFAULT_INT	"mediatek/mt7996/mt7990_eeprom_2i5i.bin"
@@ -83,6 +96,7 @@
 #define MT7996_EEPROM_BLOCK_SIZE	16
 #define MT7996_TOKEN_SIZE		16384
 #define MT7996_HW_TOKEN_SIZE		8192
+#define MT7996_SW_TOKEN_SIZE		15360
 
 #define MT7996_CFEND_RATE_DEFAULT	0x49	/* OFDM 24M */
 #define MT7996_CFEND_RATE_11B		0x03	/* 11B LP, 11M */
@@ -112,6 +126,9 @@
 #define MT7996_CRIT_TEMP		110
 #define MT7996_MAX_TEMP			120
 
+#define MT7996_BUILD_TIME_LEN		24
+
+#define MT7996_RRO_MSDU_PG_HASH_SIZE	127
 #define MT7996_RRO_MAX_SESSION		1024
 #define MT7996_RRO_WINDOW_MAX_LEN	1024
 #define MT7996_RRO_ADDR_ELEM_LEN	128
@@ -128,6 +145,25 @@
 #define MT7996_RX_MSDU_PAGE_SIZE	(128 + \
 					 SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))
 
+#define MT7996_DRR_STA_BSS_GRP_MASK	GENMASK(5, 0)
+#define MT7996_DRR_STA_AC0_QNTM_MASK	GENMASK(10, 8)
+#define MT7996_DRR_STA_AC1_QNTM_MASK	GENMASK(14, 12)
+#define MT7996_DRR_STA_AC2_QNTM_MASK	GENMASK(18, 16)
+#define MT7996_DRR_STA_AC3_QNTM_MASK	GENMASK(22, 20)
+
+/* RRO 3.1 */
+#define MT7996_RRO_MSDU_PG_CR_CNT 8
+#define MT7996_RRO_MSDU_PG_SIZE_PER_CR 0x10000
+
+#define to_rssi(field, rcpi)	((FIELD_GET(field, rcpi) - 220) / 2)
+
+#define MT7996_MAX_BEACON_LOSS		20
+#define MT7996_MAX_PROBE_TIMEOUT	500
+#define MT7996_MAX_PROBE_TRIES		2
+
+#define MT7996_HW_DROP_STAT	4
+#define MT7996_HW_DROP_REASON	0x20
+
 struct mt7996_vif;
 struct mt7996_sta;
 struct mt7996_dfs_pulse;
@@ -135,18 +171,22 @@ struct mt7996_dfs_pattern;
 
 enum mt7996_ram_type {
 	MT7996_RAM_TYPE_WM,
+	MT7996_RAM_TYPE_WM_TM = MT7996_RAM_TYPE_WM,
 	MT7996_RAM_TYPE_WA,
 	MT7996_RAM_TYPE_DSP,
+	__MT7996_RAM_TYPE_MAX,
 };
 
 enum mt7996_var_type {
 	MT7996_VAR_TYPE_444,
 	MT7996_VAR_TYPE_233,
+	MT7996_VAR_TYPE_404,
 };
 
 enum mt7992_var_type {
 	MT7992_VAR_TYPE_44,
 	MT7992_VAR_TYPE_23,
+	MT7992_VAR_TYPE_24,
 };
 
 enum mt7990_var_type {
@@ -159,6 +199,14 @@ enum mt7996_fem_type {
 	MT7996_FEM_MIX,
 };
 
+enum mt7996_coredump_state {
+	MT7996_COREDUMP_IDLE = 0,
+	MT7996_COREDUMP_MANUAL_WA,
+	MT7996_COREDUMP_MANUAL_WM,
+	MT7996_COREDUMP_AUTO,
+	__MT7996_COREDUMP_TYPE_MAX,
+};
+
 enum mt7996_txq_id {
 	MT7996_TXQ_FWDL = 16,
 	MT7996_TXQ_MCU_WM,
@@ -178,7 +226,7 @@ enum mt7996_rxq_id {
 	MT7996_RXQ_BAND1 = 5, /* for mt7992 */
 	MT7996_RXQ_BAND2 = 5,
 	MT7996_RXQ_RRO_BAND0 = 8,
-	MT7996_RXQ_RRO_BAND1 = 8,/* unused */
+	MT7996_RXQ_RRO_BAND1 = 9,
 	MT7996_RXQ_RRO_BAND2 = 6,
 	MT7996_RXQ_MSDU_PG_BAND0 = 10,
 	MT7996_RXQ_MSDU_PG_BAND1 = 11,
@@ -209,13 +257,98 @@ struct mt7996_twt_flow {
 
 DECLARE_EWMA(avg_signal, 10, 8)
 
+enum mt7996_dpd_ch_num {
+	DPD_CH_NUM_BW20_2G,
+	DPD_CH_NUM_BW20_5G,
+	DPD_CH_NUM_BW20_5G_SKIP,
+	DPD_CH_NUM_BW80_5G,
+	DPD_CH_NUM_BW160_5G,
+	DPD_CH_NUM_BW20_6G,
+	DPD_CH_NUM_BW80_6G,
+	DPD_CH_NUM_BW160_6G,
+	DPD_CH_NUM_BW320_6G,
+	DPD_CH_NUM_TYPE_MAX,
+};
+
+enum {
+	VOW_SEARCH_AC_FIRST,
+	VOW_SEARCH_WMM_FIRST
+};
+
+enum {
+	VOW_REFILL_PERIOD_1US,
+	VOW_REFILL_PERIOD_2US,
+	VOW_REFILL_PERIOD_4US,
+	VOW_REFILL_PERIOD_8US,
+	VOW_REFILL_PERIOD_16US,
+	VOW_REFILL_PERIOD_32US,
+	VOW_REFILL_PERIOD_64US,
+	VOW_REFILL_PERIOD_128US
+};
+
+/* Default DRR airtime quantum of each level */
+enum {
+	VOW_DRR_QUANTUM_L0 = 6,
+	VOW_DRR_QUANTUM_L1 = 12,
+	VOW_DRR_QUANTUM_L2 = 16,
+	VOW_DRR_QUANTUM_L3 = 20,
+	VOW_DRR_QUANTUM_L4 = 24,
+	VOW_DRR_QUANTUM_L5 = 28,
+	VOW_DRR_QUANTUM_L6 = 32,
+	VOW_DRR_QUANTUM_L7 = 36
+};
+
+enum {
+	VOW_DRR_QUANTUM_IDX0,
+	VOW_DRR_QUANTUM_IDX1,
+	VOW_DRR_QUANTUM_IDX2,
+	VOW_DRR_QUANTUM_IDX3,
+	VOW_DRR_QUANTUM_IDX4,
+	VOW_DRR_QUANTUM_IDX5,
+	VOW_DRR_QUANTUM_IDX6,
+	VOW_DRR_QUANTUM_IDX7,
+	VOW_DRR_QUANTUM_NUM
+};
+
+enum {
+	VOW_SCH_TYPE_FOLLOW_POLICY,
+	VOW_SCH_TYPE_FOLLOW_HW
+};
+
+enum {
+	VOW_SCH_POLICY_SRR, /* Shared Round-Robin */
+	VOW_SCH_POLICY_WRR /* Weighted Round-Robin */
+};
+
+enum vow_drr_ctrl_id {
+	VOW_DRR_CTRL_STA_ALL,
+	VOW_DRR_CTRL_STA_BSS_GROUP,
+	VOW_DRR_CTRL_AIRTIME_DEFICIT_BOUND = 0x10,
+	VOW_DRR_CTRL_AIRTIME_QUANTUM_ALL = 0x28,
+	VOW_DRR_CTRL_STA_PAUSE = 0x30
+};
+
+struct mt7996_vow_ctrl {
+	bool atf_enable;
+	bool watf_enable;
+	u8 drr_quantum[VOW_DRR_QUANTUM_NUM];
+	u8 max_deficit;
+	u8 sch_type;
+	u8 sch_policy;
+};
+
+struct mt7996_vow_sta_ctrl {
+	bool paused;
+	u8 bss_grp_idx;
+	u8 drr_quantum[IEEE80211_NUM_ACS];
+};
+
 struct mt7996_sta_link {
 	struct mt76_wcid wcid; /* must be first */
 
 	struct mt7996_sta *sta;
 
 	struct list_head rc_list;
-	u32 airtime_ac[8];
 
 	int ack_signal;
 	struct ewma_avg_signal avg_ack_signal;
@@ -230,6 +363,7 @@ struct mt7996_sta_link {
 	} twt;
 
 	struct rcu_head rcu_head;
+	struct mt7996_vow_sta_ctrl vow;
 };
 
 struct mt7996_sta {
@@ -238,6 +372,7 @@ struct mt7996_sta {
 	u8 deflink_id;
 
 	struct mt7996_vif *vif;
+	u8 sec_link;
 };
 
 struct mt7996_vif_link {
@@ -245,7 +380,6 @@ struct mt7996_vif_link {
 
 	struct mt7996_sta_link msta_link;
 	struct mt7996_phy *phy;
-
 	struct ieee80211_tx_queue_params queue_params[IEEE80211_NUM_ACS];
 	struct cfg80211_bitrate_mask bitrate_mask;
 
@@ -258,12 +392,23 @@ struct mt7996_vif {
 
 	u8 mld_group_idx;
 	u8 mld_remap_idx;
+	struct mt7996_sta sta;
+	struct mt7996_dev *dev;
+
+	/* for beacon monitoring */
+	struct delayed_work beacon_mon_work;
+	unsigned long beacon_received_time[__MT_MAX_BAND];
+	u16 lost_links;
+	void *probe[__MT_MAX_BAND];
+	unsigned long probe_send_time[__MT_MAX_BAND];
+	int probe_send_count[__MT_MAX_BAND];
 };
 
 /* crash-dump */
 struct mt7996_crash_data {
 	guid_t guid;
 	struct timespec64 timestamp;
+	bool supported;
 
 	u8 *memdump_buf;
 	size_t memdump_buf_len;
@@ -275,6 +420,18 @@ struct mt7996_hif {
 	struct device *dev;
 	void __iomem *regs;
 	int irq;
+	enum pci_bus_speed speed;
+	enum pcie_link_width width;
+};
+
+struct mt7996_scs_ctrl {
+	u8 scs_enable;
+	s8 sta_min_rssi;
+};
+
+enum {
+	SCS_DISABLE = 0,
+	SCS_ENABLE,
 };
 
 struct mt7996_wed_rro_addr {
@@ -291,6 +448,95 @@ struct mt7996_wed_rro_session_id {
 	u16 id;
 };
 
+struct mt7996_sta_rc_work_data {
+	unsigned int link_id;
+	u32 changed;
+};
+
+#ifdef CONFIG_MTK_VENDOR
+#define MT7996_AIR_MONITOR_MAX_ENTRY	16
+#define MT7996_AIR_MONITOR_MAX_GROUP	(MT7996_AIR_MONITOR_MAX_ENTRY >> 1)
+
+struct mt7996_air_monitor_group {
+	bool enable;
+	bool used[2];
+};
+
+struct mt7996_air_monitor_entry {
+	bool enable;
+
+	u8 group_idx;
+	u8 group_used_idx;
+	u8 muar_idx;
+	u8 addr[ETH_ALEN];
+	u32 last_seen;
+	s8 rssi[4];
+	struct ieee80211_sta *sta;
+};
+
+struct mt7996_air_monitor_ctrl {
+	u8 enable;
+	struct mt7996_air_monitor_group group[MT7996_AIR_MONITOR_MAX_GROUP];
+	struct mt7996_air_monitor_entry entry[MT7996_AIR_MONITOR_MAX_ENTRY];
+};
+
+enum {
+	CSI_BW20,
+	CSI_BW40,
+	CSI_BW80,
+	CSI_BW160,
+	CSI_BW320
+};
+
+#define CSI_BW20_DATA_COUNT	64
+#define CSI_BW40_DATA_COUNT	128
+#define CSI_BW80_DATA_COUNT	256
+#define CSI_BW160_DATA_COUNT	512
+#define CSI_BW320_DATA_COUNT	1024
+
+struct csi_data {
+	u8 fw_ver;
+	u8 ch_bw;
+	u16 data_num;
+	s16 data_i[CSI_BW320_DATA_COUNT];
+	s16 data_q[CSI_BW320_DATA_COUNT];
+	u8 band;
+	s8 rssi;
+	u8 snr;
+	u32 ts;
+	u8 data_bw;
+	u8 pri_ch_idx;
+	u8 ta[ETH_ALEN];
+	u32 ext_info;
+	u16 rx_mode;
+	u16 rx_rate;
+	u32 chain_info;
+	u16 tx_idx;
+	u16 rx_idx;
+	u32 segment_num;
+	u8 remain_last;
+	u16 pkt_sn;
+	u8 tr_stream;
+
+	struct list_head node;
+};
+#endif
+
+struct mt7996_rro_ba_session {
+	u32 ack_sn         :12;
+	u32 win_sz         :3;
+	u32 bn             :1;
+	u32 last_in_sn     :12;
+	u32 bc             :1;
+	u32 bd             :1;
+	u32 sat            :1;
+	u32 cn             :1;
+	u32 within_cnt     :12;
+	u32 to_sel         :3;
+	u32 rsv            :1;
+	u32 last_in_rxtime :12;
+};
+
 struct mt7996_phy {
 	struct mt76_phy *mt76;
 	struct mt7996_dev *dev;
@@ -318,12 +564,61 @@ struct mt7996_phy {
 
 	struct mt76_mib_stats mib;
 	struct mt76_channel_state state_ts;
+	struct delayed_work ipi_work;
 
 	u16 orig_chainmask;
 	u16 orig_antenna_mask;
 
 	bool has_aux_rx;
 	bool counter_reset;
+
+	u8 pp_mode;
+	u16 punct_bitmap;
+
+	struct mt7996_scs_ctrl scs_ctrl;
+	u32 hw_drop[MT7996_HW_DROP_STAT][MT7996_HW_DROP_REASON];
+
+	bool sku_limit_en;
+	bool sku_path_en;
+
+	u8 muru_onoff;
+
+#ifdef CONFIG_NL80211_TESTMODE
+	struct {
+		u32 *reg_backup;
+
+		s32 last_freq_offset;
+		u8 last_rcpi[4];
+		s8 last_rssi[4];
+		s8 last_ib_rssi[4];
+		s8 last_wb_rssi[4];
+		u8 last_snr;
+
+		u8 spe_idx;
+	} test;
+#endif
+#ifdef CONFIG_MTK_VENDOR
+	u8 rts_bw_sig;
+	spinlock_t amnt_lock;
+	struct mt7996_air_monitor_ctrl amnt_ctrl;
+
+	struct {
+		struct list_head list;
+		spinlock_t lock;
+		u32 count;
+		bool enable;
+
+		struct csi_data buffered_csi;
+		u32 active_bitmap;
+		u32 interval;
+		u32 last_record;
+	} csi;
+#endif
+#ifdef CONFIG_MTK_DEBUG
+	bool sr_enable:1;
+	bool enhanced_sr_enable:1;
+	bool thermal_protection_enable:1;
+#endif
 };
 
 struct mt7996_dev {
@@ -360,9 +655,12 @@ struct mt7996_dev {
 	struct work_struct rc_work;
 	struct work_struct dump_work;
 	struct work_struct reset_work;
+	struct delayed_work scs_work;
 	wait_queue_head_t reset_wait;
 	struct {
 		u32 state;
+		u32 l1_reset;
+		u32 l1_reset_last;
 		u32 wa_reset_count;
 		u32 wm_reset_count;
 		bool hw_full_reset:1;
@@ -372,11 +670,14 @@ struct mt7996_dev {
 
 	/* protects coredump data */
 	struct mutex dump_mutex;
+	u8 dump_state;
 #ifdef CONFIG_DEV_COREDUMP
 	struct {
-		struct mt7996_crash_data *crash_data;
+		struct mt7996_crash_data *crash_data[__MT7996_RAM_TYPE_MAX];
 	} coredump;
 #endif
+	char patch_build_date[MT7996_BUILD_TIME_LEN];
+	char ram_build_date[__MT7996_RAM_TYPE_MAX][MT7996_BUILD_TIME_LEN];
 
 	struct list_head sta_rc_list;
 	struct list_head twt_list;
@@ -400,20 +701,44 @@ struct mt7996_dev {
 			void *ptr;
 			dma_addr_t phy_addr;
 		} session;
+		struct {
+			void *ptr;
+			dma_addr_t phy_addr;
+		} msdu_pg[MT7996_RRO_MSDU_PG_CR_CNT];
 
 		struct work_struct work;
 		struct list_head poll_list;
 		spinlock_t lock;
+
+		struct list_head pg_addr_cache;
+		struct list_head pg_hash_head[MT7996_RRO_MSDU_PG_HASH_SIZE];
 	} wed_rro;
 
+	bool testmode_enable;
+	bool bin_file_mode;
+	u8 eeprom_mode;
+	u32 bg_nxt_freq;
+
+	u32 option_type;
+
 	bool ibf;
 	u8 fw_debug_wm;
 	u8 fw_debug_wa;
 	u8 fw_debug_bin;
 	u16 fw_debug_seq;
+	bool fw_debug_muru_disable;
+	bool idxlog_enable;
 
 	struct dentry *debugfs_dir;
 	struct rchan *relay_fwlog;
+	struct rchan *relay_idxlog;
+
+	void *cal;
+	u32 cur_prek_offset;
+	struct {
+		const u32 *rev;
+		u8 dpd_ch_num[DPD_CH_NUM_TYPE_MAX];
+	} prek;
 
 	struct {
 		u16 table_mask;
@@ -427,6 +752,46 @@ struct mt7996_dev {
 		u8 type:4;
 		u8 fem:4;
 	} var;
+
+	struct mt7996_vow_ctrl vow;
+
+	bool wmm_pbc_enable;
+	struct work_struct wmm_pbc_work;
+#ifdef CONFIG_MTK_DEBUG
+	u16 wlan_idx;
+	struct {
+		u8 sku_disable;
+		u32 fw_dbg_module;
+		u8 fw_dbg_lv;
+		u32 bcn_total_cnt[__MT_MAX_BAND];
+		u32 sid;
+
+		bool dump_mcu_pkt:1;
+		bool dump_mcu_event:1;
+		bool dump_txd:1;
+		bool dump_tx_pkt:1;
+		bool dump_rx_pkt:1;
+		bool dump_rx_raw:1;
+		u8 dump_ple_txd;
+		u32 token_idx;
+		u32 rxd_read_cnt;
+		u32 txd_read_cnt;
+		u32 fid_idx;
+	} dbg;
+	const struct mt7996_dbg_reg_desc *dbg_reg;
+	bool red_enable:1;
+#endif
+#ifdef CONFIG_MTK_VENDOR
+	bool cert_mode;
+#endif
+
+#if defined CONFIG_NL80211_TESTMODE || defined CONFIG_MTK_DEBUG
+	struct {
+		void *txbf_phase_cal;
+		void *txbf_pfmu_data;
+		void *txbf_pfmu_tag;
+	} test;
+#endif
 };
 
 enum {
@@ -456,6 +821,7 @@ enum mt7996_rdd_cmd {
 	RDD_READ_PULSE,
 	RDD_RESUME_BF,
 	RDD_IRQ_OFF,
+	RDD_DISABLE_ZW_TIMER,
 };
 
 static inline int
@@ -510,6 +876,9 @@ mt7996_band_valid(struct mt7996_dev *dev, u8 band)
 	if (!is_mt7996(&dev->mt76))
 		return band <= MT_BAND1;
 
+	if (dev->var.type == MT7996_VAR_TYPE_404 && band == MT_BAND1)
+		return false;
+
 	return band <= MT_BAND2;
 }
 
@@ -557,10 +926,12 @@ mt7996_vif_conf_link(struct mt7996_dev *dev, struct ieee80211_vif *vif,
 extern const struct ieee80211_ops mt7996_ops;
 extern struct pci_driver mt7996_pci_driver;
 extern struct pci_driver mt7996_hif_driver;
+extern const struct mt76_testmode_ops mt7996_testmode_ops;
 
 struct mt7996_dev *mt7996_mmio_probe(struct device *pdev,
 				     void __iomem *mem_base, u32 device_id);
 void mt7996_wfsys_reset(struct mt7996_dev *dev);
+void mt7996_rro_hw_init(struct mt7996_dev *dev);
 irqreturn_t mt7996_irq_handler(int irq, void *dev_instance);
 u64 __mt7996_get_tsf(struct ieee80211_hw *hw, struct mt7996_vif_link *link);
 int mt7996_register_device(struct mt7996_dev *dev);
@@ -571,7 +942,9 @@ int mt7996_vif_link_add(struct mt76_phy *mphy, struct ieee80211_vif *vif,
 void mt7996_vif_link_remove(struct mt76_phy *mphy, struct ieee80211_vif *vif,
 			    struct ieee80211_bss_conf *link_conf,
 			    struct mt76_vif_link *mlink);
+const char *mt7996_eeprom_name(struct mt7996_dev *dev);
 int mt7996_eeprom_init(struct mt7996_dev *dev);
+int mt7996_eeprom_check_fw_mode(struct mt7996_dev *dev);
 int mt7996_eeprom_parse_hw_cap(struct mt7996_dev *dev, struct mt7996_phy *phy);
 int mt7996_eeprom_get_target_power(struct mt7996_dev *dev,
 				   struct ieee80211_channel *chan);
@@ -586,7 +959,9 @@ int mt7996_init_tx_queues(struct mt7996_phy *phy, int idx,
 			  int n_desc, int ring_base, struct mtk_wed_device *wed);
 void mt7996_init_txpower(struct mt7996_phy *phy);
 int mt7996_txbf_init(struct mt7996_dev *dev);
+int mt7996_get_chip_sku(struct mt7996_dev *dev);
 void mt7996_reset(struct mt7996_dev *dev);
+void mt7996_coredump(struct mt7996_dev *dev, u8 state);
 int mt7996_run(struct mt7996_phy *phy);
 int mt7996_mcu_init(struct mt7996_dev *dev);
 int mt7996_mcu_init_firmware(struct mt7996_dev *dev);
@@ -620,7 +995,7 @@ int mt7996_mcu_update_bss_color(struct mt7996_dev *dev,
 				struct mt76_vif_link *mlink,
 				struct cfg80211_he_bss_color *he_bss_color);
 int mt7996_mcu_add_beacon(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
-			  struct ieee80211_bss_conf *link_conf);
+			  struct ieee80211_bss_conf *link_conf, int en);
 int mt7996_mcu_beacon_inband_discov(struct mt7996_dev *dev,
 				    struct ieee80211_bss_conf *link_conf,
 				    struct mt7996_vif_link *link, u32 changed);
@@ -657,8 +1032,11 @@ int mt7996_mcu_get_chan_mib_info(struct mt7996_phy *phy, bool chan_switch);
 int mt7996_mcu_get_temperature(struct mt7996_phy *phy);
 int mt7996_mcu_set_thermal_throttling(struct mt7996_phy *phy, u8 state);
 int mt7996_mcu_set_thermal_protect(struct mt7996_phy *phy, bool enable);
-int mt7996_mcu_set_txpower_sku(struct mt7996_phy *phy);
+int mt7996_mcu_set_txpower_sku(struct mt7996_phy *phy,
+			       struct ieee80211_bss_conf *conf);
 int mt7996_mcu_rdd_cmd(struct mt7996_dev *dev, int cmd, u8 rdd_idx, u8 val);
+int mt7996_mcu_rdd_background_disable_timer(struct mt7996_dev *dev,
+					    bool disable_timer);
 int mt7996_mcu_rdd_background_enable(struct mt7996_phy *phy,
 				     struct cfg80211_chan_def *chandef);
 int mt7996_mcu_set_fixed_rate_table(struct mt7996_phy *phy, u8 table_idx,
@@ -667,14 +1045,35 @@ int mt7996_mcu_rf_regval(struct mt7996_dev *dev, u32 regidx, u32 *val, bool set)
 int mt7996_mcu_set_hdr_trans(struct mt7996_dev *dev, bool hdr_trans);
 int mt7996_mcu_set_rro(struct mt7996_dev *dev, u16 tag, u16 val);
 int mt7996_mcu_wa_cmd(struct mt7996_dev *dev, int cmd, u32 a1, u32 a2, u32 a3);
+int mt7996_mcu_red_config(struct mt7996_dev *dev, bool enable);
 int mt7996_mcu_fw_log_2_host(struct mt7996_dev *dev, u8 type, u8 ctrl);
 int mt7996_mcu_fw_dbg_ctrl(struct mt7996_dev *dev, u32 module, u8 level);
+int mt7996_mcu_fw_time_sync(struct mt76_dev *dev);
 int mt7996_mcu_trigger_assert(struct mt7996_dev *dev);
 void mt7996_mcu_rx_event(struct mt7996_dev *dev, struct sk_buff *skb);
 void mt7996_mcu_exit(struct mt7996_dev *dev);
-int mt7996_mcu_get_all_sta_info(struct mt7996_phy *phy, u16 tag);
+int mt7996_mcu_get_per_sta_info(struct mt76_dev *dev, u16 tag,
+	                        u16 sta_num, u16 *sta_list);
+int mt7996_mcu_get_rssi(struct mt76_dev *dev);
+int mt7996_mcu_get_all_sta_info(struct mt76_dev *dev, u16 tag);
 int mt7996_mcu_wed_rro_reset_sessions(struct mt7996_dev *dev, u16 id);
 int mt7996_mcu_set_sniffer_mode(struct mt7996_phy *phy, bool enabled);
+int mt7996_mcu_set_tx_power_ctrl(struct mt7996_phy *phy, u8 power_ctrl_id, u8 data);
+int mt7996_mcu_get_tx_power_info(struct mt7996_phy *phy, u8 category, void *event);
+int mt7996_mcu_apply_group_cal(struct mt7996_dev *dev);
+int mt7996_mcu_apply_tx_dpd(struct mt7996_phy *phy);
+#ifdef CONFIG_NL80211_TESTMODE
+void mt7996_tm_rf_test_event(struct mt7996_dev *dev, struct sk_buff *skb);
+#endif
+int mt7996_mcu_set_scs(struct mt7996_phy *phy, u8 enable);
+void mt7996_mcu_scs_sta_poll(struct work_struct *work);
+int mt7996_mcu_set_band_confg(struct mt7996_phy *phy, u16 option, bool enable);
+int mt7996_mcu_set_vow_drr_ctrl(struct mt7996_phy *phy,
+				struct mt7996_vif_link *mconf,
+				struct mt7996_sta_link *msta_link,
+				enum vow_drr_ctrl_id id);
+int mt7996_mcu_set_vow_feature_ctrl(struct mt7996_phy *phy);
+void mt7996_mcu_wmm_pbc_work(struct work_struct *work);
 
 static inline u8 mt7996_max_interface_num(struct mt7996_dev *dev)
 {
@@ -729,6 +1128,14 @@ static inline bool mt7996_has_wa(struct mt7996_dev *dev)
 	return !is_mt7990(&dev->mt76);
 }
 
+static inline bool
+mt7996_vow_should_enable(struct mt7996_dev *dev)
+{
+	return !wiphy_ext_feature_isset(mt76_hw(dev)->wiphy,
+	                                NL80211_EXT_FEATURE_AIRTIME_FAIRNESS) ||
+	       mtk_wed_device_active(&dev->mt76.mmio.wed);
+}
+
 void mt7996_mac_init(struct mt7996_dev *dev);
 u32 mt7996_mac_wtbl_lmac_addr(struct mt7996_dev *dev, u16 wcid, u8 dw);
 bool mt7996_mac_wtbl_update(struct mt7996_dev *dev, int idx, u32 mask);
@@ -762,15 +1169,17 @@ void mt7996_queue_rx_skb(struct mt76_dev *mdev, enum mt76_rxq_id q,
 			 struct sk_buff *skb, u32 *info);
 bool mt7996_rx_check(struct mt76_dev *mdev, void *data, int len);
 void mt7996_stats_work(struct work_struct *work);
+void mt7996_beacon_mon_work(struct work_struct *work);
 int mt76_dfs_start_rdd(struct mt7996_dev *dev, bool force);
 int mt7996_dfs_init_radar_detector(struct mt7996_phy *phy);
 void mt7996_set_stream_he_eht_caps(struct mt7996_phy *phy);
 void mt7996_set_stream_vht_txbf_caps(struct mt7996_phy *phy);
 void mt7996_update_channel(struct mt76_phy *mphy);
-int mt7996_init_debugfs(struct mt7996_dev *dev);
+int mt7996_init_dev_debugfs(struct mt7996_phy *phy);
+int mt7996_init_band_debugfs(struct mt7996_phy *phy);
 void mt7996_debugfs_rx_fw_monitor(struct mt7996_dev *dev, const void *data, int len);
 bool mt7996_debugfs_rx_log(struct mt7996_dev *dev, const void *data, int len);
-int mt7996_mcu_add_key(struct mt76_dev *dev, struct ieee80211_vif *vif,
+int mt7996_mcu_add_key(struct mt76_dev *dev, struct mt7996_vif_link *mconf,
 		       struct ieee80211_key_conf *key, int mcu_cmd,
 		       struct mt76_wcid *wcid, enum set_key_cmd cmd);
 int mt7996_mcu_bcn_prot_enable(struct mt7996_dev *dev,
@@ -782,16 +1191,88 @@ int mt7996_mcu_wtbl_update_hdr_trans(struct mt7996_dev *dev,
 				     struct mt7996_vif_link *link,
 				     struct mt7996_sta_link *msta_link);
 int mt7996_mcu_cp_support(struct mt7996_dev *dev, u8 mode);
+int mt7996_mcu_set_pp_en(struct mt7996_phy *phy, u8 mode, u16 bitmap);
 #ifdef CONFIG_MAC80211_DEBUGFS
 void mt7996_sta_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			    struct ieee80211_sta *sta, struct dentry *dir);
+void mt7996_vif_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
+void mt7996_link_sta_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+				 struct ieee80211_link_sta *link_sta,
+				 struct dentry *dir);
+void mt7996_link_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			     struct ieee80211_bss_conf *link_conf, struct dentry *dir);
 #endif
 int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
 			 bool hif2, int *irq);
 u32 mt7996_wed_init_buf(void *ptr, dma_addr_t phys, int token_id);
 
+#ifdef CONFIG_MTK_VENDOR
+void mt7996_set_wireless_vif(void *data, u8 *mac, struct ieee80211_vif *vif);
+void mt7996_vendor_register(struct mt7996_phy *phy);
+void mt7996_vendor_amnt_fill_rx(struct mt7996_phy *phy, struct sk_buff *skb);
+int mt7996_vendor_amnt_sta_remove(struct mt7996_phy *phy,
+				  struct ieee80211_sta *sta);
+void mt7996_set_wireless_amsdu(struct ieee80211_hw *hw, u8 en);
+void mt7996_mcu_set_mimo(struct mt7996_phy *phy);
+int mt7996_set_muru_cfg(struct mt7996_phy *phy, u8 action, u8 val);
+int mt7996_mcu_set_muru_cfg(struct mt7996_phy *phy, void *data);
+void mt7996_set_beacon_vif(struct ieee80211_vif *vif, u8 val);
+int mt7996_mcu_set_csi(struct mt7996_phy *phy, u8 mode,
+		       u8 cfg, u8 v1, u32 v2, u8 *mac_addr);
+#endif
+
+int mt7996_mcu_edcca_enable(struct mt7996_phy *phy, bool enable);
+int mt7996_mcu_edcca_threshold_ctrl(struct mt7996_phy *phy, u8 *value, bool set);
+
+enum edcca_bw_id {
+	EDCCA_BW_20 = 0,
+	EDCCA_BW_40,
+	EDCCA_BW_80,
+	EDCCA_BW_160,
+	EDCCA_MAX_BW_NUM,
+};
+
 #ifdef CONFIG_MTK_DEBUG
-int mt7996_mtk_init_debugfs(struct mt7996_phy *phy, struct dentry *dir);
+void mt7996_mtk_init_dev_debugfs(struct mt7996_dev *dev, struct dentry *dir);
+void mt7996_mtk_init_band_debugfs(struct mt7996_phy *phy, struct dentry *dir);
+int mt7996_mcu_muru_dbg_info(struct mt7996_dev *dev, u16 item, u8 val);
+int mt7996_mcu_set_sr_enable(struct mt7996_phy *phy, u8 action, u64 val, bool set);
+void mt7996_mcu_rx_sr_event(struct mt7996_dev *dev, struct sk_buff *skb);
+int mt7996_mcu_set_dup_wtbl(struct mt7996_dev *dev);
+int mt7996_mcu_set_txbf_internal(struct mt7996_phy *phy, u8 action, int idx, bool bfer);
+void mt7996_mcu_rx_bf_event(struct mt7996_dev *dev, struct sk_buff *skb);
+int mt7996_mcu_set_muru_fixed_rate_enable(struct mt7996_dev *dev, u8 action, int val);
+int mt7996_mcu_set_muru_fixed_rate_parameter(struct mt7996_dev *dev, u8 action, void *para);
+int mt7996_mcu_set_txbf_snd_info(struct mt7996_phy *phy, void *para);
+int mt7996_mcu_set_muru_cmd(struct mt7996_dev *dev, u16 action, int val);
+int mt7996_mcu_muru_set_prot_frame_thr(struct mt7996_dev *dev, u32 val);
+int mt7996_mcu_set_bypass_smthint(struct mt7996_phy *phy, u8 val);
+int mt7996_mcu_set_rfeature_trig_type(struct mt7996_phy *phy, u8 enable, u8 trig_type);
+void mt7996_mcu_set_ppdu_tx_type(struct mt7996_phy *phy, u8 ppdu_type);
+void mt7996_mcu_set_nusers_ofdma(struct mt7996_phy *phy, u8 type, u8 ofdma_user_cnt);
+void mt7996_mcu_set_cert(struct mt7996_phy *phy, u8 type);
+void mt7996_tm_update_channel(struct mt7996_phy *phy);
+
+int mt7996_mcu_set_vow_drr_dbg(struct mt7996_dev *dev, u32 val);
+int mt7996_mcu_thermal_debug(struct mt7996_dev *dev, u8 mode, u8 action);
+
+#define PKT_BIN_DEBUG_MAGIC	0xc8763123
+enum {
+	PKT_BIN_DEBUG_MCU,
+	PKT_BIN_DEBUG_TXD,
+	PKT_BIN_DEBUG_TX,
+	PKT_BIN_DEBUG_RX,
+	PKT_BIN_DEBUG_RX_RAW,
+	PKT_BIN_DEBUG_MCU_EVENT,
+};
+
+void mt7996_packet_log_to_host(struct mt7996_dev *dev, const void *data, int len, int type, int des_len);
+void mt7996_dump_bmac_rxd_info(struct mt7996_dev *dev, __le32 *rxd);
+void mt7996_dump_bmac_txd_info(struct seq_file *s, struct mt7996_dev *dev,
+			       __le32 *txd, bool is_hif_txd, bool dump_txp);
+int mt7996_mtk_init_dev_debugfs_internal(struct mt7996_phy *phy, struct dentry *dir);
+int mt7996_mtk_init_band_debugfs_internal(struct mt7996_phy *phy, struct dentry *dir);
+int mt7996_mcu_mlo_agc(struct mt7996_dev *dev, const void *data, int len);
 #endif
 
 #ifdef CONFIG_NET_MEDIATEK_SOC_WED
diff --git a/mt7996/mt7996_trace.h b/mt7996/mt7996_trace.h
new file mode 100644
index 00000000..21d1fd53
--- /dev/null
+++ b/mt7996/mt7996_trace.h
@@ -0,0 +1,169 @@
+/* SPDX-License-Identifier: ISC */
+/*
+ * Copyright (C) 2022 MediaTek Inc.
+ */
+
+#if !defined(__MT7996_TRACE_H) || defined(TRACE_HEADER_MULTI_READ)
+#define __MT7996_TRACE_H
+
+#include <linux/types.h>
+#include <linux/tracepoint.h>
+#include "mt7996.h"
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM mt7996
+
+#define MAXNAME		32
+#define DEV_ENTRY	__array(char, wiphy_name, 32)
+#define DEV_ASSIGN(_w)	strlcpy(__entry->wiphy_name, wiphy_name(_w), MAXNAME)
+#define DEV_PR_FMT	"%s"
+#define DEV_PR_ARG	__entry->wiphy_name
+
+DECLARE_EVENT_CLASS(mt7996_mcu_debug,
+	TP_PROTO(struct mt7996_dev *dev, bool uni, u8 id, u8 ext_id,
+		 const void *data, size_t len),
+	TP_ARGS(dev, uni, id, ext_id, data, len),
+	TP_STRUCT__entry(
+		__field(bool, uni)
+		__field(u8, id)
+		__field(u8, ext_id)
+		__field(size_t, len)
+		__dynamic_array(u8, data, len)
+	),
+	TP_fast_assign(
+		__entry->uni = uni;
+		__entry->id = id;
+		__entry->ext_id = ext_id;
+		__entry->len = len;
+		memcpy(__get_dynamic_array(data), data, len);
+	),
+	TP_printk(
+		"uni: %d, id: %u, ext_id: %u, len: %zu",
+		__entry->uni,
+		__entry->id,
+		__entry->ext_id,
+		__entry->len
+	)
+);
+
+DEFINE_EVENT(mt7996_mcu_debug, mt7996_mcu_cmd,
+	TP_PROTO(struct mt7996_dev *dev, bool uni, u8 id, u8 ext_id,
+		 const void *data, size_t len),
+	TP_ARGS(dev, uni, id, ext_id, data, len)
+);
+
+DEFINE_EVENT(mt7996_mcu_debug, mt7996_mcu_event,
+	TP_PROTO(struct mt7996_dev *dev, bool uni, u8 id, u8 ext_id,
+		 const void *data, size_t len),
+	TP_ARGS(dev, uni, id, ext_id, data, len)
+);
+
+TRACE_EVENT(mt7996_tx_prepare,
+	TP_PROTO(struct mt7996_dev *dev, struct mt76_wcid *wcid, enum mt76_txq_id qid,
+		 const void *txwi, const void *data, size_t len),
+	TP_ARGS(dev, wcid, qid, txwi, data, len),
+
+	TP_STRUCT__entry(
+		DEV_ENTRY
+		__field(u16, wcid)
+		__field(u8, qid)
+		__array(u8, txwi, MT_TXD_SIZE)
+		__field(size_t, len)
+		__dynamic_array(u8, data, len)
+	),
+
+	TP_fast_assign(
+		DEV_ASSIGN(dev->mt76.phys[wcid->phy_idx]->hw->wiphy);
+		__entry->wcid = wcid->idx;
+		__entry->qid = qid;
+		memcpy(__entry->txwi, txwi, MT_TXD_SIZE);
+		__entry->len = len;
+		memcpy(__get_dynamic_array(data), data, len);
+	),
+
+	TP_printk(
+		DEV_PR_FMT " wcid: %u, qid: %u, len: %zu",
+		DEV_PR_ARG, __entry->wcid, __entry->qid, __entry->len
+	)
+);
+
+TRACE_EVENT(mt7996_fill_rx,
+	TP_PROTO(struct mt7996_phy *phy, const void *data, size_t len),
+	TP_ARGS(phy, data, len),
+
+	TP_STRUCT__entry(
+		DEV_ENTRY
+		__field(size_t, len)
+		__dynamic_array(u8, data, len)
+	),
+
+	TP_fast_assign(
+		DEV_ASSIGN(phy->mt76->hw->wiphy);
+		__entry->len = len;
+		memcpy(__get_dynamic_array(data), data, len);
+	),
+
+	TP_printk(
+		DEV_PR_FMT " len: %zu",
+		DEV_PR_ARG, __entry->len
+	)
+);
+
+TRACE_EVENT(mt7996_fill_rx_done,
+	TP_PROTO(struct mt7996_phy *phy, u16 seqno, u16 hdr_gap),
+	TP_ARGS(phy, seqno, hdr_gap),
+
+	TP_STRUCT__entry(
+		DEV_ENTRY
+		__field(u16, seqno)
+		__field(u16, hdr_gap)
+	),
+
+	TP_fast_assign(
+		DEV_ASSIGN(phy->mt76->hw->wiphy);
+		__entry->seqno = seqno;
+		__entry->hdr_gap = hdr_gap;
+	),
+
+	TP_printk(
+		DEV_PR_FMT " seqno: %u, hdr_gap: %u",
+		DEV_PR_ARG, __entry->seqno, __entry->hdr_gap
+	)
+);
+
+TRACE_EVENT(mt7996_mac_tx_free,
+	TP_PROTO(struct mt7996_dev *dev, u8 errno, void *data, int len, u16 wlan_id, u32 msdu),
+	TP_ARGS(dev, errno, data, len, wlan_id, msdu),
+
+	TP_STRUCT__entry(
+		DEV_ENTRY
+		__field(u8, errno)
+		__field(size_t, len)
+		__dynamic_array(u8, data, len)
+		__field(u16, wlan_id)
+		__field(u32, msdu)
+	),
+
+	TP_fast_assign(
+		DEV_ASSIGN(dev->mphy.hw->wiphy);
+		__entry->errno = errno;
+		__entry->len = len;
+		memcpy(__get_dynamic_array(data), data, len);
+		__entry->wlan_id = wlan_id;
+		__entry->msdu = msdu;
+	),
+
+	TP_printk(
+		DEV_PR_FMT " errno = %u, wlan_id = %u, msdu = %u",
+		DEV_PR_ARG, __entry->errno, __entry->wlan_id, __entry->msdu
+	)
+);
+
+#endif
+
+#undef TRACE_INCLUDE_PATH
+#define TRACE_INCLUDE_PATH ./mt7996
+#undef TRACE_INCLUDE_FILE
+#define TRACE_INCLUDE_FILE mt7996_trace
+
+#include <trace/define_trace.h>
diff --git a/mt7996/mtk_debug.h b/mt7996/mtk_debug.h
new file mode 100644
index 00000000..82990239
--- /dev/null
+++ b/mt7996/mtk_debug.h
@@ -0,0 +1,2951 @@
+#ifndef __MTK_DEBUG_H
+#define __MTK_DEBUG_H
+
+#ifdef CONFIG_MTK_DEBUG
+#define NO_SHIFT_DEFINE 0xFFFFFFFF
+#define BITS(m, n)              (~(BIT(m)-1) & ((BIT(n) - 1) | BIT(n)))
+
+#define GET_FIELD(_field, _reg)	\
+	({	\
+		(((_reg) & (_field##_MASK)) >> (_field##_SHIFT));	\
+	})
+
+#define __DBG_OFFS(id)		(dev->dbg_reg->offs_rev[(id)])
+
+enum dbg_offs_rev {
+	AGG_AALCR2,
+	AGG_AALCR3,
+	AGG_AALCR4,
+	AGG_AALCR5,
+	AGG_AALCR6,
+	AGG_AALCR7,
+	MIB_TDRCR0,
+	MIB_TDRCR1,
+	MIB_TDRCR2,
+	MIB_TDRCR3,
+	MIB_TDRCR4,
+	MIB_RSCR26,
+	MIB_TSCR18,
+	MIB_TRDR0,
+	MIB_TRDR2,
+	MIB_TRDR3,
+	MIB_TRDR4,
+	MIB_TRDR5,
+	MIB_TRDR6,
+	MIB_TRDR7,
+	MIB_TRDR8,
+	MIB_TRDR9,
+	MIB_TRDR10,
+	MIB_TRDR11,
+	MIB_TRDR12,
+	MIB_TRDR13,
+	MIB_TRDR14,
+	MIB_TRDR15,
+	MIB_MSR0,
+	MIB_MSR1,
+	MIB_MSR2,
+	MIB_MCTR5,
+	MIB_MCTR6,
+	__MT_DBG_OFFS_REV_MAX,
+};
+
+static const u32 mt7996_dbg_offs[] = {
+	[AGG_AALCR2]		= 0x128,
+	[AGG_AALCR3]		= 0x12c,
+	[AGG_AALCR4]		= 0x130,
+	[AGG_AALCR5]		= 0x134,
+	[AGG_AALCR6]		= 0x138,
+	[AGG_AALCR7]		= 0x13c,
+	[MIB_TDRCR0]		= 0x728,
+	[MIB_TDRCR1]		= 0x72c,
+	[MIB_TDRCR2]		= 0x730,
+	[MIB_TDRCR3]		= 0x734,
+	[MIB_TDRCR4]		= 0x738,
+	[MIB_RSCR26]		= 0x950,
+	[MIB_TSCR18]		= 0xa1c,
+	[MIB_TRDR0]		= 0xa24,
+	[MIB_TRDR2]		= 0xa2c,
+	[MIB_TRDR3]		= 0xa30,
+	[MIB_TRDR4]		= 0xa34,
+	[MIB_TRDR5]		= 0xa38,
+	[MIB_TRDR6]		= 0xa3c,
+	[MIB_TRDR7]		= 0xa40,
+	[MIB_TRDR8]		= 0xa44,
+	[MIB_TRDR9]		= 0xa48,
+	[MIB_TRDR10]		= 0xa4c,
+	[MIB_TRDR11]		= 0xa50,
+	[MIB_TRDR12]		= 0xa54,
+	[MIB_TRDR13]		= 0xa58,
+	[MIB_TRDR14]		= 0xa5c,
+	[MIB_TRDR15]		= 0xa60,
+	[MIB_MSR0]		= 0xa64,
+	[MIB_MSR1]		= 0xa68,
+	[MIB_MSR2]		= 0xa6c,
+	[MIB_MCTR5]		= 0xa70,
+	[MIB_MCTR6]		= 0xa74,
+};
+
+static const u32 mt7992_dbg_offs[] = {
+	[AGG_AALCR2]		= 0x12c,
+	[AGG_AALCR3]		= 0x130,
+	[AGG_AALCR4]		= 0x134,
+	[AGG_AALCR5]		= 0x138,
+	[AGG_AALCR6]		= 0x13c,
+	[AGG_AALCR7]		= 0x140,
+	[MIB_TDRCR0]		= 0x768,
+	[MIB_TDRCR1]		= 0x76c,
+	[MIB_TDRCR2]		= 0x770,
+	[MIB_TDRCR3]		= 0x774,
+	[MIB_TDRCR4]		= 0x778,
+	[MIB_RSCR26]		= 0x994,
+	[MIB_TSCR18]		= 0xb18,
+	[MIB_TRDR0]		= 0xb20,
+	[MIB_TRDR2]		= 0xb28,
+	[MIB_TRDR3]		= 0xb2c,
+	[MIB_TRDR4]		= 0xb30,
+	[MIB_TRDR5]		= 0xb34,
+	[MIB_TRDR6]		= 0xb38,
+	[MIB_TRDR7]		= 0xb3c,
+	[MIB_TRDR8]		= 0xb40,
+	[MIB_TRDR9]		= 0xb44,
+	[MIB_TRDR10]		= 0xb48,
+	[MIB_TRDR11]		= 0xb4c,
+	[MIB_TRDR12]		= 0xb50,
+	[MIB_TRDR13]		= 0xb54,
+	[MIB_TRDR14]		= 0xb58,
+	[MIB_TRDR15]		= 0xb5c,
+	[MIB_MSR0]		= 0xb60,
+	[MIB_MSR1]		= 0xb64,
+	[MIB_MSR2]		= 0xb68,
+	[MIB_MCTR5]		= 0xb6c,
+	[MIB_MCTR6]		= 0xb70,
+};
+
+/* used to differentiate between generations */
+struct mt7996_dbg_reg_desc {
+	const u32 id;
+	const u32 *offs_rev;
+};
+
+/* AGG */
+#define BN0_WF_AGG_TOP_BASE                                    0x820e2000
+#define BN1_WF_AGG_TOP_BASE                                    0x820f2000
+#define IP1_BN0_WF_AGG_TOP_BASE                                0x830e2000
+
+#define BN0_WF_AGG_TOP_SCR_ADDR                                (BN0_WF_AGG_TOP_BASE + 0x0) // 2000
+#define BN0_WF_AGG_TOP_SCR0_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x4) // 2004
+#define BN0_WF_AGG_TOP_SCR1_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x8) // 2008
+#define BN0_WF_AGG_TOP_BCR_ADDR                                (BN0_WF_AGG_TOP_BASE + 0xc) // 200C
+#define BN0_WF_AGG_TOP_BWCR_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x10) // 2010
+#define BN0_WF_AGG_TOP_ARCR0_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x14) // 2014
+#define BN0_WF_AGG_TOP_ARUCR_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x18) // 2018
+#define BN0_WF_AGG_TOP_ARDCR_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x1c) // 201C
+#define BN0_WF_AGG_TOP_AALCR0_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x20) // 2020
+#define BN0_WF_AGG_TOP_AALCR1_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x24) // 2024
+#define BN0_WF_AGG_TOP_PCR0_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x28) // 2028
+#define BN0_WF_AGG_TOP_PCR1_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x2c) // 202C
+#define BN0_WF_AGG_TOP_TTCR0_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x30) // 2030
+#define BN0_WF_AGG_TOP_TTCR1_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x34) // 2034
+#define BN0_WF_AGG_TOP_ACR1_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x38) // 2038
+#define BN0_WF_AGG_TOP_ACR4_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x3c) // 203C
+#define BN0_WF_AGG_TOP_ACR5_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x40) // 2040
+#define BN0_WF_AGG_TOP_ACR6_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x44) // 2044
+#define BN0_WF_AGG_TOP_ACR8_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x4c) // 204C
+#define BN0_WF_AGG_TOP_MRCR_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x50) // 2050
+#define BN0_WF_AGG_TOP_MMPDR_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x54) // 2054
+#define BN0_WF_AGG_TOP_GFPDR_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x58) // 2058
+#define BN0_WF_AGG_TOP_VHTPDR_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x5c) // 205C
+#define BN0_WF_AGG_TOP_HEPDR_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x60) // 2060
+#define BN0_WF_AGG_TOP_CTCR_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x64) // 2064
+#define BN0_WF_AGG_TOP_ATCR3_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x68) // 2068
+#define BN0_WF_AGG_TOP_SRCR_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x6c) // 206C
+#define BN0_WF_AGG_TOP_VBCR_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x70) // 2070
+#define BN0_WF_AGG_TOP_TCR_ADDR                                (BN0_WF_AGG_TOP_BASE + 0x74) // 2074
+#define BN0_WF_AGG_TOP_SRHS_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x78) // 2078
+#define BN0_WF_AGG_TOP_DBRCR0_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x7c) // 207C
+#define BN0_WF_AGG_TOP_DBRCR1_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x80) // 2080
+#define BN0_WF_AGG_TOP_CTETCR_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x84) // 2084
+#define BN0_WF_AGG_TOP_WPDR_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x88) // 2088
+#define BN0_WF_AGG_TOP_PLRPDR_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x8c) // 208C
+#define BN0_WF_AGG_TOP_CECR_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x90) // 2090
+#define BN0_WF_AGG_TOP_OMRCR0_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x94) // 2094
+#define BN0_WF_AGG_TOP_OMRCR1_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x98) // 2098
+#define BN0_WF_AGG_TOP_OMRCR2_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x9c) // 209C
+#define BN0_WF_AGG_TOP_OMRCR3_ADDR                             (BN0_WF_AGG_TOP_BASE + 0xa0) // 20A0
+#define BN0_WF_AGG_TOP_TMCR_ADDR                               (BN0_WF_AGG_TOP_BASE + 0xa4) // 20A4
+#define BN0_WF_AGG_TOP_TWTCR_ADDR                              (BN0_WF_AGG_TOP_BASE + 0xa8) // 20A8
+#define BN0_WF_AGG_TOP_TWTSTACR_ADDR                           (BN0_WF_AGG_TOP_BASE + 0xac) // 20AC
+#define BN0_WF_AGG_TOP_TWTE0TB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xb0) // 20B0
+#define BN0_WF_AGG_TOP_TWTE1TB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xb4) // 20B4
+#define BN0_WF_AGG_TOP_TWTE2TB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xb8) // 20B8
+#define BN0_WF_AGG_TOP_TWTE3TB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xbc) // 20BC
+#define BN0_WF_AGG_TOP_TWTE4TB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xc0) // 20C0
+#define BN0_WF_AGG_TOP_TWTE5TB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xc4) // 20C4
+#define BN0_WF_AGG_TOP_TWTE6TB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xc8) // 20C8
+#define BN0_WF_AGG_TOP_TWTE7TB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xcc) // 20CC
+#define BN0_WF_AGG_TOP_TWTE8TB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xd0) // 20D0
+#define BN0_WF_AGG_TOP_TWTE9TB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xd4) // 20D4
+#define BN0_WF_AGG_TOP_TWTEATB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xd8) // 20D8
+#define BN0_WF_AGG_TOP_TWTEBTB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xdc) // 20DC
+#define BN0_WF_AGG_TOP_TWTECTB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xe0) // 20E0
+#define BN0_WF_AGG_TOP_TWTEDTB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xe4) // 20E4
+#define BN0_WF_AGG_TOP_TWTEETB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xe8) // 20E8
+#define BN0_WF_AGG_TOP_TWTEFTB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xec) // 20EC
+#define BN0_WF_AGG_TOP_ATCR0_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x108) // 2108
+#define BN0_WF_AGG_TOP_ATCR1_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x10c) // 210C
+#define BN0_WF_AGG_TOP_TCCR_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x110) // 2110
+#define BN0_WF_AGG_TOP_TFCR_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x114) // 2114
+#define BN0_WF_AGG_TOP_MUCR0_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x118) // 2118
+#define BN0_WF_AGG_TOP_MUCR1_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x11c) // 211C
+#define BN0_WF_AGG_TOP_AALCR2_ADDR                             (BN0_WF_AGG_TOP_BASE + __DBG_OFFS(AGG_AALCR2))
+#define BN0_WF_AGG_TOP_AALCR3_ADDR                             (BN0_WF_AGG_TOP_BASE + __DBG_OFFS(AGG_AALCR3))
+#define BN0_WF_AGG_TOP_AALCR4_ADDR                             (BN0_WF_AGG_TOP_BASE + __DBG_OFFS(AGG_AALCR4))
+#define BN0_WF_AGG_TOP_AALCR5_ADDR                             (BN0_WF_AGG_TOP_BASE + __DBG_OFFS(AGG_AALCR5))
+#define BN0_WF_AGG_TOP_AALCR6_ADDR                             (BN0_WF_AGG_TOP_BASE + __DBG_OFFS(AGG_AALCR6))
+#define BN0_WF_AGG_TOP_AALCR7_ADDR                             (BN0_WF_AGG_TOP_BASE + __DBG_OFFS(AGG_AALCR7))
+#define BN0_WF_AGG_TOP_CSDCR0_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x150) // 2150
+#define BN0_WF_AGG_TOP_CSDCR1_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x154) // 2154
+#define BN0_WF_AGG_TOP_CSDCR2_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x158) // 2158
+#define BN0_WF_AGG_TOP_CSDCR3_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x15c) // 215C
+#define BN0_WF_AGG_TOP_CSDCR4_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x160) // 2160
+#define BN0_WF_AGG_TOP_DYNSCR_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x178) // 2178
+#define BN0_WF_AGG_TOP_DYNSSCR_ADDR                            (BN0_WF_AGG_TOP_BASE + 0x198) // 2198
+#define BN0_WF_AGG_TOP_TCDCNT0_ADDR                            (BN0_WF_AGG_TOP_BASE + 0x2c8) // 22C8
+#define BN0_WF_AGG_TOP_TCDCNT1_ADDR                            (BN0_WF_AGG_TOP_BASE + 0x2cc) // 22CC
+#define BN0_WF_AGG_TOP_TCSR0_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x2d0) // 22D0
+#define BN0_WF_AGG_TOP_TCSR1_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x2d4) // 22D4
+#define BN0_WF_AGG_TOP_TCSR2_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x2d8) // 22D8
+#define BN0_WF_AGG_TOP_DCR_ADDR                                (BN0_WF_AGG_TOP_BASE + 0x2e4) // 22E4
+#define BN0_WF_AGG_TOP_SMDCR_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x2e8) // 22E8
+#define BN0_WF_AGG_TOP_TXCMDSMCR_ADDR                          (BN0_WF_AGG_TOP_BASE + 0x2ec) // 22EC
+#define BN0_WF_AGG_TOP_SMCR0_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x2f0) // 22F0
+#define BN0_WF_AGG_TOP_SMCR1_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x2f4) // 22F4
+#define BN0_WF_AGG_TOP_SMCR2_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x2f8) // 22F8
+#define BN0_WF_AGG_TOP_SMCR3_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x2fc) // 22FC
+
+#define BN0_WF_AGG_TOP_AALCR0_AC01_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR0_ADDR
+#define BN0_WF_AGG_TOP_AALCR0_AC01_AGG_LIMIT_MASK              0x03FF0000                // AC01_AGG_LIMIT[25..16]
+#define BN0_WF_AGG_TOP_AALCR0_AC01_AGG_LIMIT_SHFT              16
+#define BN0_WF_AGG_TOP_AALCR0_AC00_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR0_ADDR
+#define BN0_WF_AGG_TOP_AALCR0_AC00_AGG_LIMIT_MASK              0x000003FF                // AC00_AGG_LIMIT[9..0]
+#define BN0_WF_AGG_TOP_AALCR0_AC00_AGG_LIMIT_SHFT              0
+
+#define BN0_WF_AGG_TOP_AALCR1_AC03_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR1_ADDR
+#define BN0_WF_AGG_TOP_AALCR1_AC03_AGG_LIMIT_MASK              0x03FF0000                // AC03_AGG_LIMIT[25..16]
+#define BN0_WF_AGG_TOP_AALCR1_AC03_AGG_LIMIT_SHFT              16
+#define BN0_WF_AGG_TOP_AALCR1_AC02_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR1_ADDR
+#define BN0_WF_AGG_TOP_AALCR1_AC02_AGG_LIMIT_MASK              0x000003FF                // AC02_AGG_LIMIT[9..0]
+#define BN0_WF_AGG_TOP_AALCR1_AC02_AGG_LIMIT_SHFT              0
+
+#define BN0_WF_AGG_TOP_AALCR2_AC11_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR2_ADDR
+#define BN0_WF_AGG_TOP_AALCR2_AC11_AGG_LIMIT_MASK              0x03FF0000                // AC11_AGG_LIMIT[25..16]
+#define BN0_WF_AGG_TOP_AALCR2_AC11_AGG_LIMIT_SHFT              16
+#define BN0_WF_AGG_TOP_AALCR2_AC10_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR2_ADDR
+#define BN0_WF_AGG_TOP_AALCR2_AC10_AGG_LIMIT_MASK              0x000003FF                // AC10_AGG_LIMIT[9..0]
+#define BN0_WF_AGG_TOP_AALCR2_AC10_AGG_LIMIT_SHFT              0
+
+#define BN0_WF_AGG_TOP_AALCR3_AC13_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR3_ADDR
+#define BN0_WF_AGG_TOP_AALCR3_AC13_AGG_LIMIT_MASK              0x03FF0000                // AC13_AGG_LIMIT[25..16]
+#define BN0_WF_AGG_TOP_AALCR3_AC13_AGG_LIMIT_SHFT              16
+#define BN0_WF_AGG_TOP_AALCR3_AC12_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR3_ADDR
+#define BN0_WF_AGG_TOP_AALCR3_AC12_AGG_LIMIT_MASK              0x000003FF                // AC12_AGG_LIMIT[9..0]
+#define BN0_WF_AGG_TOP_AALCR3_AC12_AGG_LIMIT_SHFT              0
+
+#define BN0_WF_AGG_TOP_AALCR4_AC21_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR4_ADDR
+#define BN0_WF_AGG_TOP_AALCR4_AC21_AGG_LIMIT_MASK              0x03FF0000                // AC21_AGG_LIMIT[25..16]
+#define BN0_WF_AGG_TOP_AALCR4_AC21_AGG_LIMIT_SHFT              16
+#define BN0_WF_AGG_TOP_AALCR4_AC20_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR4_ADDR
+#define BN0_WF_AGG_TOP_AALCR4_AC20_AGG_LIMIT_MASK              0x000003FF                // AC20_AGG_LIMIT[9..0]
+#define BN0_WF_AGG_TOP_AALCR4_AC20_AGG_LIMIT_SHFT              0
+
+#define BN0_WF_AGG_TOP_AALCR5_AC23_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR5_ADDR
+#define BN0_WF_AGG_TOP_AALCR5_AC23_AGG_LIMIT_MASK              0x03FF0000                // AC23_AGG_LIMIT[25..16]
+#define BN0_WF_AGG_TOP_AALCR5_AC23_AGG_LIMIT_SHFT              16
+#define BN0_WF_AGG_TOP_AALCR5_AC22_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR5_ADDR
+#define BN0_WF_AGG_TOP_AALCR5_AC22_AGG_LIMIT_MASK              0x000003FF                // AC22_AGG_LIMIT[9..0]
+#define BN0_WF_AGG_TOP_AALCR5_AC22_AGG_LIMIT_SHFT              0
+
+#define BN0_WF_AGG_TOP_AALCR6_AC31_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR6_ADDR
+#define BN0_WF_AGG_TOP_AALCR6_AC31_AGG_LIMIT_MASK              0x03FF0000                // AC31_AGG_LIMIT[25..16]
+#define BN0_WF_AGG_TOP_AALCR6_AC31_AGG_LIMIT_SHFT              16
+#define BN0_WF_AGG_TOP_AALCR6_AC30_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR6_ADDR
+#define BN0_WF_AGG_TOP_AALCR6_AC30_AGG_LIMIT_MASK              0x000003FF                // AC30_AGG_LIMIT[9..0]
+#define BN0_WF_AGG_TOP_AALCR6_AC30_AGG_LIMIT_SHFT              0
+#define BN0_WF_AGG_TOP_AALCR7_AC33_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR7_ADDR
+#define BN0_WF_AGG_TOP_AALCR7_AC33_AGG_LIMIT_MASK              0x03FF0000                // AC33_AGG_LIMIT[25..16]
+#define BN0_WF_AGG_TOP_AALCR7_AC33_AGG_LIMIT_SHFT              16
+#define BN0_WF_AGG_TOP_AALCR7_AC32_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR7_ADDR
+#define BN0_WF_AGG_TOP_AALCR7_AC32_AGG_LIMIT_MASK              0x000003FF                // AC32_AGG_LIMIT[9..0]
+#define BN0_WF_AGG_TOP_AALCR7_AC32_AGG_LIMIT_SHFT              0
+
+/* DMA */
+struct queue_desc {
+	u32 hw_desc_base;
+	u16 ring_size;
+	char *const ring_info;
+};
+
+// HOST DMA
+#define WF_WFDMA_HOST_DMA0_BASE                                0xd4000
+
+#define WF_WFDMA_HOST_DMA0_HOST_INT_STA_ADDR                                   \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x200) /* 4200 */
+#define WF_WFDMA_HOST_DMA0_HOST_INT_ENA_ADDR                                   \
+	(WF_WFDMA_HOST_DMA0_BASE + 0X204) /* 4204 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_ADDR                                  \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x208) /* 4208 */
+
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_ADDR                      \
+	WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK                      \
+	0x00000008 /* RX_DMA_BUSY[3] */
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT 3
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_ADDR                        \
+	WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_MASK                        \
+	0x00000004 /* RX_DMA_EN[2] */
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_SHFT 2
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_ADDR                      \
+	WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK                      \
+	0x00000002 /* TX_DMA_BUSY[1] */
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT 1
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_ADDR                        \
+	WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_MASK                        \
+	0x00000001 /* TX_DMA_EN[0] */
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_SHFT 0
+
+
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING0_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x300) /* 4300 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING0_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x304) /* 4304 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING0_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x308) /* 4308 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING0_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x30c) /* 430C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING1_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x310) /* 4310 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING1_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x314) /* 4314 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING1_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x318) /* 4318 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING1_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x31c) /* 431C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING2_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x320) /* 4320 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING2_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x324) /* 4324 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING2_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x328) /* 4328 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING2_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x32c) /* 432C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING3_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x330) /* 4330 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING3_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x334) /* 4334 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING3_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x338) /* 4338 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING3_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x33c) /* 433C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING4_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x340) /* 4340 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING4_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x344) /* 4344 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING4_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x348) /* 4348 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING4_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x34c) /* 434C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING5_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x350) /* 4350 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING5_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x354) /* 4354 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING5_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x358) /* 4358 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING5_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x35c) /* 435C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING6_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x360) /* 4360 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING6_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x364) /* 4364 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING6_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x368) /* 4368 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING6_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x36c) /* 436C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING16_CTRL0_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x400) /* 4400 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING16_CTRL1_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x404) /* 4404 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING16_CTRL2_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x408) /* 4408 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING16_CTRL3_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x40c) /* 440C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING17_CTRL0_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x410) /* 4410 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING17_CTRL1_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x414) /* 4414 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING17_CTRL2_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x418) /* 4418 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING17_CTRL3_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x41c) /* 441C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING18_CTRL0_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x420) /* 4420 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING18_CTRL1_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x424) /* 4424 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING18_CTRL2_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x428) /* 4428 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING18_CTRL3_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x42c) /* 442C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING19_CTRL0_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x430) /* 4430 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING19_CTRL1_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x434) /* 4434 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING19_CTRL2_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x438) /* 4438 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING19_CTRL3_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x43c) /* 443C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING20_CTRL0_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x440) /* 4440 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING20_CTRL1_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x444) /* 4444 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING20_CTRL2_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x448) /* 4448 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING20_CTRL3_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x44c) /* 444C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING21_CTRL0_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x450) /* 4450 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING21_CTRL1_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x454) /* 4454 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING21_CTRL2_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x458) /* 4458 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING21_CTRL3_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x45c) /* 445c */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING22_CTRL0_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x460) // 4460
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING22_CTRL1_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x464) // 4464
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING22_CTRL2_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x468) // 4468
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING22_CTRL3_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x46c) // 446C
+
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING0_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x500) /* 4500 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING0_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x504) /* 4504 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING0_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x508) /* 4508 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING0_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x50c) /* 450C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING1_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x510) /* 4510 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING1_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x514) /* 4514 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING1_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x518) /* 4518 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING1_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x51c) /* 451C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING2_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x520) /* 4520 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING2_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x524) /* 4524 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING2_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x528) /* 4528 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING2_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x52C) /* 452C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING3_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x530) /* 4530 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING3_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x534) /* 4534 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING3_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x538) /* 4538 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING3_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x53C) /* 453C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING4_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x540) /* 4540 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING4_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x544) /* 4544 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING4_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x548) /* 4548 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING4_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x54c) /* 454C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING5_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x550) /* 4550 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING5_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x554) /* 4554 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING5_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x558) /* 4558 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING5_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x55c) /* 455C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING6_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x560) /* 4560 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING6_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x564) /* 4564 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING6_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x568) /* 4568 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING6_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x56c) /* 456C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING7_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x570) /* 4570 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING7_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x574) /* 4574 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING7_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x578) /* 4578 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING7_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x57c) /* 457C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING8_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x580) /* 4580 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING8_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x584) /* 4584 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING8_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x588) /* 4588 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING8_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x58c) /* 458C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING9_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x590) /* 4590 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING9_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x594) /* 4594 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING9_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x598) /* 4598 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING9_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x59c) /* 459C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING10_CTRL0_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5a0) // 45A0
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING10_CTRL1_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5a4) // 45A4
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING10_CTRL2_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5a8) // 45A8
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING10_CTRL3_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5ac) // 45AC
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING11_CTRL0_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5b0) // 45B0
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING11_CTRL1_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5b4) // 45B4
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING11_CTRL2_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5b8) // 45B8
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING11_CTRL3_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5bc) // 45BC
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING12_CTRL0_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5C0) // 45C0
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING12_CTRL1_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5C4) // 45C4
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING12_CTRL2_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5C8) // 45C8
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING12_CTRL3_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5CC) // 45CC
+
+// HOST PCIE1 DMA
+#define WF_WFDMA_HOST_DMA0_PCIE1_BASE				0xd8000
+
+#define WF_WFDMA_HOST_DMA0_PCIE1_HOST_INT_STA_ADDR		(WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x200) // 8200
+#define WF_WFDMA_HOST_DMA0_PCIE1_HOST_INT_ENA_ADDR		(WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0X204) // 8204
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_ADDR		(WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x208) // 8208
+
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_PDMA_BT_SIZE_SHFT	4
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK		0x00000008
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT		3
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_RX_DMA_EN_MASK		0x00000004
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_RX_DMA_EN_SHFT		2
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK		0x00000002
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT		1
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_TX_DMA_EN_MASK		0x00000001
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_TX_DMA_EN_SHFT		0
+
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING21_CTRL0_ADDR    (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x450) // 8450
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING21_CTRL1_ADDR    (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x454) // 8454
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING21_CTRL2_ADDR    (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x458) // 8458
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING21_CTRL3_ADDR    (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x45c) // 845C
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING22_CTRL0_ADDR    (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x460) // 8460
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING22_CTRL1_ADDR    (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x464) // 8464
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING22_CTRL2_ADDR    (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x468) // 8468
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING22_CTRL3_ADDR    (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x46c) // 846C
+
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING3_CTRL0_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x530) // 8530
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING3_CTRL1_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x534) // 8534
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING3_CTRL2_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x538) // 8538
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING3_CTRL3_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x53C) // 853C
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING5_CTRL0_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x550) // 8550
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING5_CTRL1_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x554) // 8554
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING5_CTRL2_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x558) // 8558
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING5_CTRL3_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x55c) // 855C
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING6_CTRL0_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x560) // 8560
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING6_CTRL1_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x564) // 8564
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING6_CTRL2_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x568) // 8568
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING6_CTRL3_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x56c) // 856C
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING7_CTRL0_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x570) // 8570
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING7_CTRL1_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x574) // 8574
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING7_CTRL2_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x578) // 8578
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING7_CTRL3_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x57c) // 857C
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING9_CTRL0_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x590) // 8590
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING9_CTRL1_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x594) // 8594
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING9_CTRL2_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x598) // 8598
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING9_CTRL3_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x59c) // 859C
+
+//MCU DMA
+//#define WF_WFDMA_MCU_DMA0_BASE                                 0x02000
+#define WF_WFDMA_MCU_DMA0_BASE                                 0x54000000
+
+#define WF_WFDMA_MCU_DMA0_HOST_INT_STA_ADDR                    (WF_WFDMA_MCU_DMA0_BASE + 0x200) // 0200
+#define WF_WFDMA_MCU_DMA0_HOST_INT_ENA_ADDR                    (WF_WFDMA_MCU_DMA0_BASE + 0X204) // 0204
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_ADDR                   (WF_WFDMA_MCU_DMA0_BASE + 0x208) // 0208
+
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_ADDR       WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK       0x00000008                // RX_DMA_BUSY[3]
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT       3
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_ADDR         WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_MASK         0x00000004                // RX_DMA_EN[2]
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_SHFT         2
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_ADDR       WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK       0x00000002                // TX_DMA_BUSY[1]
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT       1
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_ADDR         WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_MASK         0x00000001                // TX_DMA_EN[0]
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_SHFT         0
+
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING0_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x300) // 0300
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING0_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x304) // 0304
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING0_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x308) // 0308
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING0_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x30c) // 030C
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING1_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x310) // 0310
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING1_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x314) // 0314
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING1_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x318) // 0318
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING1_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x31c) // 031C
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING2_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x320) // 0320
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING2_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x324) // 0324
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING2_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x328) // 0328
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING2_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x32c) // 032C
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING3_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x330) // 0330
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING3_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x334) // 0334
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING3_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x338) // 0338
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING3_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x33c) // 033C
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING4_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x340) // 0340
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING4_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x344) // 0344
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING4_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x348) // 0348
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING4_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x34c) // 034C
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING5_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x350) // 0350
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING5_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x354) // 0354
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING5_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x358) // 0358
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING5_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x35c) // 035C
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING6_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x360) // 0360
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING6_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x364) // 0364
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING6_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x368) // 0368
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING6_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x36c) // 036C
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING7_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x370) // 0370
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING7_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x374) // 0374
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING7_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x378) // 0378
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING7_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x37c) // 037C
+
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING0_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x500) // 0500
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING0_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x504) // 0504
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING0_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x508) // 0508
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING0_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x50c) // 050C
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING1_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x510) // 0510
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING1_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x514) // 0514
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING1_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x518) // 0518
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING1_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x51c) // 051C
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING2_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x520) // 0520
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING2_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x524) // 0524
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING2_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x528) // 0528
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING2_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x52C) // 052C
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING3_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x530) // 0530
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING3_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x534) // 0534
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING3_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x538) // 0538
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING3_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x53C) // 053C
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING4_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x540) // 0540
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING4_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x544) // 0544
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING4_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x548) // 0548
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING4_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x54C) // 054C
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING5_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x550) // 0550
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING5_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x554) // 0554
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING5_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x558) // 0558
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING5_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x55C) // 055C
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING6_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x560) // 0560
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING6_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x564) // 0564
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING6_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x568) // 0568
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING6_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x56c) // 056C
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING7_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x570) // 0570
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING7_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x574) // 0574
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING7_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x578) // 0578
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING7_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x57c) // 057C
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING8_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x580) // 0580
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING8_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x584) // 0584
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING8_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x588) // 0588
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING8_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x58c) // 058C
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING9_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x590) // 0590
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING9_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x594) // 0594
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING9_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x598) // 0598
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING9_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x59c) // 059C
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING10_CTRL0_ADDR           (WF_WFDMA_MCU_DMA0_BASE + 0x5A0) // 05A0
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING10_CTRL1_ADDR           (WF_WFDMA_MCU_DMA0_BASE + 0x5A4) // 05A4
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING10_CTRL2_ADDR           (WF_WFDMA_MCU_DMA0_BASE + 0x5A8) // 05A8
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING10_CTRL3_ADDR           (WF_WFDMA_MCU_DMA0_BASE + 0x5Ac) // 05AC
+
+// MEM DMA
+#define WF_WFDMA_MEM_DMA_BASE                                  0x58000000
+
+#define WF_WFDMA_MEM_DMA_HOST_INT_STA_ADDR                     (WF_WFDMA_MEM_DMA_BASE + 0x200) // 0200
+#define WF_WFDMA_MEM_DMA_HOST_INT_ENA_ADDR                     (WF_WFDMA_MEM_DMA_BASE + 0X204) // 0204
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_ADDR                    (WF_WFDMA_MEM_DMA_BASE + 0x208) // 0208
+
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_BUSY_ADDR        WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK        0x00000008                // RX_DMA_BUSY[3]
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT        3
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_EN_ADDR          WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_EN_MASK          0x00000004                // RX_DMA_EN[2]
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_EN_SHFT          2
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_BUSY_ADDR        WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK        0x00000002                // TX_DMA_BUSY[1]
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT        1
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_EN_ADDR          WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_EN_MASK          0x00000001                // TX_DMA_EN[0]
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_EN_SHFT          0
+
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING0_CTRL0_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x300) // 0300
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING0_CTRL1_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x304) // 0304
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING0_CTRL2_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x308) // 0308
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING0_CTRL3_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x30c) // 030C
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING1_CTRL0_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x310) // 0310
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING1_CTRL1_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x314) // 0314
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING1_CTRL2_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x318) // 0318
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING1_CTRL3_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x31c) // 031C
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING2_CTRL0_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x320) // 0320
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING2_CTRL1_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x324) // 0324
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING2_CTRL2_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x328) // 0328
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING2_CTRL3_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x32c) // 032C
+
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING0_CTRL0_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x500) // 0500
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING0_CTRL1_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x504) // 0504
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING0_CTRL2_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x508) // 0508
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING0_CTRL3_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x50c) // 050C
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING1_CTRL0_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x510) // 0510
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING1_CTRL1_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x514) // 0514
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING1_CTRL2_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x518) // 0518
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING1_CTRL3_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x51c) // 051C
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING2_CTRL0_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x520) // 0520
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING2_CTRL1_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x524) // 0524
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING2_CTRL2_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x528) // 0528
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING2_CTRL3_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x52C) // 052C
+
+/* MIB */
+#define WF_UMIB_TOP_BASE                                       0x820cd000
+#define BN0_WF_MIB_TOP_BASE                                    0x820ed000
+#define BN1_WF_MIB_TOP_BASE                                    0x820fd000
+#define IP1_BN0_WF_MIB_TOP_BASE                                0x830ed000
+
+#define WF_UMIB_TOP_B0BROCR_ADDR                               (WF_UMIB_TOP_BASE + 0x484) // D484
+#define WF_UMIB_TOP_B0BRBCR_ADDR                               (WF_UMIB_TOP_BASE + 0x4D4) // D4D4
+#define WF_UMIB_TOP_B0BRDCR_ADDR                               (WF_UMIB_TOP_BASE + 0x524) // D524
+#define WF_UMIB_TOP_B1BROCR_ADDR                               (WF_UMIB_TOP_BASE + 0x5E8) // D5E8
+#define WF_UMIB_TOP_B2BROCR_ADDR                               (WF_UMIB_TOP_BASE + 0x74C) // D74C
+
+#define BN0_WF_MIB_TOP_M0SCR0_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x000) // D000
+#define BN0_WF_MIB_TOP_M0SDR6_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x020) // D020
+#define BN0_WF_MIB_TOP_M0SDR9_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x024) // D024
+#define BN0_WF_MIB_TOP_M0SDR18_ADDR                            (BN0_WF_MIB_TOP_BASE + 0x030) // D030
+#define BN0_WF_MIB_TOP_BTOCR_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x400) // D400
+#define BN0_WF_MIB_TOP_BTBCR_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x450) // D450
+#define BN0_WF_MIB_TOP_BTDCR_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x590) // D590
+#define BN0_WF_MIB_TOP_BTCR_ADDR                               (BN0_WF_MIB_TOP_BASE + 0x5A0) // D5A0
+#define BN0_WF_MIB_TOP_RVSR0_ADDR                              (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_RVSR0))
+
+#define BN0_WF_MIB_TOP_TSCR0_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6B0) // D6B0
+#define BN0_WF_MIB_TOP_TSCR3_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6BC) // D6BC
+#define BN0_WF_MIB_TOP_TSCR4_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6C0) // D6C0
+#define BN0_WF_MIB_TOP_TSCR5_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6C4) // D6C4
+#define BN0_WF_MIB_TOP_TSCR6_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6C8) // D6C8
+#define BN0_WF_MIB_TOP_TSCR7_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6D0) // D6D0
+#define BN0_WF_MIB_TOP_TSCR8_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6CC) // D6CC
+
+#define BN0_WF_MIB_TOP_TBCR0_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6EC) // D6EC
+#define BN0_WF_MIB_TOP_TBCR1_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6F0) // D6F0
+#define BN0_WF_MIB_TOP_TBCR2_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6F4) // D6F4
+#define BN0_WF_MIB_TOP_TBCR3_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6F8) // D6F8
+#define BN0_WF_MIB_TOP_TBCR4_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6FC) // D6FC
+
+#define BN0_WF_MIB_TOP_TDRCR0_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TDRCR0))
+#define BN0_WF_MIB_TOP_TDRCR1_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TDRCR1))
+#define BN0_WF_MIB_TOP_TDRCR2_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TDRCR2))
+#define BN0_WF_MIB_TOP_TDRCR3_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TDRCR3))
+#define BN0_WF_MIB_TOP_TDRCR4_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TDRCR4))
+
+#define BN0_WF_MIB_TOP_BTSCR0_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x5E0) // D5E0
+#define BN0_WF_MIB_TOP_BTSCR1_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x5F0) // D5F0
+#define BN0_WF_MIB_TOP_BTSCR2_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x600) // D600
+#define BN0_WF_MIB_TOP_BTSCR3_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x610) // D610
+#define BN0_WF_MIB_TOP_BTSCR4_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x620) // D620
+#define BN0_WF_MIB_TOP_BTSCR5_ADDR                             (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_BTSCR5))
+#define BN0_WF_MIB_TOP_BTSCR6_ADDR                             (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_BTSCR6))
+
+#define BN0_WF_MIB_TOP_RSCR1_ADDR                              (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_RSCR1))
+#define BN0_WF_MIB_TOP_BSCR2_ADDR                              (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_BSCR2))
+#define BN0_WF_MIB_TOP_TSCR18_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TSCR18))
+
+#define BN0_WF_MIB_TOP_MSR0_ADDR                               (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_MSR0))
+#define BN0_WF_MIB_TOP_MSR1_ADDR                               (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_MSR1))
+#define BN0_WF_MIB_TOP_MSR2_ADDR                               (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_MSR2))
+#define BN0_WF_MIB_TOP_MCTR5_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_MCTR5))
+#define BN0_WF_MIB_TOP_MCTR6_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_MCTR6))
+
+#define BN0_WF_MIB_TOP_RSCR26_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_RSCR26))
+#define BN0_WF_MIB_TOP_RSCR27_ADDR                             (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_RSCR27))
+#define BN0_WF_MIB_TOP_RSCR28_ADDR                             (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_RSCR28))
+#define BN0_WF_MIB_TOP_RSCR31_ADDR                             (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_RSCR31))
+#define BN0_WF_MIB_TOP_RSCR33_ADDR                             (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_RSCR33))
+#define BN0_WF_MIB_TOP_RSCR35_ADDR                             (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_RSCR35))
+#define BN0_WF_MIB_TOP_RSCR36_ADDR                             (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_RSCR36))
+
+#define BN0_WF_MIB_TOP_TSCR3_AMPDU_MPDU_COUNT_MASK             0xFFFFFFFF                // AMPDU_MPDU_COUNT[31..0]
+#define BN0_WF_MIB_TOP_TSCR4_AMPDU_ACKED_COUNT_MASK            0xFFFFFFFF                // AMPDU_ACKED_COUNT[31..0]
+#define BN0_WF_MIB_TOP_M0SDR6_CHANNEL_IDLE_COUNT_MASK          0x0000FFFF                // CHANNEL_IDLE_COUNT[15..0]
+#define BN0_WF_MIB_TOP_M0SDR9_CCA_NAV_TX_TIME_MASK             0x00FFFFFF                // CCA_NAV_TX_TIME[23..0]
+#define BN0_WF_MIB_TOP_RSCR26_RX_MDRDY_COUNT_MASK              0xFFFFFFFF                // RX_MDRDY_COUNT[31..0]
+#define BN0_WF_MIB_TOP_MSR0_CCK_MDRDY_TIME_MASK                0xFFFFFFFF                // CCK_MDRDY_TIME[31..0]
+#define BN0_WF_MIB_TOP_MSR1_OFDM_LG_MIXED_VHT_MDRDY_TIME_MASK  0xFFFFFFFF                // OFDM_LG_MIXED_VHT_MDRDY_TIME[31..0]
+#define BN0_WF_MIB_TOP_MSR2_OFDM_GREEN_MDRDY_TIME_MASK         0xFFFFFFFF                // OFDM_GREEN_MDRDY_TIME[31..0]
+#define BN0_WF_MIB_TOP_MCTR5_P_CCA_TIME_MASK                   0xFFFFFFFF                // P_CCA_TIME[31..0]
+#define BN0_WF_MIB_TOP_MCTR6_S_CCA_TIME_MASK                   0xFFFFFFFF                // S_CCA_TIME[31..0]
+#define BN0_WF_MIB_TOP_M0SDR18_P_ED_TIME_MASK                  0x00FFFFFF                // P_ED_TIME[23..0]
+#define BN0_WF_MIB_TOP_TSCR18_BEACONTXCOUNT_MASK               0xFFFFFFFF                // BEACONTXCOUNT[31..0]
+#define BN0_WF_MIB_TOP_TBCR0_TX_20MHZ_CNT_MASK                 0xFFFFFFFF                // TX_20MHZ_CNT[31..0]
+#define BN0_WF_MIB_TOP_TBCR1_TX_40MHZ_CNT_MASK                 0xFFFFFFFF                // TX_40MHZ_CNT[31..0]
+#define BN0_WF_MIB_TOP_TBCR2_TX_80MHZ_CNT_MASK                 0xFFFFFFFF                // TX_80MHZ_CNT[31..0]
+#define BN0_WF_MIB_TOP_TBCR3_TX_160MHZ_CNT_MASK                0xFFFFFFFF                // TX_160MHZ_CNT[31..0]
+#define BN0_WF_MIB_TOP_TBCR4_TX_320MHZ_CNT_MASK                0xFFFFFFFF                // TX_320MHZ_CNT[31..0]
+#define BN0_WF_MIB_TOP_BSCR2_MUBF_TX_COUNT_MASK                0xFFFFFFFF                // MUBF_TX_COUNT[31..0]
+#define BN0_WF_MIB_TOP_RVSR0_VEC_MISS_COUNT_MASK               0xFFFFFFFF                // VEC_MISS_COUNT[31..0]
+#define BN0_WF_MIB_TOP_RSCR35_DELIMITER_FAIL_COUNT_MASK        0xFFFFFFFF                // DELIMITER_FAIL_COUNT[31..0]
+#define BN0_WF_MIB_TOP_RSCR1_RX_FCS_ERROR_COUNT_MASK           0xFFFFFFFF                // RX_FCS_ERROR_COUNT[31..0]
+#define BN0_WF_MIB_TOP_RSCR33_RX_FIFO_FULL_COUNT_MASK          0xFFFFFFFF                // RX_FIFO_FULL_COUNT[31..0]
+#define BN0_WF_MIB_TOP_RSCR36_RX_LEN_MISMATCH_MASK             0xFFFFFFFF                // RX_LEN_MISMATCH[31..0]
+#define BN0_WF_MIB_TOP_RSCR31_RX_MPDU_COUNT_MASK               0xFFFFFFFF                // RX_MPDU_COUNT[31..0]
+#define BN0_WF_MIB_TOP_BTSCR5_RTSTXCOUNTn_MASK                 0xFFFFFFFF                // RTSTXCOUNTn[31..0]
+#define BN0_WF_MIB_TOP_BTSCR6_RTSRETRYCOUNTn_MASK              0xFFFFFFFF                // RTSRETRYCOUNTn[31..0]
+#define BN0_WF_MIB_TOP_BTSCR0_BAMISSCOUNTn_MASK                0xFFFFFFFF                // BAMISSCOUNTn[31..0]
+#define BN0_WF_MIB_TOP_BTSCR1_ACKFAILCOUNTn_MASK               0xFFFFFFFF                // ACKFAILCOUNTn[31..0]
+#define BN0_WF_MIB_TOP_BTSCR2_FRAMERETRYCOUNTn_MASK            0xFFFFFFFF                // FRAMERETRYCOUNTn[31..0]
+#define BN0_WF_MIB_TOP_BTSCR3_FRAMERETRY2COUNTn_MASK           0xFFFFFFFF                // FRAMERETRY2COUNTn[31..0]
+#define BN0_WF_MIB_TOP_BTSCR4_FRAMERETRY3COUNTn_MASK           0xFFFFFFFF                // FRAMERETRY3COUNTn[31..0]
+#define BN0_WF_MIB_TOP_TRARC0_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x0B0) // D0B0
+#define BN0_WF_MIB_TOP_TRARC1_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x0B4) // D0B4
+#define BN0_WF_MIB_TOP_TRARC2_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x0B8) // D0B8
+#define BN0_WF_MIB_TOP_TRARC3_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x0BC) // D0BC
+#define BN0_WF_MIB_TOP_TRARC4_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x0C0) // D0C0
+#define BN0_WF_MIB_TOP_TRARC5_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x0C4) // D0C4
+#define BN0_WF_MIB_TOP_TRARC6_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x0C8) // D0C8
+#define BN0_WF_MIB_TOP_TRARC7_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x0CC) // D0CC
+
+#define BN0_WF_MIB_TOP_TRDR0_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR0))
+#define BN0_WF_MIB_TOP_TRDR1_ADDR                              (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_TRDR1))
+#define BN0_WF_MIB_TOP_TRDR2_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR2))
+#define BN0_WF_MIB_TOP_TRDR3_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR3))
+#define BN0_WF_MIB_TOP_TRDR4_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR4))
+#define BN0_WF_MIB_TOP_TRDR5_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR5))
+#define BN0_WF_MIB_TOP_TRDR6_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR6))
+#define BN0_WF_MIB_TOP_TRDR7_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR7))
+#define BN0_WF_MIB_TOP_TRDR8_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR8))
+#define BN0_WF_MIB_TOP_TRDR9_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR9))
+#define BN0_WF_MIB_TOP_TRDR10_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR10))
+#define BN0_WF_MIB_TOP_TRDR11_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR11))
+#define BN0_WF_MIB_TOP_TRDR12_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR12))
+#define BN0_WF_MIB_TOP_TRDR13_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR13))
+#define BN0_WF_MIB_TOP_TRDR14_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR14))
+#define BN0_WF_MIB_TOP_TRDR15_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR15))
+
+#define BN0_WF_MIB_TOP_TRARC0_AGG_RANG_SEL_1_ADDR              BN0_WF_MIB_TOP_TRARC0_ADDR
+#define BN0_WF_MIB_TOP_TRARC0_AGG_RANG_SEL_1_MASK              0x03FF0000                // AGG_RANG_SEL_1[25..16]
+#define BN0_WF_MIB_TOP_TRARC0_AGG_RANG_SEL_1_SHFT              16
+#define BN0_WF_MIB_TOP_TRARC0_AGG_RANG_SEL_0_ADDR              BN0_WF_MIB_TOP_TRARC0_ADDR
+#define BN0_WF_MIB_TOP_TRARC0_AGG_RANG_SEL_0_MASK              0x000003FF                // AGG_RANG_SEL_0[9..0]
+#define BN0_WF_MIB_TOP_TRARC0_AGG_RANG_SEL_0_SHFT              0
+
+#define BN0_WF_MIB_TOP_TRARC1_AGG_RANG_SEL_3_ADDR              BN0_WF_MIB_TOP_TRARC1_ADDR
+#define BN0_WF_MIB_TOP_TRARC1_AGG_RANG_SEL_3_MASK              0x03FF0000                // AGG_RANG_SEL_3[25..16]
+#define BN0_WF_MIB_TOP_TRARC1_AGG_RANG_SEL_3_SHFT              16
+#define BN0_WF_MIB_TOP_TRARC1_AGG_RANG_SEL_2_ADDR              BN0_WF_MIB_TOP_TRARC1_ADDR
+#define BN0_WF_MIB_TOP_TRARC1_AGG_RANG_SEL_2_MASK              0x000003FF                // AGG_RANG_SEL_2[9..0]
+#define BN0_WF_MIB_TOP_TRARC1_AGG_RANG_SEL_2_SHFT              0
+
+#define BN0_WF_MIB_TOP_TRARC2_AGG_RANG_SEL_5_ADDR              BN0_WF_MIB_TOP_TRARC2_ADDR
+#define BN0_WF_MIB_TOP_TRARC2_AGG_RANG_SEL_5_MASK              0x03FF0000                // AGG_RANG_SEL_5[25..16]
+#define BN0_WF_MIB_TOP_TRARC2_AGG_RANG_SEL_5_SHFT              16
+#define BN0_WF_MIB_TOP_TRARC2_AGG_RANG_SEL_4_ADDR              BN0_WF_MIB_TOP_TRARC2_ADDR
+#define BN0_WF_MIB_TOP_TRARC2_AGG_RANG_SEL_4_MASK              0x000003FF                // AGG_RANG_SEL_4[9..0]
+#define BN0_WF_MIB_TOP_TRARC2_AGG_RANG_SEL_4_SHFT              0
+
+#define BN0_WF_MIB_TOP_TRARC3_AGG_RANG_SEL_7_ADDR              BN0_WF_MIB_TOP_TRARC3_ADDR
+#define BN0_WF_MIB_TOP_TRARC3_AGG_RANG_SEL_7_MASK              0x03FF0000                // AGG_RANG_SEL_7[25..16]
+#define BN0_WF_MIB_TOP_TRARC3_AGG_RANG_SEL_7_SHFT              16
+#define BN0_WF_MIB_TOP_TRARC3_AGG_RANG_SEL_6_ADDR              BN0_WF_MIB_TOP_TRARC3_ADDR
+#define BN0_WF_MIB_TOP_TRARC3_AGG_RANG_SEL_6_MASK              0x000003FF                // AGG_RANG_SEL_6[9..0]
+#define BN0_WF_MIB_TOP_TRARC3_AGG_RANG_SEL_6_SHFT              0
+
+#define BN0_WF_MIB_TOP_TRARC4_AGG_RANG_SEL_9_ADDR              BN0_WF_MIB_TOP_TRARC4_ADDR
+#define BN0_WF_MIB_TOP_TRARC4_AGG_RANG_SEL_9_MASK              0x03FF0000                // AGG_RANG_SEL_9[25..16]
+#define BN0_WF_MIB_TOP_TRARC4_AGG_RANG_SEL_9_SHFT              16
+#define BN0_WF_MIB_TOP_TRARC4_AGG_RANG_SEL_8_ADDR              BN0_WF_MIB_TOP_TRARC4_ADDR
+#define BN0_WF_MIB_TOP_TRARC4_AGG_RANG_SEL_8_MASK              0x000003FF                // AGG_RANG_SEL_8[9..0]
+#define BN0_WF_MIB_TOP_TRARC4_AGG_RANG_SEL_8_SHFT              0
+
+#define BN0_WF_MIB_TOP_TRARC5_AGG_RANG_SEL_11_ADDR             BN0_WF_MIB_TOP_TRARC5_ADDR
+#define BN0_WF_MIB_TOP_TRARC5_AGG_RANG_SEL_11_MASK             0x03FF0000                // AGG_RANG_SEL_11[25..16]
+#define BN0_WF_MIB_TOP_TRARC5_AGG_RANG_SEL_11_SHFT             16
+#define BN0_WF_MIB_TOP_TRARC5_AGG_RANG_SEL_10_ADDR             BN0_WF_MIB_TOP_TRARC5_ADDR
+#define BN0_WF_MIB_TOP_TRARC5_AGG_RANG_SEL_10_MASK             0x000003FF                // AGG_RANG_SEL_10[9..0]
+#define BN0_WF_MIB_TOP_TRARC5_AGG_RANG_SEL_10_SHFT             0
+
+#define BN0_WF_MIB_TOP_TRARC6_AGG_RANG_SEL_13_ADDR             BN0_WF_MIB_TOP_TRARC6_ADDR
+#define BN0_WF_MIB_TOP_TRARC6_AGG_RANG_SEL_13_MASK             0x03FF0000                // AGG_RANG_SEL_13[25..16]
+#define BN0_WF_MIB_TOP_TRARC6_AGG_RANG_SEL_13_SHFT             16
+#define BN0_WF_MIB_TOP_TRARC6_AGG_RANG_SEL_12_ADDR             BN0_WF_MIB_TOP_TRARC6_ADDR
+#define BN0_WF_MIB_TOP_TRARC6_AGG_RANG_SEL_12_MASK             0x000003FF                // AGG_RANG_SEL_12[9..0]
+#define BN0_WF_MIB_TOP_TRARC6_AGG_RANG_SEL_12_SHFT             0
+
+#define BN0_WF_MIB_TOP_TRARC7_AGG_RANG_SEL_14_ADDR             BN0_WF_MIB_TOP_TRARC7_ADDR
+#define BN0_WF_MIB_TOP_TRARC7_AGG_RANG_SEL_14_MASK             0x000003FF                // AGG_RANG_SEL_14[9..0]
+#define BN0_WF_MIB_TOP_TRARC7_AGG_RANG_SEL_14_SHFT             0
+
+/* RRO TOP */
+#define WF_RRO_TOP_BASE                                        0xA000 /*0x820C2000 */
+#define WF_RRO_TOP_IND_CMD_0_CTRL0_ADDR                        (WF_RRO_TOP_BASE + 0x40) // 2040
+											//
+/* WTBL */
+enum mt7996_wtbl_type {
+	WTBL_TYPE_LMAC, 	/* WTBL in LMAC */
+	WTBL_TYPE_UMAC, 	/* WTBL in UMAC */
+	WTBL_TYPE_KEY,		/* Key Table */
+	MAX_NUM_WTBL_TYPE
+};
+
+struct berse_wtbl_parse {
+	u8 *name;
+	u32 mask;
+	u32 shift;
+	u8 new_line;
+};
+
+enum muar_idx {
+	MUAR_INDEX_OWN_MAC_ADDR_0 = 0,
+	MUAR_INDEX_OWN_MAC_ADDR_1,
+	MUAR_INDEX_OWN_MAC_ADDR_2,
+	MUAR_INDEX_OWN_MAC_ADDR_3,
+	MUAR_INDEX_OWN_MAC_ADDR_4,
+	MUAR_INDEX_OWN_MAC_ADDR_BC_MC = 0xE,
+	MUAR_INDEX_UNMATCHED = 0xF,
+	MUAR_INDEX_OWN_MAC_ADDR_11 = 0x11,
+	MUAR_INDEX_OWN_MAC_ADDR_12,
+	MUAR_INDEX_OWN_MAC_ADDR_13,
+	MUAR_INDEX_OWN_MAC_ADDR_14,
+	MUAR_INDEX_OWN_MAC_ADDR_15,
+	MUAR_INDEX_OWN_MAC_ADDR_16,
+	MUAR_INDEX_OWN_MAC_ADDR_17,
+	MUAR_INDEX_OWN_MAC_ADDR_18,
+	MUAR_INDEX_OWN_MAC_ADDR_19,
+	MUAR_INDEX_OWN_MAC_ADDR_1A,
+	MUAR_INDEX_OWN_MAC_ADDR_1B,
+	MUAR_INDEX_OWN_MAC_ADDR_1C,
+	MUAR_INDEX_OWN_MAC_ADDR_1D,
+	MUAR_INDEX_OWN_MAC_ADDR_1E,
+	MUAR_INDEX_OWN_MAC_ADDR_1F,
+	MUAR_INDEX_OWN_MAC_ADDR_20,
+	MUAR_INDEX_OWN_MAC_ADDR_21,
+	MUAR_INDEX_OWN_MAC_ADDR_22,
+	MUAR_INDEX_OWN_MAC_ADDR_23,
+	MUAR_INDEX_OWN_MAC_ADDR_24,
+	MUAR_INDEX_OWN_MAC_ADDR_25,
+	MUAR_INDEX_OWN_MAC_ADDR_26,
+	MUAR_INDEX_OWN_MAC_ADDR_27,
+	MUAR_INDEX_OWN_MAC_ADDR_28,
+	MUAR_INDEX_OWN_MAC_ADDR_29,
+	MUAR_INDEX_OWN_MAC_ADDR_2A,
+	MUAR_INDEX_OWN_MAC_ADDR_2B,
+	MUAR_INDEX_OWN_MAC_ADDR_2C,
+	MUAR_INDEX_OWN_MAC_ADDR_2D,
+	MUAR_INDEX_OWN_MAC_ADDR_2E,
+	MUAR_INDEX_OWN_MAC_ADDR_2F
+};
+
+enum cipher_suit {
+	IGTK_CIPHER_SUIT_NONE = 0,
+	IGTK_CIPHER_SUIT_BIP,
+	IGTK_CIPHER_SUIT_BIP_256
+};
+
+#define LWTBL_LEN_IN_DW			36
+#define UWTBL_LEN_IN_DW			16
+
+#define MT_DBG_WTBL_BASE		0x820D8000
+
+#define MT_DBG_WTBLON_TOP_BASE		0x820d4000
+#define MT_DBG_WTBLON_TOP_WDUCR_ADDR	(MT_DBG_WTBLON_TOP_BASE + 0x0370) // 4370
+#define MT_DBG_WTBLON_TOP_WDUCR_GROUP	GENMASK(4, 0)
+
+#define MT_DBG_UWTBL_TOP_BASE		0x820c4000
+#define MT_DBG_UWTBL_TOP_WDUCR_ADDR	(MT_DBG_UWTBL_TOP_BASE + 0x0104) // 4104
+#define MT_DBG_UWTBL_TOP_WDUCR_GROUP	GENMASK(5, 0)
+#define MT_DBG_UWTBL_TOP_WDUCR_TARGET	BIT(31)
+
+#define LWTBL_IDX2BASE_ID		GENMASK(14, 8)
+#define LWTBL_IDX2BASE_DW		GENMASK(7, 2)
+#define LWTBL_IDX2BASE(_id, _dw)	(MT_DBG_WTBL_BASE | \
+					FIELD_PREP(LWTBL_IDX2BASE_ID, _id) | \
+					FIELD_PREP(LWTBL_IDX2BASE_DW, _dw))
+
+#define UWTBL_IDX2BASE_ID		GENMASK(12, 6)
+#define UWTBL_IDX2BASE_DW		GENMASK(5, 2)
+#define UWTBL_IDX2BASE(_id, _dw)	(MT_DBG_UWTBL_TOP_BASE | 0x2000 | \
+					FIELD_PREP(UWTBL_IDX2BASE_ID, _id) | \
+					FIELD_PREP(UWTBL_IDX2BASE_DW, _dw))
+
+#define KEYTBL_IDX2BASE_KEY		GENMASK(12, 6)
+#define KEYTBL_IDX2BASE_DW		GENMASK(5, 2)
+#define KEYTBL_IDX2BASE(_key, _dw)	(MT_DBG_UWTBL_TOP_BASE | 0x2000 | \
+					FIELD_PREP(KEYTBL_IDX2BASE_KEY, _key) | \
+					FIELD_PREP(KEYTBL_IDX2BASE_DW, _dw))
+
+// UMAC WTBL
+// DW0
+#define WF_UWTBL_PEER_MLD_ADDRESS_47_32__DW                         0
+#define WF_UWTBL_PEER_MLD_ADDRESS_47_32__ADDR                       0
+#define WF_UWTBL_PEER_MLD_ADDRESS_47_32__MASK                       0x0000ffff // 15- 0
+#define WF_UWTBL_PEER_MLD_ADDRESS_47_32__SHIFT                      0
+#define WF_UWTBL_OWN_MLD_ID_DW                                      0
+#define WF_UWTBL_OWN_MLD_ID_ADDR                                    0
+#define WF_UWTBL_OWN_MLD_ID_MASK                                    0x003f0000 // 21-16
+#define WF_UWTBL_OWN_MLD_ID_SHIFT                                   16
+// DW1
+#define WF_UWTBL_PEER_MLD_ADDRESS_31_0__DW                          1
+#define WF_UWTBL_PEER_MLD_ADDRESS_31_0__ADDR                        4
+#define WF_UWTBL_PEER_MLD_ADDRESS_31_0__MASK                        0xffffffff // 31- 0
+#define WF_UWTBL_PEER_MLD_ADDRESS_31_0__SHIFT                       0
+// DW2
+#define WF_UWTBL_PN_31_0__DW                                        2
+#define WF_UWTBL_PN_31_0__ADDR                                      8
+#define WF_UWTBL_PN_31_0__MASK                                      0xffffffff // 31- 0
+#define WF_UWTBL_PN_31_0__SHIFT                                     0
+// DW3
+#define WF_UWTBL_PN_47_32__DW                                       3
+#define WF_UWTBL_PN_47_32__ADDR                                     12
+#define WF_UWTBL_PN_47_32__MASK                                     0x0000ffff // 15- 0
+#define WF_UWTBL_PN_47_32__SHIFT                                    0
+#define WF_UWTBL_COM_SN_DW                                          3
+#define WF_UWTBL_COM_SN_ADDR                                        12
+#define WF_UWTBL_COM_SN_MASK                                        0x0fff0000 // 27-16
+#define WF_UWTBL_COM_SN_SHIFT                                       16
+// DW4
+#define WF_UWTBL_TID0_SN_DW                                         4
+#define WF_UWTBL_TID0_SN_ADDR                                       16
+#define WF_UWTBL_TID0_SN_MASK                                       0x00000fff // 11- 0
+#define WF_UWTBL_TID0_SN_SHIFT                                      0
+#define WF_UWTBL_RX_BIPN_31_0__DW                                   4
+#define WF_UWTBL_RX_BIPN_31_0__ADDR                                 16
+#define WF_UWTBL_RX_BIPN_31_0__MASK                                 0xffffffff // 31- 0
+#define WF_UWTBL_RX_BIPN_31_0__SHIFT                                0
+#define WF_UWTBL_TID1_SN_DW                                         4
+#define WF_UWTBL_TID1_SN_ADDR                                       16
+#define WF_UWTBL_TID1_SN_MASK                                       0x00fff000 // 23-12
+#define WF_UWTBL_TID1_SN_SHIFT                                      12
+#define WF_UWTBL_TID2_SN_7_0__DW                                    4
+#define WF_UWTBL_TID2_SN_7_0__ADDR                                  16
+#define WF_UWTBL_TID2_SN_7_0__MASK                                  0xff000000 // 31-24
+#define WF_UWTBL_TID2_SN_7_0__SHIFT                                 24
+// DW5
+#define WF_UWTBL_TID2_SN_11_8__DW                                   5
+#define WF_UWTBL_TID2_SN_11_8__ADDR                                 20
+#define WF_UWTBL_TID2_SN_11_8__MASK                                 0x0000000f //  3- 0
+#define WF_UWTBL_TID2_SN_11_8__SHIFT                                0
+#define WF_UWTBL_RX_BIPN_47_32__DW                                  5
+#define WF_UWTBL_RX_BIPN_47_32__ADDR                                20
+#define WF_UWTBL_RX_BIPN_47_32__MASK                                0x0000ffff // 15- 0
+#define WF_UWTBL_RX_BIPN_47_32__SHIFT                               0
+#define WF_UWTBL_TID3_SN_DW                                         5
+#define WF_UWTBL_TID3_SN_ADDR                                       20
+#define WF_UWTBL_TID3_SN_MASK                                       0x0000fff0 // 15- 4
+#define WF_UWTBL_TID3_SN_SHIFT                                      4
+#define WF_UWTBL_TID4_SN_DW                                         5
+#define WF_UWTBL_TID4_SN_ADDR                                       20
+#define WF_UWTBL_TID4_SN_MASK                                       0x0fff0000 // 27-16
+#define WF_UWTBL_TID4_SN_SHIFT                                      16
+#define WF_UWTBL_TID5_SN_3_0__DW                                    5
+#define WF_UWTBL_TID5_SN_3_0__ADDR                                  20
+#define WF_UWTBL_TID5_SN_3_0__MASK                                  0xf0000000 // 31-28
+#define WF_UWTBL_TID5_SN_3_0__SHIFT                                 28
+// DW6
+#define WF_UWTBL_TID5_SN_11_4__DW                                   6
+#define WF_UWTBL_TID5_SN_11_4__ADDR                                 24
+#define WF_UWTBL_TID5_SN_11_4__MASK                                 0x000000ff //  7- 0
+#define WF_UWTBL_TID5_SN_11_4__SHIFT                                0
+#define WF_UWTBL_KEY_LOC2_DW                                        6
+#define WF_UWTBL_KEY_LOC2_ADDR                                      24
+#define WF_UWTBL_KEY_LOC2_MASK                                      0x00001fff // 12- 0
+#define WF_UWTBL_KEY_LOC2_SHIFT                                     0
+#define WF_UWTBL_TID6_SN_DW                                         6
+#define WF_UWTBL_TID6_SN_ADDR                                       24
+#define WF_UWTBL_TID6_SN_MASK                                       0x000fff00 // 19- 8
+#define WF_UWTBL_TID6_SN_SHIFT                                      8
+#define WF_UWTBL_TID7_SN_DW                                         6
+#define WF_UWTBL_TID7_SN_ADDR                                       24
+#define WF_UWTBL_TID7_SN_MASK                                       0xfff00000 // 31-20
+#define WF_UWTBL_TID7_SN_SHIFT                                      20
+// DW7
+#define WF_UWTBL_KEY_LOC0_DW                                        7
+#define WF_UWTBL_KEY_LOC0_ADDR                                      28
+#define WF_UWTBL_KEY_LOC0_MASK                                      0x00001fff // 12- 0
+#define WF_UWTBL_KEY_LOC0_SHIFT                                     0
+#define WF_UWTBL_KEY_LOC1_DW                                        7
+#define WF_UWTBL_KEY_LOC1_ADDR                                      28
+#define WF_UWTBL_KEY_LOC1_MASK                                      0x1fff0000 // 28-16
+#define WF_UWTBL_KEY_LOC1_SHIFT                                     16
+// DW8
+#define WF_UWTBL_AMSDU_CFG_DW                                       8
+#define WF_UWTBL_AMSDU_CFG_ADDR                                     32
+#define WF_UWTBL_AMSDU_CFG_MASK                                     0x00000fff // 11- 0
+#define WF_UWTBL_AMSDU_CFG_SHIFT                                    0
+#define WF_UWTBL_SEC_ADDR_MODE_DW                                   8
+#define WF_UWTBL_SEC_ADDR_MODE_ADDR                                 32
+#define WF_UWTBL_SEC_ADDR_MODE_MASK                                 0x00300000 // 21-20
+#define WF_UWTBL_SEC_ADDR_MODE_SHIFT                                20
+#define WF_UWTBL_WMM_Q_DW                                           8
+#define WF_UWTBL_WMM_Q_ADDR                                         32
+#define WF_UWTBL_WMM_Q_MASK                                         0x06000000 // 26-25
+#define WF_UWTBL_WMM_Q_SHIFT                                        25
+#define WF_UWTBL_QOS_DW                                             8
+#define WF_UWTBL_QOS_ADDR                                           32
+#define WF_UWTBL_QOS_MASK                                           0x08000000 // 27-27
+#define WF_UWTBL_QOS_SHIFT                                          27
+#define WF_UWTBL_HT_DW                                              8
+#define WF_UWTBL_HT_ADDR                                            32
+#define WF_UWTBL_HT_MASK                                            0x10000000 // 28-28
+#define WF_UWTBL_HT_SHIFT                                           28
+#define WF_UWTBL_HDRT_MODE_DW                                       8
+#define WF_UWTBL_HDRT_MODE_ADDR                                     32
+#define WF_UWTBL_HDRT_MODE_MASK                                     0x20000000 // 29-29
+#define WF_UWTBL_HDRT_MODE_SHIFT                                    29
+// DW9
+#define WF_UWTBL_RELATED_IDX0_DW                                    9
+#define WF_UWTBL_RELATED_IDX0_ADDR                                  36
+#define WF_UWTBL_RELATED_IDX0_MASK                                  0x00000fff // 11- 0
+#define WF_UWTBL_RELATED_IDX0_SHIFT                                 0
+#define WF_UWTBL_RELATED_BAND0_DW                                   9
+#define WF_UWTBL_RELATED_BAND0_ADDR                                 36
+#define WF_UWTBL_RELATED_BAND0_MASK                                 0x00003000 // 13-12
+#define WF_UWTBL_RELATED_BAND0_SHIFT                                12
+#define WF_UWTBL_PRIMARY_MLD_BAND_DW                                9
+#define WF_UWTBL_PRIMARY_MLD_BAND_ADDR                              36
+#define WF_UWTBL_PRIMARY_MLD_BAND_MASK                              0x0000c000 // 15-14
+#define WF_UWTBL_PRIMARY_MLD_BAND_SHIFT                             14
+#define WF_UWTBL_RELATED_IDX1_DW                                    9
+#define WF_UWTBL_RELATED_IDX1_ADDR                                  36
+#define WF_UWTBL_RELATED_IDX1_MASK                                  0x0fff0000 // 27-16
+#define WF_UWTBL_RELATED_IDX1_SHIFT                                 16
+#define WF_UWTBL_RELATED_BAND1_DW                                   9
+#define WF_UWTBL_RELATED_BAND1_ADDR                                 36
+#define WF_UWTBL_RELATED_BAND1_MASK                                 0x30000000 // 29-28
+#define WF_UWTBL_RELATED_BAND1_SHIFT                                28
+#define WF_UWTBL_SECONDARY_MLD_BAND_DW                              9
+#define WF_UWTBL_SECONDARY_MLD_BAND_ADDR                            36
+#define WF_UWTBL_SECONDARY_MLD_BAND_MASK                            0xc0000000 // 31-30
+#define WF_UWTBL_SECONDARY_MLD_BAND_SHIFT                           30
+
+/* LMAC WTBL */
+// DW0
+#define WF_LWTBL_PEER_LINK_ADDRESS_47_32__DW                        0
+#define WF_LWTBL_PEER_LINK_ADDRESS_47_32__ADDR                      0
+#define WF_LWTBL_PEER_LINK_ADDRESS_47_32__MASK \
+	0x0000ffff // 15- 0
+#define WF_LWTBL_PEER_LINK_ADDRESS_47_32__SHIFT                     0
+#define WF_LWTBL_MUAR_DW                                            0
+#define WF_LWTBL_MUAR_ADDR                                          0
+#define WF_LWTBL_MUAR_MASK \
+	0x003f0000 // 21-16
+#define WF_LWTBL_MUAR_SHIFT                                         16
+#define WF_LWTBL_RCA1_DW                                            0
+#define WF_LWTBL_RCA1_ADDR                                          0
+#define WF_LWTBL_RCA1_MASK \
+	0x00400000 // 22-22
+#define WF_LWTBL_RCA1_SHIFT                                         22
+#define WF_LWTBL_KID_DW                                             0
+#define WF_LWTBL_KID_ADDR                                           0
+#define WF_LWTBL_KID_MASK \
+	0x01800000 // 24-23
+#define WF_LWTBL_KID_SHIFT                                          23
+#define WF_LWTBL_RCID_DW                                            0
+#define WF_LWTBL_RCID_ADDR                                          0
+#define WF_LWTBL_RCID_MASK \
+	0x02000000 // 25-25
+#define WF_LWTBL_RCID_SHIFT                                         25
+#define WF_LWTBL_BAND_DW                                            0
+#define WF_LWTBL_BAND_ADDR                                          0
+#define WF_LWTBL_BAND_MASK \
+	0x0c000000 // 27-26
+#define WF_LWTBL_BAND_SHIFT                                         26
+#define WF_LWTBL_RV_DW                                              0
+#define WF_LWTBL_RV_ADDR                                            0
+#define WF_LWTBL_RV_MASK \
+	0x10000000 // 28-28
+#define WF_LWTBL_RV_SHIFT                                           28
+#define WF_LWTBL_RCA2_DW                                            0
+#define WF_LWTBL_RCA2_ADDR                                          0
+#define WF_LWTBL_RCA2_MASK \
+	0x20000000 // 29-29
+#define WF_LWTBL_RCA2_SHIFT                                         29
+#define WF_LWTBL_WPI_FLAG_DW                                        0
+#define WF_LWTBL_WPI_FLAG_ADDR                                      0
+#define WF_LWTBL_WPI_FLAG_MASK \
+	0x40000000 // 30-30
+#define WF_LWTBL_WPI_FLAG_SHIFT                                     30
+// DW1
+#define WF_LWTBL_PEER_LINK_ADDRESS_31_0__DW                         1
+#define WF_LWTBL_PEER_LINK_ADDRESS_31_0__ADDR                       4
+#define WF_LWTBL_PEER_LINK_ADDRESS_31_0__MASK \
+	0xffffffff // 31- 0
+#define WF_LWTBL_PEER_LINK_ADDRESS_31_0__SHIFT                      0
+// DW2
+#define WF_LWTBL_AID_DW                                             2
+#define WF_LWTBL_AID_ADDR                                           8
+#define WF_LWTBL_AID_MASK \
+	0x00000fff // 11- 0
+#define WF_LWTBL_AID_SHIFT                                          0
+#define WF_LWTBL_GID_SU_DW                                          2
+#define WF_LWTBL_GID_SU_ADDR                                        8
+#define WF_LWTBL_GID_SU_MASK \
+	0x00001000 // 12-12
+#define WF_LWTBL_GID_SU_SHIFT                                       12
+#define WF_LWTBL_SPP_EN_DW                                          2
+#define WF_LWTBL_SPP_EN_ADDR                                        8
+#define WF_LWTBL_SPP_EN_MASK \
+	0x00002000 // 13-13
+#define WF_LWTBL_SPP_EN_SHIFT                                       13
+#define WF_LWTBL_WPI_EVEN_DW                                        2
+#define WF_LWTBL_WPI_EVEN_ADDR                                      8
+#define WF_LWTBL_WPI_EVEN_MASK \
+	0x00004000 // 14-14
+#define WF_LWTBL_WPI_EVEN_SHIFT                                     14
+#define WF_LWTBL_AAD_OM_DW                                          2
+#define WF_LWTBL_AAD_OM_ADDR                                        8
+#define WF_LWTBL_AAD_OM_MASK \
+	0x00008000 // 15-15
+#define WF_LWTBL_AAD_OM_SHIFT                                       15
+/* kite DW2 field bit 13-14 */
+#define WF_LWTBL_DUAL_PTEC_EN_DW                                    2
+#define WF_LWTBL_DUAL_PTEC_EN_ADDR                                  8
+#define WF_LWTBL_DUAL_PTEC_EN_MASK \
+	0x00002000 // 13-13
+#define WF_LWTBL_DUAL_PTEC_EN_SHIFT                                 13
+#define WF_LWTBL_DUAL_CTS_CAP_DW                                    2
+#define WF_LWTBL_DUAL_CTS_CAP_ADDR                                  8
+#define WF_LWTBL_DUAL_CTS_CAP_MASK \
+	0x00004000 // 14-14
+#define WF_LWTBL_DUAL_CTS_CAP_SHIFT                                 14
+#define WF_LWTBL_CIPHER_SUIT_PGTK_DW                                2
+#define WF_LWTBL_CIPHER_SUIT_PGTK_ADDR                              8
+#define WF_LWTBL_CIPHER_SUIT_PGTK_MASK \
+	0x001f0000 // 20-16
+#define WF_LWTBL_CIPHER_SUIT_PGTK_SHIFT                             16
+#define WF_LWTBL_FD_DW                                              2
+#define WF_LWTBL_FD_ADDR                                            8
+#define WF_LWTBL_FD_MASK \
+	0x00200000 // 21-21
+#define WF_LWTBL_FD_SHIFT                                           21
+#define WF_LWTBL_TD_DW                                              2
+#define WF_LWTBL_TD_ADDR                                            8
+#define WF_LWTBL_TD_MASK \
+	0x00400000 // 22-22
+#define WF_LWTBL_TD_SHIFT                                           22
+#define WF_LWTBL_SW_DW                                              2
+#define WF_LWTBL_SW_ADDR                                            8
+#define WF_LWTBL_SW_MASK \
+	0x00800000 // 23-23
+#define WF_LWTBL_SW_SHIFT                                           23
+#define WF_LWTBL_UL_DW                                              2
+#define WF_LWTBL_UL_ADDR                                            8
+#define WF_LWTBL_UL_MASK \
+	0x01000000 // 24-24
+#define WF_LWTBL_UL_SHIFT                                           24
+#define WF_LWTBL_TX_PS_DW                                           2
+#define WF_LWTBL_TX_PS_ADDR                                         8
+#define WF_LWTBL_TX_PS_MASK \
+	0x02000000 // 25-25
+#define WF_LWTBL_TX_PS_SHIFT                                        25
+#define WF_LWTBL_QOS_DW                                             2
+#define WF_LWTBL_QOS_ADDR                                           8
+#define WF_LWTBL_QOS_MASK \
+	0x04000000 // 26-26
+#define WF_LWTBL_QOS_SHIFT                                          26
+#define WF_LWTBL_HT_DW                                              2
+#define WF_LWTBL_HT_ADDR                                            8
+#define WF_LWTBL_HT_MASK \
+	0x08000000 // 27-27
+#define WF_LWTBL_HT_SHIFT                                           27
+#define WF_LWTBL_VHT_DW                                             2
+#define WF_LWTBL_VHT_ADDR                                           8
+#define WF_LWTBL_VHT_MASK \
+	0x10000000 // 28-28
+#define WF_LWTBL_VHT_SHIFT                                          28
+#define WF_LWTBL_HE_DW                                              2
+#define WF_LWTBL_HE_ADDR                                            8
+#define WF_LWTBL_HE_MASK \
+	0x20000000 // 29-29
+#define WF_LWTBL_HE_SHIFT                                           29
+#define WF_LWTBL_EHT_DW                                             2
+#define WF_LWTBL_EHT_ADDR                                           8
+#define WF_LWTBL_EHT_MASK \
+	0x40000000 // 30-30
+#define WF_LWTBL_EHT_SHIFT                                          30
+#define WF_LWTBL_MESH_DW                                            2
+#define WF_LWTBL_MESH_ADDR                                          8
+#define WF_LWTBL_MESH_MASK \
+	0x80000000 // 31-31
+#define WF_LWTBL_MESH_SHIFT                                         31
+// DW3
+#define WF_LWTBL_WMM_Q_DW                                           3
+#define WF_LWTBL_WMM_Q_ADDR                                         12
+#define WF_LWTBL_WMM_Q_MASK \
+	0x00000003 // 1- 0
+#define WF_LWTBL_WMM_Q_SHIFT                                        0
+#define WF_LWTBL_EHT_SIG_MCS_DW                                     3
+#define WF_LWTBL_EHT_SIG_MCS_ADDR                                   12
+#define WF_LWTBL_EHT_SIG_MCS_MASK \
+	0x0000000c // 3- 2
+#define WF_LWTBL_EHT_SIG_MCS_SHIFT                                  2
+#define WF_LWTBL_HDRT_MODE_DW                                       3
+#define WF_LWTBL_HDRT_MODE_ADDR                                     12
+#define WF_LWTBL_HDRT_MODE_MASK \
+	0x00000010 // 4- 4
+#define WF_LWTBL_HDRT_MODE_SHIFT                                    4
+#define WF_LWTBL_BEAM_CHG_DW                                        3
+#define WF_LWTBL_BEAM_CHG_ADDR                                      12
+#define WF_LWTBL_BEAM_CHG_MASK \
+	0x00000020 // 5- 5
+#define WF_LWTBL_BEAM_CHG_SHIFT                                     5
+#define WF_LWTBL_EHT_LTF_SYM_NUM_OPT_DW                             3
+#define WF_LWTBL_EHT_LTF_SYM_NUM_OPT_ADDR                           12
+#define WF_LWTBL_EHT_LTF_SYM_NUM_OPT_MASK \
+	0x000000c0 // 7- 6
+#define WF_LWTBL_EHT_LTF_SYM_NUM_OPT_SHIFT                          6
+#define WF_LWTBL_PFMU_IDX_DW                                        3
+#define WF_LWTBL_PFMU_IDX_ADDR                                      12
+#define WF_LWTBL_PFMU_IDX_MASK \
+	0x0000ff00 // 15- 8
+#define WF_LWTBL_PFMU_IDX_SHIFT                                     8
+#define WF_LWTBL_ULPF_IDX_DW                                        3
+#define WF_LWTBL_ULPF_IDX_ADDR                                      12
+#define WF_LWTBL_ULPF_IDX_MASK \
+	0x00ff0000 // 23-16
+#define WF_LWTBL_ULPF_IDX_SHIFT                                     16
+#define WF_LWTBL_RIBF_DW                                            3
+#define WF_LWTBL_RIBF_ADDR                                          12
+#define WF_LWTBL_RIBF_MASK \
+	0x01000000 // 24-24
+#define WF_LWTBL_RIBF_SHIFT                                         24
+#define WF_LWTBL_ULPF_DW                                            3
+#define WF_LWTBL_ULPF_ADDR                                          12
+#define WF_LWTBL_ULPF_MASK \
+	0x02000000 // 25-25
+#define WF_LWTBL_ULPF_SHIFT                                         25
+#define WF_LWTBL_BYPASS_TXSMM_DW                                    3
+#define WF_LWTBL_BYPASS_TXSMM_ADDR                                  12
+#define WF_LWTBL_BYPASS_TXSMM_MASK \
+	0x04000000 // 26-26
+#define WF_LWTBL_BYPASS_TXSMM_SHIFT                                 26
+#define WF_LWTBL_TBF_HT_DW                                          3
+#define WF_LWTBL_TBF_HT_ADDR                                        12
+#define WF_LWTBL_TBF_HT_MASK \
+	0x08000000 // 27-27
+#define WF_LWTBL_TBF_HT_SHIFT                                       27
+#define WF_LWTBL_TBF_VHT_DW                                         3
+#define WF_LWTBL_TBF_VHT_ADDR                                       12
+#define WF_LWTBL_TBF_VHT_MASK \
+	0x10000000 // 28-28
+#define WF_LWTBL_TBF_VHT_SHIFT                                      28
+#define WF_LWTBL_TBF_HE_DW                                          3
+#define WF_LWTBL_TBF_HE_ADDR                                        12
+#define WF_LWTBL_TBF_HE_MASK \
+	0x20000000 // 29-29
+#define WF_LWTBL_TBF_HE_SHIFT                                       29
+#define WF_LWTBL_TBF_EHT_DW                                         3
+#define WF_LWTBL_TBF_EHT_ADDR                                       12
+#define WF_LWTBL_TBF_EHT_MASK \
+	0x40000000 // 30-30
+#define WF_LWTBL_TBF_EHT_SHIFT                                      30
+#define WF_LWTBL_IGN_FBK_DW                                         3
+#define WF_LWTBL_IGN_FBK_ADDR                                       12
+#define WF_LWTBL_IGN_FBK_MASK \
+	0x80000000 // 31-31
+#define WF_LWTBL_IGN_FBK_SHIFT                                      31
+// DW4
+#define WF_LWTBL_NEGOTIATED_WINSIZE0_DW                             4
+#define WF_LWTBL_NEGOTIATED_WINSIZE0_ADDR                           16
+#define WF_LWTBL_NEGOTIATED_WINSIZE0_MASK \
+	0x00000007 // 2- 0
+#define WF_LWTBL_NEGOTIATED_WINSIZE0_SHIFT                          0
+#define WF_LWTBL_NEGOTIATED_WINSIZE1_DW                             4
+#define WF_LWTBL_NEGOTIATED_WINSIZE1_ADDR                           16
+#define WF_LWTBL_NEGOTIATED_WINSIZE1_MASK \
+	0x00000038 // 5- 3
+#define WF_LWTBL_NEGOTIATED_WINSIZE1_SHIFT                          3
+#define WF_LWTBL_NEGOTIATED_WINSIZE2_DW                             4
+#define WF_LWTBL_NEGOTIATED_WINSIZE2_ADDR                           16
+#define WF_LWTBL_NEGOTIATED_WINSIZE2_MASK \
+	0x000001c0 // 8- 6
+#define WF_LWTBL_NEGOTIATED_WINSIZE2_SHIFT                          6
+#define WF_LWTBL_NEGOTIATED_WINSIZE3_DW                             4
+#define WF_LWTBL_NEGOTIATED_WINSIZE3_ADDR                           16
+#define WF_LWTBL_NEGOTIATED_WINSIZE3_MASK \
+	0x00000e00 // 11- 9
+#define WF_LWTBL_NEGOTIATED_WINSIZE3_SHIFT                          9
+#define WF_LWTBL_NEGOTIATED_WINSIZE4_DW                             4
+#define WF_LWTBL_NEGOTIATED_WINSIZE4_ADDR                           16
+#define WF_LWTBL_NEGOTIATED_WINSIZE4_MASK \
+	0x00007000 // 14-12
+#define WF_LWTBL_NEGOTIATED_WINSIZE4_SHIFT                          12
+#define WF_LWTBL_NEGOTIATED_WINSIZE5_DW                             4
+#define WF_LWTBL_NEGOTIATED_WINSIZE5_ADDR                           16
+#define WF_LWTBL_NEGOTIATED_WINSIZE5_MASK \
+	0x00038000 // 17-15
+#define WF_LWTBL_NEGOTIATED_WINSIZE5_SHIFT                          15
+#define WF_LWTBL_NEGOTIATED_WINSIZE6_DW                             4
+#define WF_LWTBL_NEGOTIATED_WINSIZE6_ADDR                           16
+#define WF_LWTBL_NEGOTIATED_WINSIZE6_MASK \
+	0x001c0000 // 20-18
+#define WF_LWTBL_NEGOTIATED_WINSIZE6_SHIFT                          18
+#define WF_LWTBL_NEGOTIATED_WINSIZE7_DW                             4
+#define WF_LWTBL_NEGOTIATED_WINSIZE7_ADDR                           16
+#define WF_LWTBL_NEGOTIATED_WINSIZE7_MASK \
+	0x00e00000 // 23-21
+#define WF_LWTBL_NEGOTIATED_WINSIZE7_SHIFT                          21
+#define WF_LWTBL_PE_DW                                              4
+#define WF_LWTBL_PE_ADDR                                            16
+#define WF_LWTBL_PE_MASK \
+	0x03000000 // 25-24
+#define WF_LWTBL_PE_SHIFT                                           24
+#define WF_LWTBL_DIS_RHTR_DW                                        4
+#define WF_LWTBL_DIS_RHTR_ADDR                                      16
+#define WF_LWTBL_DIS_RHTR_MASK \
+	0x04000000 // 26-26
+#define WF_LWTBL_DIS_RHTR_SHIFT                                     26
+#define WF_LWTBL_LDPC_HT_DW                                         4
+#define WF_LWTBL_LDPC_HT_ADDR                                       16
+#define WF_LWTBL_LDPC_HT_MASK \
+	0x08000000 // 27-27
+#define WF_LWTBL_LDPC_HT_SHIFT                                      27
+#define WF_LWTBL_LDPC_VHT_DW                                        4
+#define WF_LWTBL_LDPC_VHT_ADDR                                      16
+#define WF_LWTBL_LDPC_VHT_MASK \
+	0x10000000 // 28-28
+#define WF_LWTBL_LDPC_VHT_SHIFT                                     28
+#define WF_LWTBL_LDPC_HE_DW                                         4
+#define WF_LWTBL_LDPC_HE_ADDR                                       16
+#define WF_LWTBL_LDPC_HE_MASK \
+	0x20000000 // 29-29
+#define WF_LWTBL_LDPC_HE_SHIFT                                      29
+#define WF_LWTBL_LDPC_EHT_DW                                        4
+#define WF_LWTBL_LDPC_EHT_ADDR                                      16
+#define WF_LWTBL_LDPC_EHT_MASK \
+	0x40000000 // 30-30
+#define WF_LWTBL_LDPC_EHT_SHIFT                                     30
+#define WF_LWTBL_BA_MODE_DW                                         4
+#define WF_LWTBL_BA_MODE_ADDR                                       16
+#define WF_LWTBL_BA_MODE_MASK \
+	0x80000000 // 31-31
+#define WF_LWTBL_BA_MODE_SHIFT                                      31
+// DW5
+#define WF_LWTBL_AF_DW                                              5
+#define WF_LWTBL_AF_ADDR                                            20
+#define WF_LWTBL_AF_MASK \
+	0x00000007 // 2- 0
+#define WF_LWTBL_AF_MASK_7992 \
+	0x0000000f // 3- 0
+#define WF_LWTBL_AF_SHIFT                                           0
+#define WF_LWTBL_AF_HE_DW                                           5
+#define WF_LWTBL_AF_HE_ADDR                                         20
+#define WF_LWTBL_AF_HE_MASK \
+	0x00000018 // 4- 3
+#define WF_LWTBL_AF_HE_SHIFT                                        3
+#define WF_LWTBL_RTS_DW                                             5
+#define WF_LWTBL_RTS_ADDR                                           20
+#define WF_LWTBL_RTS_MASK \
+	0x00000020 // 5- 5
+#define WF_LWTBL_RTS_SHIFT                                          5
+#define WF_LWTBL_SMPS_DW                                            5
+#define WF_LWTBL_SMPS_ADDR                                          20
+#define WF_LWTBL_SMPS_MASK \
+	0x00000040 // 6- 6
+#define WF_LWTBL_SMPS_SHIFT                                         6
+#define WF_LWTBL_DYN_BW_DW                                          5
+#define WF_LWTBL_DYN_BW_ADDR                                        20
+#define WF_LWTBL_DYN_BW_MASK \
+	0x00000080 // 7- 7
+#define WF_LWTBL_DYN_BW_SHIFT                                       7
+#define WF_LWTBL_MMSS_DW                                            5
+#define WF_LWTBL_MMSS_ADDR                                          20
+#define WF_LWTBL_MMSS_MASK \
+	0x00000700 // 10- 8
+#define WF_LWTBL_MMSS_SHIFT                                         8
+#define WF_LWTBL_USR_DW                                             5
+#define WF_LWTBL_USR_ADDR                                           20
+#define WF_LWTBL_USR_MASK \
+	0x00000800 // 11-11
+#define WF_LWTBL_USR_SHIFT                                          11
+#define WF_LWTBL_SR_R_DW                                            5
+#define WF_LWTBL_SR_R_ADDR                                          20
+#define WF_LWTBL_SR_R_MASK \
+	0x00007000 // 14-12
+#define WF_LWTBL_SR_R_SHIFT                                         12
+#define WF_LWTBL_SR_ABORT_DW                                        5
+#define WF_LWTBL_SR_ABORT_ADDR                                      20
+#define WF_LWTBL_SR_ABORT_MASK \
+	0x00008000 // 15-15
+#define WF_LWTBL_SR_ABORT_SHIFT                                     15
+#define WF_LWTBL_TX_POWER_OFFSET_DW                                 5
+#define WF_LWTBL_TX_POWER_OFFSET_ADDR                               20
+#define WF_LWTBL_TX_POWER_OFFSET_MASK \
+	0x003f0000 // 21-16
+#define WF_LWTBL_TX_POWER_OFFSET_SHIFT                              16
+#define WF_LWTBL_LTF_EHT_DW                                         5
+#define WF_LWTBL_LTF_EHT_ADDR                                       20
+#define WF_LWTBL_LTF_EHT_MASK \
+	0x00c00000 // 23-22
+#define WF_LWTBL_LTF_EHT_SHIFT                                      22
+#define WF_LWTBL_GI_EHT_DW                                          5
+#define WF_LWTBL_GI_EHT_ADDR                                        20
+#define WF_LWTBL_GI_EHT_MASK \
+	0x03000000 // 25-24
+#define WF_LWTBL_GI_EHT_SHIFT                                       24
+#define WF_LWTBL_DOPPL_DW                                           5
+#define WF_LWTBL_DOPPL_ADDR                                         20
+#define WF_LWTBL_DOPPL_MASK \
+	0x04000000 // 26-26
+#define WF_LWTBL_DOPPL_SHIFT                                        26
+#define WF_LWTBL_TXOP_PS_CAP_DW                                     5
+#define WF_LWTBL_TXOP_PS_CAP_ADDR                                   20
+#define WF_LWTBL_TXOP_PS_CAP_MASK \
+	0x08000000 // 27-27
+#define WF_LWTBL_TXOP_PS_CAP_SHIFT                                  27
+#define WF_LWTBL_DU_I_PSM_DW                                        5
+#define WF_LWTBL_DU_I_PSM_ADDR                                      20
+#define WF_LWTBL_DU_I_PSM_MASK \
+	0x10000000 // 28-28
+#define WF_LWTBL_DU_I_PSM_SHIFT                                     28
+#define WF_LWTBL_I_PSM_DW                                           5
+#define WF_LWTBL_I_PSM_ADDR                                         20
+#define WF_LWTBL_I_PSM_MASK \
+	0x20000000 // 29-29
+#define WF_LWTBL_I_PSM_SHIFT                                        29
+#define WF_LWTBL_PSM_DW                                             5
+#define WF_LWTBL_PSM_ADDR                                           20
+#define WF_LWTBL_PSM_MASK \
+	0x40000000 // 30-30
+#define WF_LWTBL_PSM_SHIFT                                          30
+#define WF_LWTBL_SKIP_TX_DW                                         5
+#define WF_LWTBL_SKIP_TX_ADDR                                       20
+#define WF_LWTBL_SKIP_TX_MASK \
+	0x80000000 // 31-31
+#define WF_LWTBL_SKIP_TX_SHIFT                                      31
+// DW6
+#define WF_LWTBL_CBRN_DW                                            6
+#define WF_LWTBL_CBRN_ADDR                                          24
+#define WF_LWTBL_CBRN_MASK \
+	0x00000007 // 2- 0
+#define WF_LWTBL_CBRN_SHIFT                                         0
+#define WF_LWTBL_DBNSS_EN_DW                                        6
+#define WF_LWTBL_DBNSS_EN_ADDR                                      24
+#define WF_LWTBL_DBNSS_EN_MASK \
+	0x00000008 // 3- 3
+#define WF_LWTBL_DBNSS_EN_SHIFT                                     3
+#define WF_LWTBL_BAF_EN_DW                                          6
+#define WF_LWTBL_BAF_EN_ADDR                                        24
+#define WF_LWTBL_BAF_EN_MASK \
+	0x00000010 // 4- 4
+#define WF_LWTBL_BAF_EN_SHIFT                                       4
+#define WF_LWTBL_RDGBA_DW                                           6
+#define WF_LWTBL_RDGBA_ADDR                                         24
+#define WF_LWTBL_RDGBA_MASK \
+	0x00000020 // 5- 5
+#define WF_LWTBL_RDGBA_SHIFT                                        5
+#define WF_LWTBL_R_DW                                               6
+#define WF_LWTBL_R_ADDR                                             24
+#define WF_LWTBL_R_MASK \
+	0x00000040 // 6- 6
+#define WF_LWTBL_R_SHIFT                                            6
+#define WF_LWTBL_SPE_IDX_DW                                         6
+#define WF_LWTBL_SPE_IDX_ADDR                                       24
+#define WF_LWTBL_SPE_IDX_MASK \
+	0x00000f80 // 11- 7
+#define WF_LWTBL_SPE_IDX_SHIFT                                      7
+#define WF_LWTBL_G2_DW                                              6
+#define WF_LWTBL_G2_ADDR                                            24
+#define WF_LWTBL_G2_MASK \
+	0x00001000 // 12-12
+#define WF_LWTBL_G2_SHIFT                                           12
+#define WF_LWTBL_G4_DW                                              6
+#define WF_LWTBL_G4_ADDR                                            24
+#define WF_LWTBL_G4_MASK \
+	0x00002000 // 13-13
+#define WF_LWTBL_G4_SHIFT                                           13
+#define WF_LWTBL_G8_DW                                              6
+#define WF_LWTBL_G8_ADDR                                            24
+#define WF_LWTBL_G8_MASK \
+	0x00004000 // 14-14
+#define WF_LWTBL_G8_SHIFT                                           14
+#define WF_LWTBL_G16_DW                                             6
+#define WF_LWTBL_G16_ADDR                                           24
+#define WF_LWTBL_G16_MASK \
+	0x00008000 // 15-15
+#define WF_LWTBL_G16_SHIFT                                          15
+#define WF_LWTBL_G2_LTF_DW                                          6
+#define WF_LWTBL_G2_LTF_ADDR                                        24
+#define WF_LWTBL_G2_LTF_MASK \
+	0x00030000 // 17-16
+#define WF_LWTBL_G2_LTF_SHIFT                                       16
+#define WF_LWTBL_G4_LTF_DW                                          6
+#define WF_LWTBL_G4_LTF_ADDR                                        24
+#define WF_LWTBL_G4_LTF_MASK \
+	0x000c0000 // 19-18
+#define WF_LWTBL_G4_LTF_SHIFT                                       18
+#define WF_LWTBL_G8_LTF_DW                                          6
+#define WF_LWTBL_G8_LTF_ADDR                                        24
+#define WF_LWTBL_G8_LTF_MASK \
+	0x00300000 // 21-20
+#define WF_LWTBL_G8_LTF_SHIFT                                       20
+#define WF_LWTBL_G16_LTF_DW                                         6
+#define WF_LWTBL_G16_LTF_ADDR                                       24
+#define WF_LWTBL_G16_LTF_MASK \
+	0x00c00000 // 23-22
+#define WF_LWTBL_G16_LTF_SHIFT                                      22
+#define WF_LWTBL_G2_HE_DW                                           6
+#define WF_LWTBL_G2_HE_ADDR                                         24
+#define WF_LWTBL_G2_HE_MASK \
+	0x03000000 // 25-24
+#define WF_LWTBL_G2_HE_SHIFT                                        24
+#define WF_LWTBL_G4_HE_DW                                           6
+#define WF_LWTBL_G4_HE_ADDR                                         24
+#define WF_LWTBL_G4_HE_MASK \
+	0x0c000000 // 27-26
+#define WF_LWTBL_G4_HE_SHIFT                                        26
+#define WF_LWTBL_G8_HE_DW                                           6
+#define WF_LWTBL_G8_HE_ADDR                                         24
+#define WF_LWTBL_G8_HE_MASK \
+	0x30000000 // 29-28
+#define WF_LWTBL_G8_HE_SHIFT                                        28
+#define WF_LWTBL_G16_HE_DW                                          6
+#define WF_LWTBL_G16_HE_ADDR                                        24
+#define WF_LWTBL_G16_HE_MASK \
+	0xc0000000 // 31-30
+#define WF_LWTBL_G16_HE_SHIFT                                       30
+// DW7
+#define WF_LWTBL_BA_WIN_SIZE0_DW                                    7
+#define WF_LWTBL_BA_WIN_SIZE0_ADDR                                  28
+#define WF_LWTBL_BA_WIN_SIZE0_MASK \
+	0x0000000f // 3- 0
+#define WF_LWTBL_BA_WIN_SIZE0_SHIFT                                 0
+#define WF_LWTBL_BA_WIN_SIZE1_DW                                    7
+#define WF_LWTBL_BA_WIN_SIZE1_ADDR                                  28
+#define WF_LWTBL_BA_WIN_SIZE1_MASK \
+	0x000000f0 // 7- 4
+#define WF_LWTBL_BA_WIN_SIZE1_SHIFT                                 4
+#define WF_LWTBL_BA_WIN_SIZE2_DW                                    7
+#define WF_LWTBL_BA_WIN_SIZE2_ADDR                                  28
+#define WF_LWTBL_BA_WIN_SIZE2_MASK \
+	0x00000f00 // 11- 8
+#define WF_LWTBL_BA_WIN_SIZE2_SHIFT                                 8
+#define WF_LWTBL_BA_WIN_SIZE3_DW                                    7
+#define WF_LWTBL_BA_WIN_SIZE3_ADDR                                  28
+#define WF_LWTBL_BA_WIN_SIZE3_MASK \
+	0x0000f000 // 15-12
+#define WF_LWTBL_BA_WIN_SIZE3_SHIFT                                 12
+#define WF_LWTBL_BA_WIN_SIZE4_DW                                    7
+#define WF_LWTBL_BA_WIN_SIZE4_ADDR                                  28
+#define WF_LWTBL_BA_WIN_SIZE4_MASK \
+	0x000f0000 // 19-16
+#define WF_LWTBL_BA_WIN_SIZE4_SHIFT                                 16
+#define WF_LWTBL_BA_WIN_SIZE5_DW                                    7
+#define WF_LWTBL_BA_WIN_SIZE5_ADDR                                  28
+#define WF_LWTBL_BA_WIN_SIZE5_MASK \
+	0x00f00000 // 23-20
+#define WF_LWTBL_BA_WIN_SIZE5_SHIFT                                 20
+#define WF_LWTBL_BA_WIN_SIZE6_DW                                    7
+#define WF_LWTBL_BA_WIN_SIZE6_ADDR                                  28
+#define WF_LWTBL_BA_WIN_SIZE6_MASK \
+	0x0f000000 // 27-24
+#define WF_LWTBL_BA_WIN_SIZE6_SHIFT                                 24
+#define WF_LWTBL_BA_WIN_SIZE7_DW                                    7
+#define WF_LWTBL_BA_WIN_SIZE7_ADDR                                  28
+#define WF_LWTBL_BA_WIN_SIZE7_MASK \
+	0xf0000000 // 31-28
+#define WF_LWTBL_BA_WIN_SIZE7_SHIFT                                 28
+// DW8
+#define WF_LWTBL_AC0_RTS_FAIL_CNT_DW                                8
+#define WF_LWTBL_AC0_RTS_FAIL_CNT_ADDR                              32
+#define WF_LWTBL_AC0_RTS_FAIL_CNT_MASK \
+	0x0000001f // 4- 0
+#define WF_LWTBL_AC0_RTS_FAIL_CNT_SHIFT                             0
+#define WF_LWTBL_AC1_RTS_FAIL_CNT_DW                                8
+#define WF_LWTBL_AC1_RTS_FAIL_CNT_ADDR                              32
+#define WF_LWTBL_AC1_RTS_FAIL_CNT_MASK \
+	0x000003e0 // 9- 5
+#define WF_LWTBL_AC1_RTS_FAIL_CNT_SHIFT                             5
+#define WF_LWTBL_AC2_RTS_FAIL_CNT_DW                                8
+#define WF_LWTBL_AC2_RTS_FAIL_CNT_ADDR                              32
+#define WF_LWTBL_AC2_RTS_FAIL_CNT_MASK \
+	0x00007c00 // 14-10
+#define WF_LWTBL_AC2_RTS_FAIL_CNT_SHIFT                             10
+#define WF_LWTBL_AC3_RTS_FAIL_CNT_DW                                8
+#define WF_LWTBL_AC3_RTS_FAIL_CNT_ADDR                              32
+#define WF_LWTBL_AC3_RTS_FAIL_CNT_MASK \
+	0x000f8000 // 19-15
+#define WF_LWTBL_AC3_RTS_FAIL_CNT_SHIFT                             15
+#define WF_LWTBL_PARTIAL_AID_DW                                     8
+#define WF_LWTBL_PARTIAL_AID_ADDR                                   32
+#define WF_LWTBL_PARTIAL_AID_MASK \
+	0x1ff00000 // 28-20
+#define WF_LWTBL_PARTIAL_AID_SHIFT                                  20
+#define WF_LWTBL_CHK_PER_DW                                         8
+#define WF_LWTBL_CHK_PER_ADDR                                       32
+#define WF_LWTBL_CHK_PER_MASK \
+	0x80000000 // 31-31
+#define WF_LWTBL_CHK_PER_SHIFT                                      31
+// DW9
+#define WF_LWTBL_RX_AVG_MPDU_SIZE_DW                                9
+#define WF_LWTBL_RX_AVG_MPDU_SIZE_ADDR                              36
+#define WF_LWTBL_RX_AVG_MPDU_SIZE_MASK \
+	0x00003fff // 13- 0
+#define WF_LWTBL_RX_AVG_MPDU_SIZE_SHIFT                             0
+#define WF_LWTBL_PRITX_SW_MODE_DW                                   9
+#define WF_LWTBL_PRITX_SW_MODE_ADDR                                 36
+#define WF_LWTBL_PRITX_SW_MODE_MASK \
+	0x00008000 // 15-15
+#define WF_LWTBL_PRITX_SW_MODE_SHIFT                                15
+#define WF_LWTBL_PRITX_SW_MODE_MASK_7992 \
+	0x00004000 // 14-14
+#define WF_LWTBL_PRITX_SW_MODE_SHIFT_7992                           14
+#define WF_LWTBL_PRITX_ERSU_DW                                      9
+#define WF_LWTBL_PRITX_ERSU_ADDR                                    36
+#define WF_LWTBL_PRITX_ERSU_MASK \
+	0x00010000 // 16-16
+#define WF_LWTBL_PRITX_ERSU_SHIFT                                   16
+#define WF_LWTBL_PRITX_ERSU_MASK_7992 \
+	0x00008000 // 15-15
+#define WF_LWTBL_PRITX_ERSU_SHIFT_7992                              15
+#define WF_LWTBL_PRITX_PLR_DW                                       9
+#define WF_LWTBL_PRITX_PLR_ADDR                                     36
+#define WF_LWTBL_PRITX_PLR_MASK \
+	0x00020000 // 17-17
+#define WF_LWTBL_PRITX_PLR_SHIFT                                    17
+#define WF_LWTBL_PRITX_PLR_MASK_7992 \
+	0x00030000 // 17-16
+#define WF_LWTBL_PRITX_PLR_SHIFT_7992                               16
+#define WF_LWTBL_PRITX_DCM_DW                                       9
+#define WF_LWTBL_PRITX_DCM_ADDR                                     36
+#define WF_LWTBL_PRITX_DCM_MASK \
+	0x00040000 // 18-18
+#define WF_LWTBL_PRITX_DCM_SHIFT                                    18
+#define WF_LWTBL_PRITX_ER106T_DW                                    9
+#define WF_LWTBL_PRITX_ER106T_ADDR                                  36
+#define WF_LWTBL_PRITX_ER106T_MASK \
+	0x00080000 // 19-19
+#define WF_LWTBL_PRITX_ER106T_SHIFT                                 19
+#define WF_LWTBL_FCAP_DW                                            9
+#define WF_LWTBL_FCAP_ADDR                                          36
+#define WF_LWTBL_FCAP_MASK \
+	0x00700000 // 22-20
+#define WF_LWTBL_FCAP_SHIFT                                         20
+#define WF_LWTBL_MPDU_FAIL_CNT_DW                                   9
+#define WF_LWTBL_MPDU_FAIL_CNT_ADDR                                 36
+#define WF_LWTBL_MPDU_FAIL_CNT_MASK \
+	0x03800000 // 25-23
+#define WF_LWTBL_MPDU_FAIL_CNT_SHIFT                                23
+#define WF_LWTBL_MPDU_OK_CNT_DW                                     9
+#define WF_LWTBL_MPDU_OK_CNT_ADDR                                   36
+#define WF_LWTBL_MPDU_OK_CNT_MASK \
+	0x1c000000 // 28-26
+#define WF_LWTBL_MPDU_OK_CNT_SHIFT                                  26
+#define WF_LWTBL_RATE_IDX_DW                                        9
+#define WF_LWTBL_RATE_IDX_ADDR                                      36
+#define WF_LWTBL_RATE_IDX_MASK \
+	0xe0000000 // 31-29
+#define WF_LWTBL_RATE_IDX_SHIFT                                     29
+// DW10
+#define WF_LWTBL_RATE1_DW                                           10
+#define WF_LWTBL_RATE1_ADDR                                         40
+#define WF_LWTBL_RATE1_MASK \
+	0x00007fff // 14- 0
+#define WF_LWTBL_RATE1_SHIFT                                        0
+#define WF_LWTBL_RATE2_DW                                           10
+#define WF_LWTBL_RATE2_ADDR                                         40
+#define WF_LWTBL_RATE2_MASK \
+	0x7fff0000 // 30-16
+#define WF_LWTBL_RATE2_SHIFT                                        16
+// DW11
+#define WF_LWTBL_RATE3_DW                                           11
+#define WF_LWTBL_RATE3_ADDR                                         44
+#define WF_LWTBL_RATE3_MASK \
+	0x00007fff // 14- 0
+#define WF_LWTBL_RATE3_SHIFT                                        0
+#define WF_LWTBL_RATE4_DW                                           11
+#define WF_LWTBL_RATE4_ADDR                                         44
+#define WF_LWTBL_RATE4_MASK \
+	0x7fff0000 // 30-16
+#define WF_LWTBL_RATE4_SHIFT                                        16
+// DW12
+#define WF_LWTBL_RATE5_DW                                           12
+#define WF_LWTBL_RATE5_ADDR                                         48
+#define WF_LWTBL_RATE5_MASK \
+	0x00007fff // 14- 0
+#define WF_LWTBL_RATE5_SHIFT                                        0
+#define WF_LWTBL_RATE6_DW                                           12
+#define WF_LWTBL_RATE6_ADDR                                         48
+#define WF_LWTBL_RATE6_MASK \
+	0x7fff0000 // 30-16
+#define WF_LWTBL_RATE6_SHIFT                                        16
+// DW13
+#define WF_LWTBL_RATE7_DW                                           13
+#define WF_LWTBL_RATE7_ADDR                                         52
+#define WF_LWTBL_RATE7_MASK \
+	0x00007fff // 14- 0
+#define WF_LWTBL_RATE7_SHIFT                                        0
+#define WF_LWTBL_RATE8_DW                                           13
+#define WF_LWTBL_RATE8_ADDR                                         52
+#define WF_LWTBL_RATE8_MASK \
+	0x7fff0000 // 30-16
+#define WF_LWTBL_RATE8_SHIFT                                        16
+// DW14
+#define WF_LWTBL_RATE1_TX_CNT_DW                                    14
+#define WF_LWTBL_RATE1_TX_CNT_ADDR                                  56
+#define WF_LWTBL_RATE1_TX_CNT_MASK \
+	0x0000ffff // 15- 0
+#define WF_LWTBL_RATE1_TX_CNT_SHIFT                                 0
+#define WF_LWTBL_CIPHER_SUIT_IGTK_DW                                14
+#define WF_LWTBL_CIPHER_SUIT_IGTK_ADDR                              56
+#define WF_LWTBL_CIPHER_SUIT_IGTK_MASK \
+	0x00003000 // 13-12
+#define WF_LWTBL_CIPHER_SUIT_IGTK_SHIFT                             12
+#define WF_LWTBL_CIPHER_SUIT_BIGTK_DW                               14
+#define WF_LWTBL_CIPHER_SUIT_BIGTK_ADDR                             56
+#define WF_LWTBL_CIPHER_SUIT_BIGTK_MASK \
+	0x0000c000 // 15-14
+#define WF_LWTBL_CIPHER_SUIT_BIGTK_SHIFT                            14
+#define WF_LWTBL_RATE1_FAIL_CNT_DW                                  14
+#define WF_LWTBL_RATE1_FAIL_CNT_ADDR                                56
+#define WF_LWTBL_RATE1_FAIL_CNT_MASK \
+	0xffff0000 // 31-16
+#define WF_LWTBL_RATE1_FAIL_CNT_SHIFT                               16
+// DW15
+#define WF_LWTBL_RATE2_OK_CNT_DW                                    15
+#define WF_LWTBL_RATE2_OK_CNT_ADDR                                  60
+#define WF_LWTBL_RATE2_OK_CNT_MASK \
+	0x0000ffff // 15- 0
+#define WF_LWTBL_RATE2_OK_CNT_SHIFT                                 0
+#define WF_LWTBL_RATE3_OK_CNT_DW                                    15
+#define WF_LWTBL_RATE3_OK_CNT_ADDR                                  60
+#define WF_LWTBL_RATE3_OK_CNT_MASK \
+	0xffff0000 // 31-16
+#define WF_LWTBL_RATE3_OK_CNT_SHIFT                                 16
+// DW16
+#define WF_LWTBL_CURRENT_BW_TX_CNT_DW                               16
+#define WF_LWTBL_CURRENT_BW_TX_CNT_ADDR                             64
+#define WF_LWTBL_CURRENT_BW_TX_CNT_MASK \
+	0x0000ffff // 15- 0
+#define WF_LWTBL_CURRENT_BW_TX_CNT_SHIFT                            0
+#define WF_LWTBL_CURRENT_BW_FAIL_CNT_DW                             16
+#define WF_LWTBL_CURRENT_BW_FAIL_CNT_ADDR                           64
+#define WF_LWTBL_CURRENT_BW_FAIL_CNT_MASK \
+	0xffff0000 // 31-16
+#define WF_LWTBL_CURRENT_BW_FAIL_CNT_SHIFT                          16
+// DW17
+#define WF_LWTBL_OTHER_BW_TX_CNT_DW                                 17
+#define WF_LWTBL_OTHER_BW_TX_CNT_ADDR                               68
+#define WF_LWTBL_OTHER_BW_TX_CNT_MASK \
+	0x0000ffff // 15- 0
+#define WF_LWTBL_OTHER_BW_TX_CNT_SHIFT                              0
+#define WF_LWTBL_OTHER_BW_FAIL_CNT_DW                               17
+#define WF_LWTBL_OTHER_BW_FAIL_CNT_ADDR                             68
+#define WF_LWTBL_OTHER_BW_FAIL_CNT_MASK \
+	0xffff0000 // 31-16
+#define WF_LWTBL_OTHER_BW_FAIL_CNT_SHIFT                            16
+// DW18
+#define WF_LWTBL_RTS_OK_CNT_DW                                      18
+#define WF_LWTBL_RTS_OK_CNT_ADDR                                    72
+#define WF_LWTBL_RTS_OK_CNT_MASK \
+	0x0000ffff // 15- 0
+#define WF_LWTBL_RTS_OK_CNT_SHIFT                                   0
+#define WF_LWTBL_RTS_FAIL_CNT_DW                                    18
+#define WF_LWTBL_RTS_FAIL_CNT_ADDR                                  72
+#define WF_LWTBL_RTS_FAIL_CNT_MASK \
+	0xffff0000 // 31-16
+#define WF_LWTBL_RTS_FAIL_CNT_SHIFT                                 16
+// DW19
+#define WF_LWTBL_DATA_RETRY_CNT_DW                                  19
+#define WF_LWTBL_DATA_RETRY_CNT_ADDR                                76
+#define WF_LWTBL_DATA_RETRY_CNT_MASK \
+	0x0000ffff // 15- 0
+#define WF_LWTBL_DATA_RETRY_CNT_SHIFT                               0
+#define WF_LWTBL_MGNT_RETRY_CNT_DW                                  19
+#define WF_LWTBL_MGNT_RETRY_CNT_ADDR                                76
+#define WF_LWTBL_MGNT_RETRY_CNT_MASK \
+	0xffff0000 // 31-16
+#define WF_LWTBL_MGNT_RETRY_CNT_SHIFT                               16
+// DW20
+#define WF_LWTBL_AC0_CTT_CDT_CRB_DW                                 20
+#define WF_LWTBL_AC0_CTT_CDT_CRB_ADDR                               80
+#define WF_LWTBL_AC0_CTT_CDT_CRB_MASK \
+	0xffffffff // 31- 0
+#define WF_LWTBL_AC0_CTT_CDT_CRB_SHIFT                              0
+// DW21
+// DO NOT process repeat field(adm[0])
+// DW22
+#define WF_LWTBL_AC1_CTT_CDT_CRB_DW                                 22
+#define WF_LWTBL_AC1_CTT_CDT_CRB_ADDR                               88
+#define WF_LWTBL_AC1_CTT_CDT_CRB_MASK \
+	0xffffffff // 31- 0
+#define WF_LWTBL_AC1_CTT_CDT_CRB_SHIFT                              0
+// DW23
+// DO NOT process repeat field(adm[1])
+// DW24
+#define WF_LWTBL_AC2_CTT_CDT_CRB_DW                                 24
+#define WF_LWTBL_AC2_CTT_CDT_CRB_ADDR                               96
+#define WF_LWTBL_AC2_CTT_CDT_CRB_MASK \
+	0xffffffff // 31- 0
+#define WF_LWTBL_AC2_CTT_CDT_CRB_SHIFT                              0
+// DW25
+// DO NOT process repeat field(adm[2])
+// DW26
+#define WF_LWTBL_AC3_CTT_CDT_CRB_DW                                 26
+#define WF_LWTBL_AC3_CTT_CDT_CRB_ADDR                               104
+#define WF_LWTBL_AC3_CTT_CDT_CRB_MASK \
+	0xffffffff // 31- 0
+#define WF_LWTBL_AC3_CTT_CDT_CRB_SHIFT                              0
+// DW27
+// DO NOT process repeat field(adm[3])
+// DW28
+#define WF_LWTBL_RELATED_IDX0_DW                                    28
+#define WF_LWTBL_RELATED_IDX0_ADDR                                  112
+#define WF_LWTBL_RELATED_IDX0_MASK \
+	0x00000fff // 11- 0
+#define WF_LWTBL_RELATED_IDX0_SHIFT                                 0
+#define WF_LWTBL_RELATED_BAND0_DW                                   28
+#define WF_LWTBL_RELATED_BAND0_ADDR                                 112
+#define WF_LWTBL_RELATED_BAND0_MASK \
+	0x00003000 // 13-12
+#define WF_LWTBL_RELATED_BAND0_SHIFT                                12
+#define WF_LWTBL_PRIMARY_MLD_BAND_DW                                28
+#define WF_LWTBL_PRIMARY_MLD_BAND_ADDR                              112
+#define WF_LWTBL_PRIMARY_MLD_BAND_MASK \
+	0x0000c000 // 15-14
+#define WF_LWTBL_PRIMARY_MLD_BAND_SHIFT                             14
+#define WF_LWTBL_RELATED_IDX1_DW                                    28
+#define WF_LWTBL_RELATED_IDX1_ADDR                                  112
+#define WF_LWTBL_RELATED_IDX1_MASK \
+	0x0fff0000 // 27-16
+#define WF_LWTBL_RELATED_IDX1_SHIFT                                 16
+#define WF_LWTBL_RELATED_BAND1_DW                                   28
+#define WF_LWTBL_RELATED_BAND1_ADDR                                 112
+#define WF_LWTBL_RELATED_BAND1_MASK \
+	0x30000000 // 29-28
+#define WF_LWTBL_RELATED_BAND1_SHIFT                                28
+#define WF_LWTBL_SECONDARY_MLD_BAND_DW                              28
+#define WF_LWTBL_SECONDARY_MLD_BAND_ADDR                            112
+#define WF_LWTBL_SECONDARY_MLD_BAND_MASK \
+	0xc0000000 // 31-30
+#define WF_LWTBL_SECONDARY_MLD_BAND_SHIFT                           30
+// DW29
+#define WF_LWTBL_DISPATCH_POLICY0_DW                                29
+#define WF_LWTBL_DISPATCH_POLICY0_ADDR                              116
+#define WF_LWTBL_DISPATCH_POLICY0_MASK \
+	0x00000003 // 1- 0
+#define WF_LWTBL_DISPATCH_POLICY0_SHIFT                             0
+#define WF_LWTBL_DISPATCH_POLICY1_DW                                29
+#define WF_LWTBL_DISPATCH_POLICY1_ADDR                              116
+#define WF_LWTBL_DISPATCH_POLICY1_MASK \
+	0x0000000c // 3- 2
+#define WF_LWTBL_DISPATCH_POLICY1_SHIFT                             2
+#define WF_LWTBL_DISPATCH_POLICY2_DW                                29
+#define WF_LWTBL_DISPATCH_POLICY2_ADDR                              116
+#define WF_LWTBL_DISPATCH_POLICY2_MASK \
+	0x00000030 // 5- 4
+#define WF_LWTBL_DISPATCH_POLICY2_SHIFT                             4
+#define WF_LWTBL_DISPATCH_POLICY3_DW                                29
+#define WF_LWTBL_DISPATCH_POLICY3_ADDR                              116
+#define WF_LWTBL_DISPATCH_POLICY3_MASK \
+	0x000000c0 // 7- 6
+#define WF_LWTBL_DISPATCH_POLICY3_SHIFT                             6
+#define WF_LWTBL_DISPATCH_POLICY4_DW                                29
+#define WF_LWTBL_DISPATCH_POLICY4_ADDR                              116
+#define WF_LWTBL_DISPATCH_POLICY4_MASK \
+	0x00000300 // 9- 8
+#define WF_LWTBL_DISPATCH_POLICY4_SHIFT                             8
+#define WF_LWTBL_DISPATCH_POLICY5_DW                                29
+#define WF_LWTBL_DISPATCH_POLICY5_ADDR                              116
+#define WF_LWTBL_DISPATCH_POLICY5_MASK \
+	0x00000c00 // 11-10
+#define WF_LWTBL_DISPATCH_POLICY5_SHIFT                             10
+#define WF_LWTBL_DISPATCH_POLICY6_DW                                29
+#define WF_LWTBL_DISPATCH_POLICY6_ADDR                              116
+#define WF_LWTBL_DISPATCH_POLICY6_MASK \
+	0x00003000 // 13-12
+#define WF_LWTBL_DISPATCH_POLICY6_SHIFT                             12
+#define WF_LWTBL_DISPATCH_POLICY7_DW                                29
+#define WF_LWTBL_DISPATCH_POLICY7_ADDR                              116
+#define WF_LWTBL_DISPATCH_POLICY7_MASK \
+	0x0000c000 // 15-14
+#define WF_LWTBL_DISPATCH_POLICY7_SHIFT                             14
+#define WF_LWTBL_OWN_MLD_ID_DW                                      29
+#define WF_LWTBL_OWN_MLD_ID_ADDR                                    116
+#define WF_LWTBL_OWN_MLD_ID_MASK \
+	0x003f0000 // 21-16
+#define WF_LWTBL_OWN_MLD_ID_SHIFT                                   16
+#define WF_LWTBL_EMLSR0_DW                                          29
+#define WF_LWTBL_EMLSR0_ADDR                                        116
+#define WF_LWTBL_EMLSR0_MASK \
+	0x00400000 // 22-22
+#define WF_LWTBL_EMLSR0_SHIFT                                       22
+#define WF_LWTBL_EMLMR0_DW                                          29
+#define WF_LWTBL_EMLMR0_ADDR                                        116
+#define WF_LWTBL_EMLMR0_MASK \
+	0x00800000 // 23-23
+#define WF_LWTBL_EMLMR0_SHIFT                                       23
+#define WF_LWTBL_EMLSR1_DW                                          29
+#define WF_LWTBL_EMLSR1_ADDR                                        116
+#define WF_LWTBL_EMLSR1_MASK \
+	0x01000000 // 24-24
+#define WF_LWTBL_EMLSR1_SHIFT                                       24
+#define WF_LWTBL_EMLMR1_DW                                          29
+#define WF_LWTBL_EMLMR1_ADDR                                        116
+#define WF_LWTBL_EMLMR1_MASK \
+	0x02000000 // 25-25
+#define WF_LWTBL_EMLMR1_SHIFT                                       25
+#define WF_LWTBL_EMLSR2_DW                                          29
+#define WF_LWTBL_EMLSR2_ADDR                                        116
+#define WF_LWTBL_EMLSR2_MASK \
+	0x04000000 // 26-26
+#define WF_LWTBL_EMLSR2_SHIFT                                       26
+#define WF_LWTBL_EMLMR2_DW                                          29
+#define WF_LWTBL_EMLMR2_ADDR                                        116
+#define WF_LWTBL_EMLMR2_MASK \
+	0x08000000 // 27-27
+#define WF_LWTBL_EMLMR2_SHIFT                                       27
+#define WF_LWTBL_STR_BITMAP_DW                                      29
+#define WF_LWTBL_STR_BITMAP_ADDR                                    116
+#define WF_LWTBL_STR_BITMAP_MASK \
+	0xe0000000 // 31-29
+#define WF_LWTBL_STR_BITMAP_SHIFT                                   29
+// DW30
+#define WF_LWTBL_DISPATCH_ORDER_DW                                  30
+#define WF_LWTBL_DISPATCH_ORDER_ADDR                                120
+#define WF_LWTBL_DISPATCH_ORDER_MASK \
+	0x0000007f // 6- 0
+#define WF_LWTBL_DISPATCH_ORDER_SHIFT                               0
+#define WF_LWTBL_DISPATCH_RATIO_DW                                  30
+#define WF_LWTBL_DISPATCH_RATIO_ADDR                                120
+#define WF_LWTBL_DISPATCH_RATIO_MASK \
+	0x00003f80 // 13- 7
+#define WF_LWTBL_DISPATCH_RATIO_SHIFT                               7
+#define WF_LWTBL_LINK_MGF_DW                                        30
+#define WF_LWTBL_LINK_MGF_ADDR                                      120
+#define WF_LWTBL_LINK_MGF_MASK \
+	0xffff0000 // 31-16
+#define WF_LWTBL_LINK_MGF_SHIFT                                     16
+// DW31
+#define WF_LWTBL_BFTX_TB_DW                                         31
+#define WF_LWTBL_BFTX_TB_ADDR                                       124
+#define WF_LWTBL_BFTX_TB_MASK \
+	0x00800000 // 23-23
+#define WF_LWTBL_DROP_DW                                            31
+#define WF_LWTBL_DROP_ADDR                                          124
+#define WF_LWTBL_DROP_MASK \
+	0x01000000 // 24-24
+#define WF_LWTBL_DROP_SHIFT                                         24
+#define WF_LWTBL_CASCAD_DW                                          31
+#define WF_LWTBL_CASCAD_ADDR                                        124
+#define WF_LWTBL_CASCAD_MASK \
+	0x02000000 // 25-25
+#define WF_LWTBL_CASCAD_SHIFT                                       25
+#define WF_LWTBL_ALL_ACK_DW                                         31
+#define WF_LWTBL_ALL_ACK_ADDR                                       124
+#define WF_LWTBL_ALL_ACK_MASK \
+	0x04000000 // 26-26
+#define WF_LWTBL_ALL_ACK_SHIFT                                      26
+#define WF_LWTBL_MPDU_SIZE_DW                                       31
+#define WF_LWTBL_MPDU_SIZE_ADDR                                     124
+#define WF_LWTBL_MPDU_SIZE_MASK \
+	0x18000000 // 28-27
+#define WF_LWTBL_MPDU_SIZE_SHIFT                                    27
+#define WF_LWTBL_RXD_DUP_MODE_DW                                    31
+#define WF_LWTBL_RXD_DUP_MODE_ADDR                                  124
+#define WF_LWTBL_RXD_DUP_MODE_MASK \
+	0x60000000 // 30-29
+#define WF_LWTBL_RXD_DUP_MODE_SHIFT                                 29
+#define WF_LWTBL_ACK_EN_DW                                          31
+#define WF_LWTBL_ACK_EN_ADDR                                        128
+#define WF_LWTBL_ACK_EN_MASK \
+	0x80000000 // 31-31
+#define WF_LWTBL_ACK_EN_SHIFT                                       31
+// DW32
+#define WF_LWTBL_OM_INFO_DW                                         32
+#define WF_LWTBL_OM_INFO_ADDR                                       128
+#define WF_LWTBL_OM_INFO_MASK \
+	0x00000fff // 11- 0
+#define WF_LWTBL_OM_INFO_SHIFT                                      0
+#define WF_LWTBL_OM_INFO_EHT_DW                                     32
+#define WF_LWTBL_OM_INFO_EHT_ADDR                                   128
+#define WF_LWTBL_OM_INFO_EHT_MASK \
+	0x0000f000 // 15-12
+#define WF_LWTBL_OM_INFO_EHT_SHIFT                                  12
+#define WF_LWTBL_RXD_DUP_FOR_OM_CHG_DW                              32
+#define WF_LWTBL_RXD_DUP_FOR_OM_CHG_ADDR                            128
+#define WF_LWTBL_RXD_DUP_FOR_OM_CHG_MASK \
+	0x00010000 // 16-16
+#define WF_LWTBL_RXD_DUP_FOR_OM_CHG_SHIFT                           16
+#define WF_LWTBL_RXD_DUP_WHITE_LIST_DW                              32
+#define WF_LWTBL_RXD_DUP_WHITE_LIST_ADDR                            128
+#define WF_LWTBL_RXD_DUP_WHITE_LIST_MASK \
+	0x1ffe0000 // 28-17
+#define WF_LWTBL_RXD_DUP_WHITE_LIST_SHIFT                           17
+// DW33
+#define WF_LWTBL_USER_RSSI_DW                                       33
+#define WF_LWTBL_USER_RSSI_ADDR                                     132
+#define WF_LWTBL_USER_RSSI_MASK \
+	0x000001ff // 8- 0
+#define WF_LWTBL_USER_RSSI_SHIFT                                    0
+#define WF_LWTBL_USER_SNR_DW                                        33
+#define WF_LWTBL_USER_SNR_ADDR                                      132
+#define WF_LWTBL_USER_SNR_MASK \
+	0x00007e00 // 14- 9
+#define WF_LWTBL_USER_SNR_SHIFT                                     9
+#define WF_LWTBL_RAPID_REACTION_RATE_DW                             33
+#define WF_LWTBL_RAPID_REACTION_RATE_ADDR                           132
+#define WF_LWTBL_RAPID_REACTION_RATE_MASK \
+	0x0fff0000 // 27-16
+#define WF_LWTBL_RAPID_REACTION_RATE_SHIFT                          16
+#define WF_LWTBL_HT_AMSDU_DW                                        33
+#define WF_LWTBL_HT_AMSDU_ADDR                                      132
+#define WF_LWTBL_HT_AMSDU_MASK \
+	0x40000000 // 30-30
+#define WF_LWTBL_HT_AMSDU_SHIFT                                     30
+#define WF_LWTBL_AMSDU_CROSS_LG_DW                                  33
+#define WF_LWTBL_AMSDU_CROSS_LG_ADDR                                132
+#define WF_LWTBL_AMSDU_CROSS_LG_MASK \
+	0x80000000 // 31-31
+#define WF_LWTBL_AMSDU_CROSS_LG_SHIFT                               31
+// DW34
+#define WF_LWTBL_RESP_RCPI0_DW                                      34
+#define WF_LWTBL_RESP_RCPI0_ADDR                                    136
+#define WF_LWTBL_RESP_RCPI0_MASK \
+	0x000000ff // 7- 0
+#define WF_LWTBL_RESP_RCPI0_SHIFT                                   0
+#define WF_LWTBL_RESP_RCPI1_DW                                      34
+#define WF_LWTBL_RESP_RCPI1_ADDR                                    136
+#define WF_LWTBL_RESP_RCPI1_MASK \
+	0x0000ff00 // 15- 8
+#define WF_LWTBL_RESP_RCPI1_SHIFT                                   8
+#define WF_LWTBL_RESP_RCPI2_DW                                      34
+#define WF_LWTBL_RESP_RCPI2_ADDR                                    136
+#define WF_LWTBL_RESP_RCPI2_MASK \
+	0x00ff0000 // 23-16
+#define WF_LWTBL_RESP_RCPI2_SHIFT                                   16
+#define WF_LWTBL_RESP_RCPI3_DW                                      34
+#define WF_LWTBL_RESP_RCPI3_ADDR                                    136
+#define WF_LWTBL_RESP_RCPI3_MASK \
+	0xff000000 // 31-24
+#define WF_LWTBL_RESP_RCPI3_SHIFT                                   24
+// DW35
+#define WF_LWTBL_SNR_RX0_DW                                         35
+#define WF_LWTBL_SNR_RX0_ADDR                                       140
+#define WF_LWTBL_SNR_RX0_MASK \
+	0x0000003f // 5- 0
+#define WF_LWTBL_SNR_RX0_SHIFT                                      0
+#define WF_LWTBL_SNR_RX1_DW                                         35
+#define WF_LWTBL_SNR_RX1_ADDR                                       140
+#define WF_LWTBL_SNR_RX1_MASK \
+	0x00000fc0 // 11- 6
+#define WF_LWTBL_SNR_RX1_SHIFT                                      6
+#define WF_LWTBL_SNR_RX2_DW                                         35
+#define WF_LWTBL_SNR_RX2_ADDR                                       140
+#define WF_LWTBL_SNR_RX2_MASK \
+	0x0003f000 // 17-12
+#define WF_LWTBL_SNR_RX2_SHIFT                                      12
+#define WF_LWTBL_SNR_RX3_DW                                         35
+#define WF_LWTBL_SNR_RX3_ADDR                                       140
+#define WF_LWTBL_SNR_RX3_MASK \
+	0x00fc0000 // 23-18
+#define WF_LWTBL_SNR_RX3_SHIFT                                      18
+
+/* WTBL Group - Packet Number */
+/* DW 2 */
+#define WTBL_PN0_MASK                   BITS(0, 7)
+#define WTBL_PN0_OFFSET                 0
+#define WTBL_PN1_MASK                   BITS(8, 15)
+#define WTBL_PN1_OFFSET                 8
+#define WTBL_PN2_MASK                   BITS(16, 23)
+#define WTBL_PN2_OFFSET                 16
+#define WTBL_PN3_MASK                   BITS(24, 31)
+#define WTBL_PN3_OFFSET                 24
+
+/* DW 3 */
+#define WTBL_PN4_MASK                   BITS(0, 7)
+#define WTBL_PN4_OFFSET                 0
+#define WTBL_PN5_MASK                   BITS(8, 15)
+#define WTBL_PN5_OFFSET                 8
+
+/* DW 4 */
+#define WTBL_BIPN0_MASK                 BITS(0, 7)
+#define WTBL_BIPN0_OFFSET               0
+#define WTBL_BIPN1_MASK                 BITS(8, 15)
+#define WTBL_BIPN1_OFFSET               8
+#define WTBL_BIPN2_MASK                 BITS(16, 23)
+#define WTBL_BIPN2_OFFSET               16
+#define WTBL_BIPN3_MASK                 BITS(24, 31)
+#define WTBL_BIPN3_OFFSET               24
+
+/* DW 5 */
+#define WTBL_BIPN4_MASK                 BITS(0, 7)
+#define WTBL_BIPN4_OFFSET               0
+#define WTBL_BIPN5_MASK                 BITS(8, 15)
+#define WTBL_BIPN5_OFFSET               8
+
+/* UWTBL DW 6 */
+#define WTBL_AMSDU_LEN_MASK             BITS(0, 5)
+#define WTBL_AMSDU_LEN_OFFSET           0
+#define WTBL_AMSDU_NUM_MASK             BITS(6, 10)
+#define WTBL_AMSDU_NUM_OFFSET           6
+#define WTBL_AMSDU_EN_MASK              BIT(11)
+#define WTBL_AMSDU_EN_OFFSET            11
+
+/* UWTBL DW 8 */
+#define WTBL_SEC_ADDR_MODE_MASK		BITS(20, 21)
+#define WTBL_SEC_ADDR_MODE_OFFSET	20
+
+/* LWTBL Rate field */
+#define WTBL_RATE_TX_RATE_MASK          BITS(0, 5)
+#define WTBL_RATE_TX_RATE_OFFSET        0
+#define WTBL_RATE_TX_MODE_MASK          BITS(6, 9)
+#define WTBL_RATE_TX_MODE_OFFSET        6
+#define WTBL_RATE_NSTS_MASK             BITS(10, 13)
+#define WTBL_RATE_NSTS_OFFSET           10
+#define WTBL_RATE_STBC_MASK             BIT(14)
+#define WTBL_RATE_STBC_OFFSET           14
+
+/***** WTBL(LMAC) DW Offset *****/
+/* LMAC WTBL Group - Peer Unique Information */
+#define WTBL_GROUP_PEER_INFO_DW_0               0
+#define WTBL_GROUP_PEER_INFO_DW_1               1
+
+/* WTBL Group - TxRx Capability/Information */
+#define WTBL_GROUP_TRX_CAP_DW_2                 2
+#define WTBL_GROUP_TRX_CAP_DW_3                 3
+#define WTBL_GROUP_TRX_CAP_DW_4                 4
+#define WTBL_GROUP_TRX_CAP_DW_5                 5
+#define WTBL_GROUP_TRX_CAP_DW_6                 6
+#define WTBL_GROUP_TRX_CAP_DW_7                 7
+#define WTBL_GROUP_TRX_CAP_DW_8                 8
+#define WTBL_GROUP_TRX_CAP_DW_9                 9
+
+/* WTBL Group - Auto Rate Table*/
+#define WTBL_GROUP_AUTO_RATE_1_2                10
+#define WTBL_GROUP_AUTO_RATE_3_4                11
+#define WTBL_GROUP_AUTO_RATE_5_6                12
+#define WTBL_GROUP_AUTO_RATE_7_8                13
+
+/* WTBL Group - Tx Counter */
+#define WTBL_GROUP_TX_CNT_LINE_1                14
+#define WTBL_GROUP_TX_CNT_LINE_2                15
+#define WTBL_GROUP_TX_CNT_LINE_3                16
+#define WTBL_GROUP_TX_CNT_LINE_4                17
+#define WTBL_GROUP_TX_CNT_LINE_5                18
+#define WTBL_GROUP_TX_CNT_LINE_6                19
+
+/* WTBL Group - Admission Control Counter */
+#define WTBL_GROUP_ADM_CNT_LINE_1               20
+#define WTBL_GROUP_ADM_CNT_LINE_2               21
+#define WTBL_GROUP_ADM_CNT_LINE_3               22
+#define WTBL_GROUP_ADM_CNT_LINE_4               23
+#define WTBL_GROUP_ADM_CNT_LINE_5               24
+#define WTBL_GROUP_ADM_CNT_LINE_6               25
+#define WTBL_GROUP_ADM_CNT_LINE_7               26
+#define WTBL_GROUP_ADM_CNT_LINE_8               27
+
+/* WTBL Group -MLO Info */
+#define WTBL_GROUP_MLO_INFO_LINE_1              28
+#define WTBL_GROUP_MLO_INFO_LINE_2              29
+#define WTBL_GROUP_MLO_INFO_LINE_3              30
+
+/* WTBL Group -RESP Info */
+#define WTBL_GROUP_RESP_INFO_DW_31              31
+
+/* WTBL Group -RX DUP Info */
+#define WTBL_GROUP_RX_DUP_INFO_DW_32            32
+
+/* WTBL Group - Rx Statistics Counter */
+#define WTBL_GROUP_RX_STAT_CNT_LINE_1           33
+#define WTBL_GROUP_RX_STAT_CNT_LINE_2           34
+#define WTBL_GROUP_RX_STAT_CNT_LINE_3           35
+
+/* UWTBL Group - HW AMSDU */
+#define UWTBL_HW_AMSDU_DW                       WF_UWTBL_AMSDU_CFG_DW
+
+/* LWTBL DW 4 */
+#define WTBL_DIS_RHTR                           WF_LWTBL_DIS_RHTR_MASK
+
+/* UWTBL DW 5 */
+#define WTBL_KEY_LINK_DW_KEY_LOC0_MASK          BITS(0, 10)
+#define WTBL_PSM				WF_LWTBL_PSM_MASK
+
+/* Need to sync with FW define */
+#define INVALID_KEY_ENTRY                       WTBL_KEY_LINK_DW_KEY_LOC0_MASK
+
+// RATE
+#define WTBL_RATE_TX_RATE_MASK          	BITS(0, 5)
+#define WTBL_RATE_TX_RATE_OFFSET        	0
+#define WTBL_RATE_TX_MODE_MASK          	BITS(6, 9)
+#define WTBL_RATE_TX_MODE_OFFSET        	6
+#define WTBL_RATE_NSTS_MASK             	BITS(10, 13)
+#define WTBL_RATE_NSTS_OFFSET           	10
+#define WTBL_RATE_STBC_MASK            	 	BIT(14)
+#define WTBL_RATE_STBC_OFFSET          	 	14
+#endif
+
+struct bin_debug_hdr {
+	__le32 magic_num;
+	__le16 serial_id;
+	__le16 msg_type;
+	__le16 len;
+	__le16 des_len;	/* descriptor len for rxd */
+} __packed;
+
+enum umac_port {
+	ENUM_UMAC_HIF_PORT_0         = 0,
+	ENUM_UMAC_CPU_PORT_1         = 1,
+	ENUM_UMAC_LMAC_PORT_2        = 2,
+	ENUM_PLE_CTRL_PSE_PORT_3     = 3,
+	ENUM_UMAC_PSE_PLE_PORT_TOTAL_NUM = 4
+};
+
+/* N9 MCU QUEUE LIST */
+enum umac_cpu_port_queue_idx {
+	ENUM_UMAC_CTX_Q_0 = 0,
+	ENUM_UMAC_CTX_Q_1 = 1,
+	ENUM_UMAC_CTX_Q_2 = 2,
+	ENUM_UMAC_CTX_Q_3 = 3,
+	ENUM_UMAC_CRX     = 0,
+	ENUM_UMAC_CIF_QUEUE_TOTAL_NUM = 4
+};
+
+/* LMAC PLE For PSE Control P3 */
+enum umac_ple_ctrl_port3_queue_idx {
+	ENUM_UMAC_PLE_CTRL_P3_Q_0X1E            = 0x1e,
+	ENUM_UMAC_PLE_CTRL_P3_Q_0X1F            = 0x1f,
+	ENUM_UMAC_PLE_CTRL_P3_TOTAL_NUM         = 2
+};
+
+/* PSE PLE QUEUE */
+#define CR_NUM_OF_AC_MT7996	34
+#define CR_NUM_OF_AC_MT7992	17
+struct bmac_queue_info {
+	char *QueueName;
+	u32 Portid;
+	u32 Queueid;
+	u32 tgid;
+};
+
+struct bmac_queue_info_t {
+	char *QueueName;
+	u32 Portid;
+	u32 Queueid;
+};
+
+#define WF_DRR_TOP_BASE                                        0x820c8800
+#define WF_DRR_TOP_SBRR_ADDR                                   (WF_DRR_TOP_BASE + 0x00E0) // 88E0
+#define WF_DRR_TOP_TWT_STA_MAP00_ADDR                          (WF_DRR_TOP_BASE + 0x0100) // 8900
+#define WF_DRR_TOP_TWT_STA_MAP_EXT_00_ADDR                     (WF_DRR_TOP_BASE + 0x0180) // 8980
+#define WF_DRR_TOP_AC0_STATION_PAUSE00_ADDR                    (WF_DRR_TOP_BASE + 0x0200) // 8A00
+#define WF_DRR_TOP_AC0_STATION_PAUSE_EXT_00_ADDR               (WF_DRR_TOP_BASE + 0x0280) // 8A80
+#define WF_DRR_TOP_AC1_STATION_PAUSE00_ADDR                    (WF_DRR_TOP_BASE + 0x0300) // 8B00
+#define WF_DRR_TOP_AC1_STATION_PAUSE_EXT_00_ADDR               (WF_DRR_TOP_BASE + 0x0380) // 8B80
+#define WF_DRR_TOP_AC2_STATION_PAUSE00_ADDR                    (WF_DRR_TOP_BASE + 0x0400) // 8C00
+#define WF_DRR_TOP_AC2_STATION_PAUSE_EXT_00_ADDR               (WF_DRR_TOP_BASE + 0x0480) // 8C80
+#define WF_DRR_TOP_AC3_STATION_PAUSE00_ADDR                    (WF_DRR_TOP_BASE + 0x0500) // 8D00
+#define WF_DRR_TOP_AC3_STATION_PAUSE_EXT_00_ADDR               (WF_DRR_TOP_BASE + 0x0580) // 8D80
+
+#define WF_DRR_TOP_SBRR_TARGET_BAND_MASK                       0x00000003                // TARGET_BAND[1..0]
+/* PLE AMSDU */
+#define WF_PLE_TOP_BASE                                        0x820c0000
+
+#define WF_PLE_TOP_AMSDU_PACK_1_MSDU_CNT_ADDR                  (WF_PLE_TOP_BASE + 0x10e0) // 10E0
+#define WF_PLE_TOP_AMSDU_PACK_2_MSDU_CNT_ADDR                  (WF_PLE_TOP_BASE + 0x10e4) // 10E4
+#define WF_PLE_TOP_AMSDU_PACK_3_MSDU_CNT_ADDR                  (WF_PLE_TOP_BASE + 0x10e8) // 10E8
+#define WF_PLE_TOP_AMSDU_PACK_4_MSDU_CNT_ADDR                  (WF_PLE_TOP_BASE + 0x10ec) // 10EC
+#define WF_PLE_TOP_AMSDU_PACK_5_MSDU_CNT_ADDR                  (WF_PLE_TOP_BASE + 0x10f0) // 10F0
+#define WF_PLE_TOP_AMSDU_PACK_6_MSDU_CNT_ADDR                  (WF_PLE_TOP_BASE + 0x10f4) // 10F4
+#define WF_PLE_TOP_AMSDU_PACK_7_MSDU_CNT_ADDR                  (WF_PLE_TOP_BASE + 0x10f8) // 10F8
+#define WF_PLE_TOP_AMSDU_PACK_8_MSDU_CNT_ADDR                  (WF_PLE_TOP_BASE + 0x10fc) // 10FC
+#define WF_PLE_TOP_AMSDU_PACK_NUM                              8
+
+/* PLE */
+#define WF_PLE_TOP_PBUF_CTRL_ADDR                              (WF_PLE_TOP_BASE + 0x04) // 0004
+
+#define WF_PLE_TOP_PG_HIF_GROUP_ADDR                           (WF_PLE_TOP_BASE + 0x0c) // 000C
+#define WF_PLE_TOP_PG_HIF_WMTXD_GROUP_ADDR                     (WF_PLE_TOP_BASE + 0x10) // 0010
+#define WF_PLE_TOP_PG_HIF_TXCMD_GROUP_ADDR                     (WF_PLE_TOP_BASE + 0x14) // 0014
+#define WF_PLE_TOP_PG_CPU_GROUP_ADDR                           (WF_PLE_TOP_BASE + 0x18) // 0018
+#define WF_PLE_TOP_QUEUE_EMPTY_ADDR                            (WF_PLE_TOP_BASE + 0x360) // 0360
+
+#define WF_PLE_TOP_DIS_STA_MAP0_ADDR                           (WF_PLE_TOP_BASE + 0x100) // 0100
+#define WF_PLE_TOP_DIS_STA_MAP1_ADDR                           (WF_PLE_TOP_BASE + 0x104) // 0104
+#define WF_PLE_TOP_DIS_STA_MAP2_ADDR                           (WF_PLE_TOP_BASE + 0x108) // 0108
+#define WF_PLE_TOP_DIS_STA_MAP3_ADDR                           (WF_PLE_TOP_BASE + 0x10c) // 010C
+#define WF_PLE_TOP_DIS_STA_MAP4_ADDR                           (WF_PLE_TOP_BASE + 0x110) // 0110
+#define WF_PLE_TOP_DIS_STA_MAP5_ADDR                           (WF_PLE_TOP_BASE + 0x114) // 0114
+#define WF_PLE_TOP_DIS_STA_MAP6_ADDR                           (WF_PLE_TOP_BASE + 0x118) // 0118
+#define WF_PLE_TOP_DIS_STA_MAP7_ADDR                           (WF_PLE_TOP_BASE + 0x11c) // 011C
+#define WF_PLE_TOP_DIS_STA_MAP8_ADDR                           (WF_PLE_TOP_BASE + 0x120) // 0120
+
+#define WF_PLE_TOP_TXCMD_QUEUE_EMPTY_ADDR                      (WF_PLE_TOP_BASE + 0x378) // 0378
+#define WF_PLE_TOP_NATIVE_TXCMD_QUEUE_EMPTY_ADDR               (WF_PLE_TOP_BASE + 0x37c) // 037C
+#define WF_PLE_TOP_BN1_TXCMD_QUEUE_EMPTY_ADDR                  (WF_PLE_TOP_BASE + 0x388) // 0388
+#define WF_PLE_TOP_BN1_NATIVE_TXCMD_QUEUE_EMPTY_ADDR           (WF_PLE_TOP_BASE + 0x38c) // 038C
+#define WF_PLE_TOP_BN2_TXCMD_QUEUE_EMPTY_ADDR                  (WF_PLE_TOP_BASE + 0x398) // 0398
+#define WF_PLE_TOP_BN2_NATIVE_TXCMD_QUEUE_EMPTY_ADDR           (WF_PLE_TOP_BASE + 0x39c) // 039C
+
+#define WF_PLE_TOP_FREEPG_CNT_ADDR                             (WF_PLE_TOP_BASE + 0x3a0) // 03A0
+#define WF_PLE_TOP_FREEPG_HEAD_TAIL_ADDR                       (WF_PLE_TOP_BASE + 0x3a4) // 03A4
+#define WF_PLE_TOP_HIF_PG_INFO_ADDR                            (WF_PLE_TOP_BASE + 0x3a8) // 03A8
+#define WF_PLE_TOP_HIF_WMTXD_PG_INFO_ADDR                      (WF_PLE_TOP_BASE + 0x3ac) // 03AC
+#define WF_PLE_TOP_HIF_TXCMD_PG_INFO_ADDR                      (WF_PLE_TOP_BASE + 0x3b0) // 03B0
+#define WF_PLE_TOP_CPU_PG_INFO_ADDR                            (WF_PLE_TOP_BASE + 0x3b4) // 03B4
+
+#define WF_PLE_TOP_FL_QUE_CTRL_0_ADDR                          (WF_PLE_TOP_BASE + 0x3e0) // 03E0
+#define WF_PLE_TOP_FL_QUE_CTRL_1_ADDR                          (WF_PLE_TOP_BASE + 0x3e4) // 03E4
+#define WF_PLE_TOP_FL_QUE_CTRL_2_ADDR                          (WF_PLE_TOP_BASE + 0x3e8) // 03E8
+#define WF_PLE_TOP_FL_QUE_CTRL_3_ADDR                          (WF_PLE_TOP_BASE + 0x3ec) // 03EC
+
+#define WF_PLE_TOP_AC0_QUEUE_EMPTY0_ADDR                       (WF_PLE_TOP_BASE + 0x600) // 0600
+#define WF_PLE_TOP_AC0_QUEUE_EMPTY1_ADDR                       (WF_PLE_TOP_BASE + 0x604) // 0604
+#define WF_PLE_TOP_AC0_QUEUE_EMPTY2_ADDR                       (WF_PLE_TOP_BASE + 0x608) // 0608
+#define WF_PLE_TOP_AC0_QUEUE_EMPTY3_ADDR                       (WF_PLE_TOP_BASE + 0x60c) // 060C
+#define WF_PLE_TOP_AC0_QUEUE_EMPTY4_ADDR                       (WF_PLE_TOP_BASE + 0x610) // 0610
+#define WF_PLE_TOP_AC0_QUEUE_EMPTY5_ADDR                       (WF_PLE_TOP_BASE + 0x614) // 0614
+#define WF_PLE_TOP_AC0_QUEUE_EMPTY6_ADDR                       (WF_PLE_TOP_BASE + 0x618) // 0618
+#define WF_PLE_TOP_AC0_QUEUE_EMPTY7_ADDR                       (WF_PLE_TOP_BASE + 0x61c) // 061C
+#define WF_PLE_TOP_AC0_QUEUE_EMPTY8_ADDR                       (WF_PLE_TOP_BASE + 0x620) // 0620
+#define WF_PLE_TOP_AC0_QUEUE_EMPTY_EXT0_ADDR                   (WF_PLE_TOP_BASE + 0x680) // 0680
+
+#define WF_PLE_TOP_AC1_QUEUE_EMPTY0_ADDR                       (WF_PLE_TOP_BASE + 0x700) // 0700
+#define WF_PLE_TOP_AC1_QUEUE_EMPTY1_ADDR                       (WF_PLE_TOP_BASE + 0x704) // 0704
+#define WF_PLE_TOP_AC1_QUEUE_EMPTY2_ADDR                       (WF_PLE_TOP_BASE + 0x708) // 0708
+#define WF_PLE_TOP_AC1_QUEUE_EMPTY3_ADDR                       (WF_PLE_TOP_BASE + 0x70c) // 070C
+#define WF_PLE_TOP_AC1_QUEUE_EMPTY4_ADDR                       (WF_PLE_TOP_BASE + 0x710) // 0710
+#define WF_PLE_TOP_AC1_QUEUE_EMPTY5_ADDR                       (WF_PLE_TOP_BASE + 0x714) // 0714
+#define WF_PLE_TOP_AC1_QUEUE_EMPTY6_ADDR                       (WF_PLE_TOP_BASE + 0x718) // 0718
+#define WF_PLE_TOP_AC1_QUEUE_EMPTY7_ADDR                       (WF_PLE_TOP_BASE + 0x71c) // 071C
+#define WF_PLE_TOP_AC1_QUEUE_EMPTY8_ADDR                       (WF_PLE_TOP_BASE + 0x720) // 0720
+#define WF_PLE_TOP_AC1_QUEUE_EMPTY_EXT0_ADDR                   (WF_PLE_TOP_BASE + 0x780) // 0780
+
+#define WF_PLE_TOP_AC2_QUEUE_EMPTY0_ADDR                       (WF_PLE_TOP_BASE + 0x800) // 0800
+#define WF_PLE_TOP_AC2_QUEUE_EMPTY1_ADDR                       (WF_PLE_TOP_BASE + 0x804) // 0804
+#define WF_PLE_TOP_AC2_QUEUE_EMPTY2_ADDR                       (WF_PLE_TOP_BASE + 0x808) // 0808
+#define WF_PLE_TOP_AC2_QUEUE_EMPTY3_ADDR                       (WF_PLE_TOP_BASE + 0x80c) // 080C
+#define WF_PLE_TOP_AC2_QUEUE_EMPTY4_ADDR                       (WF_PLE_TOP_BASE + 0x810) // 0810
+#define WF_PLE_TOP_AC2_QUEUE_EMPTY5_ADDR                       (WF_PLE_TOP_BASE + 0x814) // 0814
+#define WF_PLE_TOP_AC2_QUEUE_EMPTY6_ADDR                       (WF_PLE_TOP_BASE + 0x818) // 0818
+#define WF_PLE_TOP_AC2_QUEUE_EMPTY7_ADDR                       (WF_PLE_TOP_BASE + 0x81c) // 081C
+#define WF_PLE_TOP_AC2_QUEUE_EMPTY8_ADDR                       (WF_PLE_TOP_BASE + 0x820) // 0820
+#define WF_PLE_TOP_AC2_QUEUE_EMPTY_EXT0_ADDR                   (WF_PLE_TOP_BASE + 0x880) // 0880
+
+#define WF_PLE_TOP_AC3_QUEUE_EMPTY0_ADDR                       (WF_PLE_TOP_BASE + 0x900) // 0900
+#define WF_PLE_TOP_AC3_QUEUE_EMPTY1_ADDR                       (WF_PLE_TOP_BASE + 0x904) // 0904
+#define WF_PLE_TOP_AC3_QUEUE_EMPTY2_ADDR                       (WF_PLE_TOP_BASE + 0x908) // 0908
+#define WF_PLE_TOP_AC3_QUEUE_EMPTY3_ADDR                       (WF_PLE_TOP_BASE + 0x90c) // 090C
+#define WF_PLE_TOP_AC3_QUEUE_EMPTY4_ADDR                       (WF_PLE_TOP_BASE + 0x910) // 0910
+#define WF_PLE_TOP_AC3_QUEUE_EMPTY5_ADDR                       (WF_PLE_TOP_BASE + 0x914) // 0914
+#define WF_PLE_TOP_AC3_QUEUE_EMPTY6_ADDR                       (WF_PLE_TOP_BASE + 0x918) // 0918
+#define WF_PLE_TOP_AC3_QUEUE_EMPTY7_ADDR                       (WF_PLE_TOP_BASE + 0x91c) // 091C
+#define WF_PLE_TOP_AC3_QUEUE_EMPTY8_ADDR                       (WF_PLE_TOP_BASE + 0x920) // 0920
+#define WF_PLE_TOP_AC3_QUEUE_EMPTY_EXT0_ADDR                   (WF_PLE_TOP_BASE + 0x980) // 0980
+
+#define WF_PLE_TOP_QUEUE_EMPTY_ALL_AC_EMPTY_ADDR               WF_PLE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PLE_TOP_QUEUE_EMPTY_ALL_AC_EMPTY_MASK               0x01000000                // ALL_AC_EMPTY[24]
+#define WF_PLE_TOP_QUEUE_EMPTY_ALL_AC_EMPTY_SHFT               24
+
+#define WF_PLE_TOP_PBUF_CTRL_PAGE_SIZE_CFG_ADDR                WF_PLE_TOP_PBUF_CTRL_ADDR
+#define WF_PLE_TOP_PBUF_CTRL_PAGE_SIZE_CFG_MASK                0x80000000                // PAGE_SIZE_CFG[31]
+#define WF_PLE_TOP_PBUF_CTRL_PAGE_SIZE_CFG_SHFT                31
+#define WF_PLE_TOP_PBUF_CTRL_PBUF_OFFSET_ADDR                  WF_PLE_TOP_PBUF_CTRL_ADDR
+#define WF_PLE_TOP_PBUF_CTRL_PBUF_OFFSET_MASK                  0x07FE0000                // PBUF_OFFSET[26..17]
+#define WF_PLE_TOP_PBUF_CTRL_PBUF_OFFSET_SHFT                  17
+#define WF_PLE_TOP_PBUF_CTRL_TOTAL_PAGE_NUM_ADDR               WF_PLE_TOP_PBUF_CTRL_ADDR
+#define WF_PLE_TOP_PBUF_CTRL_TOTAL_PAGE_NUM_MASK               0x00001FFF                // TOTAL_PAGE_NUM[12..0]
+#define WF_PLE_TOP_PBUF_CTRL_TOTAL_PAGE_NUM_SHFT               0
+
+#define WF_PLE_TOP_FREEPG_CNT_FFA_CNT_ADDR                     WF_PLE_TOP_FREEPG_CNT_ADDR
+#define WF_PLE_TOP_FREEPG_CNT_FFA_CNT_MASK                     0x1FFF0000                // FFA_CNT[28..16]
+#define WF_PLE_TOP_FREEPG_CNT_FFA_CNT_SHFT                     16
+#define WF_PLE_TOP_FREEPG_CNT_FREEPG_CNT_ADDR                  WF_PLE_TOP_FREEPG_CNT_ADDR
+#define WF_PLE_TOP_FREEPG_CNT_FREEPG_CNT_MASK                  0x00001FFF                // FREEPG_CNT[12..0]
+#define WF_PLE_TOP_FREEPG_CNT_FREEPG_CNT_SHFT                  0
+
+#define WF_PLE_TOP_FREEPG_HEAD_TAIL_FREEPG_TAIL_ADDR           WF_PLE_TOP_FREEPG_HEAD_TAIL_ADDR
+#define WF_PLE_TOP_FREEPG_HEAD_TAIL_FREEPG_TAIL_MASK           0x1FFF0000                // FREEPG_TAIL[28..16]
+#define WF_PLE_TOP_FREEPG_HEAD_TAIL_FREEPG_TAIL_SHFT           16
+#define WF_PLE_TOP_FREEPG_HEAD_TAIL_FREEPG_HEAD_ADDR           WF_PLE_TOP_FREEPG_HEAD_TAIL_ADDR
+#define WF_PLE_TOP_FREEPG_HEAD_TAIL_FREEPG_HEAD_MASK           0x00001FFF                // FREEPG_HEAD[12..0]
+#define WF_PLE_TOP_FREEPG_HEAD_TAIL_FREEPG_HEAD_SHFT           0
+
+#define WF_PLE_TOP_PG_HIF_GROUP_HIF_MAX_QUOTA_ADDR             WF_PLE_TOP_PG_HIF_GROUP_ADDR
+#define WF_PLE_TOP_PG_HIF_GROUP_HIF_MAX_QUOTA_MASK             0x1FFF0000                // HIF_MAX_QUOTA[28..16]
+#define WF_PLE_TOP_PG_HIF_GROUP_HIF_MAX_QUOTA_SHFT             16
+#define WF_PLE_TOP_PG_HIF_GROUP_HIF_MIN_QUOTA_ADDR             WF_PLE_TOP_PG_HIF_GROUP_ADDR
+#define WF_PLE_TOP_PG_HIF_GROUP_HIF_MIN_QUOTA_MASK             0x00001FFF                // HIF_MIN_QUOTA[12..0]
+#define WF_PLE_TOP_PG_HIF_GROUP_HIF_MIN_QUOTA_SHFT             0
+
+#define WF_PLE_TOP_HIF_PG_INFO_HIF_SRC_CNT_ADDR                WF_PLE_TOP_HIF_PG_INFO_ADDR
+#define WF_PLE_TOP_HIF_PG_INFO_HIF_SRC_CNT_MASK                0x1FFF0000                // HIF_SRC_CNT[28..16]
+#define WF_PLE_TOP_HIF_PG_INFO_HIF_SRC_CNT_SHFT                16
+#define WF_PLE_TOP_HIF_PG_INFO_HIF_RSV_CNT_ADDR                WF_PLE_TOP_HIF_PG_INFO_ADDR
+#define WF_PLE_TOP_HIF_PG_INFO_HIF_RSV_CNT_MASK                0x00001FFF                // HIF_RSV_CNT[12..0]
+#define WF_PLE_TOP_HIF_PG_INFO_HIF_RSV_CNT_SHFT                0
+
+#define WF_PLE_TOP_PG_HIF_WMTXD_GROUP_HIF_WMTXD_MAX_QUOTA_ADDR WF_PLE_TOP_PG_HIF_WMTXD_GROUP_ADDR
+#define WF_PLE_TOP_PG_HIF_WMTXD_GROUP_HIF_WMTXD_MAX_QUOTA_MASK 0x1FFF0000                // HIF_WMTXD_MAX_QUOTA[28..16]
+#define WF_PLE_TOP_PG_HIF_WMTXD_GROUP_HIF_WMTXD_MAX_QUOTA_SHFT 16
+#define WF_PLE_TOP_PG_HIF_WMTXD_GROUP_HIF_WMTXD_MIN_QUOTA_ADDR WF_PLE_TOP_PG_HIF_WMTXD_GROUP_ADDR
+#define WF_PLE_TOP_PG_HIF_WMTXD_GROUP_HIF_WMTXD_MIN_QUOTA_MASK 0x00001FFF                // HIF_WMTXD_MIN_QUOTA[12..0]
+#define WF_PLE_TOP_PG_HIF_WMTXD_GROUP_HIF_WMTXD_MIN_QUOTA_SHFT 0
+
+#define WF_PLE_TOP_HIF_WMTXD_PG_INFO_HIF_WMTXD_SRC_CNT_ADDR    WF_PLE_TOP_HIF_WMTXD_PG_INFO_ADDR
+#define WF_PLE_TOP_HIF_WMTXD_PG_INFO_HIF_WMTXD_SRC_CNT_MASK    0x1FFF0000                // HIF_WMTXD_SRC_CNT[28..16]
+#define WF_PLE_TOP_HIF_WMTXD_PG_INFO_HIF_WMTXD_SRC_CNT_SHFT    16
+#define WF_PLE_TOP_HIF_WMTXD_PG_INFO_HIF_WMTXD_RSV_CNT_ADDR    WF_PLE_TOP_HIF_WMTXD_PG_INFO_ADDR
+#define WF_PLE_TOP_HIF_WMTXD_PG_INFO_HIF_WMTXD_RSV_CNT_MASK    0x00001FFF                // HIF_WMTXD_RSV_CNT[12..0]
+#define WF_PLE_TOP_HIF_WMTXD_PG_INFO_HIF_WMTXD_RSV_CNT_SHFT    0
+
+#define WF_PLE_TOP_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MAX_QUOTA_ADDR WF_PLE_TOP_PG_HIF_TXCMD_GROUP_ADDR
+#define WF_PLE_TOP_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MAX_QUOTA_MASK 0x1FFF0000                // HIF_TXCMD_MAX_QUOTA[28..16]
+#define WF_PLE_TOP_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MAX_QUOTA_SHFT 16
+#define WF_PLE_TOP_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MIN_QUOTA_ADDR WF_PLE_TOP_PG_HIF_TXCMD_GROUP_ADDR
+#define WF_PLE_TOP_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MIN_QUOTA_MASK 0x00001FFF                // HIF_TXCMD_MIN_QUOTA[12..0]
+#define WF_PLE_TOP_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MIN_QUOTA_SHFT 0
+
+#define WF_PLE_TOP_HIF_TXCMD_PG_INFO_HIF_TXCMD_SRC_CNT_ADDR    WF_PLE_TOP_HIF_TXCMD_PG_INFO_ADDR
+#define WF_PLE_TOP_HIF_TXCMD_PG_INFO_HIF_TXCMD_SRC_CNT_MASK    0x1FFF0000                // HIF_TXCMD_SRC_CNT[28..16]
+#define WF_PLE_TOP_HIF_TXCMD_PG_INFO_HIF_TXCMD_SRC_CNT_SHFT    16
+#define WF_PLE_TOP_HIF_TXCMD_PG_INFO_HIF_TXCMD_RSV_CNT_ADDR    WF_PLE_TOP_HIF_TXCMD_PG_INFO_ADDR
+#define WF_PLE_TOP_HIF_TXCMD_PG_INFO_HIF_TXCMD_RSV_CNT_MASK    0x00001FFF                // HIF_TXCMD_RSV_CNT[12..0]
+#define WF_PLE_TOP_HIF_TXCMD_PG_INFO_HIF_TXCMD_RSV_CNT_SHFT    0
+
+#define WF_PLE_TOP_PG_CPU_GROUP_CPU_MAX_QUOTA_ADDR             WF_PLE_TOP_PG_CPU_GROUP_ADDR
+#define WF_PLE_TOP_PG_CPU_GROUP_CPU_MAX_QUOTA_MASK             0x1FFF0000                // CPU_MAX_QUOTA[28..16]
+#define WF_PLE_TOP_PG_CPU_GROUP_CPU_MAX_QUOTA_SHFT             16
+#define WF_PLE_TOP_PG_CPU_GROUP_CPU_MIN_QUOTA_ADDR             WF_PLE_TOP_PG_CPU_GROUP_ADDR
+#define WF_PLE_TOP_PG_CPU_GROUP_CPU_MIN_QUOTA_MASK             0x00001FFF                // CPU_MIN_QUOTA[12..0]
+#define WF_PLE_TOP_PG_CPU_GROUP_CPU_MIN_QUOTA_SHFT             0
+
+#define WF_PLE_TOP_CPU_PG_INFO_CPU_SRC_CNT_ADDR                WF_PLE_TOP_CPU_PG_INFO_ADDR
+#define WF_PLE_TOP_CPU_PG_INFO_CPU_SRC_CNT_MASK                0x1FFF0000                // CPU_SRC_CNT[28..16]
+#define WF_PLE_TOP_CPU_PG_INFO_CPU_SRC_CNT_SHFT                16
+#define WF_PLE_TOP_CPU_PG_INFO_CPU_RSV_CNT_ADDR                WF_PLE_TOP_CPU_PG_INFO_ADDR
+#define WF_PLE_TOP_CPU_PG_INFO_CPU_RSV_CNT_MASK                0x00001FFF                // CPU_RSV_CNT[12..0]
+#define WF_PLE_TOP_CPU_PG_INFO_CPU_RSV_CNT_SHFT                0
+
+#define WF_PLE_TOP_FL_QUE_CTRL_0_EXECUTE_ADDR                  WF_PLE_TOP_FL_QUE_CTRL_0_ADDR
+#define WF_PLE_TOP_FL_QUE_CTRL_0_EXECUTE_MASK                  0x80000000                // EXECUTE[31]
+#define WF_PLE_TOP_FL_QUE_CTRL_0_EXECUTE_SHFT                  31
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_ADDR                WF_PLE_TOP_FL_QUE_CTRL_0_ADDR
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_MASK                0x7F000000                // Q_BUF_QID[30..24]
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_SHFT                24
+#define WF_PLE_TOP_FL_QUE_CTRL_0_FL_BUFFER_ADDR_ADDR           WF_PLE_TOP_FL_QUE_CTRL_0_ADDR
+#define WF_PLE_TOP_FL_QUE_CTRL_0_FL_BUFFER_ADDR_MASK           0x00FFF000                // FL_BUFFER_ADDR[23..12]
+#define WF_PLE_TOP_FL_QUE_CTRL_0_FL_BUFFER_ADDR_SHFT           12
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_WLANID_ADDR             WF_PLE_TOP_FL_QUE_CTRL_0_ADDR
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_WLANID_MASK             0x00000FFF                // Q_BUF_WLANID[11..0]
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_WLANID_SHFT             0
+
+#define WF_PLE_TOP_FL_QUE_CTRL_1_Q_BUF_TGID_ADDR               WF_PLE_TOP_FL_QUE_CTRL_1_ADDR
+#define WF_PLE_TOP_FL_QUE_CTRL_1_Q_BUF_TGID_MASK               0xC0000000                // Q_BUF_TGID[31..30]
+#define WF_PLE_TOP_FL_QUE_CTRL_1_Q_BUF_TGID_SHFT               30
+#define WF_PLE_TOP_FL_QUE_CTRL_1_Q_BUF_PID_ADDR                WF_PLE_TOP_FL_QUE_CTRL_1_ADDR
+#define WF_PLE_TOP_FL_QUE_CTRL_1_Q_BUF_PID_MASK                0x30000000                // Q_BUF_PID[29..28]
+#define WF_PLE_TOP_FL_QUE_CTRL_1_Q_BUF_PID_SHFT                28
+
+#define WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_ADDR           WF_PLE_TOP_FL_QUE_CTRL_2_ADDR
+#define WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_MASK           0x1FFF0000                // QUEUE_TAIL_FID[28..16]
+#define WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_SHFT           16
+#define WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_ADDR           WF_PLE_TOP_FL_QUE_CTRL_2_ADDR
+#define WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_MASK           0x00001FFF                // QUEUE_HEAD_FID[12..0]
+#define WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_SHFT           0
+
+#define WF_PLE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_ADDR            WF_PLE_TOP_FL_QUE_CTRL_3_ADDR
+#define WF_PLE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_MASK            0x00001FFF                // QUEUE_PKT_NUM[12..0]
+#define WF_PLE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_SHFT            0
+
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_TGID_ADDR               WF_PLE_TOP_FL_QUE_CTRL_0_ADDR
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_TGID_MASK               0x00300000                // Q_BUF_TGID[21..20]
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_TGID_SHFT               20
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_PID_ADDR                WF_PLE_TOP_FL_QUE_CTRL_0_ADDR
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_PID_MASK                0x00030000                // Q_BUF_PID[17..16]
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_PID_SHFT                16
+/* PSE */
+#define WF_PSE_TOP_BASE                                        0x820c8000
+
+#define WF_PSE_TOP_PBUF_CTRL_ADDR                              (WF_PSE_TOP_BASE + 0x04) // 8004
+#define WF_PSE_TOP_QUEUE_EMPTY_ADDR                            (WF_PSE_TOP_BASE + 0xB0) // 80B0
+#define WF_PSE_TOP_QUEUE_EMPTY_1_ADDR                          (WF_PSE_TOP_BASE + 0xBC) // 80BC
+#define WF_PSE_TOP_PG_HIF0_GROUP_ADDR                          (WF_PSE_TOP_BASE + 0x110) // 8110
+#define WF_PSE_TOP_PG_HIF1_GROUP_ADDR                          (WF_PSE_TOP_BASE + 0x114) // 8114
+#define WF_PSE_TOP_PG_CPU_GROUP_ADDR                           (WF_PSE_TOP_BASE + 0x118) // 8118
+#define WF_PSE_TOP_PG_PLE_GROUP_ADDR                           (WF_PSE_TOP_BASE + 0x11C) // 811C
+#define WF_PSE_TOP_PG_PLE1_GROUP_ADDR                          (WF_PSE_TOP_BASE + 0x120) // 8120
+#define WF_PSE_TOP_PG_LMAC0_GROUP_ADDR                         (WF_PSE_TOP_BASE + 0x124) // 8124
+#define WF_PSE_TOP_PG_LMAC1_GROUP_ADDR                         (WF_PSE_TOP_BASE + 0x128) // 8128
+#define WF_PSE_TOP_PG_LMAC2_GROUP_ADDR                         (WF_PSE_TOP_BASE + 0x12C) // 812C
+#define WF_PSE_TOP_PG_LMAC3_GROUP_ADDR                         (WF_PSE_TOP_BASE + 0x130) // 8130
+#define WF_PSE_TOP_PG_MDP_GROUP_ADDR                           (WF_PSE_TOP_BASE + 0x134) // 8134
+#define WF_PSE_TOP_PG_MDP2_GROUP_ADDR                          (WF_PSE_TOP_BASE + 0x13C) // 813C
+#define WF_PSE_TOP_PG_HIF2_GROUP_ADDR                          (WF_PSE_TOP_BASE + 0x140) // 8140
+#define WF_PSE_TOP_PG_MDP3_GROUP_ADDR                          (WF_PSE_TOP_BASE + 0x144) // 8144
+#define WF_PSE_TOP_HIF0_PG_INFO_ADDR                           (WF_PSE_TOP_BASE + 0x150) // 8150
+#define WF_PSE_TOP_HIF1_PG_INFO_ADDR                           (WF_PSE_TOP_BASE + 0x154) // 8154
+#define WF_PSE_TOP_CPU_PG_INFO_ADDR                            (WF_PSE_TOP_BASE + 0x158) // 8158
+#define WF_PSE_TOP_PLE_PG_INFO_ADDR                            (WF_PSE_TOP_BASE + 0x15C) // 815C
+#define WF_PSE_TOP_PLE1_PG_INFO_ADDR                           (WF_PSE_TOP_BASE + 0x160) // 8160
+#define WF_PSE_TOP_LMAC0_PG_INFO_ADDR                          (WF_PSE_TOP_BASE + 0x164) // 8164
+#define WF_PSE_TOP_LMAC1_PG_INFO_ADDR                          (WF_PSE_TOP_BASE + 0x168) // 8168
+#define WF_PSE_TOP_LMAC2_PG_INFO_ADDR                          (WF_PSE_TOP_BASE + 0x16C) // 816C
+#define WF_PSE_TOP_LMAC3_PG_INFO_ADDR                          (WF_PSE_TOP_BASE + 0x170) // 8170
+#define WF_PSE_TOP_MDP_PG_INFO_ADDR                            (WF_PSE_TOP_BASE + 0x174) // 8174
+#define WF_PSE_TOP_MDP2_PG_INFO_ADDR                           (WF_PSE_TOP_BASE + 0x17C) // 817C
+#define WF_PSE_TOP_HIF2_PG_INFO_ADDR                           (WF_PSE_TOP_BASE + 0x180) // 8180
+#define WF_PSE_TOP_MDP3_PG_INFO_ADDR                           (WF_PSE_TOP_BASE + 0x184) // 8184
+#define WF_PSE_TOP_FL_QUE_CTRL_0_ADDR                          (WF_PSE_TOP_BASE + 0x1B0) // 81B0
+#define WF_PSE_TOP_FL_QUE_CTRL_1_ADDR                          (WF_PSE_TOP_BASE + 0x1B4) // 81B4
+#define WF_PSE_TOP_FL_QUE_CTRL_2_ADDR                          (WF_PSE_TOP_BASE + 0x1B8) // 81B8
+#define WF_PSE_TOP_FL_QUE_CTRL_3_ADDR                          (WF_PSE_TOP_BASE + 0x1BC) // 81BC
+#define WF_PSE_TOP_FREEPG_CNT_ADDR                             (WF_PSE_TOP_BASE + 0x3A0) // 83A0
+#define WF_PSE_TOP_FREEPG_HEAD_TAIL_ADDR                       (WF_PSE_TOP_BASE + 0x3A4) // 83A4
+
+#define WF_PSE_TOP_PBUF_CTRL_PAGE_SIZE_CFG_ADDR                WF_PSE_TOP_PBUF_CTRL_ADDR
+#define WF_PSE_TOP_PBUF_CTRL_PAGE_SIZE_CFG_MASK                0x80000000                // PAGE_SIZE_CFG[31]
+#define WF_PSE_TOP_PBUF_CTRL_PAGE_SIZE_CFG_SHFT                31
+#define WF_PSE_TOP_PBUF_CTRL_PBUF_OFFSET_ADDR                  WF_PSE_TOP_PBUF_CTRL_ADDR
+#define WF_PSE_TOP_PBUF_CTRL_PBUF_OFFSET_MASK                  0x07FE0000                // PBUF_OFFSET[26..17]
+#define WF_PSE_TOP_PBUF_CTRL_PBUF_OFFSET_SHFT                  17
+#define WF_PSE_TOP_PBUF_CTRL_TOTAL_PAGE_NUM_ADDR               WF_PSE_TOP_PBUF_CTRL_ADDR
+#define WF_PSE_TOP_PBUF_CTRL_TOTAL_PAGE_NUM_MASK               0x00001FFF                // TOTAL_PAGE_NUM[12..0]
+#define WF_PSE_TOP_PBUF_CTRL_TOTAL_PAGE_NUM_SHFT               0
+
+#define WF_PSE_TOP_QUEUE_EMPTY_RLS_Q_EMTPY_ADDR                WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_RLS_Q_EMTPY_MASK                0x80000000                // RLS_Q_EMTPY[31]
+#define WF_PSE_TOP_QUEUE_EMPTY_RLS_Q_EMTPY_SHFT                31
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q4_EMPTY_ADDR               WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q4_EMPTY_MASK               0x10000000                // CPU_Q4_EMPTY[28]
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q4_EMPTY_SHFT               28
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC1_QUEUE_EMPTY_ADDR     WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC1_QUEUE_EMPTY_MASK     0x08000000                // MDP_RXIOC1_QUEUE_EMPTY[27]
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC1_QUEUE_EMPTY_SHFT     27
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC1_QUEUE_EMPTY_ADDR     WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC1_QUEUE_EMPTY_MASK     0x04000000                // MDP_TXIOC1_QUEUE_EMPTY[26]
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC1_QUEUE_EMPTY_SHFT     26
+#define WF_PSE_TOP_QUEUE_EMPTY_SEC_TX1_QUEUE_EMPTY_ADDR        WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_SEC_TX1_QUEUE_EMPTY_MASK        0x02000000                // SEC_TX1_QUEUE_EMPTY[25]
+#define WF_PSE_TOP_QUEUE_EMPTY_SEC_TX1_QUEUE_EMPTY_SHFT        25
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TX1_QUEUE_EMPTY_ADDR        WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TX1_QUEUE_EMPTY_MASK        0x01000000                // MDP_TX1_QUEUE_EMPTY[24]
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TX1_QUEUE_EMPTY_SHFT        24
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC_QUEUE_EMPTY_ADDR      WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC_QUEUE_EMPTY_MASK      0x00800000                // MDP_RXIOC_QUEUE_EMPTY[23]
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC_QUEUE_EMPTY_SHFT      23
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC_QUEUE_EMPTY_ADDR      WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC_QUEUE_EMPTY_MASK      0x00400000                // MDP_TXIOC_QUEUE_EMPTY[22]
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC_QUEUE_EMPTY_SHFT      22
+#define WF_PSE_TOP_QUEUE_EMPTY_SFD_PARK_QUEUE_EMPTY_ADDR       WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_SFD_PARK_QUEUE_EMPTY_MASK       0x00200000                // SFD_PARK_QUEUE_EMPTY[21]
+#define WF_PSE_TOP_QUEUE_EMPTY_SFD_PARK_QUEUE_EMPTY_SHFT       21
+#define WF_PSE_TOP_QUEUE_EMPTY_SEC_RX_QUEUE_EMPTY_ADDR         WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_SEC_RX_QUEUE_EMPTY_MASK         0x00100000                // SEC_RX_QUEUE_EMPTY[20]
+#define WF_PSE_TOP_QUEUE_EMPTY_SEC_RX_QUEUE_EMPTY_SHFT         20
+#define WF_PSE_TOP_QUEUE_EMPTY_SEC_TX_QUEUE_EMPTY_ADDR         WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_SEC_TX_QUEUE_EMPTY_MASK         0x00080000                // SEC_TX_QUEUE_EMPTY[19]
+#define WF_PSE_TOP_QUEUE_EMPTY_SEC_TX_QUEUE_EMPTY_SHFT         19
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_RX_QUEUE_EMPTY_ADDR         WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_RX_QUEUE_EMPTY_MASK         0x00040000                // MDP_RX_QUEUE_EMPTY[18]
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_RX_QUEUE_EMPTY_SHFT         18
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TX_QUEUE_EMPTY_ADDR         WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TX_QUEUE_EMPTY_MASK         0x00020000                // MDP_TX_QUEUE_EMPTY[17]
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TX_QUEUE_EMPTY_SHFT         17
+#define WF_PSE_TOP_QUEUE_EMPTY_LMAC_TX_QUEUE_EMPTY_ADDR        WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_LMAC_TX_QUEUE_EMPTY_MASK        0x00010000                // LMAC_TX_QUEUE_EMPTY[16]
+#define WF_PSE_TOP_QUEUE_EMPTY_LMAC_TX_QUEUE_EMPTY_SHFT        16
+
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q3_EMPTY_ADDR               WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q3_EMPTY_MASK               0x00000008                // CPU_Q3_EMPTY[3]
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q3_EMPTY_SHFT               3
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q2_EMPTY_ADDR               WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q2_EMPTY_MASK               0x00000004                // CPU_Q2_EMPTY[2]
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q2_EMPTY_SHFT               2
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q1_EMPTY_ADDR               WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q1_EMPTY_MASK               0x00000002                // CPU_Q1_EMPTY[1]
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q1_EMPTY_SHFT               1
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q0_EMPTY_ADDR               WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q0_EMPTY_MASK               0x00000001                // CPU_Q0_EMPTY[0]
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q0_EMPTY_SHFT               0
+
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_13_EMPTY_ADDR             WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_13_EMPTY_MASK             0x20000000                // HIF_13_EMPTY[29]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_13_EMPTY_SHFT             29
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_12_EMPTY_ADDR             WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_12_EMPTY_MASK             0x10000000                // HIF_12_EMPTY[28]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_12_EMPTY_SHFT             28
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_11_EMPTY_ADDR             WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_11_EMPTY_MASK             0x08000000                // HIF_11_EMPTY[27]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_11_EMPTY_SHFT             27
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_10_EMPTY_ADDR             WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_10_EMPTY_MASK             0x04000000                // HIF_10_EMPTY[26]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_10_EMPTY_SHFT             26
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_9_EMPTY_ADDR              WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_9_EMPTY_MASK              0x02000000                // HIF_9_EMPTY[25]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_9_EMPTY_SHFT              25
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_8_EMPTY_ADDR              WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_8_EMPTY_MASK              0x01000000                // HIF_8_EMPTY[24]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_8_EMPTY_SHFT              24
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_7_EMPTY_ADDR              WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_7_EMPTY_MASK              0x00800000                // HIF_7_EMPTY[23]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_7_EMPTY_SHFT              23
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_6_EMPTY_ADDR              WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_6_EMPTY_MASK              0x00400000                // HIF_6_EMPTY[22]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_6_EMPTY_SHFT              22
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_5_EMPTY_ADDR              WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_5_EMPTY_MASK              0x00200000                // HIF_5_EMPTY[21]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_5_EMPTY_SHFT              21
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_4_EMPTY_ADDR              WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_4_EMPTY_MASK              0x00100000                // HIF_4_EMPTY[20]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_4_EMPTY_SHFT              20
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_3_EMPTY_ADDR              WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_3_EMPTY_MASK              0x00080000                // HIF_3_EMPTY[19]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_3_EMPTY_SHFT              19
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_2_EMPTY_ADDR              WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_2_EMPTY_MASK              0x00040000                // HIF_2_EMPTY[18]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_2_EMPTY_SHFT              18
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_1_EMPTY_ADDR              WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_1_EMPTY_MASK              0x00020000                // HIF_1_EMPTY[17]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_1_EMPTY_SHFT              17
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_0_EMPTY_ADDR              WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_0_EMPTY_MASK              0x00010000                // HIF_0_EMPTY[16]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_0_EMPTY_SHFT              16
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC3_QUEUE_EMPTY_ADDR   WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC3_QUEUE_EMPTY_MASK   0x00008000                // MDP_RXIOC3_QUEUE_EMPTY[15]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC3_QUEUE_EMPTY_SHFT   15
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC2_QUEUE_EMPTY_ADDR   WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC2_QUEUE_EMPTY_MASK   0x00000800                // MDP_RXIOC2_QUEUE_EMPTY[11]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC2_QUEUE_EMPTY_SHFT   11
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TXIOC2_QUEUE_EMPTY_ADDR   WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TXIOC2_QUEUE_EMPTY_MASK   0x00000400                // MDP_TXIOC2_QUEUE_EMPTY[10]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TXIOC2_QUEUE_EMPTY_SHFT   10
+#define WF_PSE_TOP_QUEUE_EMPTY_1_SEC_TX2_QUEUE_EMPTY_ADDR      WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_SEC_TX2_QUEUE_EMPTY_MASK      0x00000200                // SEC_TX2_QUEUE_EMPTY[9]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_SEC_TX2_QUEUE_EMPTY_SHFT      9
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TX2_QUEUE_EMPTY_ADDR      WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TX2_QUEUE_EMPTY_MASK      0x00000100                // MDP_TX2_QUEUE_EMPTY[8]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TX2_QUEUE_EMPTY_SHFT      8
+
+#define WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MAX_QUOTA_ADDR           WF_PSE_TOP_PG_HIF0_GROUP_ADDR
+#define WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MAX_QUOTA_MASK           0x1FFF0000                // HIF0_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MAX_QUOTA_SHFT           16
+#define WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MIN_QUOTA_ADDR           WF_PSE_TOP_PG_HIF0_GROUP_ADDR
+#define WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MIN_QUOTA_MASK           0x00001FFF                // HIF0_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MIN_QUOTA_SHFT           0
+
+
+#define WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MAX_QUOTA_ADDR           WF_PSE_TOP_PG_HIF1_GROUP_ADDR
+#define WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MAX_QUOTA_MASK           0x1FFF0000                // HIF1_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MAX_QUOTA_SHFT           16
+#define WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MIN_QUOTA_ADDR           WF_PSE_TOP_PG_HIF1_GROUP_ADDR
+#define WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MIN_QUOTA_MASK           0x00001FFF                // HIF1_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MIN_QUOTA_SHFT           0
+
+#define WF_PSE_TOP_PG_CPU_GROUP_CPU_MAX_QUOTA_ADDR             WF_PSE_TOP_PG_CPU_GROUP_ADDR
+#define WF_PSE_TOP_PG_CPU_GROUP_CPU_MAX_QUOTA_MASK             0x1FFF0000                // CPU_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_CPU_GROUP_CPU_MAX_QUOTA_SHFT             16
+#define WF_PSE_TOP_PG_CPU_GROUP_CPU_MIN_QUOTA_ADDR             WF_PSE_TOP_PG_CPU_GROUP_ADDR
+#define WF_PSE_TOP_PG_CPU_GROUP_CPU_MIN_QUOTA_MASK             0x00001FFF                // CPU_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_CPU_GROUP_CPU_MIN_QUOTA_SHFT             0
+
+#define WF_PSE_TOP_PG_PLE_GROUP_PLE_MAX_QUOTA_ADDR             WF_PSE_TOP_PG_PLE_GROUP_ADDR
+#define WF_PSE_TOP_PG_PLE_GROUP_PLE_MAX_QUOTA_MASK             0x1FFF0000                // PLE_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_PLE_GROUP_PLE_MAX_QUOTA_SHFT             16
+#define WF_PSE_TOP_PG_PLE_GROUP_PLE_MIN_QUOTA_ADDR             WF_PSE_TOP_PG_PLE_GROUP_ADDR
+#define WF_PSE_TOP_PG_PLE_GROUP_PLE_MIN_QUOTA_MASK             0x00001FFF                // PLE_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_PLE_GROUP_PLE_MIN_QUOTA_SHFT             0
+
+#define WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MAX_QUOTA_ADDR         WF_PSE_TOP_PG_LMAC0_GROUP_ADDR
+#define WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MAX_QUOTA_MASK         0x1FFF0000                // LMAC0_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MAX_QUOTA_SHFT         16
+#define WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MIN_QUOTA_ADDR         WF_PSE_TOP_PG_LMAC0_GROUP_ADDR
+#define WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MIN_QUOTA_MASK         0x00001FFF                // LMAC0_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MIN_QUOTA_SHFT         0
+
+#define WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MAX_QUOTA_ADDR         WF_PSE_TOP_PG_LMAC1_GROUP_ADDR
+#define WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MAX_QUOTA_MASK         0x1FFF0000                // LMAC1_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MAX_QUOTA_SHFT         16
+#define WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MIN_QUOTA_ADDR         WF_PSE_TOP_PG_LMAC1_GROUP_ADDR
+#define WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MIN_QUOTA_MASK         0x00001FFF                // LMAC1_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MIN_QUOTA_SHFT         0
+
+#define WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MAX_QUOTA_ADDR         WF_PSE_TOP_PG_LMAC2_GROUP_ADDR
+#define WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MAX_QUOTA_MASK         0x1FFF0000                // LMAC2_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MAX_QUOTA_SHFT         16
+#define WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MIN_QUOTA_ADDR         WF_PSE_TOP_PG_LMAC2_GROUP_ADDR
+#define WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MIN_QUOTA_MASK         0x00001FFF                // LMAC2_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MIN_QUOTA_SHFT         0
+
+#define WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MAX_QUOTA_ADDR         WF_PSE_TOP_PG_LMAC3_GROUP_ADDR
+#define WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MAX_QUOTA_MASK         0x1FFF0000                // LMAC3_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MAX_QUOTA_SHFT         16
+#define WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MIN_QUOTA_ADDR         WF_PSE_TOP_PG_LMAC3_GROUP_ADDR
+#define WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MIN_QUOTA_MASK         0x00001FFF                // LMAC3_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MIN_QUOTA_SHFT         0
+
+#define WF_PSE_TOP_PG_MDP_GROUP_MDP_MAX_QUOTA_ADDR             WF_PSE_TOP_PG_MDP_GROUP_ADDR
+#define WF_PSE_TOP_PG_MDP_GROUP_MDP_MAX_QUOTA_MASK             0x1FFF0000                // MDP_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_MDP_GROUP_MDP_MAX_QUOTA_SHFT             16
+#define WF_PSE_TOP_PG_MDP_GROUP_MDP_MIN_QUOTA_ADDR             WF_PSE_TOP_PG_MDP_GROUP_ADDR
+#define WF_PSE_TOP_PG_MDP_GROUP_MDP_MIN_QUOTA_MASK             0x00001FFF                // MDP_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_MDP_GROUP_MDP_MIN_QUOTA_SHFT             0
+
+#define WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MAX_QUOTA_ADDR           WF_PSE_TOP_PG_MDP2_GROUP_ADDR
+#define WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MAX_QUOTA_MASK           0x1FFF0000                // MDP2_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MAX_QUOTA_SHFT           16
+#define WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MIN_QUOTA_ADDR           WF_PSE_TOP_PG_MDP2_GROUP_ADDR
+#define WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MIN_QUOTA_MASK           0x00001FFF                // MDP2_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MIN_QUOTA_SHFT           0
+
+#define WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MAX_QUOTA_ADDR           WF_PSE_TOP_PG_HIF2_GROUP_ADDR
+#define WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MAX_QUOTA_MASK           0x1FFF0000                // HIF2_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MAX_QUOTA_SHFT           16
+#define WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MIN_QUOTA_ADDR           WF_PSE_TOP_PG_HIF2_GROUP_ADDR
+#define WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MIN_QUOTA_MASK           0x00001FFF                // HIF2_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MIN_QUOTA_SHFT           0
+
+#define WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MAX_QUOTA_ADDR           WF_PSE_TOP_PG_MDP3_GROUP_ADDR
+#define WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MAX_QUOTA_MASK           0x1FFF0000                // MDP3_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MAX_QUOTA_SHFT           16
+#define WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MIN_QUOTA_ADDR           WF_PSE_TOP_PG_MDP3_GROUP_ADDR
+#define WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MIN_QUOTA_MASK           0x00001FFF                // MDP3_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MIN_QUOTA_SHFT           0
+
+#define WF_PSE_TOP_HIF0_PG_INFO_HIF0_SRC_CNT_ADDR              WF_PSE_TOP_HIF0_PG_INFO_ADDR
+#define WF_PSE_TOP_HIF0_PG_INFO_HIF0_SRC_CNT_MASK              0x1FFF0000                // HIF0_SRC_CNT[28..16]
+#define WF_PSE_TOP_HIF0_PG_INFO_HIF0_SRC_CNT_SHFT              16
+#define WF_PSE_TOP_HIF0_PG_INFO_HIF0_RSV_CNT_ADDR              WF_PSE_TOP_HIF0_PG_INFO_ADDR
+#define WF_PSE_TOP_HIF0_PG_INFO_HIF0_RSV_CNT_MASK              0x00001FFF                // HIF0_RSV_CNT[12..0]
+#define WF_PSE_TOP_HIF0_PG_INFO_HIF0_RSV_CNT_SHFT              0
+
+#define WF_PSE_TOP_HIF1_PG_INFO_HIF1_SRC_CNT_ADDR              WF_PSE_TOP_HIF1_PG_INFO_ADDR
+#define WF_PSE_TOP_HIF1_PG_INFO_HIF1_SRC_CNT_MASK              0x1FFF0000                // HIF1_SRC_CNT[28..16]
+#define WF_PSE_TOP_HIF1_PG_INFO_HIF1_SRC_CNT_SHFT              16
+#define WF_PSE_TOP_HIF1_PG_INFO_HIF1_RSV_CNT_ADDR              WF_PSE_TOP_HIF1_PG_INFO_ADDR
+#define WF_PSE_TOP_HIF1_PG_INFO_HIF1_RSV_CNT_MASK              0x00001FFF                // HIF1_RSV_CNT[12..0]
+#define WF_PSE_TOP_HIF1_PG_INFO_HIF1_RSV_CNT_SHFT              0
+
+#define WF_PSE_TOP_CPU_PG_INFO_CPU_SRC_CNT_ADDR                WF_PSE_TOP_CPU_PG_INFO_ADDR
+#define WF_PSE_TOP_CPU_PG_INFO_CPU_SRC_CNT_MASK                0x1FFF0000                // CPU_SRC_CNT[28..16]
+#define WF_PSE_TOP_CPU_PG_INFO_CPU_SRC_CNT_SHFT                16
+#define WF_PSE_TOP_CPU_PG_INFO_CPU_RSV_CNT_ADDR                WF_PSE_TOP_CPU_PG_INFO_ADDR
+#define WF_PSE_TOP_CPU_PG_INFO_CPU_RSV_CNT_MASK                0x00001FFF                // CPU_RSV_CNT[12..0]
+#define WF_PSE_TOP_CPU_PG_INFO_CPU_RSV_CNT_SHFT                0
+
+#define WF_PSE_TOP_PLE_PG_INFO_PLE_SRC_CNT_ADDR                WF_PSE_TOP_PLE_PG_INFO_ADDR
+#define WF_PSE_TOP_PLE_PG_INFO_PLE_SRC_CNT_MASK                0x1FFF0000                // PLE_SRC_CNT[28..16]
+#define WF_PSE_TOP_PLE_PG_INFO_PLE_SRC_CNT_SHFT                16
+#define WF_PSE_TOP_PLE_PG_INFO_PLE_RSV_CNT_ADDR                WF_PSE_TOP_PLE_PG_INFO_ADDR
+#define WF_PSE_TOP_PLE_PG_INFO_PLE_RSV_CNT_MASK                0x00001FFF                // PLE_RSV_CNT[12..0]
+#define WF_PSE_TOP_PLE_PG_INFO_PLE_RSV_CNT_SHFT                0
+
+#define WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_SRC_CNT_ADDR            WF_PSE_TOP_LMAC0_PG_INFO_ADDR
+#define WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_SRC_CNT_MASK            0x1FFF0000                // LMAC0_SRC_CNT[28..16]
+#define WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_SRC_CNT_SHFT            16
+#define WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_RSV_CNT_ADDR            WF_PSE_TOP_LMAC0_PG_INFO_ADDR
+#define WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_RSV_CNT_MASK            0x00001FFF                // LMAC0_RSV_CNT[12..0]
+#define WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_RSV_CNT_SHFT            0
+
+#define WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_SRC_CNT_ADDR            WF_PSE_TOP_LMAC1_PG_INFO_ADDR
+#define WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_SRC_CNT_MASK            0x1FFF0000                // LMAC1_SRC_CNT[28..16]
+#define WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_SRC_CNT_SHFT            16
+#define WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_RSV_CNT_ADDR            WF_PSE_TOP_LMAC1_PG_INFO_ADDR
+#define WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_RSV_CNT_MASK            0x00001FFF                // LMAC1_RSV_CNT[12..0]
+#define WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_RSV_CNT_SHFT            0
+
+#define WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_SRC_CNT_ADDR            WF_PSE_TOP_LMAC2_PG_INFO_ADDR
+#define WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_SRC_CNT_MASK            0x1FFF0000                // LMAC2_SRC_CNT[28..16]
+#define WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_SRC_CNT_SHFT            16
+#define WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_RSV_CNT_ADDR            WF_PSE_TOP_LMAC2_PG_INFO_ADDR
+#define WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_RSV_CNT_MASK            0x00001FFF                // LMAC2_RSV_CNT[12..0]
+#define WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_RSV_CNT_SHFT            0
+
+#define WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_SRC_CNT_ADDR            WF_PSE_TOP_LMAC3_PG_INFO_ADDR
+#define WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_SRC_CNT_MASK            0x1FFF0000                // LMAC3_SRC_CNT[28..16]
+#define WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_SRC_CNT_SHFT            16
+#define WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_RSV_CNT_ADDR            WF_PSE_TOP_LMAC3_PG_INFO_ADDR
+#define WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_RSV_CNT_MASK            0x00001FFF                // LMAC3_RSV_CNT[12..0]
+#define WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_RSV_CNT_SHFT            0
+
+#define WF_PSE_TOP_MDP_PG_INFO_MDP_SRC_CNT_ADDR                WF_PSE_TOP_MDP_PG_INFO_ADDR
+#define WF_PSE_TOP_MDP_PG_INFO_MDP_SRC_CNT_MASK                0x1FFF0000                // MDP_SRC_CNT[28..16]
+#define WF_PSE_TOP_MDP_PG_INFO_MDP_SRC_CNT_SHFT                16
+#define WF_PSE_TOP_MDP_PG_INFO_MDP_RSV_CNT_ADDR                WF_PSE_TOP_MDP_PG_INFO_ADDR
+#define WF_PSE_TOP_MDP_PG_INFO_MDP_RSV_CNT_MASK                0x00001FFF                // MDP_RSV_CNT[12..0]
+#define WF_PSE_TOP_MDP_PG_INFO_MDP_RSV_CNT_SHFT                0
+
+#define WF_PSE_TOP_MDP2_PG_INFO_MDP2_SRC_CNT_ADDR              WF_PSE_TOP_MDP2_PG_INFO_ADDR
+#define WF_PSE_TOP_MDP2_PG_INFO_MDP2_SRC_CNT_MASK              0x1FFF0000                // MDP2_SRC_CNT[28..16]
+#define WF_PSE_TOP_MDP2_PG_INFO_MDP2_SRC_CNT_SHFT              16
+#define WF_PSE_TOP_MDP2_PG_INFO_MDP2_RSV_CNT_ADDR              WF_PSE_TOP_MDP2_PG_INFO_ADDR
+#define WF_PSE_TOP_MDP2_PG_INFO_MDP2_RSV_CNT_MASK              0x00001FFF                // MDP2_RSV_CNT[12..0]
+#define WF_PSE_TOP_MDP2_PG_INFO_MDP2_RSV_CNT_SHFT              0
+
+#define WF_PSE_TOP_HIF2_PG_INFO_HIF2_SRC_CNT_ADDR              WF_PSE_TOP_HIF2_PG_INFO_ADDR
+#define WF_PSE_TOP_HIF2_PG_INFO_HIF2_SRC_CNT_MASK              0x1FFF0000                // HIF2_SRC_CNT[28..16]
+#define WF_PSE_TOP_HIF2_PG_INFO_HIF2_SRC_CNT_SHFT              16
+#define WF_PSE_TOP_HIF2_PG_INFO_HIF2_RSV_CNT_ADDR              WF_PSE_TOP_HIF2_PG_INFO_ADDR
+#define WF_PSE_TOP_HIF2_PG_INFO_HIF2_RSV_CNT_MASK              0x00001FFF                // HIF2_RSV_CNT[12..0]
+#define WF_PSE_TOP_HIF2_PG_INFO_HIF2_RSV_CNT_SHFT              0
+
+#define WF_PSE_TOP_MDP3_PG_INFO_MDP3_SRC_CNT_ADDR              WF_PSE_TOP_MDP3_PG_INFO_ADDR
+#define WF_PSE_TOP_MDP3_PG_INFO_MDP3_SRC_CNT_MASK              0x1FFF0000                // MDP3_SRC_CNT[28..16]
+#define WF_PSE_TOP_MDP3_PG_INFO_MDP3_SRC_CNT_SHFT              16
+#define WF_PSE_TOP_MDP3_PG_INFO_MDP3_RSV_CNT_ADDR              WF_PSE_TOP_MDP3_PG_INFO_ADDR
+#define WF_PSE_TOP_MDP3_PG_INFO_MDP3_RSV_CNT_MASK              0x00001FFF                // MDP3_RSV_CNT[12..0]
+#define WF_PSE_TOP_MDP3_PG_INFO_MDP3_RSV_CNT_SHFT              0
+
+#define WF_PSE_TOP_FL_QUE_CTRL_0_EXECUTE_ADDR                  WF_PSE_TOP_FL_QUE_CTRL_0_ADDR
+#define WF_PSE_TOP_FL_QUE_CTRL_0_EXECUTE_MASK                  0x80000000                // EXECUTE[31]
+#define WF_PSE_TOP_FL_QUE_CTRL_0_EXECUTE_SHFT                  31
+#define WF_PSE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_ADDR                WF_PSE_TOP_FL_QUE_CTRL_0_ADDR
+#define WF_PSE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_MASK                0x7F000000                // Q_BUF_QID[30..24]
+#define WF_PSE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_SHFT                24
+#define WF_PSE_TOP_FL_QUE_CTRL_0_Q_BUF_PID_SHFT                16
+
+#define WF_PSE_TOP_FL_QUE_CTRL_1_Q_BUF_PID_ADDR                WF_PSE_TOP_FL_QUE_CTRL_1_ADDR
+#define WF_PSE_TOP_FL_QUE_CTRL_1_Q_BUF_PID_MASK                0x30000000                // Q_BUF_PID[29..28]
+#define WF_PSE_TOP_FL_QUE_CTRL_1_Q_BUF_PID_SHFT                28
+
+#define WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_ADDR           WF_PSE_TOP_FL_QUE_CTRL_2_ADDR
+#define WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_MASK           0x1FFF0000                // QUEUE_TAIL_FID[28..16]
+#define WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_SHFT           16
+#define WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_ADDR           WF_PSE_TOP_FL_QUE_CTRL_2_ADDR
+#define WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_MASK           0x00001FFF                // QUEUE_HEAD_FID[12..0]
+#define WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_SHFT           0
+
+#define WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PAGE_NUM_ADDR           WF_PSE_TOP_FL_QUE_CTRL_3_ADDR
+#define WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PAGE_NUM_MASK           0x00FFF000                // QUEUE_PAGE_NUM[23..12]
+#define WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PAGE_NUM_SHFT           12
+#define WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_ADDR            WF_PSE_TOP_FL_QUE_CTRL_3_ADDR
+#define WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_MASK            0x00001FFF                // QUEUE_PKT_NUM[12..0]
+#define WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_SHFT            0
+
+#define WF_PSE_TOP_FREEPG_CNT_FFA_CNT_ADDR                     WF_PSE_TOP_FREEPG_CNT_ADDR
+#define WF_PSE_TOP_FREEPG_CNT_FFA_CNT_MASK                     0x1FFF0000                // FFA_CNT[28..16]
+#define WF_PSE_TOP_FREEPG_CNT_FFA_CNT_SHFT                     16
+#define WF_PSE_TOP_FREEPG_CNT_FREEPG_CNT_ADDR                  WF_PSE_TOP_FREEPG_CNT_ADDR
+#define WF_PSE_TOP_FREEPG_CNT_FREEPG_CNT_MASK                  0x00001FFF                // FREEPG_CNT[12..0]
+#define WF_PSE_TOP_FREEPG_CNT_FREEPG_CNT_SHFT                  0
+
+#define WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_TAIL_ADDR           WF_PSE_TOP_FREEPG_HEAD_TAIL_ADDR
+#define WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_TAIL_MASK           0x1FFF0000                // FREEPG_TAIL[28..16]
+#define WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_TAIL_SHFT           16
+#define WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_HEAD_ADDR           WF_PSE_TOP_FREEPG_HEAD_TAIL_ADDR
+#define WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_HEAD_MASK           0x00001FFF                // FREEPG_HEAD[12..0]
+#define WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_HEAD_SHFT           0
+
+/* RXD */
+enum {
+	BMAC_GROUP_VLD_1 = 0x01,
+	BMAC_GROUP_VLD_2 = 0x02,
+	BMAC_GROUP_VLD_3 = 0x04,
+	BMAC_GROUP_VLD_4 = 0x08,
+	BMAC_GROUP_VLD_5 = 0x10,
+};
+
+#endif
diff --git a/mt7996/mtk_debug_i.h b/mt7996/mtk_debug_i.h
new file mode 100644
index 00000000..01023e16
--- /dev/null
+++ b/mt7996/mtk_debug_i.h
@@ -0,0 +1,1019 @@
+#ifndef __MTK_DEBUG_I_H
+#define __MTK_DEBUG_I_H
+
+#ifdef CONFIG_MTK_DEBUG
+
+// DW0
+#define WF_RX_DESCRIPTOR_RX_BYTE_COUNT_DW                                   0
+#define WF_RX_DESCRIPTOR_RX_BYTE_COUNT_ADDR                                 0
+#define WF_RX_DESCRIPTOR_RX_BYTE_COUNT_MASK                                 0x0000ffff // 15- 0
+#define WF_RX_DESCRIPTOR_RX_BYTE_COUNT_SHIFT                                0
+#define WF_RX_DESCRIPTOR_PACKET_TYPE_DW                                     0
+#define WF_RX_DESCRIPTOR_PACKET_TYPE_ADDR                                   0
+#define WF_RX_DESCRIPTOR_PACKET_TYPE_MASK                                   0xf8000000 // 31-27
+#define WF_RX_DESCRIPTOR_PACKET_TYPE_SHIFT                                  27
+// DW1
+#define WF_RX_DESCRIPTOR_MLD_ID_DW                                          1
+#define WF_RX_DESCRIPTOR_MLD_ID_ADDR                                        4
+#define WF_RX_DESCRIPTOR_MLD_ID_MASK                                        0x00000fff // 11- 0
+#define WF_RX_DESCRIPTOR_MLD_ID_SHIFT                                       0
+#define WF_RX_DESCRIPTOR_GROUP_VLD_DW                                       1
+#define WF_RX_DESCRIPTOR_GROUP_VLD_ADDR                                     4
+#define WF_RX_DESCRIPTOR_GROUP_VLD_MASK                                     0x001f0000 // 20-16
+#define WF_RX_DESCRIPTOR_GROUP_VLD_SHIFT                                    16
+#define WF_RX_DESCRIPTOR_KID_DW                                             1
+#define WF_RX_DESCRIPTOR_KID_ADDR                                           4
+#define WF_RX_DESCRIPTOR_KID_MASK                                           0x00600000 // 22-21
+#define WF_RX_DESCRIPTOR_KID_SHIFT                                          21
+#define WF_RX_DESCRIPTOR_CM_DW                                              1
+#define WF_RX_DESCRIPTOR_CM_ADDR                                            4
+#define WF_RX_DESCRIPTOR_CM_MASK                                            0x00800000 // 23-23
+#define WF_RX_DESCRIPTOR_CM_SHIFT                                           23
+#define WF_RX_DESCRIPTOR_CLM_DW                                             1
+#define WF_RX_DESCRIPTOR_CLM_ADDR                                           4
+#define WF_RX_DESCRIPTOR_CLM_MASK                                           0x01000000 // 24-24
+#define WF_RX_DESCRIPTOR_CLM_SHIFT                                          24
+#define WF_RX_DESCRIPTOR_I_DW                                               1
+#define WF_RX_DESCRIPTOR_I_ADDR                                             4
+#define WF_RX_DESCRIPTOR_I_MASK                                             0x02000000 // 25-25
+#define WF_RX_DESCRIPTOR_I_SHIFT                                            25
+#define WF_RX_DESCRIPTOR_T_DW                                               1
+#define WF_RX_DESCRIPTOR_T_ADDR                                             4
+#define WF_RX_DESCRIPTOR_T_MASK                                             0x04000000 // 26-26
+#define WF_RX_DESCRIPTOR_T_SHIFT                                            26
+#define WF_RX_DESCRIPTOR_BN_DW                                              1
+#define WF_RX_DESCRIPTOR_BN_ADDR                                            4
+#define WF_RX_DESCRIPTOR_BN_MASK                                            0x18000000 // 28-27
+#define WF_RX_DESCRIPTOR_BN_SHIFT                                           27
+#define WF_RX_DESCRIPTOR_BIPN_FAIL_DW                                       1
+#define WF_RX_DESCRIPTOR_BIPN_FAIL_ADDR                                     4
+#define WF_RX_DESCRIPTOR_BIPN_FAIL_MASK                                     0x20000000 // 29-29
+#define WF_RX_DESCRIPTOR_BIPN_FAIL_SHIFT                                    29
+// DW2
+#define WF_RX_DESCRIPTOR_BSSID_DW                                           2
+#define WF_RX_DESCRIPTOR_BSSID_ADDR                                         8
+#define WF_RX_DESCRIPTOR_BSSID_MASK                                         0x0000003f //  5- 0
+#define WF_RX_DESCRIPTOR_BSSID_SHIFT                                        0
+#define WF_RX_DESCRIPTOR_H_DW                                               2
+#define WF_RX_DESCRIPTOR_H_ADDR                                             8
+#define WF_RX_DESCRIPTOR_H_MASK                                             0x00000080 //  7- 7
+#define WF_RX_DESCRIPTOR_H_SHIFT                                            7
+#define WF_RX_DESCRIPTOR_HEADER_LENGTH_DW                                   2
+#define WF_RX_DESCRIPTOR_HEADER_LENGTH_ADDR                                 8
+#define WF_RX_DESCRIPTOR_HEADER_LENGTH_MASK                                 0x00001f00 // 12- 8
+#define WF_RX_DESCRIPTOR_HEADER_LENGTH_SHIFT                                8
+#define WF_RX_DESCRIPTOR_HO_DW                                              2
+#define WF_RX_DESCRIPTOR_HO_ADDR                                            8
+#define WF_RX_DESCRIPTOR_HO_MASK                                            0x0000e000 // 15-13
+#define WF_RX_DESCRIPTOR_HO_SHIFT                                           13
+#define WF_RX_DESCRIPTOR_SEC_MODE_DW                                        2
+#define WF_RX_DESCRIPTOR_SEC_MODE_ADDR                                      8
+#define WF_RX_DESCRIPTOR_SEC_MODE_MASK                                      0x001f0000 // 20-16
+#define WF_RX_DESCRIPTOR_SEC_MODE_SHIFT                                     16
+#define WF_RX_DESCRIPTOR_MUBAR_DW                                           2
+#define WF_RX_DESCRIPTOR_MUBAR_ADDR                                         8
+#define WF_RX_DESCRIPTOR_MUBAR_MASK                                         0x00200000 // 21-21
+#define WF_RX_DESCRIPTOR_MUBAR_SHIFT                                        21
+#define WF_RX_DESCRIPTOR_SWBIT_DW                                           2
+#define WF_RX_DESCRIPTOR_SWBIT_ADDR                                         8
+#define WF_RX_DESCRIPTOR_SWBIT_MASK                                         0x00400000 // 22-22
+#define WF_RX_DESCRIPTOR_SWBIT_SHIFT                                        22
+#define WF_RX_DESCRIPTOR_DAF_DW                                             2
+#define WF_RX_DESCRIPTOR_DAF_ADDR                                           8
+#define WF_RX_DESCRIPTOR_DAF_MASK                                           0x00800000 // 23-23
+#define WF_RX_DESCRIPTOR_DAF_SHIFT                                          23
+#define WF_RX_DESCRIPTOR_EL_DW                                              2
+#define WF_RX_DESCRIPTOR_EL_ADDR                                            8
+#define WF_RX_DESCRIPTOR_EL_MASK                                            0x01000000 // 24-24
+#define WF_RX_DESCRIPTOR_EL_SHIFT                                           24
+#define WF_RX_DESCRIPTOR_HTF_DW                                             2
+#define WF_RX_DESCRIPTOR_HTF_ADDR                                           8
+#define WF_RX_DESCRIPTOR_HTF_MASK                                           0x02000000 // 25-25
+#define WF_RX_DESCRIPTOR_HTF_SHIFT                                          25
+#define WF_RX_DESCRIPTOR_INTF_DW                                            2
+#define WF_RX_DESCRIPTOR_INTF_ADDR                                          8
+#define WF_RX_DESCRIPTOR_INTF_MASK                                          0x04000000 // 26-26
+#define WF_RX_DESCRIPTOR_INTF_SHIFT                                         26
+#define WF_RX_DESCRIPTOR_FRAG_DW                                            2
+#define WF_RX_DESCRIPTOR_FRAG_ADDR                                          8
+#define WF_RX_DESCRIPTOR_FRAG_MASK                                          0x08000000 // 27-27
+#define WF_RX_DESCRIPTOR_FRAG_SHIFT                                         27
+#define WF_RX_DESCRIPTOR_NUL_DW                                             2
+#define WF_RX_DESCRIPTOR_NUL_ADDR                                           8
+#define WF_RX_DESCRIPTOR_NUL_MASK                                           0x10000000 // 28-28
+#define WF_RX_DESCRIPTOR_NUL_SHIFT                                          28
+#define WF_RX_DESCRIPTOR_NDATA_DW                                           2
+#define WF_RX_DESCRIPTOR_NDATA_ADDR                                         8
+#define WF_RX_DESCRIPTOR_NDATA_MASK                                         0x20000000 // 29-29
+#define WF_RX_DESCRIPTOR_NDATA_SHIFT                                        29
+#define WF_RX_DESCRIPTOR_NAMP_DW                                            2
+#define WF_RX_DESCRIPTOR_NAMP_ADDR                                          8
+#define WF_RX_DESCRIPTOR_NAMP_MASK                                          0x40000000 // 30-30
+#define WF_RX_DESCRIPTOR_NAMP_SHIFT                                         30
+#define WF_RX_DESCRIPTOR_BF_RPT_DW                                          2
+#define WF_RX_DESCRIPTOR_BF_RPT_ADDR                                        8
+#define WF_RX_DESCRIPTOR_BF_RPT_MASK                                        0x80000000 // 31-31
+#define WF_RX_DESCRIPTOR_BF_RPT_SHIFT                                       31
+// DW3
+#define WF_RX_DESCRIPTOR_RXV_SN_DW                                          3
+#define WF_RX_DESCRIPTOR_RXV_SN_ADDR                                        12
+#define WF_RX_DESCRIPTOR_RXV_SN_MASK                                        0x000000ff //  7- 0
+#define WF_RX_DESCRIPTOR_RXV_SN_SHIFT                                       0
+#define WF_RX_DESCRIPTOR_CH_FREQUENCY_DW                                    3
+#define WF_RX_DESCRIPTOR_CH_FREQUENCY_ADDR                                  12
+#define WF_RX_DESCRIPTOR_CH_FREQUENCY_MASK                                  0x0000ff00 // 15- 8
+#define WF_RX_DESCRIPTOR_CH_FREQUENCY_SHIFT                                 8
+#define WF_RX_DESCRIPTOR_A1_TYPE_DW                                         3
+#define WF_RX_DESCRIPTOR_A1_TYPE_ADDR                                       12
+#define WF_RX_DESCRIPTOR_A1_TYPE_MASK                                       0x00030000 // 17-16
+#define WF_RX_DESCRIPTOR_A1_TYPE_SHIFT                                      16
+#define WF_RX_DESCRIPTOR_HTC_DW                                             3
+#define WF_RX_DESCRIPTOR_HTC_ADDR                                           12
+#define WF_RX_DESCRIPTOR_HTC_MASK                                           0x00040000 // 18-18
+#define WF_RX_DESCRIPTOR_HTC_SHIFT                                          18
+#define WF_RX_DESCRIPTOR_TCL_DW                                             3
+#define WF_RX_DESCRIPTOR_TCL_ADDR                                           12
+#define WF_RX_DESCRIPTOR_TCL_MASK                                           0x00080000 // 19-19
+#define WF_RX_DESCRIPTOR_TCL_SHIFT                                          19
+#define WF_RX_DESCRIPTOR_BBM_DW                                             3
+#define WF_RX_DESCRIPTOR_BBM_ADDR                                           12
+#define WF_RX_DESCRIPTOR_BBM_MASK                                           0x00100000 // 20-20
+#define WF_RX_DESCRIPTOR_BBM_SHIFT                                          20
+#define WF_RX_DESCRIPTOR_BU_DW                                              3
+#define WF_RX_DESCRIPTOR_BU_ADDR                                            12
+#define WF_RX_DESCRIPTOR_BU_MASK                                            0x00200000 // 21-21
+#define WF_RX_DESCRIPTOR_BU_SHIFT                                           21
+#define WF_RX_DESCRIPTOR_CO_ANT_DW                                          3
+#define WF_RX_DESCRIPTOR_CO_ANT_ADDR                                        12
+#define WF_RX_DESCRIPTOR_CO_ANT_MASK                                        0x00400000 // 22-22
+#define WF_RX_DESCRIPTOR_CO_ANT_SHIFT                                       22
+#define WF_RX_DESCRIPTOR_BF_CQI_DW                                          3
+#define WF_RX_DESCRIPTOR_BF_CQI_ADDR                                        12
+#define WF_RX_DESCRIPTOR_BF_CQI_MASK                                        0x00800000 // 23-23
+#define WF_RX_DESCRIPTOR_BF_CQI_SHIFT                                       23
+#define WF_RX_DESCRIPTOR_FC_DW                                              3
+#define WF_RX_DESCRIPTOR_FC_ADDR                                            12
+#define WF_RX_DESCRIPTOR_FC_MASK                                            0x01000000 // 24-24
+#define WF_RX_DESCRIPTOR_FC_SHIFT                                           24
+#define WF_RX_DESCRIPTOR_VLAN_DW                                            3
+#define WF_RX_DESCRIPTOR_VLAN_ADDR                                          12
+#define WF_RX_DESCRIPTOR_VLAN_MASK                                          0x80000000 // 31-31
+#define WF_RX_DESCRIPTOR_VLAN_SHIFT                                         31
+// DW4
+#define WF_RX_DESCRIPTOR_PF_DW                                              4
+#define WF_RX_DESCRIPTOR_PF_ADDR                                            16
+#define WF_RX_DESCRIPTOR_PF_MASK                                            0x00000003 //  1- 0
+#define WF_RX_DESCRIPTOR_PF_SHIFT                                           0
+#define WF_RX_DESCRIPTOR_MAC_DW                                             4
+#define WF_RX_DESCRIPTOR_MAC_ADDR                                           16
+#define WF_RX_DESCRIPTOR_MAC_MASK                                           0x00000004 //  2- 2
+#define WF_RX_DESCRIPTOR_MAC_SHIFT                                          2
+#define WF_RX_DESCRIPTOR_TID_DW                                             4
+#define WF_RX_DESCRIPTOR_TID_ADDR                                           16
+#define WF_RX_DESCRIPTOR_TID_MASK                                           0x00000078 //  6- 3
+#define WF_RX_DESCRIPTOR_TID_SHIFT                                          3
+#define WF_RX_DESCRIPTOR_ETHER_TYPE_OFFSET_DW                               4
+#define WF_RX_DESCRIPTOR_ETHER_TYPE_OFFSET_ADDR                             16
+#define WF_RX_DESCRIPTOR_ETHER_TYPE_OFFSET_MASK                             0x00003f80 // 13- 7
+#define WF_RX_DESCRIPTOR_ETHER_TYPE_OFFSET_SHIFT                            7
+#define WF_RX_DESCRIPTOR_IP_DW                                              4
+#define WF_RX_DESCRIPTOR_IP_ADDR                                            16
+#define WF_RX_DESCRIPTOR_IP_MASK                                            0x00004000 // 14-14
+#define WF_RX_DESCRIPTOR_IP_SHIFT                                           14
+#define WF_RX_DESCRIPTOR_UT_DW                                              4
+#define WF_RX_DESCRIPTOR_UT_ADDR                                            16
+#define WF_RX_DESCRIPTOR_UT_MASK                                            0x00008000 // 15-15
+#define WF_RX_DESCRIPTOR_UT_SHIFT                                           15
+#define WF_RX_DESCRIPTOR_PSE_FID_DW                                         4
+#define WF_RX_DESCRIPTOR_PSE_FID_ADDR                                       16
+#define WF_RX_DESCRIPTOR_PSE_FID_MASK                                       0x0fff0000 // 27-16
+#define WF_RX_DESCRIPTOR_PSE_FID_SHIFT                                      16
+// DW5
+// DW6
+#define WF_RX_DESCRIPTOR_CLS_BITMAP_31_0__DW                                6
+#define WF_RX_DESCRIPTOR_CLS_BITMAP_31_0__ADDR                              24
+#define WF_RX_DESCRIPTOR_CLS_BITMAP_31_0__MASK                              0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_CLS_BITMAP_31_0__SHIFT                             0
+// DW7
+#define WF_RX_DESCRIPTOR_CLS_BITMAP_33_32__DW                               7
+#define WF_RX_DESCRIPTOR_CLS_BITMAP_33_32__ADDR                             28
+#define WF_RX_DESCRIPTOR_CLS_BITMAP_33_32__MASK                             0x00000003 //  1- 0
+#define WF_RX_DESCRIPTOR_CLS_BITMAP_33_32__SHIFT                            0
+#define WF_RX_DESCRIPTOR_DP_DW                                              7
+#define WF_RX_DESCRIPTOR_DP_ADDR                                            28
+#define WF_RX_DESCRIPTOR_DP_MASK                                            0x00080000 // 19-19
+#define WF_RX_DESCRIPTOR_DP_SHIFT                                           19
+#define WF_RX_DESCRIPTOR_CLS_DW                                             7
+#define WF_RX_DESCRIPTOR_CLS_ADDR                                           28
+#define WF_RX_DESCRIPTOR_CLS_MASK                                           0x00100000 // 20-20
+#define WF_RX_DESCRIPTOR_CLS_SHIFT                                          20
+#define WF_RX_DESCRIPTOR_OFLD_DW                                            7
+#define WF_RX_DESCRIPTOR_OFLD_ADDR                                          28
+#define WF_RX_DESCRIPTOR_OFLD_MASK                                          0x00600000 // 22-21
+#define WF_RX_DESCRIPTOR_OFLD_SHIFT                                         21
+#define WF_RX_DESCRIPTOR_MGC_DW                                             7
+#define WF_RX_DESCRIPTOR_MGC_ADDR                                           28
+#define WF_RX_DESCRIPTOR_MGC_MASK                                           0x00800000 // 23-23
+#define WF_RX_DESCRIPTOR_MGC_SHIFT                                          23
+#define WF_RX_DESCRIPTOR_WOL_DW                                             7
+#define WF_RX_DESCRIPTOR_WOL_ADDR                                           28
+#define WF_RX_DESCRIPTOR_WOL_MASK                                           0x1f000000 // 28-24
+#define WF_RX_DESCRIPTOR_WOL_SHIFT                                          24
+#define WF_RX_DESCRIPTOR_PF_MODE_DW                                         7
+#define WF_RX_DESCRIPTOR_PF_MODE_ADDR                                       28
+#define WF_RX_DESCRIPTOR_PF_MODE_MASK                                       0x20000000 // 29-29
+#define WF_RX_DESCRIPTOR_PF_MODE_SHIFT                                      29
+#define WF_RX_DESCRIPTOR_PF_STS_DW                                          7
+#define WF_RX_DESCRIPTOR_PF_STS_ADDR                                        28
+#define WF_RX_DESCRIPTOR_PF_STS_MASK                                        0xc0000000 // 31-30
+#define WF_RX_DESCRIPTOR_PF_STS_SHIFT                                       30
+// DW8
+#define WF_RX_DESCRIPTOR_FRAME_CONTROL_FIELD_DW                             8
+#define WF_RX_DESCRIPTOR_FRAME_CONTROL_FIELD_ADDR                           32
+#define WF_RX_DESCRIPTOR_FRAME_CONTROL_FIELD_MASK                           0x0000ffff // 15- 0
+#define WF_RX_DESCRIPTOR_FRAME_CONTROL_FIELD_SHIFT                          0
+#define WF_RX_DESCRIPTOR_PEER_MLD_ADDRESS_15_0__DW                          8
+#define WF_RX_DESCRIPTOR_PEER_MLD_ADDRESS_15_0__ADDR                        32
+#define WF_RX_DESCRIPTOR_PEER_MLD_ADDRESS_15_0__MASK                        0xffff0000 // 31-16
+#define WF_RX_DESCRIPTOR_PEER_MLD_ADDRESS_15_0__SHIFT                       16
+// DW9
+#define WF_RX_DESCRIPTOR_PEER_MLD_ADDRESS_47_16__DW                         9
+#define WF_RX_DESCRIPTOR_PEER_MLD_ADDRESS_47_16__ADDR                       36
+#define WF_RX_DESCRIPTOR_PEER_MLD_ADDRESS_47_16__MASK                       0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_PEER_MLD_ADDRESS_47_16__SHIFT                      0
+// DW10
+#define WF_RX_DESCRIPTOR_FRAGMENT_NUMBER_DW                                 10
+#define WF_RX_DESCRIPTOR_FRAGMENT_NUMBER_ADDR                               40
+#define WF_RX_DESCRIPTOR_FRAGMENT_NUMBER_MASK                               0x0000000f //  3- 0
+#define WF_RX_DESCRIPTOR_FRAGMENT_NUMBER_SHIFT                              0
+#define WF_RX_DESCRIPTOR_SEQUENCE_NUMBER_DW                                 10
+#define WF_RX_DESCRIPTOR_SEQUENCE_NUMBER_ADDR                               40
+#define WF_RX_DESCRIPTOR_SEQUENCE_NUMBER_MASK                               0x0000fff0 // 15- 4
+#define WF_RX_DESCRIPTOR_SEQUENCE_NUMBER_SHIFT                              4
+#define WF_RX_DESCRIPTOR_QOS_CONTROL_FIELD_DW                               10
+#define WF_RX_DESCRIPTOR_QOS_CONTROL_FIELD_ADDR                             40
+#define WF_RX_DESCRIPTOR_QOS_CONTROL_FIELD_MASK                             0xffff0000 // 31-16
+#define WF_RX_DESCRIPTOR_QOS_CONTROL_FIELD_SHIFT                            16
+// DW11
+#define WF_RX_DESCRIPTOR_HT_CONTROL_FIELD_DW                                11
+#define WF_RX_DESCRIPTOR_HT_CONTROL_FIELD_ADDR                              44
+#define WF_RX_DESCRIPTOR_HT_CONTROL_FIELD_MASK                              0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_HT_CONTROL_FIELD_SHIFT                             0
+// DW12
+#define WF_RX_DESCRIPTOR_PN_31_0__DW                                        12
+#define WF_RX_DESCRIPTOR_PN_31_0__ADDR                                      48
+#define WF_RX_DESCRIPTOR_PN_31_0__MASK                                      0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_PN_31_0__SHIFT                                     0
+// DW13
+#define WF_RX_DESCRIPTOR_PN_63_32__DW                                       13
+#define WF_RX_DESCRIPTOR_PN_63_32__ADDR                                     52
+#define WF_RX_DESCRIPTOR_PN_63_32__MASK                                     0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_PN_63_32__SHIFT                                    0
+// DW14
+#define WF_RX_DESCRIPTOR_PN_95_64__DW                                       14
+#define WF_RX_DESCRIPTOR_PN_95_64__ADDR                                     56
+#define WF_RX_DESCRIPTOR_PN_95_64__MASK                                     0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_PN_95_64__SHIFT                                    0
+// DW15
+#define WF_RX_DESCRIPTOR_PN_127_96__DW                                      15
+#define WF_RX_DESCRIPTOR_PN_127_96__ADDR                                    60
+#define WF_RX_DESCRIPTOR_PN_127_96__MASK                                    0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_PN_127_96__SHIFT                                   0
+// DW16
+#define WF_RX_DESCRIPTOR_TIMESTAMP_DW                                       16
+#define WF_RX_DESCRIPTOR_TIMESTAMP_ADDR                                     64
+#define WF_RX_DESCRIPTOR_TIMESTAMP_MASK                                     0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_TIMESTAMP_SHIFT                                    0
+// DW17
+#define WF_RX_DESCRIPTOR_CRC_DW                                             17
+#define WF_RX_DESCRIPTOR_CRC_ADDR                                           68
+#define WF_RX_DESCRIPTOR_CRC_MASK                                           0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_CRC_SHIFT                                          0
+// DW18
+// DW19
+// DW20
+#define WF_RX_DESCRIPTOR_P_RXV_DW                                           20
+#define WF_RX_DESCRIPTOR_P_RXV_ADDR                                         80
+#define WF_RX_DESCRIPTOR_P_RXV_MASK                                         0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_P_RXV_SHIFT                                        0
+// DW21
+// DO NOT process repeat field(p_rxv)
+// DW22
+#define WF_RX_DESCRIPTOR_DBW_DW                                             22
+#define WF_RX_DESCRIPTOR_DBW_ADDR                                           88
+#define WF_RX_DESCRIPTOR_DBW_MASK                                           0x00000007 //  2- 0
+#define WF_RX_DESCRIPTOR_DBW_SHIFT                                          0
+#define WF_RX_DESCRIPTOR_GI_DW                                              22
+#define WF_RX_DESCRIPTOR_GI_ADDR                                            88
+#define WF_RX_DESCRIPTOR_GI_MASK                                            0x00000018 //  4- 3
+#define WF_RX_DESCRIPTOR_GI_SHIFT                                           3
+#define WF_RX_DESCRIPTOR_DCM_DW                                             22
+#define WF_RX_DESCRIPTOR_DCM_ADDR                                           88
+#define WF_RX_DESCRIPTOR_DCM_MASK                                           0x00000020 //  5- 5
+#define WF_RX_DESCRIPTOR_DCM_SHIFT                                          5
+#define WF_RX_DESCRIPTOR_NUM_RX_DW                                          22
+#define WF_RX_DESCRIPTOR_NUM_RX_ADDR                                        88
+#define WF_RX_DESCRIPTOR_NUM_RX_MASK                                        0x000001c0 //  8- 6
+#define WF_RX_DESCRIPTOR_NUM_RX_SHIFT                                       6
+#define WF_RX_DESCRIPTOR_STBC_DW                                            22
+#define WF_RX_DESCRIPTOR_STBC_ADDR                                          88
+#define WF_RX_DESCRIPTOR_STBC_MASK                                          0x00000600 // 10- 9
+#define WF_RX_DESCRIPTOR_STBC_SHIFT                                         9
+#define WF_RX_DESCRIPTOR_TX_MODE_DW                                         22
+#define WF_RX_DESCRIPTOR_TX_MODE_ADDR                                       88
+#define WF_RX_DESCRIPTOR_TX_MODE_MASK                                       0x00007800 // 14-11
+#define WF_RX_DESCRIPTOR_TX_MODE_SHIFT                                      11
+// DW23
+#define WF_RX_DESCRIPTOR_RCPI_DW                                            23
+#define WF_RX_DESCRIPTOR_RCPI_ADDR                                          92
+#define WF_RX_DESCRIPTOR_RCPI_MASK                                          0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_RCPI_SHIFT                                         0
+// DW24
+#define WF_RX_DESCRIPTOR_C_RXV_DW                                           24
+#define WF_RX_DESCRIPTOR_C_RXV_ADDR                                         96
+#define WF_RX_DESCRIPTOR_C_RXV_MASK                                         0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_C_RXV_SHIFT                                        0
+// DW25
+// DO NOT process repeat field(c_rxv)
+// DW26
+// DO NOT process repeat field(c_rxv)
+// DW27
+// DO NOT process repeat field(c_rxv)
+// DW28
+// DO NOT process repeat field(c_rxv)
+// DW29
+// DO NOT process repeat field(c_rxv)
+// DW30
+// DO NOT process repeat field(c_rxv)
+// DW31
+// DO NOT process repeat field(c_rxv)
+// DW32
+// DO NOT process repeat field(c_rxv)
+// DW33
+// DO NOT process repeat field(c_rxv)
+// DW34
+// DO NOT process repeat field(c_rxv)
+// DW35
+// DO NOT process repeat field(c_rxv)
+// DW36
+// DO NOT process repeat field(c_rxv)
+// DW37
+// DO NOT process repeat field(c_rxv)
+// DW38
+// DO NOT process repeat field(c_rxv)
+// DW39
+// DO NOT process repeat field(c_rxv)
+// DW40
+// DO NOT process repeat field(c_rxv)
+// DW41
+// DO NOT process repeat field(c_rxv)
+// DW42
+// DO NOT process repeat field(c_rxv)
+// DW43
+// DO NOT process repeat field(c_rxv)
+// DW44
+// DO NOT process repeat field(c_rxv)
+// DW45
+// DO NOT process repeat field(c_rxv)
+// DW46
+// DW47
+
+/* TXD */
+// DW0
+#define WF_TX_DESCRIPTOR_TX_BYTE_COUNT_DW                                   0
+#define WF_TX_DESCRIPTOR_TX_BYTE_COUNT_ADDR                                 0
+#define WF_TX_DESCRIPTOR_TX_BYTE_COUNT_MASK                                 0x0000ffff // 15- 0
+#define WF_TX_DESCRIPTOR_TX_BYTE_COUNT_SHIFT                                0
+#define WF_TX_DESCRIPTOR_ETHER_TYPE_OFFSET_DW                               0
+#define WF_TX_DESCRIPTOR_ETHER_TYPE_OFFSET_ADDR                             0
+#define WF_TX_DESCRIPTOR_ETHER_TYPE_OFFSET_MASK                             0x007f0000 // 22-16
+#define WF_TX_DESCRIPTOR_ETHER_TYPE_OFFSET_SHIFT                            16
+#define WF_TX_DESCRIPTOR_PKT_FT_DW                                          0
+#define WF_TX_DESCRIPTOR_PKT_FT_ADDR                                        0
+#define WF_TX_DESCRIPTOR_PKT_FT_MASK                                        0x01800000 // 24-23
+#define WF_TX_DESCRIPTOR_PKT_FT_SHIFT                                       23
+#define WF_TX_DESCRIPTOR_Q_IDX_DW                                           0
+#define WF_TX_DESCRIPTOR_Q_IDX_ADDR                                         0
+#define WF_TX_DESCRIPTOR_Q_IDX_MASK                                         0xfe000000 // 31-25
+#define WF_TX_DESCRIPTOR_Q_IDX_SHIFT                                        25
+// DW1
+#define WF_TX_DESCRIPTOR_MLD_ID_DW                                          1
+#define WF_TX_DESCRIPTOR_MLD_ID_ADDR                                        4
+#define WF_TX_DESCRIPTOR_MLD_ID_MASK                                        0x00000fff // 11- 0
+#define WF_TX_DESCRIPTOR_MLD_ID_SHIFT                                       0
+#define WF_TX_DESCRIPTOR_TGID_DW                                            1
+#define WF_TX_DESCRIPTOR_TGID_ADDR                                          4
+#define WF_TX_DESCRIPTOR_TGID_MASK                                          0x00003000 // 13-12
+#define WF_TX_DESCRIPTOR_TGID_SHIFT                                         12
+#define WF_TX_DESCRIPTOR_HF_DW                                              1
+#define WF_TX_DESCRIPTOR_HF_ADDR                                            4
+#define WF_TX_DESCRIPTOR_HF_MASK                                            0x0000c000 // 15-14
+#define WF_TX_DESCRIPTOR_HF_SHIFT                                           14
+#define WF_TX_DESCRIPTOR_HEADER_LENGTH_DW                                   1
+#define WF_TX_DESCRIPTOR_HEADER_LENGTH_ADDR                                 4
+#define WF_TX_DESCRIPTOR_HEADER_LENGTH_MASK                                 0x001f0000 // 20-16
+#define WF_TX_DESCRIPTOR_HEADER_LENGTH_SHIFT                                16
+#define WF_TX_DESCRIPTOR_MRD_DW                                             1
+#define WF_TX_DESCRIPTOR_MRD_ADDR                                           4
+#define WF_TX_DESCRIPTOR_MRD_MASK                                           0x00010000 // 16-16
+#define WF_TX_DESCRIPTOR_MRD_SHIFT                                          16
+#define WF_TX_DESCRIPTOR_EOSP_DW                                            1
+#define WF_TX_DESCRIPTOR_EOSP_ADDR                                          4
+#define WF_TX_DESCRIPTOR_EOSP_MASK                                          0x00020000 // 17-17
+#define WF_TX_DESCRIPTOR_EOSP_SHIFT                                         17
+#define WF_TX_DESCRIPTOR_EOSP_DW                                            1
+#define WF_TX_DESCRIPTOR_EOSP_ADDR                                          4
+#define WF_TX_DESCRIPTOR_EOSP_MASK                                          0x00020000 // 17-17
+#define WF_TX_DESCRIPTOR_EOSP_SHIFT                                         17
+#define WF_TX_DESCRIPTOR_AMS_DW                                             1
+#define WF_TX_DESCRIPTOR_AMS_ADDR                                           4
+#define WF_TX_DESCRIPTOR_AMS_MASK                                           0x00040000 // 18-18
+#define WF_TX_DESCRIPTOR_AMS_SHIFT                                          18
+#define WF_TX_DESCRIPTOR_RMVL_DW                                            1
+#define WF_TX_DESCRIPTOR_RMVL_ADDR                                          4
+#define WF_TX_DESCRIPTOR_RMVL_MASK                                          0x00040000 // 18-18
+#define WF_TX_DESCRIPTOR_RMVL_SHIFT                                         18
+#define WF_TX_DESCRIPTOR_VLAN_DW                                            1
+#define WF_TX_DESCRIPTOR_VLAN_ADDR                                          4
+#define WF_TX_DESCRIPTOR_VLAN_MASK                                          0x00080000 // 19-19
+#define WF_TX_DESCRIPTOR_VLAN_SHIFT                                         19
+#define WF_TX_DESCRIPTOR_ETYP_DW                                            1
+#define WF_TX_DESCRIPTOR_ETYP_ADDR                                          4
+#define WF_TX_DESCRIPTOR_ETYP_MASK                                          0x00100000 // 20-20
+#define WF_TX_DESCRIPTOR_ETYP_SHIFT                                         20
+#define WF_TX_DESCRIPTOR_TID_MGMT_TYPE_DW                                   1
+#define WF_TX_DESCRIPTOR_TID_MGMT_TYPE_ADDR                                 4
+#define WF_TX_DESCRIPTOR_TID_MGMT_TYPE_MASK                                 0x01e00000 // 24-21
+#define WF_TX_DESCRIPTOR_TID_MGMT_TYPE_SHIFT                                21
+#define WF_TX_DESCRIPTOR_OM_DW                                              1
+#define WF_TX_DESCRIPTOR_OM_ADDR                                            4
+#define WF_TX_DESCRIPTOR_OM_MASK                                            0x7e000000 // 30-25
+#define WF_TX_DESCRIPTOR_OM_SHIFT                                           25
+#define WF_TX_DESCRIPTOR_FR_DW                                              1
+#define WF_TX_DESCRIPTOR_FR_ADDR                                            4
+#define WF_TX_DESCRIPTOR_FR_MASK                                            0x80000000 // 31-31
+#define WF_TX_DESCRIPTOR_FR_SHIFT                                           31
+// DW2
+#define WF_TX_DESCRIPTOR_SUBTYPE_DW                                         2
+#define WF_TX_DESCRIPTOR_SUBTYPE_ADDR                                       8
+#define WF_TX_DESCRIPTOR_SUBTYPE_MASK                                       0x0000000f //  3- 0
+#define WF_TX_DESCRIPTOR_SUBTYPE_SHIFT                                      0
+#define WF_TX_DESCRIPTOR_FTYPE_DW                                           2
+#define WF_TX_DESCRIPTOR_FTYPE_ADDR                                         8
+#define WF_TX_DESCRIPTOR_FTYPE_MASK                                         0x00000030 //  5- 4
+#define WF_TX_DESCRIPTOR_FTYPE_SHIFT                                        4
+#define WF_TX_DESCRIPTOR_BF_TYPE_DW                                         2
+#define WF_TX_DESCRIPTOR_BF_TYPE_ADDR                                       8
+#define WF_TX_DESCRIPTOR_BF_TYPE_MASK                                       0x000000c0 //  7- 6
+#define WF_TX_DESCRIPTOR_BF_TYPE_SHIFT                                      6
+#define WF_TX_DESCRIPTOR_OM_MAP_DW                                          2
+#define WF_TX_DESCRIPTOR_OM_MAP_ADDR                                        8
+#define WF_TX_DESCRIPTOR_OM_MAP_MASK                                        0x00000100 //  8- 8
+#define WF_TX_DESCRIPTOR_OM_MAP_SHIFT                                       8
+#define WF_TX_DESCRIPTOR_RTS_DW                                             2
+#define WF_TX_DESCRIPTOR_RTS_ADDR                                           8
+#define WF_TX_DESCRIPTOR_RTS_MASK                                           0x00000200 //  9- 9
+#define WF_TX_DESCRIPTOR_RTS_SHIFT                                          9
+#define WF_TX_DESCRIPTOR_HEADER_PADDING_DW                                  2
+#define WF_TX_DESCRIPTOR_HEADER_PADDING_ADDR                                8
+#define WF_TX_DESCRIPTOR_HEADER_PADDING_MASK                                0x00000c00 // 11-10
+#define WF_TX_DESCRIPTOR_HEADER_PADDING_SHIFT                               10
+#define WF_TX_DESCRIPTOR_DU_DW                                              2
+#define WF_TX_DESCRIPTOR_DU_ADDR                                            8
+#define WF_TX_DESCRIPTOR_DU_MASK                                            0x00001000 // 12-12
+#define WF_TX_DESCRIPTOR_DU_SHIFT                                           12
+#define WF_TX_DESCRIPTOR_HE_DW                                              2
+#define WF_TX_DESCRIPTOR_HE_ADDR                                            8
+#define WF_TX_DESCRIPTOR_HE_MASK                                            0x00002000 // 13-13
+#define WF_TX_DESCRIPTOR_HE_SHIFT                                           13
+#define WF_TX_DESCRIPTOR_FRAG_DW                                            2
+#define WF_TX_DESCRIPTOR_FRAG_ADDR                                          8
+#define WF_TX_DESCRIPTOR_FRAG_MASK                                          0x0000c000 // 15-14
+#define WF_TX_DESCRIPTOR_FRAG_SHIFT                                         14
+#define WF_TX_DESCRIPTOR_REMAINING_TX_TIME_DW                               2
+#define WF_TX_DESCRIPTOR_REMAINING_TX_TIME_ADDR                             8
+#define WF_TX_DESCRIPTOR_REMAINING_TX_TIME_MASK                             0x03ff0000 // 25-16
+#define WF_TX_DESCRIPTOR_REMAINING_TX_TIME_SHIFT                            16
+#define WF_TX_DESCRIPTOR_POWER_OFFSET_DW                                    2
+#define WF_TX_DESCRIPTOR_POWER_OFFSET_ADDR                                  8
+#define WF_TX_DESCRIPTOR_POWER_OFFSET_MASK                                  0xfc000000 // 31-26
+#define WF_TX_DESCRIPTOR_POWER_OFFSET_SHIFT                                 26
+// DW3
+#define WF_TX_DESCRIPTOR_NA_DW                                              3
+#define WF_TX_DESCRIPTOR_NA_ADDR                                            12
+#define WF_TX_DESCRIPTOR_NA_MASK                                            0x00000001 //  0- 0
+#define WF_TX_DESCRIPTOR_NA_SHIFT                                           0
+#define WF_TX_DESCRIPTOR_PF_DW                                              3
+#define WF_TX_DESCRIPTOR_PF_ADDR                                            12
+#define WF_TX_DESCRIPTOR_PF_MASK                                            0x00000002 //  1- 1
+#define WF_TX_DESCRIPTOR_PF_SHIFT                                           1
+#define WF_TX_DESCRIPTOR_EMRD_DW                                            3
+#define WF_TX_DESCRIPTOR_EMRD_ADDR                                          12
+#define WF_TX_DESCRIPTOR_EMRD_MASK                                          0x00000004 //  2- 2
+#define WF_TX_DESCRIPTOR_EMRD_SHIFT                                         2
+#define WF_TX_DESCRIPTOR_EEOSP_DW                                           3
+#define WF_TX_DESCRIPTOR_EEOSP_ADDR                                         12
+#define WF_TX_DESCRIPTOR_EEOSP_MASK                                         0x00000008 //  3- 3
+#define WF_TX_DESCRIPTOR_EEOSP_SHIFT                                        3
+#define WF_TX_DESCRIPTOR_BM_DW                                              3
+#define WF_TX_DESCRIPTOR_BM_ADDR                                            12
+#define WF_TX_DESCRIPTOR_BM_MASK                                            0x00000010 //  4- 4
+#define WF_TX_DESCRIPTOR_BM_SHIFT                                           4
+#define WF_TX_DESCRIPTOR_HW_AMSDU_CAP_DW                                    3
+#define WF_TX_DESCRIPTOR_HW_AMSDU_CAP_ADDR                                  12
+#define WF_TX_DESCRIPTOR_HW_AMSDU_CAP_MASK                                  0x00000020 //  5- 5
+#define WF_TX_DESCRIPTOR_HW_AMSDU_CAP_SHIFT                                 5
+#define WF_TX_DESCRIPTOR_TX_COUNT_DW                                        3
+#define WF_TX_DESCRIPTOR_TX_COUNT_ADDR                                      12
+#define WF_TX_DESCRIPTOR_TX_COUNT_MASK                                      0x000007c0 // 10- 6
+#define WF_TX_DESCRIPTOR_TX_COUNT_SHIFT                                     6
+#define WF_TX_DESCRIPTOR_REMAINING_TX_COUNT_DW                              3
+#define WF_TX_DESCRIPTOR_REMAINING_TX_COUNT_ADDR                            12
+#define WF_TX_DESCRIPTOR_REMAINING_TX_COUNT_MASK                            0x0000f800 // 15-11
+#define WF_TX_DESCRIPTOR_REMAINING_TX_COUNT_SHIFT                           11
+#define WF_TX_DESCRIPTOR_SN_DW                                              3
+#define WF_TX_DESCRIPTOR_SN_ADDR                                            12
+#define WF_TX_DESCRIPTOR_SN_MASK                                            0x0fff0000 // 27-16
+#define WF_TX_DESCRIPTOR_SN_SHIFT                                           16
+#define WF_TX_DESCRIPTOR_BA_DIS_DW                                          3
+#define WF_TX_DESCRIPTOR_BA_DIS_ADDR                                        12
+#define WF_TX_DESCRIPTOR_BA_DIS_MASK                                        0x10000000 // 28-28
+#define WF_TX_DESCRIPTOR_BA_DIS_SHIFT                                       28
+#define WF_TX_DESCRIPTOR_PM_DW                                              3
+#define WF_TX_DESCRIPTOR_PM_ADDR                                            12
+#define WF_TX_DESCRIPTOR_PM_MASK                                            0x20000000 // 29-29
+#define WF_TX_DESCRIPTOR_PM_SHIFT                                           29
+#define WF_TX_DESCRIPTOR_PN_VLD_DW                                          3
+#define WF_TX_DESCRIPTOR_PN_VLD_ADDR                                        12
+#define WF_TX_DESCRIPTOR_PN_VLD_MASK                                        0x40000000 // 30-30
+#define WF_TX_DESCRIPTOR_PN_VLD_SHIFT                                       30
+#define WF_TX_DESCRIPTOR_SN_VLD_DW                                          3
+#define WF_TX_DESCRIPTOR_SN_VLD_ADDR                                        12
+#define WF_TX_DESCRIPTOR_SN_VLD_MASK                                        0x80000000 // 31-31
+#define WF_TX_DESCRIPTOR_SN_VLD_SHIFT                                       31
+// DW4
+#define WF_TX_DESCRIPTOR_PN_31_0__DW                                        4
+#define WF_TX_DESCRIPTOR_PN_31_0__ADDR                                      16
+#define WF_TX_DESCRIPTOR_PN_31_0__MASK                                      0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_PN_31_0__SHIFT                                     0
+// DW5
+#define WF_TX_DESCRIPTOR_PID_DW                                             5
+#define WF_TX_DESCRIPTOR_PID_ADDR                                           20
+#define WF_TX_DESCRIPTOR_PID_MASK                                           0x000000ff //  7- 0
+#define WF_TX_DESCRIPTOR_PID_SHIFT                                          0
+#define WF_TX_DESCRIPTOR_TXSFM_DW                                           5
+#define WF_TX_DESCRIPTOR_TXSFM_ADDR                                         20
+#define WF_TX_DESCRIPTOR_TXSFM_MASK                                         0x00000100 //  8- 8
+#define WF_TX_DESCRIPTOR_TXSFM_SHIFT                                        8
+#define WF_TX_DESCRIPTOR_TXS2M_DW                                           5
+#define WF_TX_DESCRIPTOR_TXS2M_ADDR                                         20
+#define WF_TX_DESCRIPTOR_TXS2M_MASK                                         0x00000200 //  9- 9
+#define WF_TX_DESCRIPTOR_TXS2M_SHIFT                                        9
+#define WF_TX_DESCRIPTOR_TXS2H_DW                                           5
+#define WF_TX_DESCRIPTOR_TXS2H_ADDR                                         20
+#define WF_TX_DESCRIPTOR_TXS2H_MASK                                         0x00000400 // 10-10
+#define WF_TX_DESCRIPTOR_TXS2H_SHIFT                                        10
+#define WF_TX_DESCRIPTOR_FBCZ_DW                                            5
+#define WF_TX_DESCRIPTOR_FBCZ_ADDR                                          20
+#define WF_TX_DESCRIPTOR_FBCZ_MASK                                          0x00001000 // 12-12
+#define WF_TX_DESCRIPTOR_FBCZ_SHIFT                                         12
+#define WF_TX_DESCRIPTOR_BYPASS_RBB_DW                                      5
+#define WF_TX_DESCRIPTOR_BYPASS_RBB_ADDR                                    20
+#define WF_TX_DESCRIPTOR_BYPASS_RBB_MASK                                    0x00002000 // 13-13
+#define WF_TX_DESCRIPTOR_BYPASS_RBB_SHIFT                                   13
+#define WF_TX_DESCRIPTOR_BYPASS_TBB_DW                                      5
+#define WF_TX_DESCRIPTOR_BYPASS_TBB_ADDR                                    20
+#define WF_TX_DESCRIPTOR_BYPASS_TBB_MASK                                    0x00004000 // 14-14
+#define WF_TX_DESCRIPTOR_BYPASS_TBB_SHIFT                                   14
+#define WF_TX_DESCRIPTOR_FL_DW                                              5
+#define WF_TX_DESCRIPTOR_FL_ADDR                                            20
+#define WF_TX_DESCRIPTOR_FL_MASK                                            0x00008000 // 15-15
+#define WF_TX_DESCRIPTOR_FL_SHIFT                                           15
+#define WF_TX_DESCRIPTOR_PN_47_32__DW                                       5
+#define WF_TX_DESCRIPTOR_PN_47_32__ADDR                                     20
+#define WF_TX_DESCRIPTOR_PN_47_32__MASK                                     0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_PN_47_32__SHIFT                                    16
+// DW6
+#define WF_TX_DESCRIPTOR_AMSDU_CAP_UTXB_DW                                  6
+#define WF_TX_DESCRIPTOR_AMSDU_CAP_UTXB_ADDR                                24
+#define WF_TX_DESCRIPTOR_AMSDU_CAP_UTXB_MASK                                0x00000002 //  1- 1
+#define WF_TX_DESCRIPTOR_AMSDU_CAP_UTXB_SHIFT                               1
+#define WF_TX_DESCRIPTOR_DAS_DW                                             6
+#define WF_TX_DESCRIPTOR_DAS_ADDR                                           24
+#define WF_TX_DESCRIPTOR_DAS_MASK                                           0x00000004 //  2- 2
+#define WF_TX_DESCRIPTOR_DAS_SHIFT                                          2
+#define WF_TX_DESCRIPTOR_DIS_MAT_DW                                         6
+#define WF_TX_DESCRIPTOR_DIS_MAT_ADDR                                       24
+#define WF_TX_DESCRIPTOR_DIS_MAT_MASK                                       0x00000008 //  3- 3
+#define WF_TX_DESCRIPTOR_DIS_MAT_SHIFT                                      3
+#define WF_TX_DESCRIPTOR_MSDU_COUNT_DW                                      6
+#define WF_TX_DESCRIPTOR_MSDU_COUNT_ADDR                                    24
+#define WF_TX_DESCRIPTOR_MSDU_COUNT_MASK                                    0x000003f0 //  9- 4
+#define WF_TX_DESCRIPTOR_MSDU_COUNT_SHIFT                                   4
+#define WF_TX_DESCRIPTOR_TIMESTAMP_OFFSET_IDX_DW                            6
+#define WF_TX_DESCRIPTOR_TIMESTAMP_OFFSET_IDX_ADDR                          24
+#define WF_TX_DESCRIPTOR_TIMESTAMP_OFFSET_IDX_MASK                          0x00007c00 // 14-10
+#define WF_TX_DESCRIPTOR_TIMESTAMP_OFFSET_IDX_SHIFT                         10
+#define WF_TX_DESCRIPTOR_TIMESTAMP_OFFSET_EN_DW                             6
+#define WF_TX_DESCRIPTOR_TIMESTAMP_OFFSET_EN_ADDR                           24
+#define WF_TX_DESCRIPTOR_TIMESTAMP_OFFSET_EN_MASK                           0x00008000 // 15-15
+#define WF_TX_DESCRIPTOR_TIMESTAMP_OFFSET_EN_SHIFT                          15
+#define WF_TX_DESCRIPTOR_FIXED_RATE_IDX_DW                                  6
+#define WF_TX_DESCRIPTOR_FIXED_RATE_IDX_ADDR                                24
+#define WF_TX_DESCRIPTOR_FIXED_RATE_IDX_MASK                                0x003f0000 // 21-16
+#define WF_TX_DESCRIPTOR_FIXED_RATE_IDX_SHIFT                               16
+#define WF_TX_DESCRIPTOR_BW_DW                                              6
+#define WF_TX_DESCRIPTOR_BW_ADDR                                            24
+#define WF_TX_DESCRIPTOR_BW_MASK                                            0x03c00000 // 25-22
+#define WF_TX_DESCRIPTOR_BW_SHIFT                                           22
+#define WF_TX_DESCRIPTOR_VTA_DW                                             6
+#define WF_TX_DESCRIPTOR_VTA_ADDR                                           24
+#define WF_TX_DESCRIPTOR_VTA_MASK                                           0x10000000 // 28-28
+#define WF_TX_DESCRIPTOR_VTA_SHIFT                                          28
+#define WF_TX_DESCRIPTOR_SRC_DW                                             6
+#define WF_TX_DESCRIPTOR_SRC_ADDR                                           24
+#define WF_TX_DESCRIPTOR_SRC_MASK                                           0xc0000000 // 31-30
+#define WF_TX_DESCRIPTOR_SRC_SHIFT                                          30
+// DW7
+#define WF_TX_DESCRIPTOR_SW_TX_TIME_DW                                      7
+#define WF_TX_DESCRIPTOR_SW_TX_TIME_ADDR                                    28
+#define WF_TX_DESCRIPTOR_SW_TX_TIME_MASK                                    0x000003ff //  9- 0
+#define WF_TX_DESCRIPTOR_SW_TX_TIME_SHIFT                                   0
+#define WF_TX_DESCRIPTOR_UT_DW                                              7
+#define WF_TX_DESCRIPTOR_UT_ADDR                                            28
+#define WF_TX_DESCRIPTOR_UT_MASK                                            0x00008000 // 15-15
+#define WF_TX_DESCRIPTOR_UT_SHIFT                                           15
+#define WF_TX_DESCRIPTOR_CTXD_CNT_DW                                        7
+#define WF_TX_DESCRIPTOR_CTXD_CNT_ADDR                                      28
+#define WF_TX_DESCRIPTOR_CTXD_CNT_MASK                                      0x03c00000 // 25-22
+#define WF_TX_DESCRIPTOR_CTXD_CNT_SHIFT                                     22
+#define WF_TX_DESCRIPTOR_CTXD_DW                                            7
+#define WF_TX_DESCRIPTOR_CTXD_ADDR                                          28
+#define WF_TX_DESCRIPTOR_CTXD_MASK                                          0x04000000 // 26-26
+#define WF_TX_DESCRIPTOR_CTXD_SHIFT                                         26
+#define WF_TX_DESCRIPTOR_HM_DW                                              7
+#define WF_TX_DESCRIPTOR_HM_ADDR                                            28
+#define WF_TX_DESCRIPTOR_HM_MASK                                            0x08000000 // 27-27
+#define WF_TX_DESCRIPTOR_HM_SHIFT                                           27
+#define WF_TX_DESCRIPTOR_DP_DW                                              7
+#define WF_TX_DESCRIPTOR_DP_ADDR                                            28
+#define WF_TX_DESCRIPTOR_DP_MASK                                            0x10000000 // 28-28
+#define WF_TX_DESCRIPTOR_DP_SHIFT                                           28
+#define WF_TX_DESCRIPTOR_IP_DW                                              7
+#define WF_TX_DESCRIPTOR_IP_ADDR                                            28
+#define WF_TX_DESCRIPTOR_IP_MASK                                            0x20000000 // 29-29
+#define WF_TX_DESCRIPTOR_IP_SHIFT                                           29
+#define WF_TX_DESCRIPTOR_TXD_LEN_DW                                         7
+#define WF_TX_DESCRIPTOR_TXD_LEN_ADDR                                       28
+#define WF_TX_DESCRIPTOR_TXD_LEN_MASK                                       0xc0000000 // 31-30
+#define WF_TX_DESCRIPTOR_TXD_LEN_SHIFT                                      30
+// DW8
+#define WF_TX_DESCRIPTOR_MSDU0_DW                                           8
+#define WF_TX_DESCRIPTOR_MSDU0_ADDR                                         32
+#define WF_TX_DESCRIPTOR_MSDU0_MASK                                         0x0000ffff // 15- 0
+#define WF_TX_DESCRIPTOR_MSDU0_SHIFT                                        0
+#define WF_TX_DESCRIPTOR_MSDU1_DW                                           8
+#define WF_TX_DESCRIPTOR_MSDU1_ADDR                                         32
+#define WF_TX_DESCRIPTOR_MSDU1_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_MSDU1_SHIFT                                        16
+// DW9
+#define WF_TX_DESCRIPTOR_MSDU2_DW                                           9
+#define WF_TX_DESCRIPTOR_MSDU2_ADDR                                         36
+#define WF_TX_DESCRIPTOR_MSDU2_MASK                                         0x0000ffff // 15- 0
+#define WF_TX_DESCRIPTOR_MSDU2_SHIFT                                        0
+#define WF_TX_DESCRIPTOR_MSDU3_DW                                           9
+#define WF_TX_DESCRIPTOR_MSDU3_ADDR                                         36
+#define WF_TX_DESCRIPTOR_MSDU3_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_MSDU3_SHIFT                                        16
+// DW10
+#define WF_TX_DESCRIPTOR_TXP0_DW                                            10
+#define WF_TX_DESCRIPTOR_TXP0_ADDR                                          40
+#define WF_TX_DESCRIPTOR_TXP0_MASK                                          0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP0_SHIFT                                         0
+// DW11
+// DO NOT process repeat field(txp[0])
+#define WF_TX_DESCRIPTOR_TXP1_DW                                            11
+#define WF_TX_DESCRIPTOR_TXP1_ADDR                                          44
+#define WF_TX_DESCRIPTOR_TXP1_MASK                                          0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP1_SHIFT                                         16
+// DW12
+// DO NOT process repeat field(txp[1])
+// DW13
+#define WF_TX_DESCRIPTOR_TXP2_DW                                            13
+#define WF_TX_DESCRIPTOR_TXP2_ADDR                                          52
+#define WF_TX_DESCRIPTOR_TXP2_MASK                                          0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP2_SHIFT                                         0
+// DW14
+// DO NOT process repeat field(txp[2])
+#define WF_TX_DESCRIPTOR_TXP3_DW                                            14
+#define WF_TX_DESCRIPTOR_TXP3_ADDR                                          56
+#define WF_TX_DESCRIPTOR_TXP3_MASK                                          0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP3_SHIFT                                         16
+// DW15
+// DO NOT process repeat field(txp[3])
+// DW16
+#define WF_TX_DESCRIPTOR_MSDU4_DW                                           16
+#define WF_TX_DESCRIPTOR_MSDU4_ADDR                                         64
+#define WF_TX_DESCRIPTOR_MSDU4_MASK                                         0x0000ffff // 15- 0
+#define WF_TX_DESCRIPTOR_MSDU4_SHIFT                                        0
+#define WF_TX_DESCRIPTOR_MSDU5_DW                                           16
+#define WF_TX_DESCRIPTOR_MSDU5_ADDR                                         64
+#define WF_TX_DESCRIPTOR_MSDU5_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_MSDU5_SHIFT                                        16
+// DW17
+#define WF_TX_DESCRIPTOR_MSDU6_DW                                           17
+#define WF_TX_DESCRIPTOR_MSDU6_ADDR                                         68
+#define WF_TX_DESCRIPTOR_MSDU6_MASK                                         0x0000ffff // 15- 0
+#define WF_TX_DESCRIPTOR_MSDU6_SHIFT                                        0
+#define WF_TX_DESCRIPTOR_MSDU7_DW                                           17
+#define WF_TX_DESCRIPTOR_MSDU7_ADDR                                         68
+#define WF_TX_DESCRIPTOR_MSDU7_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_MSDU7_SHIFT                                        16
+// DW18
+#define WF_TX_DESCRIPTOR_TXP4_DW                                            18
+#define WF_TX_DESCRIPTOR_TXP4_ADDR                                          72
+#define WF_TX_DESCRIPTOR_TXP4_MASK                                          0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP4_SHIFT                                         0
+// DW19
+// DO NOT process repeat field(txp[4])
+#define WF_TX_DESCRIPTOR_TXP5_DW                                            19
+#define WF_TX_DESCRIPTOR_TXP5_ADDR                                          76
+#define WF_TX_DESCRIPTOR_TXP5_MASK                                          0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP5_SHIFT                                         16
+// DW20
+// DO NOT process repeat field(txp[5])
+// DW21
+#define WF_TX_DESCRIPTOR_TXP6_DW                                            21
+#define WF_TX_DESCRIPTOR_TXP6_ADDR                                          84
+#define WF_TX_DESCRIPTOR_TXP6_MASK                                          0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP6_SHIFT                                         0
+// DW22
+// DO NOT process repeat field(txp[6])
+#define WF_TX_DESCRIPTOR_TXP7_DW                                            22
+#define WF_TX_DESCRIPTOR_TXP7_ADDR                                          88
+#define WF_TX_DESCRIPTOR_TXP7_MASK                                          0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP7_SHIFT                                         16
+// DW23
+// DO NOT process repeat field(txp[7])
+// DW24
+#define WF_TX_DESCRIPTOR_TXP8_DW                                            24
+#define WF_TX_DESCRIPTOR_TXP8_ADDR                                          96
+#define WF_TX_DESCRIPTOR_TXP8_MASK                                          0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP8_SHIFT                                         0
+// DW25
+// DO NOT process repeat field(txp[8])
+#define WF_TX_DESCRIPTOR_TXP9_DW                                            25
+#define WF_TX_DESCRIPTOR_TXP9_ADDR                                          100
+#define WF_TX_DESCRIPTOR_TXP9_MASK                                          0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP9_SHIFT                                         16
+// DW26
+// DO NOT process repeat field(txp[9])
+// DW27
+#define WF_TX_DESCRIPTOR_TXP10_DW                                           27
+#define WF_TX_DESCRIPTOR_TXP10_ADDR                                         108
+#define WF_TX_DESCRIPTOR_TXP10_MASK                                         0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP10_SHIFT                                        0
+// DW28
+// DO NOT process repeat field(txp[10])
+#define WF_TX_DESCRIPTOR_TXP11_DW                                           28
+#define WF_TX_DESCRIPTOR_TXP11_ADDR                                         112
+#define WF_TX_DESCRIPTOR_TXP11_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP11_SHIFT                                        16
+// DW29
+// DO NOT process repeat field(txp[11])
+// DW30
+#define WF_TX_DESCRIPTOR_TXP12_DW                                           30
+#define WF_TX_DESCRIPTOR_TXP12_ADDR                                         120
+#define WF_TX_DESCRIPTOR_TXP12_MASK                                         0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP12_SHIFT                                        0
+// DW31
+// DO NOT process repeat field(txp[12])
+#define WF_TX_DESCRIPTOR_TXP13_DW                                           31
+#define WF_TX_DESCRIPTOR_TXP13_ADDR                                         124
+#define WF_TX_DESCRIPTOR_TXP13_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP13_SHIFT                                        16
+// DW32
+// DO NOT process repeat field(txp[13])
+// DW33
+#define WF_TX_DESCRIPTOR_TXP14_DW                                           33
+#define WF_TX_DESCRIPTOR_TXP14_ADDR                                         132
+#define WF_TX_DESCRIPTOR_TXP14_MASK                                         0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP14_SHIFT                                        0
+// DW34
+// DO NOT process repeat field(txp[14])
+#define WF_TX_DESCRIPTOR_TXP15_DW                                           34
+#define WF_TX_DESCRIPTOR_TXP15_ADDR                                         136
+#define WF_TX_DESCRIPTOR_TXP15_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP15_SHIFT                                        16
+// DW35
+// DO NOT process repeat field(txp[15])
+// DW36
+#define WF_TX_DESCRIPTOR_TXP16_DW                                           36
+#define WF_TX_DESCRIPTOR_TXP16_ADDR                                         144
+#define WF_TX_DESCRIPTOR_TXP16_MASK                                         0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP16_SHIFT                                        0
+// DW37
+// DO NOT process repeat field(txp[16])
+#define WF_TX_DESCRIPTOR_TXP17_DW                                           37
+#define WF_TX_DESCRIPTOR_TXP17_ADDR                                         148
+#define WF_TX_DESCRIPTOR_TXP17_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP17_SHIFT                                        16
+// DW38
+// DO NOT process repeat field(txp[17])
+// DW39
+#define WF_TX_DESCRIPTOR_TXP18_DW                                           39
+#define WF_TX_DESCRIPTOR_TXP18_ADDR                                         156
+#define WF_TX_DESCRIPTOR_TXP18_MASK                                         0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP18_SHIFT                                        0
+// DW40
+// DO NOT process repeat field(txp[18])
+#define WF_TX_DESCRIPTOR_TXP19_DW                                           40
+#define WF_TX_DESCRIPTOR_TXP19_ADDR                                         160
+#define WF_TX_DESCRIPTOR_TXP19_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP19_SHIFT                                        16
+// DW41
+// DO NOT process repeat field(txp[19])
+// DW42
+#define WF_TX_DESCRIPTOR_TXP20_DW                                           42
+#define WF_TX_DESCRIPTOR_TXP20_ADDR                                         168
+#define WF_TX_DESCRIPTOR_TXP20_MASK                                         0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP20_SHIFT                                        0
+// DW43
+// DO NOT process repeat field(txp[20])
+#define WF_TX_DESCRIPTOR_TXP21_DW                                           43
+#define WF_TX_DESCRIPTOR_TXP21_ADDR                                         172
+#define WF_TX_DESCRIPTOR_TXP21_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP21_SHIFT                                        16
+// DW44
+// DO NOT process repeat field(txp[21])
+// DW45
+#define WF_TX_DESCRIPTOR_TXP22_DW                                           45
+#define WF_TX_DESCRIPTOR_TXP22_ADDR                                         180
+#define WF_TX_DESCRIPTOR_TXP22_MASK                                         0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP22_SHIFT                                        0
+// DW46
+// DO NOT process repeat field(txp[22])
+#define WF_TX_DESCRIPTOR_TXP23_DW                                           46
+#define WF_TX_DESCRIPTOR_TXP23_ADDR                                         184
+#define WF_TX_DESCRIPTOR_TXP23_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP23_SHIFT                                        16
+// DW47
+// DO NOT process repeat field(txp[23])
+// DW48
+#define WF_TX_DESCRIPTOR_TXP24_DW                                           48
+#define WF_TX_DESCRIPTOR_TXP24_ADDR                                         192
+#define WF_TX_DESCRIPTOR_TXP24_MASK                                         0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP24_SHIFT                                        0
+// DW49
+// DO NOT process repeat field(txp[24])
+#define WF_TX_DESCRIPTOR_TXP25_DW                                           49
+#define WF_TX_DESCRIPTOR_TXP25_ADDR                                         196
+#define WF_TX_DESCRIPTOR_TXP25_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP25_SHIFT                                        16
+// DW50
+// DO NOT process repeat field(txp[25])
+// DW51
+#define WF_TX_DESCRIPTOR_TXP26_DW                                           51
+#define WF_TX_DESCRIPTOR_TXP26_ADDR                                         204
+#define WF_TX_DESCRIPTOR_TXP26_MASK                                         0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP26_SHIFT                                        0
+// DW52
+// DO NOT process repeat field(txp[26])
+#define WF_TX_DESCRIPTOR_TXP27_DW                                           52
+#define WF_TX_DESCRIPTOR_TXP27_ADDR                                         208
+#define WF_TX_DESCRIPTOR_TXP27_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP27_SHIFT                                        16
+// DW53
+// DO NOT process repeat field(txp[27])
+// DW54
+#define WF_TX_DESCRIPTOR_TXP28_DW                                           54
+#define WF_TX_DESCRIPTOR_TXP28_ADDR                                         216
+#define WF_TX_DESCRIPTOR_TXP28_MASK                                         0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP28_SHIFT                                        0
+// DW55
+// DO NOT process repeat field(txp[28])
+#define WF_TX_DESCRIPTOR_TXP29_DW                                           55
+#define WF_TX_DESCRIPTOR_TXP29_ADDR                                         220
+#define WF_TX_DESCRIPTOR_TXP29_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP29_SHIFT                                        16
+// DW56
+// DO NOT process repeat field(txp[29])
+// DW57
+#define WF_TX_DESCRIPTOR_TXP30_DW                                           57
+#define WF_TX_DESCRIPTOR_TXP30_ADDR                                         228
+#define WF_TX_DESCRIPTOR_TXP30_MASK                                         0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP30_SHIFT                                        0
+// DW58
+// DO NOT process repeat field(txp[30])
+#define WF_TX_DESCRIPTOR_TXP31_DW                                           58
+#define WF_TX_DESCRIPTOR_TXP31_ADDR                                         232
+#define WF_TX_DESCRIPTOR_TXP31_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP31_SHIFT                                        16
+// DW59
+// DO NOT process repeat field(txp[31])
+
+/* TXP PAO */
+#define HIF_TXP_V2_SIZE (24 * 4)
+/* DW0 */
+#define HIF_TXD_VERSION_SHIFT 19
+#define HIF_TXD_VERSION_MASK 0x00780000
+
+/* DW8 */
+#define HIF_TXP_PRIORITY_SHIFT 0
+#define HIF_TXP_PRIORITY_MASK 0x00000001
+#define HIF_TXP_FIXED_RATE_SHIFT 1
+#define HIF_TXP_FIXED_RATE_MASK 0x00000002
+#define HIF_TXP_TCP_SHIFT 2
+#define HIF_TXP_TCP_MASK 0x00000004
+#define HIF_TXP_NON_CIPHER_SHIFT 3
+#define HIF_TXP_NON_CIPHER_MASK 0x00000008
+#define HIF_TXP_VLAN_SHIFT 4
+#define HIF_TXP_VLAN_MASK 0x00000010
+#define HIF_TXP_BC_MC_FLAG_SHIFT 5
+#define HIF_TXP_BC_MC_FLAG_MASK 0x00000060
+#define HIF_TXP_FR_HOST_SHIFT 7
+#define HIF_TXP_FR_HOST_MASK 0x00000080
+#define HIF_TXP_ETYPE_SHIFT 8
+#define HIF_TXP_ETYPE_MASK 0x00000100
+#define HIF_TXP_TXP_AMSDU_SHIFT 9
+#define HIF_TXP_TXP_AMSDU_MASK 0x00000200
+#define HIF_TXP_TXP_MC_CLONE_SHIFT 10
+#define HIF_TXP_TXP_MC_CLONE_MASK 0x00000400
+#define HIF_TXP_TOKEN_ID_SHIFT 16
+#define HIF_TXP_TOKEN_ID_MASK 0xffff0000
+
+/* DW9 */
+#define HIF_TXP_BSS_IDX_SHIFT 0
+#define HIF_TXP_BSS_IDX_MASK 0x000000ff
+#define HIF_TXP_USER_PRIORITY_SHIFT 8
+#define HIF_TXP_USER_PRIORITY_MASK 0x0000ff00
+#define HIF_TXP_BUF_NUM_SHIFT 16
+#define HIF_TXP_BUF_NUM_MASK 0x001f0000
+#define HIF_TXP_MSDU_CNT_SHIFT 21
+#define HIF_TXP_MSDU_CNT_MASK 0x03e00000
+#define HIF_TXP_SRC_SHIFT 26
+#define HIF_TXP_SRC_MASK 0x0c000000
+
+/* DW10 */
+#define HIF_TXP_ETH_TYPE_SHIFT 0
+#define HIF_TXP_ETH_TYPE_MASK 0x0000ffff
+#define HIF_TXP_WLAN_IDX_SHIFT 16
+#define HIF_TXP_WLAN_IDX_MASK 0x0fff0000
+
+/* DW11 */
+#define HIF_TXP_PPE_INFO_SHIFT 0
+#define HIF_TXP_PPE_INFO_MASK 0xffffffff
+
+/* DW12 - DW31 */
+#define HIF_TXP_BUF_PTR0_L_SHIFT 0
+#define HIF_TXP_BUF_PTR0_L_MASK 0xffffffff
+#define HIF_TXP_BUF_LEN0_SHIFT 0
+#define HIF_TXP_BUF_LEN0_MASK 0x00000fff
+#define HIF_TXP_BUF_PTR0_H_SHIFT 12
+#define HIF_TXP_BUF_PTR0_H_MASK 0x0000f000
+#define HIF_TXP_BUF_LEN1_SHIFT 16
+#define HIF_TXP_BUF_LEN1_MASK 0x0fff0000
+#define HIF_TXP_BUF_PTR1_H_SHIFT 28
+#define HIF_TXP_BUF_PTR1_H_MASK 0xf0000000
+#define HIF_TXP_BUF_PTR1_L_SHIFT 0
+#define HIF_TXP_BUF_PTR1_L_MASK 0xffffffff
+
+/* DW31 */
+#define HIF_TXP_ML_SHIFT 16
+#define HIF_TXP_ML_MASK 0xffff0000
+
+/* UWTBL */
+#define MT_WF_UWTBL_BASE		0x820c4000
+#define MT_WF_UWTBL(ofs)		(MT_WF_UWTBL_BASE + (ofs))
+
+#define MT_WF_UWTBL_ITCR		MT_WF_UWTBL(0x130)
+#define MT_WF_UWTBL_ITCR0		MT_WF_UWTBL(0x138)
+#define MT_WF_UWTBL_ITCR1		MT_WF_UWTBL(0x13c)
+
+#define MT_WF_UWTBL_ITCR_SET		BIT(31)
+#define MT_WF_UWTBL_ITCR_INDEX		GENMASK(5, 0)
+
+/* RMAC */
+#define MT_WF_RMAC_SRAM_DATA0(_band)	MT_WF_RMAC(_band, 0x210)
+#define MT_WF_RMAC_SRAM_DATA1(_band)	MT_WF_RMAC(_band, 0x214)
+#define MT_WF_RMAC_SRAM_BITMAP0(_band)	MT_WF_RMAC(_band, 0x220)
+#define MT_WF_RMAC_SRAM_BITMAP1(_band)	MT_WF_RMAC(_band, 0x224)
+#define MT_WF_RMAC_MEM_CTRL(_band)	MT_WF_RMAC(_band, 0x228)
+
+#define MT_WF_RMAC_MEM_CRTL_TRIG	BIT(31)
+#define MT_WF_RMAC_MEM_CRTL_TDX		GENMASK(7, 0)
+
+/* AGG */
+#define MT_AGG_REMAP_CTRL(_band)	MT_WF_AGG(_band, 0x094)
+#define MT_AGG_REMAP_CTRL_OM_REMAP	GENMASK(5, 0)
+
+/* TMAC */
+#define MT_WF_TMAC_WMM0_OFFSET		0x0c4
+#define MT_WF_TMAC_WMM1_OFFSET		0x364
+#define MT_WF_TMAC_WMM2_OFFSET		0x36c
+#define MT_WF_TMAC_WMM3_OFFSET		0x374
+#define MT_WF_TMAC_WMM_TXOP_MASK	GENMASK(31, 16)
+#define MT_WF_TMAC_WMM_TXOP_SHIFT	16
+#endif
+
+#endif
diff --git a/mt7996/mtk_debugfs.c b/mt7996/mtk_debugfs.c
new file mode 100644
index 00000000..7086a08a
--- /dev/null
+++ b/mt7996/mtk_debugfs.c
@@ -0,0 +1,4517 @@
+// SPDX-License-Identifier: ISC
+/*
+ * Copyright (C) 2023 MediaTek Inc.
+ */
+#include "mt7996.h"
+#include "../mt76.h"
+#include "mcu.h"
+#include "mac.h"
+#include "eeprom.h"
+#include "mtk_debug.h"
+#include "mtk_mcu.h"
+#include "coredump.h"
+
+#ifdef CONFIG_MTK_DEBUG
+
+#ifndef PKG_YEAR
+#define PKG_YEAR 0
+#endif
+
+#ifndef PKG_MONTH
+#define PKG_MONTH 0
+#endif
+
+/* AGG INFO */
+static int mt7996_agginfo_show(struct seq_file *s, void *data)
+{
+	struct mt7996_phy *phy = s->private;
+	struct mt7996_dev *dev = phy->dev;
+	u64 total_burst, total_ampdu, ampdu_cnt[16];
+	u32 value, idx, row_idx, col_idx, start_range, agg_rang_sel[16], burst_cnt[16], band_offset = 0;
+	u8 partial_str[16] = {}, full_str[64] = {};
+	u8 band_idx = phy->mt76->band_idx;
+
+	switch (band_idx) {
+	case 0:
+		band_offset = 0;
+		break;
+	case 1:
+		band_offset = BN1_WF_AGG_TOP_BASE - BN0_WF_AGG_TOP_BASE;
+		break;
+	case 2:
+		band_offset = IP1_BN0_WF_AGG_TOP_BASE - BN0_WF_AGG_TOP_BASE;
+		break;
+	default:
+		return 0;
+	}
+
+	seq_printf(s, "Band %d AGG Status\n", band_idx);
+	seq_printf(s, "===============================\n");
+	value = mt76_rr(dev, BN0_WF_AGG_TOP_AALCR0_ADDR + band_offset);
+	seq_printf(s, "AC00 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR0_AC00_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR0_AC00_AGG_LIMIT_SHFT);
+	seq_printf(s, "AC01 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR0_AC01_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR0_AC01_AGG_LIMIT_SHFT);
+	value = mt76_rr(dev, BN0_WF_AGG_TOP_AALCR1_ADDR + band_offset);
+	seq_printf(s, "AC02 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR1_AC02_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR1_AC02_AGG_LIMIT_SHFT);
+	seq_printf(s, "AC03 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR1_AC03_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR1_AC03_AGG_LIMIT_SHFT);
+	value = mt76_rr(dev, BN0_WF_AGG_TOP_AALCR2_ADDR + band_offset);
+	seq_printf(s, "AC10 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR2_AC10_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR2_AC10_AGG_LIMIT_SHFT);
+	seq_printf(s, "AC11 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR2_AC11_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR2_AC11_AGG_LIMIT_SHFT);
+	value = mt76_rr(dev, BN0_WF_AGG_TOP_AALCR3_ADDR + band_offset);
+	seq_printf(s, "AC12 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR3_AC12_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR3_AC12_AGG_LIMIT_SHFT);
+	seq_printf(s, "AC13 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR3_AC13_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR3_AC13_AGG_LIMIT_SHFT);
+	value = mt76_rr(dev, BN0_WF_AGG_TOP_AALCR4_ADDR + band_offset);
+	seq_printf(s, "AC20 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR4_AC20_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR4_AC20_AGG_LIMIT_SHFT);
+	seq_printf(s, "AC21 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR4_AC21_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR4_AC21_AGG_LIMIT_SHFT);
+	value = mt76_rr(dev, BN0_WF_AGG_TOP_AALCR5_ADDR + band_offset);
+	seq_printf(s, "AC22 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR5_AC22_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR5_AC22_AGG_LIMIT_SHFT);
+	seq_printf(s, "AC23 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR5_AC23_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR5_AC23_AGG_LIMIT_SHFT);
+	value = mt76_rr(dev, BN0_WF_AGG_TOP_AALCR6_ADDR + band_offset);
+	seq_printf(s, "AC30 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR6_AC30_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR6_AC30_AGG_LIMIT_SHFT);
+	seq_printf(s, "AC31 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR6_AC31_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR6_AC31_AGG_LIMIT_SHFT);
+	value = mt76_rr(dev, BN0_WF_AGG_TOP_AALCR7_ADDR + band_offset);
+	seq_printf(s, "AC32 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR7_AC32_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR7_AC32_AGG_LIMIT_SHFT);
+	seq_printf(s, "AC33 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR7_AC33_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR7_AC33_AGG_LIMIT_SHFT);
+
+	switch (band_idx) {
+	case 0:
+		band_offset = 0;
+		break;
+	case 1:
+		band_offset = BN1_WF_MIB_TOP_BASE - BN0_WF_MIB_TOP_BASE;
+		break;
+	case 2:
+		band_offset = IP1_BN0_WF_MIB_TOP_BASE - BN0_WF_MIB_TOP_BASE;
+		break;
+	default:
+		return 0;
+	}
+
+	seq_printf(s, "===AMPDU Related Counters===\n");
+
+	value = mt76_rr(dev, BN0_WF_MIB_TOP_TRARC0_ADDR + band_offset);
+	agg_rang_sel[0] = (value & BN0_WF_MIB_TOP_TRARC0_AGG_RANG_SEL_0_MASK) >> BN0_WF_MIB_TOP_TRARC0_AGG_RANG_SEL_0_SHFT;
+	agg_rang_sel[1] = (value & BN0_WF_MIB_TOP_TRARC0_AGG_RANG_SEL_1_MASK) >> BN0_WF_MIB_TOP_TRARC0_AGG_RANG_SEL_1_SHFT;
+	value = mt76_rr(dev, BN0_WF_MIB_TOP_TRARC1_ADDR + band_offset);
+	agg_rang_sel[2] = (value & BN0_WF_MIB_TOP_TRARC1_AGG_RANG_SEL_2_MASK) >> BN0_WF_MIB_TOP_TRARC1_AGG_RANG_SEL_2_SHFT;
+	agg_rang_sel[3] = (value & BN0_WF_MIB_TOP_TRARC1_AGG_RANG_SEL_3_MASK) >> BN0_WF_MIB_TOP_TRARC1_AGG_RANG_SEL_3_SHFT;
+	value = mt76_rr(dev, BN0_WF_MIB_TOP_TRARC2_ADDR + band_offset);
+	agg_rang_sel[4] = (value & BN0_WF_MIB_TOP_TRARC2_AGG_RANG_SEL_4_MASK) >> BN0_WF_MIB_TOP_TRARC2_AGG_RANG_SEL_4_SHFT;
+	agg_rang_sel[5] = (value & BN0_WF_MIB_TOP_TRARC2_AGG_RANG_SEL_5_MASK) >> BN0_WF_MIB_TOP_TRARC2_AGG_RANG_SEL_5_SHFT;
+	value = mt76_rr(dev, BN0_WF_MIB_TOP_TRARC3_ADDR + band_offset);
+	agg_rang_sel[6] = (value & BN0_WF_MIB_TOP_TRARC3_AGG_RANG_SEL_6_MASK) >> BN0_WF_MIB_TOP_TRARC3_AGG_RANG_SEL_6_SHFT;
+	agg_rang_sel[7] = (value & BN0_WF_MIB_TOP_TRARC3_AGG_RANG_SEL_7_MASK) >> BN0_WF_MIB_TOP_TRARC3_AGG_RANG_SEL_7_SHFT;
+	value = mt76_rr(dev, BN0_WF_MIB_TOP_TRARC4_ADDR + band_offset);
+	agg_rang_sel[8] = (value & BN0_WF_MIB_TOP_TRARC4_AGG_RANG_SEL_8_MASK) >> BN0_WF_MIB_TOP_TRARC4_AGG_RANG_SEL_8_SHFT;
+	agg_rang_sel[9] = (value & BN0_WF_MIB_TOP_TRARC4_AGG_RANG_SEL_9_MASK) >> BN0_WF_MIB_TOP_TRARC4_AGG_RANG_SEL_9_SHFT;
+	value = mt76_rr(dev, BN0_WF_MIB_TOP_TRARC5_ADDR + band_offset);
+	agg_rang_sel[10] = (value & BN0_WF_MIB_TOP_TRARC5_AGG_RANG_SEL_10_MASK) >> BN0_WF_MIB_TOP_TRARC5_AGG_RANG_SEL_10_SHFT;
+	agg_rang_sel[11] = (value & BN0_WF_MIB_TOP_TRARC5_AGG_RANG_SEL_11_MASK) >> BN0_WF_MIB_TOP_TRARC5_AGG_RANG_SEL_11_SHFT;
+	value = mt76_rr(dev, BN0_WF_MIB_TOP_TRARC6_ADDR + band_offset);
+	agg_rang_sel[12] = (value & BN0_WF_MIB_TOP_TRARC6_AGG_RANG_SEL_12_MASK) >> BN0_WF_MIB_TOP_TRARC6_AGG_RANG_SEL_12_SHFT;
+	agg_rang_sel[13] = (value & BN0_WF_MIB_TOP_TRARC6_AGG_RANG_SEL_13_MASK) >> BN0_WF_MIB_TOP_TRARC6_AGG_RANG_SEL_13_SHFT;
+	value = mt76_rr(dev, BN0_WF_MIB_TOP_TRARC7_ADDR + band_offset);
+	agg_rang_sel[14] = (value & BN0_WF_MIB_TOP_TRARC7_AGG_RANG_SEL_14_MASK) >> BN0_WF_MIB_TOP_TRARC7_AGG_RANG_SEL_14_SHFT;
+
+	burst_cnt[0] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR0_ADDR + band_offset);
+	burst_cnt[1] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR1_ADDR + band_offset);
+	burst_cnt[2] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR2_ADDR + band_offset);
+	burst_cnt[3] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR3_ADDR + band_offset);
+	burst_cnt[4] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR4_ADDR + band_offset);
+	burst_cnt[5] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR5_ADDR + band_offset);
+	burst_cnt[6] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR6_ADDR + band_offset);
+	burst_cnt[7] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR7_ADDR + band_offset);
+	burst_cnt[8] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR8_ADDR + band_offset);
+	burst_cnt[9] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR9_ADDR + band_offset);
+	burst_cnt[10] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR10_ADDR + band_offset);
+	burst_cnt[11] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR11_ADDR + band_offset);
+	burst_cnt[12] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR12_ADDR + band_offset);
+	burst_cnt[13] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR13_ADDR + band_offset);
+	burst_cnt[14] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR14_ADDR + band_offset);
+	burst_cnt[15] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR15_ADDR + band_offset);
+
+	start_range = 1;
+	total_burst = 0;
+	total_ampdu = 0;
+	agg_rang_sel[15] = 1023;
+
+	/* Need to add 1 after read from AGG_RANG_SEL CR */
+	for (idx = 0; idx < 16; idx++) {
+		agg_rang_sel[idx]++;
+		total_burst += burst_cnt[idx];
+
+		if (start_range == agg_rang_sel[idx])
+			ampdu_cnt[idx] = (u64) start_range * burst_cnt[idx];
+		else
+			ampdu_cnt[idx] = (u64) ((start_range + agg_rang_sel[idx]) >> 1) * burst_cnt[idx];
+
+		start_range = agg_rang_sel[idx] + 1;
+		total_ampdu += ampdu_cnt[idx];
+	}
+
+	start_range = 1;
+	sprintf(full_str, "%13s ", "Tx Agg Range:");
+
+	for (row_idx = 0; row_idx < 4; row_idx++) {
+		for (col_idx = 0; col_idx < 4; col_idx++, idx++) {
+			idx = 4 * row_idx + col_idx;
+
+			if (start_range == agg_rang_sel[idx])
+				sprintf(partial_str, "%d", agg_rang_sel[idx]);
+			else
+				sprintf(partial_str, "%d~%d", start_range, agg_rang_sel[idx]);
+
+			start_range = agg_rang_sel[idx] + 1;
+			sprintf(full_str + strlen(full_str), "%-11s ", partial_str);
+		}
+
+		idx = 4 * row_idx;
+
+		seq_printf(s, "%s\n", full_str);
+		seq_printf(s, "%13s 0x%-9x 0x%-9x 0x%-9x 0x%-9x\n",
+			row_idx ? "" : "Burst count:",
+			burst_cnt[idx], burst_cnt[idx + 1],
+			burst_cnt[idx + 2], burst_cnt[idx + 3]);
+
+		if (total_burst != 0) {
+			if (row_idx == 0)
+				sprintf(full_str, "%13s ",
+					"Burst ratio:");
+			else
+				sprintf(full_str, "%13s ", "");
+
+			for (col_idx = 0; col_idx < 4; col_idx++) {
+				u64 count = (u64) burst_cnt[idx + col_idx] * 100;
+
+				sprintf(partial_str, "(%llu%%)",
+					div64_u64(count, total_burst));
+				sprintf(full_str + strlen(full_str),
+					"%-11s ", partial_str);
+			}
+
+			seq_printf(s, "%s\n", full_str);
+
+			if (row_idx == 0)
+				sprintf(full_str, "%13s ",
+					"MDPU ratio:");
+			else
+				sprintf(full_str, "%13s ", "");
+
+			for (col_idx = 0; col_idx < 4; col_idx++) {
+				u64 count = ampdu_cnt[idx + col_idx] * 100;
+
+				sprintf(partial_str, "(%llu%%)",
+					div64_u64(count, total_ampdu));
+				sprintf(full_str + strlen(full_str),
+					"%-11s ", partial_str);
+			}
+
+			seq_printf(s, "%s\n", full_str);
+		}
+
+		sprintf(full_str, "%13s ", "");
+	}
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_agginfo);
+
+/* AMSDU INFO */
+static int mt7996_amsdu_result_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	struct mt7996_phy *phy = &dev->phy;
+	struct mt76_mib_stats *mib = &phy->mib;
+	static u32 tx_amsdu_last[8] = {0};
+	static u32 tx_amsdu_cnt_last = 0;
+	u32 tx_amsdu, tx_amsdu_cnt, ratio;
+	int i;
+
+	mutex_lock(&dev->mt76.mutex);
+
+	mt7996_mac_update_stats(phy);
+
+	tx_amsdu_cnt = mib->tx_amsdu_cnt - tx_amsdu_cnt_last;
+
+	seq_puts(s, "Tx MSDU statistics:\n");
+	for (i = 0; i < ARRAY_SIZE(mib->tx_amsdu); i++) {
+		tx_amsdu = mib->tx_amsdu[i] - tx_amsdu_last[i];
+		ratio = tx_amsdu_cnt ? tx_amsdu * 100 / tx_amsdu_cnt : 0;
+
+		seq_printf(s, "AMSDU pack count of %d MSDU in TXD: %8d (%3d%%)\n",
+			   i + 1, tx_amsdu, ratio);
+
+		tx_amsdu_last[i] = mib->tx_amsdu[i];
+	}
+
+	tx_amsdu_cnt_last = mib->tx_amsdu_cnt;
+
+	mutex_unlock(&dev->mt76.mutex);
+
+	return 0;
+}
+
+/* DBG MODLE */
+static int
+mt7996_fw_debug_module_set(void *data, u64 module)
+{
+	struct mt7996_dev *dev = data;
+
+	dev->dbg.fw_dbg_module = module;
+	return 0;
+}
+
+static int
+mt7996_fw_debug_module_get(void *data, u64 *module)
+{
+	struct mt7996_dev *dev = data;
+
+	*module = dev->dbg.fw_dbg_module;
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_fw_debug_module, mt7996_fw_debug_module_get,
+			 mt7996_fw_debug_module_set, "%lld\n");
+
+static int
+mt7996_fw_debug_level_set(void *data, u64 level)
+{
+	struct mt7996_dev *dev = data;
+
+	dev->dbg.fw_dbg_lv = level;
+	mt7996_mcu_fw_dbg_ctrl(dev, dev->dbg.fw_dbg_module, dev->dbg.fw_dbg_lv);
+	return 0;
+}
+
+static int
+mt7996_fw_debug_level_get(void *data, u64 *level)
+{
+	struct mt7996_dev *dev = data;
+
+	*level = dev->dbg.fw_dbg_lv;
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_fw_debug_level, mt7996_fw_debug_level_get,
+			 mt7996_fw_debug_level_set, "%lld\n");
+
+/* usage: echo 0x[arg3][arg2][arg1] > fw_wa_set */
+static int
+mt7996_wa_set(void *data, u64 val)
+{
+	struct mt7996_dev *dev = data;
+	u32 arg1, arg2, arg3;
+
+	arg1 = FIELD_GET(GENMASK_ULL(7, 0), val);
+	arg2 = FIELD_GET(GENMASK_ULL(15, 8), val);
+	arg3 = FIELD_GET(GENMASK_ULL(23, 16), val);
+
+	return mt7996_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(SET),
+				arg1, arg2, arg3);
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_wa_set, NULL, mt7996_wa_set,
+			 "0x%llx\n");
+
+/* usage: echo 0x[arg3][arg2][arg1] > fw_wa_query */
+static int
+mt7996_wa_query(void *data, u64 val)
+{
+	struct mt7996_dev *dev = data;
+	u32 arg1, arg2, arg3;
+
+	arg1 = FIELD_GET(GENMASK_ULL(7, 0), val);
+	arg2 = FIELD_GET(GENMASK_ULL(15, 8), val);
+	arg3 = FIELD_GET(GENMASK_ULL(23, 16), val);
+
+	return mt7996_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(QUERY),
+				arg1, arg2, arg3);
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_wa_query, NULL, mt7996_wa_query,
+			 "0x%llx\n");
+
+static int mt7996_dump_version(struct seq_file *s, void *data)
+{
+#define MAX_ADIE_NUM	3
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	u32 regval;
+	u16 adie_chip_id, adie_chip_ver;
+	int adie_idx;
+	static const char * const fem_type[] = {
+		[MT7996_FEM_EXT] = "eFEM",
+		[MT7996_FEM_INT] = "iFEM",
+		[MT7996_FEM_MIX] = "mixed FEM",
+	};
+
+	seq_printf(s, "Version: 4.4.%02d.%02d\n", PKG_YEAR, PKG_MONTH);
+
+	if (!test_bit(MT76_STATE_MCU_RUNNING, &dev->mphy.state))
+		return 0;
+
+	seq_printf(s, "Rom Patch Build Time: %.16s\n", dev->patch_build_date);
+	seq_printf(s, "WM Patch Build Time: %.15s, Mode: %s\n",
+		   dev->ram_build_date[MT7996_RAM_TYPE_WM],
+		   dev->testmode_enable ? "Testmode" : "Normal mode");
+	seq_printf(s, "WA Patch Build Time: %.15s\n",
+		   dev->ram_build_date[MT7996_RAM_TYPE_WA]);
+	seq_printf(s, "DSP Patch Build Time: %.15s\n",
+		   dev->ram_build_date[MT7996_RAM_TYPE_DSP]);
+	for (adie_idx = 0; adie_idx < MAX_ADIE_NUM; adie_idx++) {
+		mt7996_mcu_rf_regval(dev, MT_ADIE_CHIP_ID(adie_idx), &regval, false);
+		adie_chip_id = FIELD_GET(MT_ADIE_CHIP_ID_MASK, regval);
+		adie_chip_ver = FIELD_GET(MT_ADIE_VERSION_MASK, regval);
+		if (adie_chip_id)
+			seq_printf(s, "Adie %d: ID = 0x%04x, Ver = 0x%04x\n",
+				   adie_idx, adie_chip_id, adie_chip_ver);
+		else
+			seq_printf(s, "Adie %d: ID = N/A, Ver = N/A\n", adie_idx);
+	}
+	seq_printf(s, "FEM type: %s\n", fem_type[dev->var.fem]);
+
+	return 0;
+}
+
+/* fw wm call trace info dump */
+void mt7996_show_lp_history(struct seq_file *s, u32 type)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	struct mt7996_crash_data *crash_data;
+	struct mt7996_coredump *dump;
+	u64 now = 0;
+	int i = 0;
+	u8 fw_type = !!type;
+
+	mutex_lock(&dev->dump_mutex);
+
+	crash_data = mt7996_coredump_new(dev, fw_type);
+	if (!crash_data) {
+		mutex_unlock(&dev->dump_mutex);
+		seq_printf(s, "the coredump is disable!\n");
+		return;
+	}
+	mutex_unlock(&dev->dump_mutex);
+
+	dump = mt7996_coredump_build(dev, fw_type, false);
+	if (!dump) {
+		seq_printf(s, "no call stack data found!\n");
+		return;
+	}
+
+	seq_printf(s, "\x1b[32m%s log output\x1b[0m\n", dump->fw_type);
+	seq_printf(s, "\x1b[32mfw status: %s\n", dump->fw_state);
+	/* PC log */
+	now = jiffies;
+	for (i = 0; i < 10; i++)
+		seq_printf(s, "\tCurrent PC=%x\n", dump->pc_cur[i]);
+
+	seq_printf(s, "PC log contorl=0x%x(T=%llu)(latest PC index = 0x%x)\n",
+		dump->pc_dbg_ctrl, now, dump->pc_cur_idx);
+	for (i = 0; i < 32; i++)
+		seq_printf(s, "\tPC log(%d)=0x%08x\n", i, dump->pc_stack[i]);
+
+	/* LR log */
+	now = jiffies;
+	seq_printf(s, "\nLR log contorl=0x%x(T=%llu)(latest LR index = 0x%x)\n",
+		dump->lr_dbg_ctrl, now, dump->lr_cur_idx);
+	for (i = 0; i < 32; i++)
+		seq_printf(s, "\tLR log(%d)=0x%08x\n", i, dump->lr_stack[i]);
+
+	vfree(dump);
+}
+
+static int mt7996_fw_wa_info_read(struct seq_file *s, void *data)
+{
+	seq_printf(s, "======[ShowPcLpHistory]======\n");
+	mt7996_show_lp_history(s, MT7996_RAM_TYPE_WA);
+	seq_printf(s, "======[End ShowPcLpHistory]==\n");
+
+	return 0;
+}
+
+static int mt7996_fw_wm_info_read(struct seq_file *s, void *data)
+{
+	seq_printf(s, "======[ShowPcLpHistory]======\n");
+	mt7996_show_lp_history(s, MT7996_RAM_TYPE_WM);
+	seq_printf(s, "======[End ShowPcLpHistory]==\n");
+
+	return 0;
+}
+
+/* dma info dump */
+static void
+dump_dma_tx_ring_info(struct seq_file *s, struct mt7996_dev *dev,  char *str1, char *str2, u32 ring_base)
+{
+	u32 base, cnt, cidx, didx, queue_cnt;
+
+	base= mt76_rr(dev, ring_base);
+	cnt = mt76_rr(dev, ring_base + 4);
+	cidx = mt76_rr(dev, ring_base + 8);
+	didx = mt76_rr(dev, ring_base + 12);
+	queue_cnt = (cidx >= didx) ? (cidx - didx) : (cidx - didx + cnt);
+
+	seq_printf(s, "%20s %6s %10x %15x %10x %10x %10x\n", str1, str2, base, cnt, cidx, didx, queue_cnt);
+}
+
+static void
+dump_dma_rx_ring_info(struct seq_file *s, struct mt7996_dev *dev,  char *str1, char *str2, u32 ring_base)
+{
+	u32 base, ctrl1, cnt, cidx, didx, queue_cnt;
+
+	base= mt76_rr(dev, ring_base);
+	ctrl1 = mt76_rr(dev, ring_base + 4);
+	cidx = mt76_rr(dev, ring_base + 8) & 0xfff;
+	didx = mt76_rr(dev, ring_base + 12) & 0xfff;
+	cnt = ctrl1 & 0xfff;
+	queue_cnt = (didx > cidx) ? (didx - cidx - 1) : (didx - cidx + cnt - 1);
+
+	seq_printf(s, "%20s %6s %10x %10x(%3x) %10x %10x %10x\n",
+		   str1, str2, base, ctrl1, cnt, cidx, didx, queue_cnt);
+}
+
+static void
+mt7996_show_dma_info(struct seq_file *s, struct mt7996_dev *dev)
+{
+	u32 sys_ctrl[10];
+
+	/* HOST DMA0 information */
+	sys_ctrl[0] = mt76_rr(dev, WF_WFDMA_HOST_DMA0_HOST_INT_STA_ADDR);
+	sys_ctrl[1] = mt76_rr(dev, WF_WFDMA_HOST_DMA0_HOST_INT_ENA_ADDR);
+	sys_ctrl[2] = mt76_rr(dev, WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_ADDR);
+
+	seq_printf(s, "HOST_DMA Configuration\n");
+	seq_printf(s, "%10s %10s %10s %10s %10s %10s\n",
+		"DMA", "IntCSR", "IntMask", "Glocfg", "Tx/RxEn", "Tx/RxBusy");
+	seq_printf(s, "%10s %10x %10x %10x %4x/%5x %4x/%5x\n",
+		"DMA0", sys_ctrl[0], sys_ctrl[1], sys_ctrl[2],
+		(sys_ctrl[2] & WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_MASK)
+			>> WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_SHFT,
+		(sys_ctrl[2] & WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_MASK)
+			>> WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_SHFT,
+		(sys_ctrl[2] & WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK)
+			>> WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT,
+		(sys_ctrl[2] & WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK)
+			>> WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT);
+
+	if (dev->hif2) {
+		/* HOST DMA1 information */
+		sys_ctrl[0] = mt76_rr(dev, WF_WFDMA_HOST_DMA0_PCIE1_HOST_INT_STA_ADDR);
+		sys_ctrl[1] = mt76_rr(dev, WF_WFDMA_HOST_DMA0_PCIE1_HOST_INT_ENA_ADDR);
+		sys_ctrl[2] = mt76_rr(dev, WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_ADDR);
+
+		seq_printf(s, "%10s %10x %10x %10x %4x/%5x %4x/%5x\n",
+			"DMA0P1", sys_ctrl[0], sys_ctrl[1], sys_ctrl[2],
+			(sys_ctrl[2] & WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_TX_DMA_EN_MASK)
+				>> WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_TX_DMA_EN_SHFT,
+			(sys_ctrl[2] & WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_RX_DMA_EN_MASK)
+				>> WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_RX_DMA_EN_SHFT,
+			(sys_ctrl[2] & WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK)
+				>> WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT,
+			(sys_ctrl[2] & WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK)
+				>> WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT);
+	}
+
+	seq_printf(s, "HOST_DMA0 Ring Configuration\n");
+	seq_printf(s, "%20s %6s %10s %15s %10s %10s %10s\n",
+		"Name", "Used", "Base", "Ctrl1(Cnt)", "CIDX", "DIDX", "QCnt");
+	dump_dma_tx_ring_info(s, dev, "T0:TXD0(H2MAC)", "STA",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING0_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T1:TXD1(H2MAC)", "STA",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING1_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T2:TXD2(H2MAC)", "STA",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING2_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T3:", "STA",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING3_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T4:", "STA",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING4_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T5:", "STA",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING5_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T6:", "STA",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING6_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T16:FWDL", "Both",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING16_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T17:Cmd(H2WM)", "Both",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING17_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T18:TXD0(H2WA)", "AP",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING18_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T19:TXD1(H2WA)", "AP",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING19_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T20:Cmd(H2WA)", "AP",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING20_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T21:TXD2(H2WA)", "AP",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING21_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T22:TXD3(H2WA)", "AP",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING22_CTRL0_ADDR);
+
+
+	dump_dma_rx_ring_info(s, dev, "R0:Event(WM2H)", "Both",
+		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING0_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R1:Event(WA2H)", "AP",
+		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING1_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R2:TxDone0(WA2H)", "AP",
+		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING2_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R3:TxDone1(WA2H)", "AP",
+		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING3_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R4:Data0(MAC2H)", "Both",
+		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING4_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R5:Data1(MAC2H)", "Both",
+		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING5_CTRL0_ADDR);
+	if (is_mt7996(&dev->mt76))
+		dump_dma_rx_ring_info(s, dev, "R6:BUF1(MAC2H)", "Both",
+			WF_WFDMA_HOST_DMA0_WPDMA_RX_RING6_CTRL0_ADDR);
+	else
+		dump_dma_rx_ring_info(s, dev, "R6:TxDone0(MAC2H)", "Both",
+			WF_WFDMA_HOST_DMA0_WPDMA_RX_RING6_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R7:TxDone1(MAC2H)", "Both",
+		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING7_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R8:BUF0(MAC2H)", "Both",
+		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING8_CTRL0_ADDR);
+	if (is_mt7996(&dev->mt76))
+		dump_dma_rx_ring_info(s, dev, "R9:TxDone0(MAC2H)", "Both",
+			WF_WFDMA_HOST_DMA0_WPDMA_RX_RING9_CTRL0_ADDR);
+	else
+		dump_dma_rx_ring_info(s, dev, "R9:BUF0(MAC2H)", "Both",
+			WF_WFDMA_HOST_DMA0_WPDMA_RX_RING9_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R10:MSDU_PG0(MAC2H)", "Both",
+		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING10_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R11:MSDU_PG1(MAC2H)", "Both",
+		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING11_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R12:MSDU_PG2(MAC2H)", "Both",
+		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING12_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "IND:IND_CMD(MAC2H)", "Both",
+		WF_RRO_TOP_IND_CMD_0_CTRL0_ADDR);
+
+	if (dev->hif2) {
+		seq_printf(s, "HOST_DMA0 PCIe1 Ring Configuration\n");
+		seq_printf(s, "%20s %6s %10s %15s %10s %10s %10s\n",
+			"Name", "Used", "Base", "Ctrl1(Cnt)", "CIDX", "DIDX", "QCnt");
+		dump_dma_tx_ring_info(s, dev, "T21:TXD2(H2WA)", "AP",
+			WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING21_CTRL0_ADDR);
+		dump_dma_tx_ring_info(s, dev, "T22:TXD?(H2WA)", "AP",
+			WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING22_CTRL0_ADDR);
+		dump_dma_rx_ring_info(s, dev, "R3:TxDone1(WA2H)", "AP",
+			WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING3_CTRL0_ADDR);
+		dump_dma_rx_ring_info(s, dev, "R5:Data1(MAC2H)", "Both",
+			WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING5_CTRL0_ADDR);
+		if (is_mt7996(&dev->mt76))
+			dump_dma_rx_ring_info(s, dev, "R6:BUF1(MAC2H)", "Both",
+				WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING6_CTRL0_ADDR);
+		dump_dma_rx_ring_info(s, dev, "R7:TxDone1(MAC2H)", "Both",
+			WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING7_CTRL0_ADDR);
+		if (is_mt7992(&dev->mt76))
+			dump_dma_rx_ring_info(s, dev, "R9:BUF1(MAC2H)", "Both",
+				WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING9_CTRL0_ADDR);
+	}
+
+	/* MCU DMA information */
+	sys_ctrl[0] = mt76_rr(dev, WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_ADDR);
+	sys_ctrl[1] = mt76_rr(dev, WF_WFDMA_MCU_DMA0_HOST_INT_STA_ADDR);
+	sys_ctrl[2] = mt76_rr(dev, WF_WFDMA_MCU_DMA0_HOST_INT_ENA_ADDR);
+
+	seq_printf(s, "MCU_DMA Configuration\n");
+	seq_printf(s, "%10s %10s %10s %10s %10s %10s\n",
+		"DMA", "IntCSR", "IntMask", "Glocfg", "Tx/RxEn", "Tx/RxBusy");
+	seq_printf(s, "%10s %10x %10x %10x %4x/%5x %4x/%5x\n",
+		"DMA0", sys_ctrl[1], sys_ctrl[2], sys_ctrl[0],
+		(sys_ctrl[0] & WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_MASK)
+			>> WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_SHFT,
+		(sys_ctrl[0] & WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_MASK)
+			>> WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_SHFT,
+		(sys_ctrl[0] & WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK)
+			>> WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT,
+		(sys_ctrl[0] & WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK)
+			>> WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT);
+
+	seq_printf(s, "MCU_DMA0 Ring Configuration\n");
+	seq_printf(s, "%20s %6s %10s %15s %10s %10s %10s\n",
+		"Name", "Used", "Base", "Cnt", "CIDX", "DIDX", "QCnt");
+	dump_dma_tx_ring_info(s, dev, "T0:Event(WM2H)", "Both",
+		WF_WFDMA_MCU_DMA0_WPDMA_TX_RING0_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T1:Event(WA2H)", "AP",
+		WF_WFDMA_MCU_DMA0_WPDMA_TX_RING1_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T2:TxDone0(WA2H)", "AP",
+		WF_WFDMA_MCU_DMA0_WPDMA_TX_RING2_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T3:TxDone1(WA2H)", "AP",
+		WF_WFDMA_MCU_DMA0_WPDMA_TX_RING3_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T4:TXD(WM2MAC)", "Both",
+		WF_WFDMA_MCU_DMA0_WPDMA_TX_RING4_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T5:TXCMD(WM2MAC)", "Both",
+		WF_WFDMA_MCU_DMA0_WPDMA_TX_RING5_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T6:TXD(WA2MAC)", "AP",
+		WF_WFDMA_MCU_DMA0_WPDMA_TX_RING6_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R0:FWDL", "Both",
+		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING0_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R1:Cmd(H2WM)", "Both",
+		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING1_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R2:TXD0(H2WA)", "AP",
+		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING2_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R3:TXD1(H2WA)", "AP",
+		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING3_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R4:Cmd(H2WA)", "AP",
+		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING4_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R5:Data0(MAC2WM)", "Both",
+		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING5_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R6:TxDone(MAC2WM)", "Both",
+		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING6_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R7:SPL/RPT(MAC2WM)", "Both",
+		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING7_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R8:TxDone(MAC2WA)", "AP",
+		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING8_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R9:Data1(MAC2WM)", "Both",
+		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING9_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R10:TXD2(H2WA)", "AP",
+		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING10_CTRL0_ADDR);
+
+	/* MEM DMA information */
+	sys_ctrl[0] = mt76_rr(dev, WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_ADDR);
+	sys_ctrl[1] = mt76_rr(dev, WF_WFDMA_MEM_DMA_HOST_INT_STA_ADDR);
+	sys_ctrl[2] = mt76_rr(dev, WF_WFDMA_MEM_DMA_HOST_INT_ENA_ADDR);
+
+	seq_printf(s, "MEM_DMA Configuration\n");
+	seq_printf(s, "%10s %10s %10s %10s %10s %10s\n",
+		"DMA", "IntCSR", "IntMask", "Glocfg", "Tx/RxEn", "Tx/RxBusy");
+	seq_printf(s, "%10s %10x %10x %10x %4x/%5x %4x/%5x\n",
+		"MEM", sys_ctrl[1], sys_ctrl[2], sys_ctrl[0],
+		(sys_ctrl[0] & WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_EN_MASK)
+			>> WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_EN_SHFT,
+		(sys_ctrl[0] & WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_EN_MASK)
+			>> WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_EN_SHFT,
+		(sys_ctrl[0] & WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK)
+			>> WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT,
+		(sys_ctrl[0] & WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK)
+			>> WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT);
+
+	seq_printf(s, "MEM_DMA Ring Configuration\n");
+	seq_printf(s, "%20s %6s %10s %10s %10s %10s %10s\n",
+		"Name", "Used", "Base", "Cnt", "CIDX", "DIDX", "QCnt");
+	dump_dma_tx_ring_info(s, dev, "T0:CmdEvent(WM2WA)", "AP",
+		WF_WFDMA_MEM_DMA_WPDMA_TX_RING0_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T1:CmdEvent(WA2WM)", "AP",
+		WF_WFDMA_MEM_DMA_WPDMA_TX_RING1_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R0:CmdEvent(WM2WA)", "AP",
+		WF_WFDMA_MEM_DMA_WPDMA_RX_RING0_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R1:CmdEvent(WA2WM)", "AP",
+		WF_WFDMA_MEM_DMA_WPDMA_RX_RING1_CTRL0_ADDR);
+}
+
+static int mt7996_trinfo_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	mt7996_show_dma_info(s, dev);
+	return 0;
+}
+
+/* MIB INFO */
+static int mt7996_mibinfo_show(struct seq_file *s, void *data)
+{
+#define BSS_NUM	4
+	struct mt7996_phy *phy = s->private;
+	struct mt7996_dev *dev = phy->dev;
+	u8 band_idx = phy->mt76->band_idx;
+	u8 bss_nums = BSS_NUM;
+	u32 idx;
+	u32 mac_val, band_offset = 0, band_offset_umib = 0;
+	u32 msdr6, msdr9, msdr18;
+	u32 rvsr0, rscr26, rscr35, mctr5, mctr6, msr0, msr1, msr2;
+	u32 tbcr0, tbcr1, tbcr2, tbcr3, tbcr4;
+	u32 btscr[7];
+	u32 tdrcr[5];
+	u32 mbtocr[16], mbtbcr[16], mbrocr[16], mbrbcr[16];
+	u32 btcr, btbcr, brocr, brbcr, btdcr, brdcr;
+	u32 mu_cnt[5];
+	u32 ampdu_cnt[3];
+	u64 per = 0;
+
+	switch (band_idx) {
+	case 0:
+		band_offset = 0;
+		band_offset_umib = 0;
+		break;
+	case 1:
+		band_offset = BN1_WF_MIB_TOP_BASE - BN0_WF_MIB_TOP_BASE;
+		band_offset_umib = WF_UMIB_TOP_B1BROCR_ADDR - WF_UMIB_TOP_B0BROCR_ADDR;
+		break;
+	case 2:
+		band_offset = IP1_BN0_WF_MIB_TOP_BASE - BN0_WF_MIB_TOP_BASE;
+		band_offset_umib = WF_UMIB_TOP_B2BROCR_ADDR - WF_UMIB_TOP_B0BROCR_ADDR;
+		break;
+	default:
+		return true;
+	}
+
+	seq_printf(s, "Band %d MIB Status\n", band_idx);
+	seq_printf(s, "===============================\n");
+	mac_val = mt76_rr(dev, BN0_WF_MIB_TOP_M0SCR0_ADDR + band_offset);
+	seq_printf(s, "MIB Status Control=0x%x\n", mac_val);
+
+	msdr6 = mt76_rr(dev, BN0_WF_MIB_TOP_M0SDR6_ADDR + band_offset);
+	rvsr0 = mt76_rr(dev, BN0_WF_MIB_TOP_RVSR0_ADDR + band_offset);
+	rscr35 = mt76_rr(dev, BN0_WF_MIB_TOP_RSCR35_ADDR + band_offset);
+	msdr9 = mt76_rr(dev, BN0_WF_MIB_TOP_M0SDR9_ADDR + band_offset);
+	rscr26 = mt76_rr(dev, BN0_WF_MIB_TOP_RSCR26_ADDR + band_offset);
+	mctr5 = mt76_rr(dev, BN0_WF_MIB_TOP_MCTR5_ADDR + band_offset);
+	mctr6 = mt76_rr(dev, BN0_WF_MIB_TOP_MCTR6_ADDR + band_offset);
+	msdr18 = mt76_rr(dev, BN0_WF_MIB_TOP_M0SDR18_ADDR + band_offset);
+	msr0 = mt76_rr(dev, BN0_WF_MIB_TOP_MSR0_ADDR + band_offset);
+	msr1 = mt76_rr(dev, BN0_WF_MIB_TOP_MSR1_ADDR + band_offset);
+	msr2 = mt76_rr(dev, BN0_WF_MIB_TOP_MSR2_ADDR + band_offset);
+	ampdu_cnt[0] = mt76_rr(dev, BN0_WF_MIB_TOP_TSCR0_ADDR + band_offset);
+	ampdu_cnt[1] = mt76_rr(dev, BN0_WF_MIB_TOP_TSCR3_ADDR + band_offset);
+	ampdu_cnt[2] = mt76_rr(dev, BN0_WF_MIB_TOP_TSCR4_ADDR + band_offset);
+	ampdu_cnt[1] &= BN0_WF_MIB_TOP_TSCR3_AMPDU_MPDU_COUNT_MASK;
+	ampdu_cnt[2] &= BN0_WF_MIB_TOP_TSCR4_AMPDU_ACKED_COUNT_MASK;
+
+	seq_printf(s, "===Phy/Timing Related Counters===\n");
+	seq_printf(s, "\tChannelIdleCnt=0x%x\n",
+		msdr6 & BN0_WF_MIB_TOP_M0SDR6_CHANNEL_IDLE_COUNT_MASK);
+	seq_printf(s, "\tCCA_NAV_Tx_Time=0x%x\n",
+		msdr9 & BN0_WF_MIB_TOP_M0SDR9_CCA_NAV_TX_TIME_MASK);
+	seq_printf(s, "\tRx_MDRDY_CNT=0x%x\n",
+		rscr26 & BN0_WF_MIB_TOP_RSCR26_RX_MDRDY_COUNT_MASK);
+	seq_printf(s, "\tCCK_MDRDY_TIME=0x%x, OFDM_MDRDY_TIME=0x%x",
+		msr0 & BN0_WF_MIB_TOP_MSR0_CCK_MDRDY_TIME_MASK,
+		msr1 & BN0_WF_MIB_TOP_MSR1_OFDM_LG_MIXED_VHT_MDRDY_TIME_MASK);
+	seq_printf(s, ", OFDM_GREEN_MDRDY_TIME=0x%x\n",
+		msr2 & BN0_WF_MIB_TOP_MSR2_OFDM_GREEN_MDRDY_TIME_MASK);
+	seq_printf(s, "\tPrim CCA Time=0x%x\n",
+		mctr5 & BN0_WF_MIB_TOP_MCTR5_P_CCA_TIME_MASK);
+	seq_printf(s, "\tSec CCA Time=0x%x\n",
+		mctr6 & BN0_WF_MIB_TOP_MCTR6_S_CCA_TIME_MASK);
+	seq_printf(s, "\tPrim ED Time=0x%x\n",
+		msdr18 & BN0_WF_MIB_TOP_M0SDR18_P_ED_TIME_MASK);
+
+	seq_printf(s, "===Tx Related Counters(Generic)===\n");
+	mac_val = mt76_rr(dev, BN0_WF_MIB_TOP_TSCR18_ADDR + band_offset);
+	dev->dbg.bcn_total_cnt[band_idx] +=
+		(mac_val & BN0_WF_MIB_TOP_TSCR18_BEACONTXCOUNT_MASK);
+	seq_printf(s, "\tBeaconTxCnt=0x%x\n", dev->dbg.bcn_total_cnt[band_idx]);
+	dev->dbg.bcn_total_cnt[band_idx] = 0;
+
+	tbcr0 = mt76_rr(dev, BN0_WF_MIB_TOP_TBCR0_ADDR + band_offset);
+	seq_printf(s, "\tTx 20MHz Cnt=0x%x\n",
+		tbcr0 & BN0_WF_MIB_TOP_TBCR0_TX_20MHZ_CNT_MASK);
+	tbcr1 = mt76_rr(dev, BN0_WF_MIB_TOP_TBCR1_ADDR + band_offset);
+	seq_printf(s, "\tTx 40MHz Cnt=0x%x\n",
+		tbcr1 & BN0_WF_MIB_TOP_TBCR1_TX_40MHZ_CNT_MASK);
+	tbcr2 = mt76_rr(dev, BN0_WF_MIB_TOP_TBCR2_ADDR + band_offset);
+	seq_printf(s, "\tTx 80MHz Cnt=0x%x\n",
+		tbcr2 & BN0_WF_MIB_TOP_TBCR2_TX_80MHZ_CNT_MASK);
+	tbcr3 = mt76_rr(dev, BN0_WF_MIB_TOP_TBCR3_ADDR + band_offset);
+	seq_printf(s, "\tTx 160MHz Cnt=0x%x\n",
+		tbcr3 & BN0_WF_MIB_TOP_TBCR3_TX_160MHZ_CNT_MASK);
+	tbcr4 = mt76_rr(dev, BN0_WF_MIB_TOP_TBCR4_ADDR + band_offset);
+	seq_printf(s, "\tTx 320MHz Cnt=0x%x\n",
+		tbcr4 & BN0_WF_MIB_TOP_TBCR4_TX_320MHZ_CNT_MASK);
+	seq_printf(s, "\tAMPDU Cnt=0x%x\n", ampdu_cnt[0]);
+	seq_printf(s, "\tAMPDU MPDU Cnt=0x%x\n", ampdu_cnt[1]);
+	seq_printf(s, "\tAMPDU MPDU Ack Cnt=0x%x\n", ampdu_cnt[2]);
+	if (ampdu_cnt[1])
+		per = (u64)1000 * (ampdu_cnt[1] - ampdu_cnt[2]) / ampdu_cnt[1];
+	seq_printf(s, "\tAMPDU MPDU PER=%llu.%1llu%%\n", per / 10, per % 10);
+
+	seq_printf(s, "===MU Related Counters===\n");
+	mu_cnt[0] = mt76_rr(dev, BN0_WF_MIB_TOP_BSCR2_ADDR + band_offset);
+	mu_cnt[1] = mt76_rr(dev, BN0_WF_MIB_TOP_TSCR5_ADDR + band_offset);
+	mu_cnt[2] = mt76_rr(dev, BN0_WF_MIB_TOP_TSCR6_ADDR + band_offset);
+	mu_cnt[3] = mt76_rr(dev, BN0_WF_MIB_TOP_TSCR8_ADDR + band_offset);
+	mu_cnt[4] = mt76_rr(dev, BN0_WF_MIB_TOP_TSCR7_ADDR + band_offset);
+
+	seq_printf(s, "\tMUBF_TX_COUNT=0x%x\n",
+		mu_cnt[0] & BN0_WF_MIB_TOP_BSCR2_MUBF_TX_COUNT_MASK);
+	seq_printf(s, "\tMU_TX_MPDU_COUNT(Ok+Fail)=0x%x\n", mu_cnt[1]);
+	seq_printf(s, "\tMU_TX_OK_MPDU_COUNT=0x%x\n", mu_cnt[2]);
+	seq_printf(s, "\tSU_TX_MPDU_COUNT(Ok+Fail)=0x%x\n", mu_cnt[3]);
+	seq_printf(s, "\tSU_TX_OK_MPDU_COUNT=0x%x\n", mu_cnt[4]);
+
+	seq_printf(s, "===Rx Related Counters(Generic)===\n");
+	seq_printf(s, "\tVector Mismacth Cnt=0x%x\n",
+		rvsr0 & BN0_WF_MIB_TOP_RVSR0_VEC_MISS_COUNT_MASK);
+	seq_printf(s, "\tDelimiter Fail Cnt=0x%x\n",
+		rscr35 & BN0_WF_MIB_TOP_RSCR35_DELIMITER_FAIL_COUNT_MASK);
+
+	mac_val = mt76_rr(dev, BN0_WF_MIB_TOP_RSCR1_ADDR + band_offset);
+	seq_printf(s, "\tRxFCSErrCnt=0x%x\n",
+		(mac_val & BN0_WF_MIB_TOP_RSCR1_RX_FCS_ERROR_COUNT_MASK));
+	mac_val = mt76_rr(dev, BN0_WF_MIB_TOP_RSCR33_ADDR + band_offset);
+	seq_printf(s, "\tRxFifoFullCnt=0x%x\n",
+		(mac_val & BN0_WF_MIB_TOP_RSCR33_RX_FIFO_FULL_COUNT_MASK));
+	mac_val = mt76_rr(dev, BN0_WF_MIB_TOP_RSCR36_ADDR + band_offset);
+	seq_printf(s, "\tRxLenMismatch=0x%x\n",
+		(mac_val & BN0_WF_MIB_TOP_RSCR36_RX_LEN_MISMATCH_MASK));
+	mac_val = mt76_rr(dev, BN0_WF_MIB_TOP_RSCR31_ADDR + band_offset);
+	seq_printf(s, "\tRxMPDUCnt=0x%x\n",
+		(mac_val & BN0_WF_MIB_TOP_RSCR31_RX_MPDU_COUNT_MASK));
+	mac_val = mt76_rr(dev, BN0_WF_MIB_TOP_RSCR27_ADDR + band_offset);
+	seq_printf(s, "\tRx AMPDU Cnt=0x%x\n", mac_val);
+	mac_val = mt76_rr(dev, BN0_WF_MIB_TOP_RSCR28_ADDR + band_offset);
+	seq_printf(s, "\tRx Total ByteCnt=0x%x\n", mac_val);
+
+
+	/* Per-BSS T/RX Counters */
+	seq_printf(s, "===Per-BSS Related Tx/Rx Counters===\n");
+	seq_printf(s, "BSS Idx TxCnt/DataCnt TxByteCnt RxOkCnt/DataCnt RxByteCnt\n");
+	for (idx = 0; idx < bss_nums; idx++) {
+		btcr = mt76_rr(dev, BN0_WF_MIB_TOP_BTCR_ADDR + band_offset + idx * 4);
+		btdcr = mt76_rr(dev, BN0_WF_MIB_TOP_BTDCR_ADDR + band_offset + idx * 4);
+		btbcr = mt76_rr(dev, BN0_WF_MIB_TOP_BTBCR_ADDR + band_offset + idx * 4);
+
+		brocr = mt76_rr(dev, WF_UMIB_TOP_B0BROCR_ADDR + band_offset_umib + idx * 4);
+		brdcr = mt76_rr(dev, WF_UMIB_TOP_B0BRDCR_ADDR + band_offset_umib + idx * 4);
+		brbcr = mt76_rr(dev, WF_UMIB_TOP_B0BRBCR_ADDR + band_offset_umib + idx * 4);
+
+		seq_printf(s, "%d\t 0x%x/0x%x\t 0x%x \t 0x%x/0x%x \t 0x%x\n",
+			idx, btcr, btdcr, btbcr, brocr, brdcr, brbcr);
+	}
+
+	seq_printf(s, "===Per-BSS Related MIB Counters===\n");
+	seq_printf(s, "BSS Idx RTSTx/RetryCnt BAMissCnt AckFailCnt FrmRetry1/2/3Cnt\n");
+
+	/* Per-BSS TX Status */
+	for (idx = 0; idx < bss_nums; idx++) {
+		btscr[0] = mt76_rr(dev, BN0_WF_MIB_TOP_BTSCR5_ADDR + band_offset + idx * 4);
+		btscr[1] = mt76_rr(dev, BN0_WF_MIB_TOP_BTSCR6_ADDR + band_offset + idx * 4);
+		btscr[2] = mt76_rr(dev, BN0_WF_MIB_TOP_BTSCR0_ADDR + band_offset + idx * 4);
+		btscr[3] = mt76_rr(dev, BN0_WF_MIB_TOP_BTSCR1_ADDR + band_offset + idx * 4);
+		btscr[4] = mt76_rr(dev, BN0_WF_MIB_TOP_BTSCR2_ADDR + band_offset + idx * 4);
+		btscr[5] = mt76_rr(dev, BN0_WF_MIB_TOP_BTSCR3_ADDR + band_offset + idx * 4);
+		btscr[6] = mt76_rr(dev, BN0_WF_MIB_TOP_BTSCR4_ADDR + band_offset + idx * 4);
+
+		seq_printf(s, "%d:\t0x%x/0x%x  0x%x \t 0x%x \t  0x%x/0x%x/0x%x\n",
+			idx, (btscr[0] & BN0_WF_MIB_TOP_BTSCR5_RTSTXCOUNTn_MASK),
+			(btscr[1] & BN0_WF_MIB_TOP_BTSCR6_RTSRETRYCOUNTn_MASK),
+			(btscr[2] & BN0_WF_MIB_TOP_BTSCR0_BAMISSCOUNTn_MASK),
+			(btscr[3] & BN0_WF_MIB_TOP_BTSCR1_ACKFAILCOUNTn_MASK),
+			(btscr[4] & BN0_WF_MIB_TOP_BTSCR2_FRAMERETRYCOUNTn_MASK),
+			(btscr[5] & BN0_WF_MIB_TOP_BTSCR3_FRAMERETRY2COUNTn_MASK),
+			(btscr[6] & BN0_WF_MIB_TOP_BTSCR4_FRAMERETRY3COUNTn_MASK));
+	}
+
+	/* Dummy delimiter insertion result */
+	seq_printf(s, "===Dummy delimiter insertion result===\n");
+	tdrcr[0] = mt76_rr(dev, BN0_WF_MIB_TOP_TDRCR0_ADDR + band_offset);
+	tdrcr[1] = mt76_rr(dev, BN0_WF_MIB_TOP_TDRCR1_ADDR + band_offset);
+	tdrcr[2] = mt76_rr(dev, BN0_WF_MIB_TOP_TDRCR2_ADDR + band_offset);
+	tdrcr[3] = mt76_rr(dev, BN0_WF_MIB_TOP_TDRCR3_ADDR + band_offset);
+	tdrcr[4] = mt76_rr(dev, BN0_WF_MIB_TOP_TDRCR4_ADDR + band_offset);
+
+	seq_printf(s, "Range0 = %d\t Range1 = %d\t Range2 = %d\t Range3 = %d\t Range4 = %d\n",
+		tdrcr[0],
+		tdrcr[1],
+		tdrcr[2],
+		tdrcr[3],
+		tdrcr[4]);
+
+	/* Per-MBSS T/RX Counters */
+	seq_printf(s, "===Per-MBSS Related Tx/Rx Counters===\n");
+	seq_printf(s, "MBSSIdx   TxOkCnt  TxByteCnt  RxOkCnt  RxByteCnt\n");
+
+	for (idx = 0; idx < 16; idx++) {
+		mbtocr[idx] = mt76_rr(dev, BN0_WF_MIB_TOP_BTOCR_ADDR + band_offset + (bss_nums + idx) * 4);
+		mbtbcr[idx] = mt76_rr(dev, BN0_WF_MIB_TOP_BTBCR_ADDR + band_offset + (bss_nums + idx) * 4);
+
+		mbrocr[idx] = mt76_rr(dev, WF_UMIB_TOP_B0BROCR_ADDR + band_offset_umib + (bss_nums + idx) * 4);
+		mbrbcr[idx] = mt76_rr(dev, WF_UMIB_TOP_B0BRBCR_ADDR + band_offset_umib + (bss_nums + idx) * 4);
+	}
+
+	for (idx = 0; idx < 16; idx++) {
+		seq_printf(s, "%d\t 0x%x\t 0x%x \t 0x%x \t 0x%x\n",
+			idx, mbtocr[idx], mbtbcr[idx], mbrocr[idx], mbrbcr[idx]);
+	}
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_mibinfo);
+
+/* WTBL INFO */
+static int
+mt7996_wtbl_read_raw(struct mt7996_dev *dev, u16 idx,
+		     enum mt7996_wtbl_type type, u16 start_dw,
+		     u16 len, void *buf)
+{
+	u32 *dest_cpy = (u32 *)buf;
+	u32 size_dw = len;
+	u32 src = 0;
+
+	if (!buf)
+		return 0xFF;
+
+	if (type == WTBL_TYPE_LMAC) {
+		mt76_wr(dev, MT_DBG_WTBLON_TOP_WDUCR_ADDR,
+			FIELD_PREP(MT_DBG_WTBLON_TOP_WDUCR_GROUP, (idx >> 7)));
+		src = LWTBL_IDX2BASE(idx, start_dw);
+	} else if (type == WTBL_TYPE_UMAC) {
+		mt76_wr(dev,  MT_DBG_UWTBL_TOP_WDUCR_ADDR,
+			FIELD_PREP(MT_DBG_UWTBL_TOP_WDUCR_GROUP, (idx >> 7)));
+		src = UWTBL_IDX2BASE(idx, start_dw);
+	} else if (type == WTBL_TYPE_KEY) {
+		mt76_wr(dev,  MT_DBG_UWTBL_TOP_WDUCR_ADDR,
+			MT_DBG_UWTBL_TOP_WDUCR_TARGET |
+			FIELD_PREP(MT_DBG_UWTBL_TOP_WDUCR_GROUP, (idx >> 7)));
+		src = KEYTBL_IDX2BASE(idx, start_dw);
+	}
+
+	while (size_dw--) {
+		*dest_cpy++ = mt76_rr(dev, src);
+		src += 4;
+	};
+
+	return 0;
+}
+
+#if 0
+static int
+mt7996_wtbl_write_raw(struct mt7996_dev *dev, u16 idx,
+			  enum mt7996_wtbl_type type, u16 start_dw,
+			  u32 val)
+{
+	u32 addr = 0;
+
+	if (type == WTBL_TYPE_LMAC) {
+		mt76_wr(dev, MT_DBG_WTBLON_TOP_WDUCR_ADDR,
+			FIELD_PREP(MT_DBG_WTBLON_TOP_WDUCR_GROUP, (idx >> 7)));
+		addr = LWTBL_IDX2BASE(idx, start_dw);
+	} else if (type == WTBL_TYPE_UMAC) {
+		mt76_wr(dev, MT_DBG_UWTBL_TOP_WDUCR_ADDR,
+			FIELD_PREP(MT_DBG_UWTBL_TOP_WDUCR_GROUP, (idx >> 7)));
+		addr = UWTBL_IDX2BASE(idx, start_dw);
+	} else if (type == WTBL_TYPE_KEY) {
+		mt76_wr(dev, MT_DBG_UWTBL_TOP_WDUCR_ADDR,
+			MT_DBG_UWTBL_TOP_WDUCR_TARGET |
+			FIELD_PREP(MT_DBG_UWTBL_TOP_WDUCR_GROUP, (idx >> 7)));
+		addr = KEYTBL_IDX2BASE(idx, start_dw);
+	}
+
+	mt76_wr(dev, addr, val);
+
+	return 0;
+}
+#endif
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW0[] = {
+	{"MUAR_IDX",	WF_LWTBL_MUAR_MASK,	WF_LWTBL_MUAR_SHIFT,	false},
+	{"RCA1",	WF_LWTBL_RCA1_MASK,	NO_SHIFT_DEFINE,	false},
+	{"KID",		WF_LWTBL_KID_MASK,	WF_LWTBL_KID_SHIFT,	false},
+	{"RCID",	WF_LWTBL_RCID_MASK,	NO_SHIFT_DEFINE,	false},
+	{"BAND",	WF_LWTBL_BAND_MASK,	WF_LWTBL_BAND_SHIFT,	false},
+	{"RV",		WF_LWTBL_RV_MASK,	NO_SHIFT_DEFINE,	false},
+	{"RCA2",	WF_LWTBL_RCA2_MASK,	NO_SHIFT_DEFINE,	false},
+	{"WPI_FLAG",	WF_LWTBL_WPI_FLAG_MASK,	NO_SHIFT_DEFINE,	true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw0_1(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LinkAddr: %02x:%02x:%02x:%02x:%02x:%02x(D0[B0~15], D1[B0~31])\n",
+		lwtbl[4], lwtbl[5], lwtbl[6], lwtbl[7], lwtbl[0], lwtbl[1]);
+
+	/* LMAC WTBL DW 0 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 0/1\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_PEER_INFO_DW_0*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW0[i].name) {
+
+		if (WTBL_LMAC_DW0[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW0[i].name,
+					 (dw_value & WTBL_LMAC_DW0[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW0[i].name,
+					  (dw_value & WTBL_LMAC_DW0[i].mask) >> WTBL_LMAC_DW0[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse *WTBL_LMAC_DW2;
+static const struct berse_wtbl_parse WTBL_LMAC_DW2_7996[] = {
+	{"AID",			WF_LWTBL_AID_MASK,		WF_LWTBL_AID_SHIFT,			false},
+	{"GID_SU",		WF_LWTBL_GID_SU_MASK,		NO_SHIFT_DEFINE,			false},
+	{"SPP_EN",		WF_LWTBL_SPP_EN_MASK,		NO_SHIFT_DEFINE,			false},
+	{"WPI_EVEN",		WF_LWTBL_WPI_EVEN_MASK,		NO_SHIFT_DEFINE,			false},
+	{"AAD_OM",		WF_LWTBL_AAD_OM_MASK,		NO_SHIFT_DEFINE,			false},
+	{"CIPHER_PGTK",		WF_LWTBL_CIPHER_SUIT_PGTK_MASK,	WF_LWTBL_CIPHER_SUIT_PGTK_SHIFT,	true},
+	{"FROM_DS",		WF_LWTBL_FD_MASK,		NO_SHIFT_DEFINE,			false},
+	{"TO_DS",		WF_LWTBL_TD_MASK,		NO_SHIFT_DEFINE,			false},
+	{"SW",			WF_LWTBL_SW_MASK,		NO_SHIFT_DEFINE,			false},
+	{"UL",			WF_LWTBL_UL_MASK,		NO_SHIFT_DEFINE,			false},
+	{"TX_POWER_SAVE",	WF_LWTBL_TX_PS_MASK,		NO_SHIFT_DEFINE,			true},
+	{"QOS",			WF_LWTBL_QOS_MASK,		NO_SHIFT_DEFINE,			false},
+	{"HT",			WF_LWTBL_HT_MASK,		NO_SHIFT_DEFINE,			false},
+	{"VHT",			WF_LWTBL_VHT_MASK,		NO_SHIFT_DEFINE,			false},
+	{"HE",			WF_LWTBL_HE_MASK,		NO_SHIFT_DEFINE,			false},
+	{"EHT",			WF_LWTBL_EHT_MASK,		NO_SHIFT_DEFINE,			false},
+	{"MESH",		WF_LWTBL_MESH_MASK,		NO_SHIFT_DEFINE,			true},
+	{NULL,}
+};
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW2_7992[] = {
+	{"AID",			WF_LWTBL_AID_MASK,		WF_LWTBL_AID_SHIFT,			false},
+	{"GID_SU",		WF_LWTBL_GID_SU_MASK,		NO_SHIFT_DEFINE,			false},
+	{"DUAL_PTEC_EN",	WF_LWTBL_DUAL_PTEC_EN_MASK,	NO_SHIFT_DEFINE,			false},
+	{"DUAL_CTS_CAP",	WF_LWTBL_DUAL_CTS_CAP_MASK,	NO_SHIFT_DEFINE,			false},
+	{"CIPHER_PGTK",		WF_LWTBL_CIPHER_SUIT_PGTK_MASK,	WF_LWTBL_CIPHER_SUIT_PGTK_SHIFT,	true},
+	{"FROM_DS",		WF_LWTBL_FD_MASK,		NO_SHIFT_DEFINE,			false},
+	{"TO_DS",		WF_LWTBL_TD_MASK,		NO_SHIFT_DEFINE,			false},
+	{"SW",			WF_LWTBL_SW_MASK,		NO_SHIFT_DEFINE,			false},
+	{"UL",			WF_LWTBL_UL_MASK,		NO_SHIFT_DEFINE,			false},
+	{"TX_POWER_SAVE",	WF_LWTBL_TX_PS_MASK,		NO_SHIFT_DEFINE,			true},
+	{"QOS",			WF_LWTBL_QOS_MASK,		NO_SHIFT_DEFINE,			false},
+	{"HT",			WF_LWTBL_HT_MASK,		NO_SHIFT_DEFINE,			false},
+	{"VHT",			WF_LWTBL_VHT_MASK,		NO_SHIFT_DEFINE,			false},
+	{"HE",			WF_LWTBL_HE_MASK,		NO_SHIFT_DEFINE,			false},
+	{"EHT",			WF_LWTBL_EHT_MASK,		NO_SHIFT_DEFINE,			false},
+	{"MESH",		WF_LWTBL_MESH_MASK,		NO_SHIFT_DEFINE,			true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw2(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 2 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 2\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_TRX_CAP_DW_2*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW2[i].name) {
+
+		if (WTBL_LMAC_DW2[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW2[i].name,
+					 (dw_value & WTBL_LMAC_DW2[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW2[i].name,
+					  (dw_value & WTBL_LMAC_DW2[i].mask) >> WTBL_LMAC_DW2[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW3[] = {
+	{"WMM_Q",		WF_LWTBL_WMM_Q_MASK,			WF_LWTBL_WMM_Q_SHIFT,			false},
+	{"EHT_SIG_MCS",		WF_LWTBL_EHT_SIG_MCS_MASK,		WF_LWTBL_EHT_SIG_MCS_SHIFT,		false},
+	{"HDRT_MODE",		WF_LWTBL_HDRT_MODE_MASK,		NO_SHIFT_DEFINE,			false},
+	{"BEAM_CHG",		WF_LWTBL_BEAM_CHG_MASK,			NO_SHIFT_DEFINE,			false},
+	{"EHT_LTF_SYM_NUM",	WF_LWTBL_EHT_LTF_SYM_NUM_OPT_MASK,	WF_LWTBL_EHT_LTF_SYM_NUM_OPT_SHIFT,	true},
+	{"PFMU_IDX",		WF_LWTBL_PFMU_IDX_MASK,			WF_LWTBL_PFMU_IDX_SHIFT,		false},
+	{"ULPF_IDX",		WF_LWTBL_ULPF_IDX_MASK,			WF_LWTBL_ULPF_IDX_SHIFT,		false},
+	{"RIBF",		WF_LWTBL_RIBF_MASK,			NO_SHIFT_DEFINE,			false},
+	{"ULPF",		WF_LWTBL_ULPF_MASK,			NO_SHIFT_DEFINE,			false},
+	{"BYPASS_TXSMM",	WF_LWTBL_BYPASS_TXSMM_MASK,		NO_SHIFT_DEFINE,			true},
+	{"TBF_HT",		WF_LWTBL_TBF_HT_MASK,			NO_SHIFT_DEFINE,			false},
+	{"TBF_VHT",		WF_LWTBL_TBF_VHT_MASK,			NO_SHIFT_DEFINE,			false},
+	{"TBF_HE",		WF_LWTBL_TBF_HE_MASK,			NO_SHIFT_DEFINE,			false},
+	{"TBF_EHT",		WF_LWTBL_TBF_EHT_MASK,			NO_SHIFT_DEFINE,			false},
+	{"IGN_FBK",		WF_LWTBL_IGN_FBK_MASK,			NO_SHIFT_DEFINE,			true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw3(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 3 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 3\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_TRX_CAP_DW_3*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW3[i].name) {
+
+		if (WTBL_LMAC_DW3[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW3[i].name,
+					 (dw_value & WTBL_LMAC_DW3[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW3[i].name,
+					  (dw_value & WTBL_LMAC_DW3[i].mask) >> WTBL_LMAC_DW3[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW4[] = {
+	{"NEGOTIATED_WINSIZE0",	WF_LWTBL_NEGOTIATED_WINSIZE0_MASK,	WF_LWTBL_NEGOTIATED_WINSIZE0_SHIFT,	false},
+	{"WINSIZE1",		WF_LWTBL_NEGOTIATED_WINSIZE1_MASK,	WF_LWTBL_NEGOTIATED_WINSIZE1_SHIFT,	false},
+	{"WINSIZE2",		WF_LWTBL_NEGOTIATED_WINSIZE2_MASK,	WF_LWTBL_NEGOTIATED_WINSIZE2_SHIFT,	false},
+	{"WINSIZE3",		WF_LWTBL_NEGOTIATED_WINSIZE3_MASK,	WF_LWTBL_NEGOTIATED_WINSIZE3_SHIFT,	true},
+	{"WINSIZE4",		WF_LWTBL_NEGOTIATED_WINSIZE4_MASK,	WF_LWTBL_NEGOTIATED_WINSIZE4_SHIFT,	false},
+	{"WINSIZE5",		WF_LWTBL_NEGOTIATED_WINSIZE5_MASK,	WF_LWTBL_NEGOTIATED_WINSIZE5_SHIFT,	false},
+	{"WINSIZE6",		WF_LWTBL_NEGOTIATED_WINSIZE6_MASK,	WF_LWTBL_NEGOTIATED_WINSIZE6_SHIFT,	false},
+	{"WINSIZE7",		WF_LWTBL_NEGOTIATED_WINSIZE7_MASK,	WF_LWTBL_NEGOTIATED_WINSIZE7_SHIFT,	true},
+	{"PE",			WF_LWTBL_PE_MASK,			WF_LWTBL_PE_SHIFT,			false},
+	{"DIS_RHTR",		WF_LWTBL_DIS_RHTR_MASK,			NO_SHIFT_DEFINE,			false},
+	{"LDPC_HT",		WF_LWTBL_LDPC_HT_MASK,			NO_SHIFT_DEFINE,			false},
+	{"LDPC_VHT",		WF_LWTBL_LDPC_VHT_MASK,			NO_SHIFT_DEFINE,			false},
+	{"LDPC_HE",		WF_LWTBL_LDPC_HE_MASK,			NO_SHIFT_DEFINE,			false},
+	{"LDPC_EHT",		WF_LWTBL_LDPC_EHT_MASK,			NO_SHIFT_DEFINE,			true},
+	{"BA_MODE",		WF_LWTBL_BA_MODE_MASK,			NO_SHIFT_DEFINE,			true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw4(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 4 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 4\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_TRX_CAP_DW_4*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW4[i].name) {
+		if (WTBL_LMAC_DW4[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW4[i].name,
+					 (dw_value & WTBL_LMAC_DW4[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW4[i].name,
+					  (dw_value & WTBL_LMAC_DW4[i].mask) >> WTBL_LMAC_DW4[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse *WTBL_LMAC_DW5;
+static const struct berse_wtbl_parse WTBL_LMAC_DW5_7996[] = {
+	{"AF",			WF_LWTBL_AF_MASK,		WF_LWTBL_AF_SHIFT,		false},
+	{"AF_HE",		WF_LWTBL_AF_HE_MASK,		WF_LWTBL_AF_HE_SHIFT,		false},
+	{"RTS",			WF_LWTBL_RTS_MASK,		NO_SHIFT_DEFINE,		false},
+	{"SMPS",		WF_LWTBL_SMPS_MASK,		NO_SHIFT_DEFINE,		false},
+	{"DYN_BW",		WF_LWTBL_DYN_BW_MASK,		NO_SHIFT_DEFINE,		true},
+	{"MMSS",		WF_LWTBL_MMSS_MASK,		WF_LWTBL_MMSS_SHIFT,		false},
+	{"USR",			WF_LWTBL_USR_MASK,		NO_SHIFT_DEFINE,		false},
+	{"SR_RATE",		WF_LWTBL_SR_R_MASK,		WF_LWTBL_SR_R_SHIFT,		false},
+	{"SR_ABORT",		WF_LWTBL_SR_ABORT_MASK,		NO_SHIFT_DEFINE,		true},
+	{"TX_POWER_OFFSET",	WF_LWTBL_TX_POWER_OFFSET_MASK,  WF_LWTBL_TX_POWER_OFFSET_SHIFT,	false},
+	{"LTF_EHT",		WF_LWTBL_LTF_EHT_MASK,		WF_LWTBL_LTF_EHT_SHIFT, 	false},
+	{"GI_EHT",		WF_LWTBL_GI_EHT_MASK,		WF_LWTBL_GI_EHT_SHIFT,		false},
+	{"DOPPL",		WF_LWTBL_DOPPL_MASK,		NO_SHIFT_DEFINE,		false},
+	{"TXOP_PS_CAP",		WF_LWTBL_TXOP_PS_CAP_MASK,	NO_SHIFT_DEFINE,		false},
+	{"DONOT_UPDATE_I_PSM",	WF_LWTBL_DU_I_PSM_MASK,		NO_SHIFT_DEFINE,		true},
+	{"I_PSM",		WF_LWTBL_I_PSM_MASK,		NO_SHIFT_DEFINE,		false},
+	{"PSM",			WF_LWTBL_PSM_MASK,		NO_SHIFT_DEFINE,		false},
+	{"SKIP_TX",		WF_LWTBL_SKIP_TX_MASK,		NO_SHIFT_DEFINE,		true},
+	{NULL,}
+};
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW5_7992[] = {
+	{"AF",			WF_LWTBL_AF_MASK_7992,		WF_LWTBL_AF_SHIFT,		false},
+	{"RTS",			WF_LWTBL_RTS_MASK,		NO_SHIFT_DEFINE,		false},
+	{"SMPS",		WF_LWTBL_SMPS_MASK,		NO_SHIFT_DEFINE,		false},
+	{"DYN_BW",		WF_LWTBL_DYN_BW_MASK,		NO_SHIFT_DEFINE,		true},
+	{"MMSS",		WF_LWTBL_MMSS_MASK,		WF_LWTBL_MMSS_SHIFT,		false},
+	{"USR",			WF_LWTBL_USR_MASK,		NO_SHIFT_DEFINE,		false},
+	{"SR_RATE",		WF_LWTBL_SR_R_MASK,		WF_LWTBL_SR_R_SHIFT,		false},
+	{"SR_ABORT",		WF_LWTBL_SR_ABORT_MASK,		NO_SHIFT_DEFINE,		true},
+	{"TX_POWER_OFFSET",	WF_LWTBL_TX_POWER_OFFSET_MASK,	WF_LWTBL_TX_POWER_OFFSET_SHIFT,	false},
+	{"LTF_EHT",		WF_LWTBL_LTF_EHT_MASK,		WF_LWTBL_LTF_EHT_SHIFT,		false},
+	{"GI_EHT",		WF_LWTBL_GI_EHT_MASK,		WF_LWTBL_GI_EHT_SHIFT,		false},
+	{"DOPPL",		WF_LWTBL_DOPPL_MASK,		NO_SHIFT_DEFINE,		false},
+	{"TXOP_PS_CAP",		WF_LWTBL_TXOP_PS_CAP_MASK,	NO_SHIFT_DEFINE,		false},
+	{"DONOT_UPDATE_I_PSM",	WF_LWTBL_DU_I_PSM_MASK,		NO_SHIFT_DEFINE,		true},
+	{"I_PSM",		WF_LWTBL_I_PSM_MASK,		NO_SHIFT_DEFINE,		false},
+	{"PSM",			WF_LWTBL_PSM_MASK,		NO_SHIFT_DEFINE,		false},
+	{"SKIP_TX",		WF_LWTBL_SKIP_TX_MASK,		NO_SHIFT_DEFINE,		true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw5(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 5 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 5\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_TRX_CAP_DW_5*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW5[i].name) {
+		if (WTBL_LMAC_DW5[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW5[i].name,
+					 (dw_value & WTBL_LMAC_DW5[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW5[i].name,
+					  (dw_value & WTBL_LMAC_DW5[i].mask) >> WTBL_LMAC_DW5[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW6[] = {
+	{"CBRN",	WF_LWTBL_CBRN_MASK,	WF_LWTBL_CBRN_SHIFT,	false},
+	{"DBNSS_EN",	WF_LWTBL_DBNSS_EN_MASK,	NO_SHIFT_DEFINE,	false},
+	{"BAF_EN",	WF_LWTBL_BAF_EN_MASK,	NO_SHIFT_DEFINE,	false},
+	{"RDGBA",	WF_LWTBL_RDGBA_MASK,	NO_SHIFT_DEFINE,	false},
+	{"RDG",		WF_LWTBL_R_MASK,	NO_SHIFT_DEFINE,	false},
+	{"SPE_IDX",	WF_LWTBL_SPE_IDX_MASK,	WF_LWTBL_SPE_IDX_SHIFT,	true},
+	{"G2",		WF_LWTBL_G2_MASK,	NO_SHIFT_DEFINE,	false},
+	{"G4",		WF_LWTBL_G4_MASK,	NO_SHIFT_DEFINE,	false},
+	{"G8",		WF_LWTBL_G8_MASK,	NO_SHIFT_DEFINE,	false},
+	{"G16",		WF_LWTBL_G16_MASK,	NO_SHIFT_DEFINE,	true},
+	{"G2_LTF",	WF_LWTBL_G2_LTF_MASK,	WF_LWTBL_G2_LTF_SHIFT,	false},
+	{"G4_LTF",	WF_LWTBL_G4_LTF_MASK,	WF_LWTBL_G4_LTF_SHIFT,	false},
+	{"G8_LTF",	WF_LWTBL_G8_LTF_MASK,	WF_LWTBL_G8_LTF_SHIFT,	false},
+	{"G16_LTF",	WF_LWTBL_G16_LTF_MASK,	WF_LWTBL_G16_LTF_SHIFT,	true},
+	{"G2_HE",	WF_LWTBL_G2_HE_MASK,	WF_LWTBL_G2_HE_SHIFT,	false},
+	{"G4_HE",	WF_LWTBL_G4_HE_MASK,	WF_LWTBL_G4_HE_SHIFT,	false},
+	{"G8_HE",	WF_LWTBL_G8_HE_MASK,	WF_LWTBL_G8_HE_SHIFT,	false},
+	{"G16_HE",	WF_LWTBL_G16_HE_MASK,	WF_LWTBL_G16_HE_SHIFT,	true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw6(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 6 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 6\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_TRX_CAP_DW_6*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW6[i].name) {
+		if (WTBL_LMAC_DW6[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW6[i].name,
+					 (dw_value & WTBL_LMAC_DW6[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW6[i].name,
+					  (dw_value & WTBL_LMAC_DW6[i].mask) >> WTBL_LMAC_DW6[i].shift);
+		i++;
+	}
+}
+
+static void parse_fmac_lwtbl_dw7(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	int i = 0;
+
+	/* LMAC WTBL DW 7 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 7\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_TRX_CAP_DW_7*4]);
+	dw_value = *addr;
+
+	for (i = 0; i < 8; i++) {
+		seq_printf(s, "\tBA_WIN_SIZE%u:%lu\n", i, ((dw_value & BITS(i*4, i*4+3)) >> i*4));
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW8[] = {
+	{"RTS_FAIL_CNT_AC0",	WF_LWTBL_AC0_RTS_FAIL_CNT_MASK,	WF_LWTBL_AC0_RTS_FAIL_CNT_SHIFT,	false},
+	{"AC1",			WF_LWTBL_AC1_RTS_FAIL_CNT_MASK,	WF_LWTBL_AC1_RTS_FAIL_CNT_SHIFT,	false},
+	{"AC2",			WF_LWTBL_AC2_RTS_FAIL_CNT_MASK,	WF_LWTBL_AC2_RTS_FAIL_CNT_SHIFT,	false},
+	{"AC3",			WF_LWTBL_AC3_RTS_FAIL_CNT_MASK,	WF_LWTBL_AC3_RTS_FAIL_CNT_SHIFT,	true},
+	{"PARTIAL_AID",		WF_LWTBL_PARTIAL_AID_MASK,	WF_LWTBL_PARTIAL_AID_SHIFT,		false},
+	{"CHK_PER",		WF_LWTBL_CHK_PER_MASK,		NO_SHIFT_DEFINE,			true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw8(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 8 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 8\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_TRX_CAP_DW_8*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW8[i].name) {
+		if (WTBL_LMAC_DW8[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW8[i].name,
+					 (dw_value & WTBL_LMAC_DW8[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW8[i].name,
+					  (dw_value & WTBL_LMAC_DW8[i].mask) >> WTBL_LMAC_DW8[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse *WTBL_LMAC_DW9;
+static const struct berse_wtbl_parse WTBL_LMAC_DW9_7996[] = {
+	{"RX_AVG_MPDU_SIZE",	WF_LWTBL_RX_AVG_MPDU_SIZE_MASK,	WF_LWTBL_RX_AVG_MPDU_SIZE_SHIFT,	false},
+	{"PRITX_SW_MODE",	WF_LWTBL_PRITX_SW_MODE_MASK,	NO_SHIFT_DEFINE,			false},
+	{"PRITX_ERSU",		WF_LWTBL_PRITX_ERSU_MASK,	NO_SHIFT_DEFINE,			false},
+	{"PRITX_PLR",		WF_LWTBL_PRITX_PLR_MASK,	NO_SHIFT_DEFINE,			true},
+	{"PRITX_DCM",		WF_LWTBL_PRITX_DCM_MASK,	NO_SHIFT_DEFINE,			false},
+	{"PRITX_ER106T",	WF_LWTBL_PRITX_ER106T_MASK,	NO_SHIFT_DEFINE,			true},
+	/* {"FCAP(0:20 1:~40)",	WTBL_FCAP_20_TO_160_MHZ,	WTBL_FCAP_20_TO_160_MHZ_OFFSET}, */
+	{"MPDU_FAIL_CNT",	WF_LWTBL_MPDU_FAIL_CNT_MASK,	WF_LWTBL_MPDU_FAIL_CNT_SHIFT,		false},
+	{"MPDU_OK_CNT",		WF_LWTBL_MPDU_OK_CNT_MASK,	WF_LWTBL_MPDU_OK_CNT_SHIFT,		false},
+	{"RATE_IDX",		WF_LWTBL_RATE_IDX_MASK,		WF_LWTBL_RATE_IDX_SHIFT,		true},
+	{NULL,}
+};
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW9_7992[] = {
+	{"RX_AVG_MPDU_SIZE",	WF_LWTBL_RX_AVG_MPDU_SIZE_MASK,		WF_LWTBL_RX_AVG_MPDU_SIZE_SHIFT,	false},
+	{"PRITX_SW_MODE",	WF_LWTBL_PRITX_SW_MODE_MASK_7992,	NO_SHIFT_DEFINE,			false},
+	{"PRITX_ERSU",		WF_LWTBL_PRITX_ERSU_MASK_7992,		NO_SHIFT_DEFINE,			false},
+	{"PRITX_PLR",		WF_LWTBL_PRITX_PLR_MASK_7992,		NO_SHIFT_DEFINE,			true},
+	{"PRITX_DCM",		WF_LWTBL_PRITX_DCM_MASK,		NO_SHIFT_DEFINE,			false},
+	{"PRITX_ER106T",	WF_LWTBL_PRITX_ER106T_MASK,		NO_SHIFT_DEFINE,			true},
+	/* {"FCAP(0:20 1:~40)",	WTBL_FCAP_20_TO_160_MHZ,		WTBL_FCAP_20_TO_160_MHZ_OFFSET}, */
+	{"MPDU_FAIL_CNT",	WF_LWTBL_MPDU_FAIL_CNT_MASK,		WF_LWTBL_MPDU_FAIL_CNT_SHIFT,		false},
+	{"MPDU_OK_CNT",		WF_LWTBL_MPDU_OK_CNT_MASK,		WF_LWTBL_MPDU_OK_CNT_SHIFT,		false},
+	{"RATE_IDX",		WF_LWTBL_RATE_IDX_MASK,			WF_LWTBL_RATE_IDX_SHIFT,		true},
+	{NULL,}
+};
+
+char *fcap_name[] = {"20MHz", "20/40MHz", "20/40/80MHz", "20/40/80/160/80+80MHz", "20/40/80/160/80+80/320MHz"};
+
+static void parse_fmac_lwtbl_dw9(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 9 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 9\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_TRX_CAP_DW_9*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW9[i].name) {
+		if (WTBL_LMAC_DW9[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW9[i].name,
+					 (dw_value & WTBL_LMAC_DW9[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW9[i].name,
+					  (dw_value & WTBL_LMAC_DW9[i].mask) >> WTBL_LMAC_DW9[i].shift);
+		i++;
+	}
+
+	/* FCAP parser */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "FCAP:%s\n", fcap_name[(dw_value & WF_LWTBL_FCAP_MASK) >> WF_LWTBL_FCAP_SHIFT]);
+}
+
+#define HW_TX_RATE_TO_MODE(_x)			(((_x) & WTBL_RATE_TX_MODE_MASK) >> WTBL_RATE_TX_MODE_OFFSET)
+#define HW_TX_RATE_TO_MCS(_x, _mode)		((_x) & WTBL_RATE_TX_RATE_MASK >> WTBL_RATE_TX_RATE_OFFSET)
+#define HW_TX_RATE_TO_NSS(_x)			(((_x) & WTBL_RATE_NSTS_MASK) >> WTBL_RATE_NSTS_OFFSET)
+#define HW_TX_RATE_TO_STBC(_x)			(((_x) & WTBL_RATE_STBC_MASK) >> WTBL_RATE_STBC_OFFSET)
+
+static char *HW_TX_MODE_STR[] = {"CCK", "OFDM", "HT-Mix", "HT-GF", "VHT",
+				 "N/A", "N/A", "N/A",
+				 "HE_SU", "HE_EXT_SU", "HE_TRIG", "HE_MU",
+				 "N/A",
+				 "EHT_EXT_SU", "EHT_TRIG", "EHT_MU"};
+static char *HW_TX_RATE_CCK_STR[] = {"1M", "2Mlong", "5.5Mlong", "11Mlong", "N/A", "2Mshort", "5.5Mshort", "11Mshort", "N/A"};
+static char *HW_TX_RATE_OFDM_STR[] = {"6M", "9M", "12M", "18M", "24M", "36M", "48M", "54M", "N/A"};
+
+static char *hw_rate_ofdm_str(uint16_t ofdm_idx)
+{
+	switch (ofdm_idx) {
+	case 11: /* 6M */
+		return HW_TX_RATE_OFDM_STR[0];
+
+	case 15: /* 9M */
+		return HW_TX_RATE_OFDM_STR[1];
+
+	case 10: /* 12M */
+		return HW_TX_RATE_OFDM_STR[2];
+
+	case 14: /* 18M */
+		return HW_TX_RATE_OFDM_STR[3];
+
+	case 9: /* 24M */
+		return HW_TX_RATE_OFDM_STR[4];
+
+	case 13: /* 36M */
+		return HW_TX_RATE_OFDM_STR[5];
+
+	case 8: /* 48M */
+		return HW_TX_RATE_OFDM_STR[6];
+
+	case 12: /* 54M */
+		return HW_TX_RATE_OFDM_STR[7];
+
+	default:
+		return HW_TX_RATE_OFDM_STR[8];
+	}
+}
+
+static char *hw_rate_str(u8 mode, uint16_t rate_idx)
+{
+	if (mode == 0)
+		return rate_idx < 8 ? HW_TX_RATE_CCK_STR[rate_idx] : HW_TX_RATE_CCK_STR[8];
+	else if (mode == 1)
+		return hw_rate_ofdm_str(rate_idx);
+	else
+		return "MCS";
+}
+
+static void
+parse_rate(struct seq_file *s, uint16_t rate_idx, uint16_t txrate)
+{
+	uint16_t txmode, mcs, nss, stbc;
+
+	txmode = HW_TX_RATE_TO_MODE(txrate);
+	mcs = HW_TX_RATE_TO_MCS(txrate, txmode);
+	nss = HW_TX_RATE_TO_NSS(txrate);
+	stbc = HW_TX_RATE_TO_STBC(txrate);
+
+	seq_printf(s, "\tRate%d(0x%x):TxMode=%d(%s), TxRate=%d(%s), Nsts=%d, STBC=%d\n",
+			  rate_idx + 1, txrate,
+			  txmode, HW_TX_MODE_STR[txmode],
+			  mcs, hw_rate_str(txmode, mcs), nss, stbc);
+}
+
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW10[] = {
+	{"RATE1",	WF_LWTBL_RATE1_MASK,	WF_LWTBL_RATE1_SHIFT},
+	{"RATE2",	WF_LWTBL_RATE2_MASK,	WF_LWTBL_RATE2_SHIFT},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw10(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 10 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 10\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_AUTO_RATE_1_2*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW10[i].name) {
+		parse_rate(s, i, (dw_value & WTBL_LMAC_DW10[i].mask) >> WTBL_LMAC_DW10[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW11[] = {
+	{"RATE3",	WF_LWTBL_RATE3_MASK,	WF_LWTBL_RATE3_SHIFT},
+	{"RATE4",	WF_LWTBL_RATE4_MASK,	WF_LWTBL_RATE4_SHIFT},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw11(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 11 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 11\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_AUTO_RATE_3_4*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW11[i].name) {
+		parse_rate(s, i+2, (dw_value & WTBL_LMAC_DW11[i].mask) >> WTBL_LMAC_DW11[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW12[] = {
+	{"RATE5",	WF_LWTBL_RATE5_MASK,	WF_LWTBL_RATE5_SHIFT},
+	{"RATE6",	WF_LWTBL_RATE6_MASK,	WF_LWTBL_RATE6_SHIFT},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw12(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 12 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 12\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_AUTO_RATE_5_6*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW12[i].name) {
+		parse_rate(s, i+4, (dw_value & WTBL_LMAC_DW12[i].mask) >> WTBL_LMAC_DW12[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW13[] = {
+	{"RATE7",	WF_LWTBL_RATE7_MASK,	WF_LWTBL_RATE7_SHIFT},
+	{"RATE8",	WF_LWTBL_RATE8_MASK,	WF_LWTBL_RATE8_SHIFT},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw13(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 13 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 13\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_AUTO_RATE_7_8*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW13[i].name) {
+		parse_rate(s, i+6, (dw_value & WTBL_LMAC_DW13[i].mask) >> WTBL_LMAC_DW13[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW14_BMC[] = {
+	{"CIPHER_IGTK",		WF_LWTBL_CIPHER_SUIT_IGTK_MASK,		WF_LWTBL_CIPHER_SUIT_IGTK_SHIFT,	false},
+	{"CIPHER_BIGTK",	WF_LWTBL_CIPHER_SUIT_BIGTK_MASK,	WF_LWTBL_CIPHER_SUIT_BIGTK_SHIFT,	true},
+	{NULL,}
+};
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW14[] = {
+	{"RATE1_TX_CNT",	WF_LWTBL_RATE1_TX_CNT_MASK,	WF_LWTBL_RATE1_TX_CNT_SHIFT,	false},
+	{"RATE1_FAIL_CNT",	WF_LWTBL_RATE1_FAIL_CNT_MASK,	WF_LWTBL_RATE1_FAIL_CNT_SHIFT,	true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw14(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr, *muar_addr = 0;
+	u32 dw_value, muar_dw_value = 0;
+	u16 i = 0;
+
+	/* DUMP DW14 for BMC entry only */
+	muar_addr = (u32 *)&(lwtbl[WF_LWTBL_MUAR_DW*4]);
+	muar_dw_value = *muar_addr;
+	if (((muar_dw_value & WF_LWTBL_MUAR_MASK) >> WF_LWTBL_MUAR_SHIFT)
+		== MUAR_INDEX_OWN_MAC_ADDR_BC_MC) {
+		/* LMAC WTBL DW 14 */
+		seq_printf(s, "\t\n");
+		seq_printf(s, "LWTBL DW 14\n");
+		addr = (u32 *)&(lwtbl[WF_LWTBL_CIPHER_SUIT_IGTK_DW*4]);
+		dw_value = *addr;
+
+		while (WTBL_LMAC_DW14_BMC[i].name) {
+			if (WTBL_LMAC_DW14_BMC[i].shift == NO_SHIFT_DEFINE)
+				seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW14_BMC[i].name,
+					(dw_value & WTBL_LMAC_DW14_BMC[i].mask) ? 1 : 0);
+			else
+				seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW14_BMC[i].name,
+					(dw_value & WTBL_LMAC_DW14_BMC[i].mask) >> WTBL_LMAC_DW14_BMC[i].shift);
+			i++;
+		}
+	} else {
+		seq_printf(s, "\t\n");
+		seq_printf(s, "LWTBL DW 14\n");
+		addr = (u32 *)&(lwtbl[WF_LWTBL_CIPHER_SUIT_IGTK_DW*4]);
+		dw_value = *addr;
+
+		while (WTBL_LMAC_DW14[i].name) {
+			if (WTBL_LMAC_DW14[i].shift == NO_SHIFT_DEFINE)
+				seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW14[i].name,
+					(dw_value & WTBL_LMAC_DW14[i].mask) ? 1 : 0);
+			else
+				seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW14[i].name,
+					(dw_value & WTBL_LMAC_DW14[i].mask) >> WTBL_LMAC_DW14[i].shift);
+			i++;
+		}
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW28[] = {
+	{"RELATED_IDX0",	WF_LWTBL_RELATED_IDX0_MASK,		WF_LWTBL_RELATED_IDX0_SHIFT,		false},
+	{"RELATED_BAND0",	WF_LWTBL_RELATED_BAND0_MASK,		WF_LWTBL_RELATED_BAND0_SHIFT,		false},
+	{"PRI_MLD_BAND",	WF_LWTBL_PRIMARY_MLD_BAND_MASK,		WF_LWTBL_PRIMARY_MLD_BAND_SHIFT,	true},
+	{"RELATED_IDX1",	WF_LWTBL_RELATED_IDX1_MASK,		WF_LWTBL_RELATED_IDX1_SHIFT,		false},
+	{"RELATED_BAND1",	WF_LWTBL_RELATED_BAND1_MASK,		WF_LWTBL_RELATED_BAND1_SHIFT,		false},
+	{"SEC_MLD_BAND",	WF_LWTBL_SECONDARY_MLD_BAND_MASK,	WF_LWTBL_SECONDARY_MLD_BAND_SHIFT,	true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw28(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 28 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 28\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_MLO_INFO_LINE_1*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW28[i].name) {
+		if (WTBL_LMAC_DW28[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW28[i].name,
+				(dw_value & WTBL_LMAC_DW28[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW28[i].name,
+				(dw_value & WTBL_LMAC_DW28[i].mask) >>
+					WTBL_LMAC_DW28[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW29[] = {
+	{"DISPATCH_POLICY_MLD_TID0",	WF_LWTBL_DISPATCH_POLICY0_MASK,		WF_LWTBL_DISPATCH_POLICY0_SHIFT,	false},
+	{"MLD_TID1",			WF_LWTBL_DISPATCH_POLICY1_MASK,		WF_LWTBL_DISPATCH_POLICY1_SHIFT,	false},
+	{"MLD_TID2",			WF_LWTBL_DISPATCH_POLICY2_MASK,		WF_LWTBL_DISPATCH_POLICY2_SHIFT,	false},
+	{"MLD_TID3",			WF_LWTBL_DISPATCH_POLICY3_MASK,		WF_LWTBL_DISPATCH_POLICY3_SHIFT,	true},
+	{"MLD_TID4",			WF_LWTBL_DISPATCH_POLICY4_MASK,		WF_LWTBL_DISPATCH_POLICY4_SHIFT,	false},
+	{"MLD_TID5",			WF_LWTBL_DISPATCH_POLICY5_MASK,		WF_LWTBL_DISPATCH_POLICY5_SHIFT,	false},
+	{"MLD_TID6",			WF_LWTBL_DISPATCH_POLICY6_MASK,		WF_LWTBL_DISPATCH_POLICY6_SHIFT,	false},
+	{"MLD_TID7",			WF_LWTBL_DISPATCH_POLICY7_MASK,		WF_LWTBL_DISPATCH_POLICY7_SHIFT,	true},
+	{"OMLD_ID",			WF_LWTBL_OWN_MLD_ID_MASK,		WF_LWTBL_OWN_MLD_ID_SHIFT,		false},
+	{"EMLSR0",			WF_LWTBL_EMLSR0_MASK,			NO_SHIFT_DEFINE,			false},
+	{"EMLMR0",			WF_LWTBL_EMLMR0_MASK,			NO_SHIFT_DEFINE,			false},
+	{"EMLSR1",			WF_LWTBL_EMLSR1_MASK,			NO_SHIFT_DEFINE,			false},
+	{"EMLMR1",			WF_LWTBL_EMLMR1_MASK,			NO_SHIFT_DEFINE,			true},
+	{"EMLSR2",			WF_LWTBL_EMLSR2_MASK,			NO_SHIFT_DEFINE,			false},
+	{"EMLMR2",			WF_LWTBL_EMLMR2_MASK,			NO_SHIFT_DEFINE,			false},
+	{"STR_BITMAP",			WF_LWTBL_STR_BITMAP_MASK,		WF_LWTBL_STR_BITMAP_SHIFT,		true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw29(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 29 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 29\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_MLO_INFO_LINE_2*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW29[i].name) {
+		if (WTBL_LMAC_DW29[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW29[i].name,
+				(dw_value & WTBL_LMAC_DW29[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW29[i].name,
+				(dw_value & WTBL_LMAC_DW29[i].mask) >>
+					WTBL_LMAC_DW29[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW30[] = {
+	{"DISPATCH_ORDER",	WF_LWTBL_DISPATCH_ORDER_MASK,	WF_LWTBL_DISPATCH_ORDER_SHIFT,	false},
+	{"DISPATCH_RATIO",	WF_LWTBL_DISPATCH_RATIO_MASK,	WF_LWTBL_DISPATCH_RATIO_SHIFT,	false},
+	{"LINK_MGF",		WF_LWTBL_LINK_MGF_MASK,		WF_LWTBL_LINK_MGF_SHIFT,	true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw30(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 30 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 30\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_MLO_INFO_LINE_3*4]);
+	dw_value = *addr;
+
+
+	while (WTBL_LMAC_DW30[i].name) {
+		if (WTBL_LMAC_DW30[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW30[i].name,
+				(dw_value & WTBL_LMAC_DW30[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW30[i].name,
+				(dw_value & WTBL_LMAC_DW30[i].mask) >> WTBL_LMAC_DW30[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW31[] = {
+	{"BFTX_TB",		WF_LWTBL_BFTX_TB_MASK,		NO_SHIFT_DEFINE,		false},
+	{"DROP",		WF_LWTBL_DROP_MASK,		NO_SHIFT_DEFINE,		false},
+	{"CASCAD",		WF_LWTBL_CASCAD_MASK,		NO_SHIFT_DEFINE,		false},
+	{"ALL_ACK",		WF_LWTBL_ALL_ACK_MASK,		NO_SHIFT_DEFINE,		false},
+	{"MPDU_SIZE",		WF_LWTBL_MPDU_SIZE_MASK,	WF_LWTBL_MPDU_SIZE_SHIFT,	false},
+	{"RXD_DUP_MODE",	WF_LWTBL_RXD_DUP_MODE_MASK,	WF_LWTBL_RXD_DUP_MODE_SHIFT,	true},
+	{"ACK_EN",		WF_LWTBL_ACK_EN_MASK,		NO_SHIFT_DEFINE,		true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw31(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 31 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 31\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_RESP_INFO_DW_31*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW31[i].name) {
+		if (WTBL_LMAC_DW31[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW31[i].name,
+				(dw_value & WTBL_LMAC_DW31[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW31[i].name,
+				(dw_value & WTBL_LMAC_DW31[i].mask) >>
+					WTBL_LMAC_DW31[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW32[] = {
+	{"OM_INFO",			WF_LWTBL_OM_INFO_MASK,			WF_LWTBL_OM_INFO_SHIFT,		false},
+	{"OM_INFO_EHT",         WF_LWTBL_OM_INFO_EHT_MASK,         WF_LWTBL_OM_INFO_EHT_SHIFT,  false},
+	{"RXD_DUP_FOR_OM_CHG",		WF_LWTBL_RXD_DUP_FOR_OM_CHG_MASK,	NO_SHIFT_DEFINE,		false},
+	{"RXD_DUP_WHITE_LIST",	WF_LWTBL_RXD_DUP_WHITE_LIST_MASK,	WF_LWTBL_RXD_DUP_WHITE_LIST_SHIFT,	false},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw32(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 32 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 32\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_RX_DUP_INFO_DW_32*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW32[i].name) {
+		if (WTBL_LMAC_DW32[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW32[i].name,
+				(dw_value & WTBL_LMAC_DW32[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW32[i].name,
+				(dw_value & WTBL_LMAC_DW32[i].mask) >>
+					WTBL_LMAC_DW32[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW33[] = {
+	{"USER_RSSI",			WF_LWTBL_USER_RSSI_MASK,		WF_LWTBL_USER_RSSI_SHIFT,		false},
+	{"USER_SNR",			WF_LWTBL_USER_SNR_MASK,			WF_LWTBL_USER_SNR_SHIFT,		false},
+	{"RAPID_REACTION_RATE",		WF_LWTBL_RAPID_REACTION_RATE_MASK,	WF_LWTBL_RAPID_REACTION_RATE_SHIFT,	true},
+	{"HT_AMSDU(Read Only)",		WF_LWTBL_HT_AMSDU_MASK,			NO_SHIFT_DEFINE,			false},
+	{"AMSDU_CROSS_LG(Read Only)",	WF_LWTBL_AMSDU_CROSS_LG_MASK,		NO_SHIFT_DEFINE,			true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw33(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 33 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 33\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_RX_STAT_CNT_LINE_1*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW33[i].name) {
+		if (WTBL_LMAC_DW33[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW33[i].name,
+				(dw_value & WTBL_LMAC_DW33[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW33[i].name,
+				(dw_value & WTBL_LMAC_DW33[i].mask) >>
+					WTBL_LMAC_DW33[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW34[] = {
+	{"RESP_RCPI0",	WF_LWTBL_RESP_RCPI0_MASK,	WF_LWTBL_RESP_RCPI0_SHIFT,	false},
+	{"RCPI1",	WF_LWTBL_RESP_RCPI1_MASK,	WF_LWTBL_RESP_RCPI1_SHIFT,	false},
+	{"RCPI2",	WF_LWTBL_RESP_RCPI2_MASK,	WF_LWTBL_RESP_RCPI2_SHIFT,	false},
+	{"RCPI3",	WF_LWTBL_RESP_RCPI3_MASK,	WF_LWTBL_RESP_RCPI3_SHIFT,	true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw34(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 34 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 34\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_RX_STAT_CNT_LINE_2*4]);
+	dw_value = *addr;
+
+
+	while (WTBL_LMAC_DW34[i].name) {
+		if (WTBL_LMAC_DW34[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW34[i].name,
+				(dw_value & WTBL_LMAC_DW34[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW34[i].name,
+				(dw_value & WTBL_LMAC_DW34[i].mask) >>
+					WTBL_LMAC_DW34[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW35[] = {
+	{"SNR 0",	WF_LWTBL_SNR_RX0_MASK,		WF_LWTBL_SNR_RX0_SHIFT,		false},
+	{"SNR 1",	WF_LWTBL_SNR_RX1_MASK,		WF_LWTBL_SNR_RX1_SHIFT,		false},
+	{"SNR 2",	WF_LWTBL_SNR_RX2_MASK,		WF_LWTBL_SNR_RX2_SHIFT,		false},
+	{"SNR 3",	WF_LWTBL_SNR_RX3_MASK,		WF_LWTBL_SNR_RX3_SHIFT,		true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw35(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 35 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 35\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_RX_STAT_CNT_LINE_3*4]);
+	dw_value = *addr;
+
+
+	while (WTBL_LMAC_DW35[i].name) {
+		if (WTBL_LMAC_DW35[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW35[i].name,
+				(dw_value & WTBL_LMAC_DW35[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW35[i].name,
+				(dw_value & WTBL_LMAC_DW35[i].mask) >>
+					WTBL_LMAC_DW35[i].shift);
+		i++;
+	}
+}
+
+static void parse_fmac_lwtbl_rx_stats(struct seq_file *s, u8 *lwtbl)
+{
+	parse_fmac_lwtbl_dw33(s, lwtbl);
+	parse_fmac_lwtbl_dw34(s, lwtbl);
+	parse_fmac_lwtbl_dw35(s, lwtbl);
+}
+
+static void parse_fmac_lwtbl_mlo_info(struct seq_file *s, u8 *lwtbl)
+{
+	parse_fmac_lwtbl_dw28(s, lwtbl);
+	parse_fmac_lwtbl_dw29(s, lwtbl);
+	parse_fmac_lwtbl_dw30(s, lwtbl);
+}
+
+static const struct berse_wtbl_parse WTBL_UMAC_DW9[] = {
+	{"RELATED_IDX0",	WF_UWTBL_RELATED_IDX0_MASK,		WF_UWTBL_RELATED_IDX0_SHIFT,		false},
+	{"RELATED_BAND0",	WF_UWTBL_RELATED_BAND0_MASK,		WF_UWTBL_RELATED_BAND0_SHIFT,		false},
+	{"PRI_MLD_BAND",	WF_UWTBL_PRIMARY_MLD_BAND_MASK,		WF_UWTBL_PRIMARY_MLD_BAND_SHIFT,	true},
+	{"RELATED_IDX1",	WF_UWTBL_RELATED_IDX1_MASK,		WF_UWTBL_RELATED_IDX1_SHIFT,		false},
+	{"RELATED_BAND1",	WF_UWTBL_RELATED_BAND1_MASK,		WF_UWTBL_RELATED_BAND1_SHIFT,		false},
+	{"SEC_MLD_BAND",	WF_UWTBL_SECONDARY_MLD_BAND_MASK,	WF_UWTBL_SECONDARY_MLD_BAND_SHIFT,	true},
+	{NULL,}
+};
+
+static void parse_fmac_uwtbl_mlo_info(struct seq_file *s, u8 *uwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	seq_printf(s, "\t\n");
+	seq_printf(s, "MldAddr: %02x:%02x:%02x:%02x:%02x:%02x(D0[B0~15], D1[B0~31])\n",
+		uwtbl[4], uwtbl[5], uwtbl[6], uwtbl[7], uwtbl[0], uwtbl[1]);
+
+	/* UMAC WTBL DW 0 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "UWTBL DW 0\n");
+	addr = (u32 *)&(uwtbl[WF_UWTBL_OWN_MLD_ID_DW*4]);
+	dw_value = *addr;
+
+	seq_printf(s, "\t%s:%u\n", "OMLD_ID",
+		(dw_value & WF_UWTBL_OWN_MLD_ID_MASK) >> WF_UWTBL_OWN_MLD_ID_SHIFT);
+
+	/* UMAC WTBL DW 9 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "UWTBL DW 9\n");
+	addr = (u32 *)&(uwtbl[WF_UWTBL_RELATED_IDX0_DW*4]);
+	dw_value = *addr;
+
+	while (WTBL_UMAC_DW9[i].name) {
+
+		if (WTBL_UMAC_DW9[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_UMAC_DW9[i].name,
+				(dw_value & WTBL_UMAC_DW9[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_UMAC_DW9[i].name,
+				 (dw_value & WTBL_UMAC_DW9[i].mask) >>
+					WTBL_UMAC_DW9[i].shift);
+		i++;
+	}
+}
+
+static bool
+is_wtbl_bigtk_exist(u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+
+	addr = (u32 *)&(lwtbl[WF_LWTBL_MUAR_DW*4]);
+	dw_value = *addr;
+	if (((dw_value & WF_LWTBL_MUAR_MASK) >> WF_LWTBL_MUAR_SHIFT) ==
+					MUAR_INDEX_OWN_MAC_ADDR_BC_MC) {
+		addr = (u32 *)&(lwtbl[WF_LWTBL_CIPHER_SUIT_BIGTK_DW*4]);
+		dw_value = *addr;
+		if (((dw_value & WF_LWTBL_CIPHER_SUIT_BIGTK_MASK) >>
+			WF_LWTBL_CIPHER_SUIT_BIGTK_SHIFT) != IGTK_CIPHER_SUIT_NONE)
+			return true;
+	}
+
+	return false;
+}
+
+static const struct berse_wtbl_parse WTBL_UMAC_DW2[] = {
+	{"PN0",		WTBL_PN0_MASK,		WTBL_PN0_OFFSET,	false},
+	{"PN1",		WTBL_PN1_MASK,		WTBL_PN1_OFFSET,	false},
+	{"PN2",		WTBL_PN2_MASK,		WTBL_PN2_OFFSET,	true},
+	{"PN3",		WTBL_PN3_MASK,		WTBL_PN3_OFFSET,	false},
+	{NULL,}
+};
+
+static const struct berse_wtbl_parse WTBL_UMAC_DW3[] = {
+	{"PN4",		WTBL_PN4_MASK,		WTBL_PN4_OFFSET,	false},
+	{"PN5",		WTBL_PN5_MASK,		WTBL_PN5_OFFSET,	true},
+	{"COM_SN",	WF_UWTBL_COM_SN_MASK,	WF_UWTBL_COM_SN_SHIFT,	true},
+	{NULL,}
+};
+
+static const struct berse_wtbl_parse WTBL_UMAC_DW4_BIPN[] = {
+	{"BIPN0",	WTBL_BIPN0_MASK,	WTBL_BIPN0_OFFSET,	false},
+	{"BIPN1",	WTBL_BIPN1_MASK,	WTBL_BIPN1_OFFSET,	false},
+	{"BIPN2",	WTBL_BIPN2_MASK,	WTBL_BIPN2_OFFSET,	true},
+	{"BIPN3",	WTBL_BIPN3_MASK,	WTBL_BIPN3_OFFSET,	false},
+	{NULL,}
+};
+
+static const struct berse_wtbl_parse WTBL_UMAC_DW5_BIPN[] = {
+	{"BIPN4",	WTBL_BIPN4_MASK,	WTBL_BIPN4_OFFSET,	false},
+	{"BIPN5",	WTBL_BIPN5_MASK,	WTBL_BIPN5_OFFSET,	true},
+	{NULL,}
+};
+
+static void parse_fmac_uwtbl_pn(struct seq_file *s, u8 *uwtbl, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	seq_printf(s, "\t\n");
+	seq_printf(s, "UWTBL PN\n");
+
+	/* UMAC WTBL DW 2/3 */
+	addr = (u32 *)&(uwtbl[WF_UWTBL_PN_31_0__DW*4]);
+	dw_value = *addr;
+
+	while (WTBL_UMAC_DW2[i].name) {
+		seq_printf(s, "\t%s:%u\n", WTBL_UMAC_DW2[i].name,
+			(dw_value & WTBL_UMAC_DW2[i].mask) >>
+				WTBL_UMAC_DW2[i].shift);
+		i++;
+	}
+
+	i = 0;
+	addr = (u32 *)&(uwtbl[WF_UWTBL_PN_47_32__DW*4]);
+	dw_value = *addr;
+
+	while (WTBL_UMAC_DW3[i].name) {
+		seq_printf(s, "\t%s:%u\n", WTBL_UMAC_DW3[i].name,
+			 (dw_value & WTBL_UMAC_DW3[i].mask) >>
+			WTBL_UMAC_DW3[i].shift);
+		i++;
+	}
+
+
+	/* UMAC WTBL DW 4/5 for BIGTK */
+	if (is_wtbl_bigtk_exist(lwtbl) == true) {
+		i = 0;
+		addr = (u32 *)&(uwtbl[WF_UWTBL_RX_BIPN_31_0__DW*4]);
+		dw_value = *addr;
+
+		while (WTBL_UMAC_DW4_BIPN[i].name) {
+			seq_printf(s, "\t%s:%u\n", WTBL_UMAC_DW4_BIPN[i].name,
+				(dw_value & WTBL_UMAC_DW4_BIPN[i].mask) >>
+					WTBL_UMAC_DW4_BIPN[i].shift);
+			i++;
+		}
+
+		i = 0;
+		addr = (u32 *)&(uwtbl[WF_UWTBL_RX_BIPN_47_32__DW*4]);
+		dw_value = *addr;
+
+		while (WTBL_UMAC_DW5_BIPN[i].name) {
+			seq_printf(s, "\t%s:%u\n", WTBL_UMAC_DW5_BIPN[i].name,
+				(dw_value & WTBL_UMAC_DW5_BIPN[i].mask) >>
+				WTBL_UMAC_DW5_BIPN[i].shift);
+			i++;
+		}
+	}
+}
+
+static void parse_fmac_uwtbl_sn(struct seq_file *s, u8 *uwtbl)
+{
+	u32 *addr = 0;
+	u32 u2SN = 0;
+
+	/* UMAC WTBL DW SN part */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "UWTBL SN\n");
+
+	addr = (u32 *)&(uwtbl[WF_UWTBL_TID0_SN_DW*4]);
+	u2SN = ((*addr) & WF_UWTBL_TID0_SN_MASK) >> WF_UWTBL_TID0_SN_SHIFT;
+	seq_printf(s, "\t%s:%u\n", "TID0_AC0_SN", u2SN);
+
+	addr = (u32 *)&(uwtbl[WF_UWTBL_TID1_SN_DW*4]);
+	u2SN = ((*addr) & WF_UWTBL_TID1_SN_MASK) >> WF_UWTBL_TID1_SN_SHIFT;
+	seq_printf(s, "\t%s:%u\n", "TID1_AC1_SN", u2SN);
+
+	addr = (u32 *)&(uwtbl[WF_UWTBL_TID2_SN_7_0__DW*4]);
+	u2SN = ((*addr) & WF_UWTBL_TID2_SN_7_0__MASK) >>
+				WF_UWTBL_TID2_SN_7_0__SHIFT;
+	addr = (u32 *)&(uwtbl[WF_UWTBL_TID2_SN_11_8__DW*4]);
+	u2SN |= (((*addr) & WF_UWTBL_TID2_SN_11_8__MASK) >>
+			WF_UWTBL_TID2_SN_11_8__SHIFT) << 8;
+	seq_printf(s, "\t%s:%u\n", "TID2_AC2_SN", u2SN);
+
+	addr = (u32 *)&(uwtbl[WF_UWTBL_TID3_SN_DW*4]);
+	u2SN = ((*addr) & WF_UWTBL_TID3_SN_MASK) >> WF_UWTBL_TID3_SN_SHIFT;
+	seq_printf(s, "\t%s:%u\n", "TID3_AC3_SN", u2SN);
+
+	addr = (u32 *)&(uwtbl[WF_UWTBL_TID4_SN_DW*4]);
+	u2SN = ((*addr) & WF_UWTBL_TID4_SN_MASK) >> WF_UWTBL_TID4_SN_SHIFT;
+	seq_printf(s, "\t%s:%u\n", "TID4_SN", u2SN);
+
+	addr = (u32 *)&(uwtbl[WF_UWTBL_TID5_SN_3_0__DW*4]);
+	u2SN = ((*addr) & WF_UWTBL_TID5_SN_3_0__MASK) >>
+				WF_UWTBL_TID5_SN_3_0__SHIFT;
+	addr = (u32 *)&(uwtbl[WF_UWTBL_TID5_SN_11_4__DW*4]);
+	u2SN |= (((*addr) & WF_UWTBL_TID5_SN_11_4__MASK) >>
+				WF_UWTBL_TID5_SN_11_4__SHIFT) << 4;
+	seq_printf(s, "\t%s:%u\n", "TID5_SN", u2SN);
+
+	addr = (u32 *)&(uwtbl[WF_UWTBL_TID6_SN_DW*4]);
+	u2SN = ((*addr) & WF_UWTBL_TID6_SN_MASK) >> WF_UWTBL_TID6_SN_SHIFT;
+	seq_printf(s, "\t%s:%u\n", "TID6_SN", u2SN);
+
+	addr = (u32 *)&(uwtbl[WF_UWTBL_TID7_SN_DW*4]);
+	u2SN = ((*addr) & WF_UWTBL_TID7_SN_MASK) >> WF_UWTBL_TID7_SN_SHIFT;
+	seq_printf(s, "\t%s:%u\n", "TID7_SN", u2SN);
+
+	addr = (u32 *)&(uwtbl[WF_UWTBL_COM_SN_DW*4]);
+	u2SN = ((*addr) & WF_UWTBL_COM_SN_MASK) >> WF_UWTBL_COM_SN_SHIFT;
+	seq_printf(s, "\t%s:%u\n", "COM_SN", u2SN);
+}
+
+static void dump_key_table(
+	struct seq_file *s,
+	uint16_t keyloc0,
+	uint16_t keyloc1,
+	uint16_t keyloc2
+)
+{
+#define ONE_KEY_ENTRY_LEN_IN_DW                8
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	u8 keytbl[ONE_KEY_ENTRY_LEN_IN_DW*4] = {0};
+	uint16_t x;
+
+	seq_printf(s, "\t\n");
+	seq_printf(s, "\t%s:%d\n", "keyloc0", keyloc0);
+	if (keyloc0 != INVALID_KEY_ENTRY) {
+
+		/* Don't swap below two lines, halWtblReadRaw will
+		* write new value WF_WTBLON_TOP_WDUCR_ADDR
+		*/
+		mt7996_wtbl_read_raw(dev, keyloc0,
+			WTBL_TYPE_KEY, 0, ONE_KEY_ENTRY_LEN_IN_DW, keytbl);
+		seq_printf(s, "\t\tKEY WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
+			MT_DBG_UWTBL_TOP_WDUCR_ADDR,
+			mt76_rr(dev, MT_DBG_UWTBL_TOP_WDUCR_ADDR),
+			KEYTBL_IDX2BASE(keyloc0, 0));
+		for (x = 0; x < ONE_KEY_ENTRY_LEN_IN_DW; x++) {
+			seq_printf(s, "\t\tDW%02d: %02x %02x %02x %02x\n",
+				x,
+				keytbl[x * 4 + 3],
+				keytbl[x * 4 + 2],
+				keytbl[x * 4 + 1],
+				keytbl[x * 4]);
+		}
+	}
+
+	seq_printf(s, "\t%s:%d\n", "keyloc1", keyloc1);
+	if (keyloc1 != INVALID_KEY_ENTRY) {
+		/* Don't swap below two lines, halWtblReadRaw will
+		* write new value WF_WTBLON_TOP_WDUCR_ADDR
+		*/
+		mt7996_wtbl_read_raw(dev, keyloc1,
+			WTBL_TYPE_KEY, 0, ONE_KEY_ENTRY_LEN_IN_DW, keytbl);
+		seq_printf(s, "\t\tKEY WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
+			MT_DBG_UWTBL_TOP_WDUCR_ADDR,
+			mt76_rr(dev, MT_DBG_UWTBL_TOP_WDUCR_ADDR),
+			KEYTBL_IDX2BASE(keyloc1, 0));
+		for (x = 0; x < ONE_KEY_ENTRY_LEN_IN_DW; x++) {
+			seq_printf(s, "\t\tDW%02d: %02x %02x %02x %02x\n",
+				x,
+				keytbl[x * 4 + 3],
+				keytbl[x * 4 + 2],
+				keytbl[x * 4 + 1],
+				keytbl[x * 4]);
+		}
+	}
+
+	seq_printf(s, "\t%s:%d\n", "keyloc2", keyloc2);
+	if (keyloc2 != INVALID_KEY_ENTRY) {
+		/* Don't swap below two lines, halWtblReadRaw will
+		* write new value WF_WTBLON_TOP_WDUCR_ADDR
+		*/
+		mt7996_wtbl_read_raw(dev, keyloc2,
+			WTBL_TYPE_KEY, 0, ONE_KEY_ENTRY_LEN_IN_DW, keytbl);
+		seq_printf(s, "\t\tKEY WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
+			MT_DBG_UWTBL_TOP_WDUCR_ADDR,
+			mt76_rr(dev, MT_DBG_UWTBL_TOP_WDUCR_ADDR),
+			KEYTBL_IDX2BASE(keyloc2, 0));
+		for (x = 0; x < ONE_KEY_ENTRY_LEN_IN_DW; x++) {
+			seq_printf(s, "\t\tDW%02d: %02x %02x %02x %02x\n",
+				x,
+				keytbl[x * 4 + 3],
+				keytbl[x * 4 + 2],
+				keytbl[x * 4 + 1],
+				keytbl[x * 4]);
+		}
+	}
+}
+
+static void parse_fmac_uwtbl_key_info(struct seq_file *s, u8 *uwtbl, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	uint16_t keyloc0 = INVALID_KEY_ENTRY;
+	uint16_t keyloc1 = INVALID_KEY_ENTRY;
+	uint16_t keyloc2 = INVALID_KEY_ENTRY;
+
+	/* UMAC WTBL DW 7 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "UWTBL key info\n");
+
+	addr = (u32 *)&(uwtbl[WF_UWTBL_KEY_LOC0_DW*4]);
+	dw_value = *addr;
+	keyloc0 = (dw_value & WF_UWTBL_KEY_LOC0_MASK) >> WF_UWTBL_KEY_LOC0_SHIFT;
+	keyloc1 = (dw_value & WF_UWTBL_KEY_LOC1_MASK) >> WF_UWTBL_KEY_LOC1_SHIFT;
+
+	seq_printf(s, "\t%s:%u/%u\n", "Key Loc 0/1", keyloc0, keyloc1);
+
+	/* UMAC WTBL DW 6 for BIGTK */
+	if (is_wtbl_bigtk_exist(lwtbl) == true) {
+		addr = (u32 *)&(uwtbl[WF_UWTBL_KEY_LOC2_DW*4]);
+		dw_value = *addr;
+		keyloc2 = (dw_value & WF_UWTBL_KEY_LOC2_MASK) >>
+			WF_UWTBL_KEY_LOC2_SHIFT;
+		seq_printf(s, "\t%s:%u\n", "Key Loc 2", keyloc2);
+	}
+
+	/* Parse KEY link */
+	dump_key_table(s, keyloc0, keyloc1, keyloc2);
+}
+
+static const struct berse_wtbl_parse WTBL_UMAC_DW8[] = {
+	{"UWTBL_WMM_Q",		WF_UWTBL_WMM_Q_MASK,		WF_UWTBL_WMM_Q_SHIFT,	false},
+	{"UWTBL_QOS",		WF_UWTBL_QOS_MASK,		NO_SHIFT_DEFINE,	false},
+	{"UWTBL_HT_VHT_HE",	WF_UWTBL_HT_MASK,		NO_SHIFT_DEFINE,	false},
+	{"UWTBL_HDRT_MODE",	WF_UWTBL_HDRT_MODE_MASK,	NO_SHIFT_DEFINE,	true},
+	{NULL,}
+};
+
+static void parse_fmac_uwtbl_msdu_info(struct seq_file *s, u8 *uwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u32 amsdu_len = 0;
+	u16 i = 0;
+
+	/* UMAC WTBL DW 8 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "UWTBL DW8\n");
+
+	addr = (u32 *)&(uwtbl[WF_UWTBL_AMSDU_CFG_DW*4]);
+	dw_value = *addr;
+
+	while (WTBL_UMAC_DW8[i].name) {
+
+		if (WTBL_UMAC_DW8[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_UMAC_DW8[i].name,
+				(dw_value & WTBL_UMAC_DW8[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_UMAC_DW8[i].name,
+				(dw_value & WTBL_UMAC_DW8[i].mask) >>
+					WTBL_UMAC_DW8[i].shift);
+		i++;
+	}
+
+	/* UMAC WTBL DW 8 - SEC_ADDR_MODE */
+	addr = (u32 *)&(uwtbl[WF_UWTBL_SEC_ADDR_MODE_DW*4]);
+	dw_value = *addr;
+	seq_printf(s, "\t%s:%lu\n", "SEC_ADDR_MODE",
+		(dw_value & WTBL_SEC_ADDR_MODE_MASK) >> WTBL_SEC_ADDR_MODE_OFFSET);
+
+	/* UMAC WTBL DW 8 - AMSDU_CFG */
+	seq_printf(s, "\t%s:%d\n", "HW AMSDU Enable",
+				(dw_value & WTBL_AMSDU_EN_MASK) ? 1 : 0);
+
+	amsdu_len = (dw_value & WTBL_AMSDU_LEN_MASK) >> WTBL_AMSDU_LEN_OFFSET;
+	if (amsdu_len == 0)
+		seq_printf(s, "\t%s:invalid (WTBL value=0x%x)\n", "HW AMSDU Len",
+			amsdu_len);
+	else if (amsdu_len == 1)
+		seq_printf(s, "\t%s:%d~%d (WTBL value=0x%x)\n", "HW AMSDU Len",
+			1,
+			255,
+			amsdu_len);
+	else if (amsdu_len == 2)
+		seq_printf(s, "\t%s:%d~%d (WTBL value=0x%x)\n", "HW AMSDU Len",
+			256,
+			511,
+			amsdu_len);
+	else if (amsdu_len == 3)
+		seq_printf(s, "\t%s:%d~%d (WTBL value=0x%x)\n", "HW AMSDU Len",
+			512,
+			767,
+			amsdu_len);
+	else
+		seq_printf(s, "\t%s:%d~%d (WTBL value=0x%x)\n", "HW AMSDU Len",
+			256 * (amsdu_len - 1),
+			256 * (amsdu_len - 1) + 255,
+			amsdu_len);
+
+	seq_printf(s, "\t%s:%lu (WTBL value=0x%lx)\n", "HW AMSDU Num",
+		((dw_value & WTBL_AMSDU_NUM_MASK) >> WTBL_AMSDU_NUM_OFFSET) + 1,
+		(dw_value & WTBL_AMSDU_NUM_MASK) >> WTBL_AMSDU_NUM_OFFSET);
+}
+
+static int mt7996_wtbl_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	u8 lwtbl[LWTBL_LEN_IN_DW * 4] = {0};
+	u8 uwtbl[UWTBL_LEN_IN_DW * 4] = {0};
+	int x;
+
+	mt7996_wtbl_read_raw(dev, dev->wlan_idx, WTBL_TYPE_LMAC, 0,
+				 LWTBL_LEN_IN_DW, lwtbl);
+	seq_printf(s, "Dump WTBL info of WLAN_IDX:%d\n", dev->wlan_idx);
+	seq_printf(s, "LMAC WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
+		   MT_DBG_WTBLON_TOP_WDUCR_ADDR,
+		   mt76_rr(dev, MT_DBG_WTBLON_TOP_WDUCR_ADDR),
+		   LWTBL_IDX2BASE(dev->wlan_idx, 0));
+	for (x = 0; x < LWTBL_LEN_IN_DW; x++) {
+		seq_printf(s, "DW%02d: %02x %02x %02x %02x\n",
+			   x,
+			   lwtbl[x * 4 + 3],
+			   lwtbl[x * 4 + 2],
+			   lwtbl[x * 4 + 1],
+			   lwtbl[x * 4]);
+	}
+
+	/* Parse LWTBL */
+	parse_fmac_lwtbl_dw0_1(s, lwtbl);
+	parse_fmac_lwtbl_dw2(s, lwtbl);
+	parse_fmac_lwtbl_dw3(s, lwtbl);
+	parse_fmac_lwtbl_dw4(s, lwtbl);
+	parse_fmac_lwtbl_dw5(s, lwtbl);
+	parse_fmac_lwtbl_dw6(s, lwtbl);
+	parse_fmac_lwtbl_dw7(s, lwtbl);
+	parse_fmac_lwtbl_dw8(s, lwtbl);
+	parse_fmac_lwtbl_dw9(s, lwtbl);
+	parse_fmac_lwtbl_dw10(s, lwtbl);
+	parse_fmac_lwtbl_dw11(s, lwtbl);
+	parse_fmac_lwtbl_dw12(s, lwtbl);
+	parse_fmac_lwtbl_dw13(s, lwtbl);
+	parse_fmac_lwtbl_dw14(s, lwtbl);
+	parse_fmac_lwtbl_mlo_info(s, lwtbl);
+	parse_fmac_lwtbl_dw31(s, lwtbl);
+	parse_fmac_lwtbl_dw32(s, lwtbl);
+	parse_fmac_lwtbl_rx_stats(s, lwtbl);
+
+	mt7996_wtbl_read_raw(dev, dev->wlan_idx, WTBL_TYPE_UMAC, 0,
+				 UWTBL_LEN_IN_DW, uwtbl);
+	seq_printf(s, "Dump WTBL info of WLAN_IDX:%d\n", dev->wlan_idx);
+	seq_printf(s, "UMAC WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
+		   MT_DBG_UWTBL_TOP_WDUCR_ADDR,
+		   mt76_rr(dev, MT_DBG_UWTBL_TOP_WDUCR_ADDR),
+		   UWTBL_IDX2BASE(dev->wlan_idx, 0));
+	for (x = 0; x < UWTBL_LEN_IN_DW; x++) {
+		seq_printf(s, "DW%02d: %02x %02x %02x %02x\n",
+			   x,
+			   uwtbl[x * 4 + 3],
+			   uwtbl[x * 4 + 2],
+			   uwtbl[x * 4 + 1],
+			   uwtbl[x * 4]);
+	}
+
+	/* Parse UWTBL */
+	parse_fmac_uwtbl_mlo_info(s, uwtbl);
+	parse_fmac_uwtbl_pn(s, uwtbl, lwtbl);
+	parse_fmac_uwtbl_sn(s, uwtbl);
+	parse_fmac_uwtbl_key_info(s, uwtbl, lwtbl);
+	parse_fmac_uwtbl_msdu_info(s, uwtbl);
+
+	return 0;
+}
+
+static int mt7996_sta_info(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	u8 lwtbl[LWTBL_LEN_IN_DW*4] = {0};
+	u16 i = 0;
+
+	for (i=0; i < mt7996_wtbl_size(dev); i++) {
+		mt7996_wtbl_read_raw(dev, i, WTBL_TYPE_LMAC, 0,
+				     LWTBL_LEN_IN_DW, lwtbl);
+
+		if (lwtbl[4] || lwtbl[5] || lwtbl[6] || lwtbl[7] || lwtbl[0] || lwtbl[1]) {
+			u32 *addr, dw_value;
+
+			seq_printf(s, "wcid:%d\tAddr: %02x:%02x:%02x:%02x:%02x:%02x",
+					i, lwtbl[4], lwtbl[5], lwtbl[6], lwtbl[7], lwtbl[0], lwtbl[1]);
+
+			addr = (u32 *)&(lwtbl[WTBL_GROUP_TRX_CAP_DW_2*4]);
+			dw_value = *addr;
+			seq_printf(s, "\t%s:%u", WTBL_LMAC_DW2[0].name,
+					(dw_value & WTBL_LMAC_DW2[0].mask) >> WTBL_LMAC_DW2[0].shift);
+
+			addr = (u32 *)&(lwtbl[WTBL_GROUP_TRX_CAP_DW_5*4]);
+			dw_value = *addr;
+			seq_printf(s, "\tPSM:%u\n", !!(dw_value & WF_LWTBL_PSM_MASK));
+		}
+	}
+
+	return 0;
+}
+
+static int mt7996_token_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	int msdu_id;
+	struct mt76_txwi_cache *txwi;
+
+	seq_printf(s, "Token from host:\n");
+	spin_lock_bh(&dev->mt76.token_lock);
+	idr_for_each_entry(&dev->mt76.token, txwi, msdu_id) {
+		seq_printf(s, "%4d (wcid = %4d, pending time %u ms)\n",
+			   msdu_id, txwi->wcid,
+			   jiffies_to_msecs(jiffies - txwi->jiffies));
+	}
+	spin_unlock_bh(&dev->mt76.token_lock);
+	seq_printf(s, "\n");
+
+	return 0;
+}
+
+static int
+mt7996_scs_enable_set(void *data, u64 val)
+{
+	struct mt7996_phy *phy = data;
+
+	return mt7996_mcu_set_scs(phy, (u8) val);
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_scs_enable, NULL,
+			 mt7996_scs_enable_set, "%lld\n");
+
+static int
+mt7996_txpower_level_set(void *data, u64 val)
+{
+	struct mt7996_phy *phy = data;
+	int ret;
+
+	if (val > 100)
+		return -EINVAL;
+
+	ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_PERCENTAGE_CTRL, !!val);
+	if (ret)
+		return ret;
+
+	return mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_PERCENTAGE_DROP_CTRL, val);
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_txpower_level, NULL,
+			 mt7996_txpower_level_set, "%lld\n");
+
+static ssize_t
+mt7996_get_txpower_info(struct file *file, char __user *user_buf,
+			size_t count, loff_t *ppos)
+{
+	struct mt7996_phy *phy = file->private_data;
+	struct mt7996_mcu_txpower_event *event;
+	struct txpower_basic_info *basic_info;
+	struct device_node *np;
+	static const size_t size = 2048;
+	int len = 0;
+	ssize_t ret;
+	char *buf;
+
+	buf = kzalloc(size, GFP_KERNEL);
+	event = kzalloc(sizeof(*event), GFP_KERNEL);
+	if (!buf || !event) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = mt7996_mcu_get_tx_power_info(phy, BASIC_INFO, event);
+	if (ret ||
+	    le32_to_cpu(event->basic_info.category) != UNI_TXPOWER_BASIC_INFO)
+		goto out;
+
+	basic_info = &event->basic_info;
+
+	len += scnprintf(buf + len, size - len,
+			 "======================== BASIC INFO ========================\n");
+	len += scnprintf(buf + len, size - len, "    Band Index: %d, Channel Band: %d\n",
+			 basic_info->band_idx, basic_info->band);
+	len += scnprintf(buf + len, size - len, "    PA Type: %s\n",
+			 basic_info->is_epa ? "ePA" : "iPA");
+	len += scnprintf(buf + len, size - len, "    LNA Type: %s\n",
+			 basic_info->is_elna ? "eLNA" : "iLNA");
+
+	len += scnprintf(buf + len, size - len,
+			 "------------------------------------------------------------\n");
+	len += scnprintf(buf + len, size - len, "    SKU: %s\n",
+			 basic_info->sku_enable ? "enable" : "disable");
+	len += scnprintf(buf + len, size - len, "    Percentage Control: %s\n",
+			 basic_info->percentage_ctrl_enable ? "enable" : "disable");
+	len += scnprintf(buf + len, size - len, "    Power Drop: %d [dBm]\n",
+			 basic_info->power_drop_level >> 1);
+	len += scnprintf(buf + len, size - len, "    Backoff: %s\n",
+			 basic_info->bf_backoff_enable ? "enable" : "disable");
+	len += scnprintf(buf + len, size - len, "    TX Front-end Loss:  %d, %d, %d, %d\n",
+			 basic_info->front_end_loss_tx[0], basic_info->front_end_loss_tx[1],
+			 basic_info->front_end_loss_tx[2], basic_info->front_end_loss_tx[3]);
+	len += scnprintf(buf + len, size - len, "    RX Front-end Loss:  %d, %d, %d, %d\n",
+			 basic_info->front_end_loss_rx[0], basic_info->front_end_loss_rx[1],
+			 basic_info->front_end_loss_rx[2], basic_info->front_end_loss_rx[3]);
+	len += scnprintf(buf + len, size - len,
+			 "    MU TX Power Mode:  %s\n",
+			 basic_info->mu_tx_power_manual_enable ? "manual" : "auto");
+	len += scnprintf(buf + len, size - len,
+			 "    MU TX Power (Auto / Manual): %d / %d [0.5 dBm]\n",
+			 basic_info->mu_tx_power_auto, basic_info->mu_tx_power_manual);
+	len += scnprintf(buf + len, size - len,
+			 "    Thermal Compensation:  %s\n",
+			 basic_info->thermal_compensate_enable ? "enable" : "disable");
+	len += scnprintf(buf + len, size - len,
+			 "    Theraml Compensation Value: %d\n",
+			 basic_info->thermal_compensate_value);
+	np = mt76_find_power_limits_node(phy->mt76->dev);
+	len += scnprintf(buf + len, size - len,
+			 "    RegDB:  %s\n",
+			 !np ? "enable" : "disable");
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+
+out:
+	kfree(buf);
+	kfree(event);
+	return ret;
+}
+
+static const struct file_operations mt7996_txpower_info_fops = {
+	.read = mt7996_get_txpower_info,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+#define mt7996_txpower_puts(rate, _len)							\
+({											\
+	len += scnprintf(buf + len, size - len, "%-*s:", _len, #rate " (TMAC)");	\
+	for (i = 0; i < mt7996_sku_group_len[SKU_##rate]; i++, offs++)			\
+		len += scnprintf(buf + len, size - len, " %6d",				\
+				 event->phy_rate_info.frame_power[offs][band_idx]);	\
+	len += scnprintf(buf + len, size - len, "\n");					\
+})
+
+static ssize_t
+mt7996_get_txpower_sku(struct file *file, char __user *user_buf,
+		       size_t count, loff_t *ppos)
+{
+	struct mt7996_phy *phy = file->private_data;
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_mcu_txpower_event *event;
+	struct ieee80211_channel *chan = phy->mt76->chandef.chan;
+	struct ieee80211_supported_band sband;
+	u8 band_idx = phy->mt76->band_idx;
+	static const size_t size = 5120;
+	int i, offs = 0, len = 0;
+	u32 target_power = 0;
+	int n_chains = hweight16(phy->mt76->chainmask);
+	int path_delta = mt76_tx_power_path_delta(n_chains);
+	int pwr_delta;
+	ssize_t ret;
+	char *buf;
+	u32 reg;
+
+	buf = kzalloc(size, GFP_KERNEL);
+	event = kzalloc(sizeof(*event), GFP_KERNEL);
+	if (!buf || !event) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = mt7996_mcu_get_tx_power_info(phy, PHY_RATE_INFO, event);
+	if (ret ||
+	    le32_to_cpu(event->phy_rate_info.category) != UNI_TXPOWER_PHY_RATE_INFO)
+		goto out;
+
+	len += scnprintf(buf + len, size - len,
+			 "\nPhy %d TX Power Table (Channel %d)\n",
+			 band_idx, phy->mt76->chandef.chan->hw_value);
+	len += scnprintf(buf + len, size - len, "%-21s  %6s %6s %6s %6s\n",
+			 " ", "1m", "2m", "5m", "11m");
+	mt7996_txpower_puts(CCK, 21);
+
+	len += scnprintf(buf + len, size - len,
+			 "%-21s  %6s %6s %6s %6s %6s %6s %6s %6s\n",
+			 " ", "6m", "9m", "12m", "18m", "24m", "36m", "48m",
+			 "54m");
+	mt7996_txpower_puts(OFDM, 21);
+
+	len += scnprintf(buf + len, size - len,
+			 "%-21s  %6s %6s %6s %6s %6s %6s %6s %6s\n",
+			 " ", "mcs0", "mcs1", "mcs2", "mcs3", "mcs4",
+			 "mcs5", "mcs6", "mcs7");
+	mt7996_txpower_puts(HT20, 21);
+
+	len += scnprintf(buf + len, size - len,
+			 "%-21s  %6s %6s %6s %6s %6s %6s %6s %6s %6s\n",
+			 " ", "mcs0", "mcs1", "mcs2", "mcs3", "mcs4", "mcs5",
+			 "mcs6", "mcs7", "mcs32");
+	mt7996_txpower_puts(HT40, 21);
+
+	len += scnprintf(buf + len, size - len,
+			 "%-21s  %6s %6s %6s %6s %6s %6s %6s %6s %6s %6s %6s %6s\n",
+			 " ", "mcs0", "mcs1", "mcs2", "mcs3", "mcs4", "mcs5",
+			 "mcs6", "mcs7", "mcs8", "mcs9", "mcs10", "mcs11");
+	mt7996_txpower_puts(VHT20, 21);
+	mt7996_txpower_puts(VHT40, 21);
+	mt7996_txpower_puts(VHT80, 21);
+	mt7996_txpower_puts(VHT160, 21);
+	mt7996_txpower_puts(HE26, 21);
+	mt7996_txpower_puts(HE52, 21);
+	mt7996_txpower_puts(HE106, 21);
+	len += scnprintf(buf + len, size - len, "BW20/");
+	mt7996_txpower_puts(HE242, 16);
+	len += scnprintf(buf + len, size - len, "BW40/");
+	mt7996_txpower_puts(HE484, 16);
+	len += scnprintf(buf + len, size - len, "BW80/");
+	mt7996_txpower_puts(HE996, 16);
+	len += scnprintf(buf + len, size - len, "BW160/");
+	mt7996_txpower_puts(HE2x996, 15);
+
+	len += scnprintf(buf + len, size - len,
+			 "%-21s  %6s %6s %6s %6s %6s %6s %6s %6s ",
+			 " ", "mcs0", "mcs1", "mcs2", "mcs3", "mcs4", "mcs5", "mcs6", "mcs7");
+	len += scnprintf(buf + len, size - len,
+			 "%6s %6s %6s %6s %6s %6s %6s %6s\n",
+			 "mcs8", "mcs9", "mcs10", "mcs11", "mcs12", "mcs13", "mcs14", "mcs15");
+	mt7996_txpower_puts(EHT26, 21);
+	mt7996_txpower_puts(EHT52, 21);
+	mt7996_txpower_puts(EHT106, 21);
+	len += scnprintf(buf + len, size - len, "BW20/");
+	mt7996_txpower_puts(EHT242, 16);
+	len += scnprintf(buf + len, size - len, "BW40/");
+	mt7996_txpower_puts(EHT484, 16);
+	len += scnprintf(buf + len, size - len, "BW80/");
+	mt7996_txpower_puts(EHT996, 16);
+	len += scnprintf(buf + len, size - len, "BW160/");
+	mt7996_txpower_puts(EHT2x996, 15);
+	len += scnprintf(buf + len, size - len, "BW320/");
+	mt7996_txpower_puts(EHT4x996, 15);
+	mt7996_txpower_puts(EHT26_52, 21);
+	mt7996_txpower_puts(EHT26_106, 21);
+	mt7996_txpower_puts(EHT484_242, 21);
+	mt7996_txpower_puts(EHT996_484, 21);
+	mt7996_txpower_puts(EHT996_484_242, 21);
+	mt7996_txpower_puts(EHT2x996_484, 21);
+	mt7996_txpower_puts(EHT3x996, 21);
+	mt7996_txpower_puts(EHT3x996_484, 21);
+
+	len += scnprintf(buf + len, size - len, "\nePA Gain: %d\n",
+			 event->phy_rate_info.epa_gain);
+	len += scnprintf(buf + len, size - len, "Max Power Bound: %d\n",
+			 event->phy_rate_info.max_power_bound);
+	len += scnprintf(buf + len, size - len, "Min Power Bound: %d\n",
+			 event->phy_rate_info.min_power_bound);
+
+	reg = MT_WF_PHYDFE_TSSI_TXCTRL01(band_idx);
+	len += scnprintf(buf + len, size - len,
+			 "\nBBP TX Power (target power from TMAC)  : %6hhd [0.5 dBm]\n",
+			 (s8)mt76_get_field(dev, reg,
+			 		    MT_WF_PHYDFE_TSSI_TXCTRL_POWER_TMAC));
+	len += scnprintf(buf + len, size - len,
+			 "RegDB maximum power:\t%d [dBm]\n",
+			 chan->max_reg_power);
+
+	if (chan->band == NL80211_BAND_2GHZ)
+		sband = phy->mt76->sband_2g.sband;
+	else if (chan->band == NL80211_BAND_5GHZ)
+		sband = phy->mt76->sband_5g.sband;
+	else if (chan->band == NL80211_BAND_6GHZ)
+		sband = phy->mt76->sband_6g.sband;
+
+	pwr_delta = mt7996_eeprom_get_power_delta(dev, sband.band);
+
+	target_power = max_t(u32, target_power, mt7996_eeprom_get_target_power(dev, chan));
+	target_power += pwr_delta + path_delta;
+	target_power = DIV_ROUND_UP(target_power, 2);
+	len += scnprintf(buf + len, size - len,
+			 "eeprom maximum power:\t%d [dBm]\n",
+			 target_power);
+
+	len += scnprintf(buf + len, size - len,
+			 "path_delta:\t%d [0.5 dBm]\n",
+			 path_delta);
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+
+out:
+	kfree(buf);
+	kfree(event);
+	return ret;
+}
+
+static const struct file_operations mt7996_txpower_sku_fops = {
+	.read = mt7996_get_txpower_sku,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+#define mt7996_txpower_path_puts(rate, arr_length)					\
+({											\
+	len += scnprintf(buf + len, size - len, "%23s:", #rate " (TMAC)");		\
+	for (i = 0; i < arr_length; i++, offs++)					\
+		len += scnprintf(buf + len, size - len, " %4d",				\
+				 event->backoff_table_info.frame_power[offs]);		\
+	len += scnprintf(buf + len, size - len, "\n");					\
+})
+
+static ssize_t
+mt7996_get_txpower_path(struct file *file, char __user *user_buf,
+		       size_t count, loff_t *ppos)
+{
+	struct mt7996_phy *phy = file->private_data;
+	struct mt7996_mcu_txpower_event *event;
+	static const size_t size = 5120;
+	int i, offs = 0, len = 0;
+	ssize_t ret;
+	char *buf;
+
+	buf = kzalloc(size, GFP_KERNEL);
+	event = kzalloc(sizeof(*event), GFP_KERNEL);
+	if (!buf || !event) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = mt7996_mcu_get_tx_power_info(phy, BACKOFF_TABLE_INFO, event);
+	if (ret ||
+	    le32_to_cpu(event->phy_rate_info.category) != UNI_TXPOWER_BACKOFF_TABLE_SHOW_INFO)
+		goto out;
+
+	len += scnprintf(buf + len, size - len, "\n%*c", 25, ' ');
+	len += scnprintf(buf + len, size - len, "1T1S/2T1S/3T1S/4T1S/5T1S/2T2S/3T2S/4T2S/5T2S/"
+			 "3T3S/4T3S/5T3S/4T4S/5T4S/5T5S\n");
+
+	mt7996_txpower_path_puts(CCK, 5);
+	mt7996_txpower_path_puts(OFDM, 5);
+	mt7996_txpower_path_puts(BF-OFDM, 4);
+
+	mt7996_txpower_path_puts(RU26, 15);
+	mt7996_txpower_path_puts(BF-RU26, 15);
+	mt7996_txpower_path_puts(RU52, 15);
+	mt7996_txpower_path_puts(BF-RU52, 15);
+	mt7996_txpower_path_puts(RU26_52, 15);
+	mt7996_txpower_path_puts(BF-RU26_52, 15);
+	mt7996_txpower_path_puts(RU106, 15);
+	mt7996_txpower_path_puts(BF-RU106, 15);
+	mt7996_txpower_path_puts(RU106_52, 15);
+	mt7996_txpower_path_puts(BF-RU106_52, 15);
+
+	mt7996_txpower_path_puts(BW20/RU242, 15);
+	mt7996_txpower_path_puts(BF-BW20/RU242, 15);
+	mt7996_txpower_path_puts(BW40/RU484, 15);
+	mt7996_txpower_path_puts(BF-BW40/RU484, 15);
+	mt7996_txpower_path_puts(RU242_484, 15);
+	mt7996_txpower_path_puts(BF-RU242_484, 15);
+	mt7996_txpower_path_puts(BW80/RU996, 15);
+	mt7996_txpower_path_puts(BF-BW80/RU996, 15);
+	mt7996_txpower_path_puts(RU484_996, 15);
+	mt7996_txpower_path_puts(BF-RU484_996, 15);
+	mt7996_txpower_path_puts(RU242_484_996, 15);
+	mt7996_txpower_path_puts(BF-RU242_484_996, 15);
+	mt7996_txpower_path_puts(BW160/RU996x2, 15);
+	mt7996_txpower_path_puts(BF-BW160/RU996x2, 15);
+	mt7996_txpower_path_puts(RU484_996x2, 15);
+	mt7996_txpower_path_puts(BF-RU484_996x2, 15);
+	mt7996_txpower_path_puts(RU996x3, 15);
+	mt7996_txpower_path_puts(BF-RU996x3, 15);
+	mt7996_txpower_path_puts(RU484_996x3, 15);
+	mt7996_txpower_path_puts(BF-RU484_996x3, 15);
+	mt7996_txpower_path_puts(BW320/RU996x4, 15);
+	mt7996_txpower_path_puts(BF-BW320/RU996x4, 15);
+
+	len += scnprintf(buf + len, size - len, "\nBackoff table: %s\n",
+			 event->backoff_table_info.backoff_en ? "enable" : "disable");
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+
+out:
+	kfree(buf);
+	kfree(event);
+	return ret;
+}
+
+static const struct file_operations mt7996_txpower_path_fops = {
+	.read = mt7996_get_txpower_path,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static int mt7996_show_eeprom_mode(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	struct mt76_dev *mdev = &dev->mt76;
+#ifdef CONFIG_NL80211_TESTMODE
+	const char *mtd_name = mdev->test_mtd.name;
+	u32 mtd_offset = mdev->test_mtd.offset;
+#else
+	const char *mtd_name = NULL;
+	u32 mtd_offset;
+#endif
+
+	seq_printf(s, "Current eeprom mode:\n");
+
+	switch (dev->eeprom_mode) {
+	case DEFAULT_BIN_MODE:
+		seq_printf(s, "   default bin mode\n   filename = %s\n", mt7996_eeprom_name(dev));
+		break;
+	case EFUSE_MODE:
+		seq_printf(s, "   efuse mode\n");
+		break;
+	case FLASH_MODE:
+		if (mtd_name)
+			seq_printf(s, "   flash mode\n   mtd name = %s\n   flash offset = 0x%x\n",
+				   mtd_name, mtd_offset);
+		else
+			seq_printf(s, "   flash mode\n");
+		break;
+	case BIN_FILE_MODE:
+		seq_printf(s, "   bin file mode\n   filename = %s\n", dev->mt76.bin_file_name);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int
+mt7996_sr_enable_get(void *data, u64 *val)
+{
+	struct mt7996_phy *phy = data;
+
+	*val = phy->sr_enable;
+
+	return 0;
+}
+
+static int
+mt7996_sr_enable_set(void *data, u64 val)
+{
+	struct mt7996_phy *phy = data;
+	int ret;
+
+	if (!!val == phy->sr_enable)
+		return 0;
+
+	ret = mt7996_mcu_set_sr_enable(phy, UNI_CMD_SR_CFG_SR_ENABLE, val, true);
+	if (ret)
+		return ret;
+
+	return mt7996_mcu_set_sr_enable(phy, UNI_CMD_SR_CFG_SR_ENABLE, 0, false);
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_sr_enable, mt7996_sr_enable_get,
+			 mt7996_sr_enable_set, "%lld\n");
+static int
+mt7996_sr_enhanced_enable_get(void *data, u64 *val)
+{
+	struct mt7996_phy *phy = data;
+
+	*val = phy->enhanced_sr_enable;
+
+	return 0;
+}
+
+static int
+mt7996_sr_enhanced_enable_set(void *data, u64 val)
+{
+	struct mt7996_phy *phy = data;
+	int ret;
+
+	if (!!val == phy->enhanced_sr_enable)
+		return 0;
+
+	ret = mt7996_mcu_set_sr_enable(phy, UNI_CMD_SR_HW_ENHANCE_SR_ENABLE, val, true);
+	if (ret)
+		return ret;
+
+	return mt7996_mcu_set_sr_enable(phy, UNI_CMD_SR_HW_ENHANCE_SR_ENABLE, 0, false);
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_sr_enhanced_enable, mt7996_sr_enhanced_enable_get,
+			 mt7996_sr_enhanced_enable_set, "%lld\n");
+
+static int
+mt7996_sr_stats_show(struct seq_file *file, void *data)
+{
+	struct mt7996_phy *phy = file->private;
+
+	mt7996_mcu_set_sr_enable(phy, UNI_CMD_SR_HW_IND, 0, false);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_sr_stats);
+
+static int
+mt7996_sr_scene_cond_show(struct seq_file *file, void *data)
+{
+	struct mt7996_phy *phy = file->private;
+
+	mt7996_mcu_set_sr_enable(phy, UNI_CMD_SR_SW_SD, 0, false);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_sr_scene_cond);
+
+static int
+mt7996_starec_bf_read_set(void *data, u64 wlan_idx)
+{
+	struct mt7996_phy *phy = data;
+
+	return mt7996_mcu_set_txbf_internal(phy, BF_STA_REC_READ, wlan_idx, 0);
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_starec_bf_read, NULL,
+			 mt7996_starec_bf_read_set, "%lld\n");
+
+static ssize_t
+mt7996_bf_txsnd_info_set(struct file *file,
+			 const char __user *user_buf,
+			 size_t count, loff_t *ppos)
+{
+	struct mt7996_phy *phy = file->private_data;
+	char buf[40];
+	int ret;
+
+	if (count >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (count && buf[count - 1] == '\n')
+		buf[count - 1] = '\0';
+	else
+		buf[count] = '\0';
+
+	ret = mt7996_mcu_set_txbf_snd_info(phy, buf);
+
+	if (ret) return -EFAULT;
+
+	return count;
+}
+
+static const struct file_operations fops_bf_txsnd_info = {
+	.write = mt7996_bf_txsnd_info_set,
+	.read = NULL,
+	.open = simple_open,
+	.llseek = default_llseek,
+};
+
+static int
+mt7996_bf_fbk_rpt_set(void *data, u64 wlan_idx)
+{
+	struct mt7996_phy *phy = data;
+
+	return mt7996_mcu_set_txbf_internal(phy, BF_FBRPT_DBG_INFO_READ, wlan_idx, 0);
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_bf_fbk_rpt, NULL,
+			 mt7996_bf_fbk_rpt_set, "%lld\n");
+
+static int
+mt7996_bf_pfmu_tag_read_set(void *data, u64 wlan_idx)
+{
+	struct mt7996_phy *phy = data;
+
+	return mt7996_mcu_set_txbf_internal(phy, BF_PFMU_TAG_READ, wlan_idx, 1);
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_bf_pfmu_tag_read, NULL,
+			 mt7996_bf_pfmu_tag_read_set, "%lld\n");
+
+static int
+mt7996_muru_fixed_rate_set(void *data, u64 val)
+{
+	struct mt7996_dev *dev = data;
+
+	return mt7996_mcu_set_muru_fixed_rate_enable(dev, UNI_CMD_MURU_FIXED_RATE_CTRL,
+						     val);
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_muru_fixed_rate_enable, NULL,
+			 mt7996_muru_fixed_rate_set, "%lld\n");
+
+static ssize_t
+mt7996_muru_fixed_rate_parameter_set(struct file *file,
+				     const char __user *user_buf,
+				     size_t count, loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+	char buf[40];
+	int ret;
+
+	if (count >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (count && buf[count - 1] == '\n')
+		buf[count - 1] = '\0';
+	else
+		buf[count] = '\0';
+
+
+	ret = mt7996_mcu_set_muru_fixed_rate_parameter(dev, UNI_CMD_MURU_FIXED_GROUP_RATE_CTRL,
+						       buf);
+
+	if (ret) return -EFAULT;
+
+	return count;
+}
+
+static const struct file_operations fops_muru_fixed_group_rate = {
+	.write = mt7996_muru_fixed_rate_parameter_set,
+	.read = NULL,
+	.open = simple_open,
+	.llseek = default_llseek,
+};
+
+static int mt7996_muru_prot_thr_set(void *data, u64 val)
+{
+	struct mt7996_dev *dev = data;
+
+	return mt7996_mcu_muru_set_prot_frame_thr(dev, (u32)val);
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_muru_prot_thr, NULL,
+			 mt7996_muru_prot_thr_set, "%lld\n");
+
+static int
+mt7996_red_config_get(void *data, u64 *val)
+{
+	struct mt7996_dev *dev = data;
+
+	*val = dev->red_enable;
+
+	return 0;
+}
+
+static int
+mt7996_red_config_set(void *data, u64 val)
+{
+	struct mt7996_dev *dev = data;
+
+	return mt7996_mcu_red_config(dev, !!val);
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_red_config, mt7996_red_config_get,
+			 mt7996_red_config_set, "%lld\n");
+
+static int
+mt7996_vow_drr_dbg(void *data, u64 val)
+{
+	struct mt7996_dev *dev = data;
+
+	return mt7996_mcu_set_vow_drr_dbg(dev, (u32)val);
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_vow_drr_dbg, NULL,
+			 mt7996_vow_drr_dbg, "%lld\n");
+
+static int
+mt7996_rro_session_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	struct mt7996_rro_ba_session *tbl;
+	u32 value[2];
+
+	mt76_wr(dev, MT_RRO_DBG_RD_CTRL, MT_RRO_DBG_RD_EXEC +
+		(dev->dbg.sid >> 1) + 0x200);
+
+	if (dev->dbg.sid & 0x1) {
+		value[0] = mt76_rr(dev, MT_RRO_DBG_RDAT_DW(2));
+		value[1] = mt76_rr(dev, MT_RRO_DBG_RDAT_DW(3));
+	} else {
+		value[0] = mt76_rr(dev, MT_RRO_DBG_RDAT_DW(0));
+		value[1] = mt76_rr(dev, MT_RRO_DBG_RDAT_DW(1));
+	}
+
+	tbl = (struct mt7996_rro_ba_session *)&value[0];
+
+	seq_printf(s, " seid %d:\nba session table DW0:%08x DW2:%08x\n",
+		   dev->dbg.sid, value[0], value[1]);
+
+	seq_printf(s, "ack_sn = 0x%x, last_in_sn = 0x%x, sat/bn/bc/bd/cn = %d/%d/%d/%d/%d\n",
+		   tbl->ack_sn, tbl->last_in_sn, tbl->sat, tbl->bn, tbl->bc, tbl->bd, tbl->cn);
+
+	seq_printf(s, "within_cnt = %d, to_sel = %d, last_in_rxtime = %d\n",
+		   tbl->within_cnt, tbl->to_sel, tbl->last_in_rxtime);
+
+	return 0;
+}
+
+static int
+mt7996_show_rro_mib(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	u32 reg[12];
+
+	seq_printf(s, "RRO mib Info:\n");
+
+	reg[0] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(0));
+	reg[1] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(1));
+	reg[2] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(2));
+	reg[3] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(3));
+	reg[4] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(4));
+	reg[5] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(5));
+	reg[6] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(6));
+	reg[7] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(7));
+	reg[8] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(8));
+	reg[9] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(9));
+	reg[10] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(10));
+	reg[11] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(11));
+
+	seq_printf(s, "STEP_ONE/WITHIN/SURPASS = %x/%x/%x\n", reg[0], reg[3], reg[4]);
+	seq_printf(s, "REPEAT/OLDPKT/BAR = %x/%x/%x\n", reg[1], reg[2], reg[5]);
+	seq_printf(s, "SURPASS with big gap = %x\n", reg[6]);
+	seq_printf(s, "DISCONNECT/INVALID = %x/%x\n", reg[7], reg[8]);
+	seq_printf(s, "TO(Step one)/TO(flush all) = %x/%x\n", reg[9], reg[10]);
+	seq_printf(s, "buf ran out = %x\n", reg[11]);
+
+	return 0;
+}
+
+static int
+mt7996_thermal_enable_get(void *data, u64 *enable)
+{
+	struct mt7996_phy *phy = data;
+
+	*enable = phy->thermal_protection_enable;
+
+	return 0;
+}
+
+static int
+mt7996_thermal_enable_set(void *data, u64 action)
+{
+	struct mt7996_phy *phy = data;
+	int ret;
+	u8 throttling;
+
+	if (action > 1)
+		return -EINVAL;
+
+	if (!!action == phy->thermal_protection_enable)
+		return 0;
+
+	ret = mt7996_mcu_set_thermal_protect(phy, !!action);
+	if (ret)
+		return ret;
+
+	if (!!!action)
+		goto out;
+
+	throttling = MT7996_THERMAL_THROTTLE_MAX - phy->cdev_state;
+	ret = mt7996_mcu_set_thermal_throttling(phy, throttling);
+	if (ret)
+		return ret;
+
+out:
+	phy->thermal_protection_enable = !!action;
+
+	return 0;
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_thermal_enable, mt7996_thermal_enable_get,
+			 mt7996_thermal_enable_set, "%lld\n");
+
+static int
+mt7996_thermal_recal_set(void *data, u64 val)
+{
+#define THERMAL_DEBUG_OPERATION_MANUAL_TRIGGER 2
+#define THERMAL_DEBUG_MODE_RECAL 1
+	struct mt7996_dev *dev = data;
+
+	if (val > THERMAL_DEBUG_OPERATION_MANUAL_TRIGGER)
+		return -EINVAL;
+
+	return mt7996_mcu_thermal_debug(dev, THERMAL_DEBUG_MODE_RECAL, val);
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_thermal_recal, NULL,
+			 mt7996_thermal_recal_set, "%llu\n");
+
+static int
+mt7996_reset_counter(void *data, u64 val)
+{
+	struct mt7996_dev *dev = data;
+	struct mt76_dev *mdev = &dev->mt76;
+	struct mt76_wcid *wcid;
+	int ret;
+
+	/* Reset read-clear counters in FW and WTBL. */
+	ret = mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_TXRX_ADM_STAT);
+	if (ret)
+		return ret;
+
+	ret = mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_TXRX_MSDU_COUNT);
+	if (ret)
+		return ret;
+
+	ret = mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_TXRX_AIR_TIME);
+	if (ret)
+		return ret;
+
+	ret = mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_RX_MPDU_COUNT);
+	if (ret)
+		return ret;
+
+	/* Reset counters in MT76. */
+	rcu_read_lock();
+	wcid = rcu_dereference(dev->mt76.wcid[dev->wlan_idx]);
+	if (wcid)
+		memset(&wcid->stats, 0, sizeof(struct mt76_sta_stats));
+	else
+		ret = -EINVAL;
+	rcu_read_unlock();
+
+	return ret;
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_reset_counter, NULL, mt7996_reset_counter, "%llu\n");
+
+void mt7996_packet_log_to_host(struct mt7996_dev *dev, const void *data, int len, int type, int des_len)
+{
+	struct bin_debug_hdr *hdr;
+	char *buf;
+
+	if (len > 1500 - sizeof(*hdr))
+	len = 1500 - sizeof(*hdr);
+
+	buf = kzalloc(sizeof(*hdr) + len, GFP_KERNEL);
+	if (!buf)
+		return;
+
+	hdr = (struct bin_debug_hdr *)buf;
+	hdr->magic_num = cpu_to_le32(PKT_BIN_DEBUG_MAGIC);
+	hdr->serial_id = cpu_to_le16(dev->fw_debug_seq++);
+	hdr->msg_type = cpu_to_le16(type);
+	hdr->len = cpu_to_le16(len);
+	hdr->des_len = cpu_to_le16(des_len);
+
+	memcpy(buf + sizeof(*hdr), data, len);
+
+	mt7996_debugfs_rx_log(dev, buf, sizeof(*hdr) + len);
+	kfree(buf);
+}
+
+static int mt7996_rx_token_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	int id, count = 0;
+	struct mt76_txwi_cache *t;
+
+	seq_printf(s, "Rx cut through token:\n");
+	spin_lock_bh(&dev->mt76.rx_token_lock);
+	idr_for_each_entry(&dev->mt76.rx_token, t, id) {
+		count++;
+	}
+	seq_printf(s, "\ttotal:%8d used:%8d\n",
+		   dev->mt76.rx_token_size, count);
+	spin_unlock_bh(&dev->mt76.rx_token_lock);
+
+	return 0;
+}
+
+/* AMSDU SETTING */
+static ssize_t mt7996_amsdu_algo_write(struct file *file,
+				   const char __user *user_buf,
+				   size_t count,
+				   loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+	char buf[100];
+	int ret;
+	struct {
+		u8 _rsv[4];
+
+		u16 tag;
+		u16 len;
+
+		u16 wlan_idx;
+		u8 algo_en;
+		u8 rsv[1];
+	} __packed data = {
+		.tag = cpu_to_le16(UNI_MEC_AMSDU_ALGO_EN_STA),
+		.len = cpu_to_le16(sizeof(data) - 4),
+	};
+
+	if (count >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (count && buf[count - 1] == '\n')
+		buf[count - 1] = '\0';
+	else
+		buf[count] = '\0';
+
+	if (sscanf(buf, "%hu %hhu", &data.wlan_idx, &data.algo_en) != 2)
+		return -EINVAL;
+
+	if (data.wlan_idx >= mt7996_wtbl_size(dev))
+		return -EINVAL;
+
+	ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MEC), &data,
+				sizeof(data), true);
+	if (ret)
+		return -EINVAL;
+
+	return count;
+}
+static const struct file_operations fops_amsdu_algo = {
+	.write = mt7996_amsdu_algo_write,
+	.read = NULL,
+	.open = simple_open,
+	.llseek = default_llseek,
+};
+
+static ssize_t mt7996_amsdu_para_write(struct file *file,
+				   const char __user *user_buf,
+				   size_t count,
+				   loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+	char buf[100];
+	int ret;
+	struct {
+		u8 _rsv[4];
+
+		u16 tag;
+		u16 len;
+
+		u16 wlan_idx;
+		u8  amsdu_en;
+		u8  num;
+		u16 lenth;
+		u8  rsv[2];
+	} __packed data = {
+		.tag = cpu_to_le16(UNI_MEC_AMSDU_PARA_STA),
+		.len = cpu_to_le16(sizeof(data) - 4),
+	};
+
+	if (count >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (count && buf[count - 1] == '\n')
+		buf[count - 1] = '\0';
+	else
+		buf[count] = '\0';
+
+	if (sscanf(buf, "%hu %hhu %hhu %hu", &data.wlan_idx, &data.amsdu_en, &data.num, &data.lenth) != 4)
+		return -EINVAL;
+
+	if (data.wlan_idx >= mt7996_wtbl_size(dev))
+		return -EINVAL;
+
+	ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MEC), &data,
+			  sizeof(data), true);
+	if (ret)
+		return -EINVAL;
+
+	return count;
+}
+static const struct file_operations fops_amsdu_para = {
+	.write = mt7996_amsdu_para_write,
+	.read = NULL,
+	.open = simple_open,
+	.llseek = default_llseek,
+};
+
+/* PSE INFO */
+static struct bmac_queue_info_t pse_queue_empty_info[] = {
+	{"CPU Q0",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_0},
+	{"CPU Q1",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_1},
+	{"CPU Q2",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_2},
+	{"CPU Q3",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_3},
+	{NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, /* 4~7 not defined */
+	{NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0},
+	{NULL, 0, 0}, {NULL, 0, 0},  /* 14~15 not defined */
+	{"LMAC Q",  ENUM_UMAC_LMAC_PORT_2,    0},
+	{"MDP TX Q0", ENUM_UMAC_LMAC_PORT_2, 1},
+	{"MDP RX Q", ENUM_UMAC_LMAC_PORT_2, 2},
+	{"SEC TX Q0", ENUM_UMAC_LMAC_PORT_2, 3},
+	{"SEC RX Q", ENUM_UMAC_LMAC_PORT_2, 4},
+	{"SFD_PARK Q", ENUM_UMAC_LMAC_PORT_2, 5},
+	{"MDP_TXIOC Q0", ENUM_UMAC_LMAC_PORT_2, 6},
+	{"MDP_RXIOC Q0", ENUM_UMAC_LMAC_PORT_2, 7},
+	{"MDP TX Q1", ENUM_UMAC_LMAC_PORT_2, 0x11},
+	{"SEC TX Q1", ENUM_UMAC_LMAC_PORT_2, 0x13},
+	{"MDP_TXIOC Q1", ENUM_UMAC_LMAC_PORT_2, 0x16},
+	{"MDP_RXIOC Q1", ENUM_UMAC_LMAC_PORT_2, 0x17},
+	{"CPU Q3",  ENUM_UMAC_CPU_PORT_1,     4},
+	{NULL, 0, 0}, {NULL, 0, 0},
+	{"RLS Q",  ENUM_PLE_CTRL_PSE_PORT_3, ENUM_UMAC_PLE_CTRL_P3_Q_0X1F}
+};
+
+static struct bmac_queue_info_t pse_queue_empty2_info[] = {
+	{"MDP_TDPIOC Q0", ENUM_UMAC_LMAC_PORT_2, 0x8},
+	{"MDP_RDPIOC Q0", ENUM_UMAC_LMAC_PORT_2, 0x9},
+	{"MDP_TDPIOC Q1", ENUM_UMAC_LMAC_PORT_2, 0x18},
+	{"MDP_RDPIOC Q1", ENUM_UMAC_LMAC_PORT_2, 0x19},
+	{"MDP_TDPIOC Q2", ENUM_UMAC_LMAC_PORT_2, 0x28},
+	{"MDP_RDPIOC Q2", ENUM_UMAC_LMAC_PORT_2, 0x29},
+	{NULL, 0, 0},
+	{"MDP_RDPIOC Q3", ENUM_UMAC_LMAC_PORT_2, 0x39},
+	{"MDP TX Q2", ENUM_UMAC_LMAC_PORT_2, 0x21},
+	{"SEC TX Q2", ENUM_UMAC_LMAC_PORT_2, 0x23},
+	{"MDP_TXIOC Q2", ENUM_UMAC_LMAC_PORT_2, 0x26},
+	{"MDP_RXIOC Q2", ENUM_UMAC_LMAC_PORT_2, 0x27},
+	{NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0},
+	{"MDP_RXIOC Q3", ENUM_UMAC_LMAC_PORT_2, 0x37},
+	{"HIF Q0", ENUM_UMAC_HIF_PORT_0,    0},
+	{"HIF Q1", ENUM_UMAC_HIF_PORT_0,    1},
+	{"HIF Q2", ENUM_UMAC_HIF_PORT_0,    2},
+	{"HIF Q3", ENUM_UMAC_HIF_PORT_0,    3},
+	{"HIF Q4", ENUM_UMAC_HIF_PORT_0,    4},
+	{"HIF Q5", ENUM_UMAC_HIF_PORT_0,    5},
+	{"HIF Q6", ENUM_UMAC_HIF_PORT_0,    6},
+	{"HIF Q7", ENUM_UMAC_HIF_PORT_0,    7},
+	{"HIF Q8", ENUM_UMAC_HIF_PORT_0,    8},
+	{"HIF Q9", ENUM_UMAC_HIF_PORT_0,    9},
+	{"HIF Q10", ENUM_UMAC_HIF_PORT_0,    10},
+	{"HIF Q11", ENUM_UMAC_HIF_PORT_0,    11},
+	{"HIF Q12", ENUM_UMAC_HIF_PORT_0,    12},
+	{"HIF Q13", ENUM_UMAC_HIF_PORT_0,    13},
+	{NULL, 0, 0}, {NULL, 0, 0}
+};
+
+static int
+mt7996_pseinfo_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	u32 pse_buf_ctrl, pg_sz, pg_num;
+	u32 pse_stat[2], pg_flow_ctrl[28] = {0};
+	u32 fpg_cnt, ffa_cnt, fpg_head, fpg_tail;
+	u32 max_q, min_q, rsv_pg, used_pg;
+	int i;
+
+	pse_buf_ctrl = mt76_rr(dev, WF_PSE_TOP_PBUF_CTRL_ADDR);
+	pse_stat[0] = mt76_rr(dev, WF_PSE_TOP_QUEUE_EMPTY_ADDR);
+	pse_stat[1] = mt76_rr(dev, WF_PSE_TOP_QUEUE_EMPTY_1_ADDR);
+	pg_flow_ctrl[0] = mt76_rr(dev, WF_PSE_TOP_FREEPG_CNT_ADDR);
+	pg_flow_ctrl[1] = mt76_rr(dev, WF_PSE_TOP_FREEPG_HEAD_TAIL_ADDR);
+	pg_flow_ctrl[2] = mt76_rr(dev, WF_PSE_TOP_PG_HIF0_GROUP_ADDR);
+	pg_flow_ctrl[3] = mt76_rr(dev, WF_PSE_TOP_HIF0_PG_INFO_ADDR);
+	pg_flow_ctrl[4] = mt76_rr(dev, WF_PSE_TOP_PG_HIF1_GROUP_ADDR);
+	pg_flow_ctrl[5] = mt76_rr(dev, WF_PSE_TOP_HIF1_PG_INFO_ADDR);
+	pg_flow_ctrl[6] = mt76_rr(dev, WF_PSE_TOP_PG_CPU_GROUP_ADDR);
+	pg_flow_ctrl[7] = mt76_rr(dev, WF_PSE_TOP_CPU_PG_INFO_ADDR);
+	pg_flow_ctrl[8] = mt76_rr(dev, WF_PSE_TOP_PG_LMAC0_GROUP_ADDR);
+	pg_flow_ctrl[9] = mt76_rr(dev, WF_PSE_TOP_LMAC0_PG_INFO_ADDR);
+	pg_flow_ctrl[10] = mt76_rr(dev, WF_PSE_TOP_PG_LMAC1_GROUP_ADDR);
+	pg_flow_ctrl[11] = mt76_rr(dev, WF_PSE_TOP_LMAC1_PG_INFO_ADDR);
+	pg_flow_ctrl[12] = mt76_rr(dev, WF_PSE_TOP_PG_LMAC2_GROUP_ADDR);
+	pg_flow_ctrl[13] = mt76_rr(dev, WF_PSE_TOP_LMAC2_PG_INFO_ADDR);
+	pg_flow_ctrl[14] = mt76_rr(dev, WF_PSE_TOP_PG_PLE_GROUP_ADDR);
+	pg_flow_ctrl[15] = mt76_rr(dev, WF_PSE_TOP_PLE_PG_INFO_ADDR);
+	pg_flow_ctrl[16] = mt76_rr(dev, WF_PSE_TOP_PG_LMAC3_GROUP_ADDR);
+	pg_flow_ctrl[17] = mt76_rr(dev, WF_PSE_TOP_LMAC3_PG_INFO_ADDR);
+	pg_flow_ctrl[18] = mt76_rr(dev, WF_PSE_TOP_PG_MDP_GROUP_ADDR);
+	pg_flow_ctrl[19] = mt76_rr(dev, WF_PSE_TOP_MDP_PG_INFO_ADDR);
+	pg_flow_ctrl[20] = mt76_rr(dev, WF_PSE_TOP_PG_PLE1_GROUP_ADDR);
+	pg_flow_ctrl[21] = mt76_rr(dev, WF_PSE_TOP_PLE1_PG_INFO_ADDR);
+	pg_flow_ctrl[22] = mt76_rr(dev, WF_PSE_TOP_PG_MDP2_GROUP_ADDR);
+	pg_flow_ctrl[23] = mt76_rr(dev, WF_PSE_TOP_MDP2_PG_INFO_ADDR);
+	if (mt7996_band_valid(dev, MT_BAND2)) {
+		pg_flow_ctrl[24] = mt76_rr(dev, WF_PSE_TOP_PG_MDP3_GROUP_ADDR);
+		pg_flow_ctrl[25] = mt76_rr(dev, WF_PSE_TOP_MDP3_PG_INFO_ADDR);
+	}
+	pg_flow_ctrl[26] = mt76_rr(dev, WF_PSE_TOP_PG_HIF2_GROUP_ADDR);
+	pg_flow_ctrl[27] = mt76_rr(dev, WF_PSE_TOP_HIF2_PG_INFO_ADDR);
+	/* Configuration Info */
+	seq_printf(s, "PSE Configuration Info:\n");
+	seq_printf(s, "\tPacket Buffer Control: 0x%08x\n", pse_buf_ctrl);
+	pg_sz = (pse_buf_ctrl & WF_PSE_TOP_PBUF_CTRL_PAGE_SIZE_CFG_MASK) >> WF_PSE_TOP_PBUF_CTRL_PAGE_SIZE_CFG_SHFT;
+	seq_printf(s, "\t\tPage Size=%d(%d bytes per page)\n", pg_sz, (pg_sz == 1 ? 256 : 128));
+	seq_printf(s, "\t\tPage Offset=%d(in unit of 64KB)\n",
+			 (pse_buf_ctrl & WF_PSE_TOP_PBUF_CTRL_PBUF_OFFSET_MASK) >> WF_PSE_TOP_PBUF_CTRL_PBUF_OFFSET_SHFT);
+	pg_num = (pse_buf_ctrl & WF_PSE_TOP_PBUF_CTRL_TOTAL_PAGE_NUM_MASK) >> WF_PSE_TOP_PBUF_CTRL_TOTAL_PAGE_NUM_SHFT;
+	seq_printf(s, "\t\tTotal page numbers=%d pages\n", pg_num);
+	/* Page Flow Control */
+	seq_printf(s, "PSE Page Flow Control:\n");
+	seq_printf(s, "\tFree page counter: 0x%08x\n", pg_flow_ctrl[0]);
+	fpg_cnt = (pg_flow_ctrl[0] & WF_PSE_TOP_FREEPG_CNT_FREEPG_CNT_MASK) >> WF_PSE_TOP_FREEPG_CNT_FREEPG_CNT_SHFT;
+	seq_printf(s, "\t\tThe toal page number of free=0x%03x\n", fpg_cnt);
+	ffa_cnt = (pg_flow_ctrl[0] & WF_PSE_TOP_FREEPG_CNT_FFA_CNT_MASK) >> WF_PSE_TOP_FREEPG_CNT_FFA_CNT_SHFT;
+	seq_printf(s, "\t\tThe free page numbers of free for all=0x%03x\n", ffa_cnt);
+	seq_printf(s, "\tFree page head and tail: 0x%08x\n", pg_flow_ctrl[1]);
+	fpg_head = (pg_flow_ctrl[1] & WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_HEAD_MASK) >> WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_HEAD_SHFT;
+	fpg_tail = (pg_flow_ctrl[1] & WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_TAIL_MASK) >> WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_TAIL_SHFT;
+	seq_printf(s, "\t\tThe tail/head page of free page list=0x%03x/0x%03x\n", fpg_tail, fpg_head);
+	seq_printf(s, "\tReserved page counter of HIF0 group: 0x%08x\n", pg_flow_ctrl[2]);
+	seq_printf(s, "\tHIF0 group page status: 0x%08x\n", pg_flow_ctrl[3]);
+	min_q = (pg_flow_ctrl[2] & WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[2] & WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of HIF0 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[3] & WF_PSE_TOP_HIF0_PG_INFO_HIF0_RSV_CNT_MASK) >> WF_PSE_TOP_HIF0_PG_INFO_HIF0_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[3] & WF_PSE_TOP_HIF0_PG_INFO_HIF0_SRC_CNT_MASK) >> WF_PSE_TOP_HIF0_PG_INFO_HIF0_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of HIF0 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of HIF1 group: 0x%08x\n", pg_flow_ctrl[4]);
+	seq_printf(s, "\tHIF1 group page status: 0x%08x\n", pg_flow_ctrl[5]);
+	min_q = (pg_flow_ctrl[4] & WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[4] & WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of HIF1 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[5] & WF_PSE_TOP_HIF1_PG_INFO_HIF1_RSV_CNT_MASK) >> WF_PSE_TOP_HIF1_PG_INFO_HIF1_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[5] & WF_PSE_TOP_HIF1_PG_INFO_HIF1_SRC_CNT_MASK) >> WF_PSE_TOP_HIF1_PG_INFO_HIF1_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of HIF1 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of HIF2 group: 0x%08x\n", pg_flow_ctrl[26]);
+	seq_printf(s, "\tHIF2 group page status: 0x%08x\n", pg_flow_ctrl[27]);
+	min_q = (pg_flow_ctrl[26] & WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[26] & WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of HIF2 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[27] & WF_PSE_TOP_HIF2_PG_INFO_HIF2_RSV_CNT_MASK) >> WF_PSE_TOP_HIF2_PG_INFO_HIF2_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[27] & WF_PSE_TOP_HIF2_PG_INFO_HIF2_SRC_CNT_MASK) >> WF_PSE_TOP_HIF2_PG_INFO_HIF2_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of HIF2 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of CPU group: 0x%08x\n", pg_flow_ctrl[6]);
+	seq_printf(s, "\tCPU group page status: 0x%08x\n", pg_flow_ctrl[7]);
+	min_q = (pg_flow_ctrl[6] & WF_PSE_TOP_PG_CPU_GROUP_CPU_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_CPU_GROUP_CPU_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[6] & WF_PSE_TOP_PG_CPU_GROUP_CPU_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_CPU_GROUP_CPU_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of CPU group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[7] & WF_PSE_TOP_CPU_PG_INFO_CPU_RSV_CNT_MASK) >> WF_PSE_TOP_CPU_PG_INFO_CPU_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[7] & WF_PSE_TOP_CPU_PG_INFO_CPU_SRC_CNT_MASK) >> WF_PSE_TOP_CPU_PG_INFO_CPU_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of CPU group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of LMAC0 group: 0x%08x\n", pg_flow_ctrl[8]);
+	seq_printf(s, "\tLMAC0 group page status: 0x%08x\n", pg_flow_ctrl[9]);
+	min_q = (pg_flow_ctrl[8] & WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[8] & WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of LMAC0 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[9] & WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_RSV_CNT_MASK) >> WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[9] & WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_SRC_CNT_MASK) >> WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of LMAC0 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of LMAC1 group: 0x%08x\n", pg_flow_ctrl[10]);
+	seq_printf(s, "\tLMAC1 group page status: 0x%08x\n", pg_flow_ctrl[11]);
+	min_q = (pg_flow_ctrl[10] & WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[10] & WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of LMAC1 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[11] & WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_RSV_CNT_MASK) >> WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[11] & WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_SRC_CNT_MASK) >> WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of LMAC1 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of LMAC2 group: 0x%08x\n", pg_flow_ctrl[11]);
+	seq_printf(s, "\tLMAC2 group page status: 0x%08x\n", pg_flow_ctrl[12]);
+	min_q = (pg_flow_ctrl[12] & WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[12] & WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of LMAC2 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[13] & WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_RSV_CNT_MASK) >> WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[13] & WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_SRC_CNT_MASK) >> WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of LMAC2 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+
+	seq_printf(s, "\tReserved page counter of LMAC3 group: 0x%08x\n", pg_flow_ctrl[16]);
+	seq_printf(s, "\tLMAC3 group page status: 0x%08x\n", pg_flow_ctrl[17]);
+	min_q = (pg_flow_ctrl[16] & WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[16] & WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of LMAC3 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[17] & WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_RSV_CNT_MASK) >> WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[17] & WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_SRC_CNT_MASK) >> WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of LMAC3 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+
+	seq_printf(s, "\tReserved page counter of PLE group: 0x%08x\n", pg_flow_ctrl[14]);
+	seq_printf(s, "\tPLE group page status: 0x%08x\n", pg_flow_ctrl[15]);
+	min_q = (pg_flow_ctrl[14] & WF_PSE_TOP_PG_PLE_GROUP_PLE_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_PLE_GROUP_PLE_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[14] & WF_PSE_TOP_PG_PLE_GROUP_PLE_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_PLE_GROUP_PLE_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of PLE group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[15] & WF_PSE_TOP_PLE_PG_INFO_PLE_RSV_CNT_MASK) >> WF_PSE_TOP_PLE_PG_INFO_PLE_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[15] & WF_PSE_TOP_PLE_PG_INFO_PLE_SRC_CNT_MASK) >> WF_PSE_TOP_PLE_PG_INFO_PLE_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of PLE group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+
+	seq_printf(s, "\tReserved page counter of PLE1 group: 0x%08x\n", pg_flow_ctrl[14]);
+	seq_printf(s, "\tPLE1 group page status: 0x%08x\n", pg_flow_ctrl[15]);
+	min_q = (pg_flow_ctrl[20] & WF_PSE_TOP_PG_PLE_GROUP_PLE_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_PLE_GROUP_PLE_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[20] & WF_PSE_TOP_PG_PLE_GROUP_PLE_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_PLE_GROUP_PLE_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of PLE1 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[21] & WF_PSE_TOP_PLE_PG_INFO_PLE_RSV_CNT_MASK) >> WF_PSE_TOP_PLE_PG_INFO_PLE_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[21] & WF_PSE_TOP_PLE_PG_INFO_PLE_SRC_CNT_MASK) >> WF_PSE_TOP_PLE_PG_INFO_PLE_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of PLE1 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+
+	seq_printf(s, "\tReserved page counter of MDP group: 0x%08x\n", pg_flow_ctrl[18]);
+	seq_printf(s, "\tMDP group page status: 0x%08x\n", pg_flow_ctrl[19]);
+	min_q = (pg_flow_ctrl[18] & WF_PSE_TOP_PG_MDP_GROUP_MDP_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_MDP_GROUP_MDP_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[18] & WF_PSE_TOP_PG_MDP_GROUP_MDP_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_MDP_GROUP_MDP_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of MDP group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[19] & WF_PSE_TOP_MDP_PG_INFO_MDP_RSV_CNT_MASK) >> WF_PSE_TOP_MDP_PG_INFO_MDP_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[19] & WF_PSE_TOP_MDP_PG_INFO_MDP_SRC_CNT_MASK) >> WF_PSE_TOP_MDP_PG_INFO_MDP_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of MDP group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of MDP2 group: 0x%08x\n", pg_flow_ctrl[22]);
+	seq_printf(s, "\tMDP2 group page status: 0x%08x\n", pg_flow_ctrl[23]);
+	min_q = (pg_flow_ctrl[22] & WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[22] & WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of MDP2 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[23] & WF_PSE_TOP_MDP2_PG_INFO_MDP2_RSV_CNT_MASK) >> WF_PSE_TOP_MDP2_PG_INFO_MDP2_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[23] & WF_PSE_TOP_MDP2_PG_INFO_MDP2_SRC_CNT_MASK) >> WF_PSE_TOP_MDP2_PG_INFO_MDP2_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of MDP2 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	if (mt7996_band_valid(dev, MT_BAND2)) {
+		seq_printf(s, "\tReserved page counter of MDP3 group: 0x%08x\n", pg_flow_ctrl[24]);
+		seq_printf(s, "\tMDP3 group page status: 0x%08x\n", pg_flow_ctrl[25]);
+		min_q = (pg_flow_ctrl[24] & WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MIN_QUOTA_SHFT;
+		max_q = (pg_flow_ctrl[24] & WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MAX_QUOTA_SHFT;
+		seq_printf(s, "\t\tThe max/min quota pages of MDP3 group=0x%03x/0x%03x\n", max_q, min_q);
+		rsv_pg = (pg_flow_ctrl[25] & WF_PSE_TOP_MDP3_PG_INFO_MDP3_RSV_CNT_MASK) >> WF_PSE_TOP_MDP3_PG_INFO_MDP3_RSV_CNT_SHFT;
+		used_pg = (pg_flow_ctrl[25] & WF_PSE_TOP_MDP3_PG_INFO_MDP3_SRC_CNT_MASK) >> WF_PSE_TOP_MDP3_PG_INFO_MDP3_SRC_CNT_SHFT;
+		seq_printf(s, "\t\tThe used/reserved pages of MDP3 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	}
+	/* Queue Empty Status */
+	seq_printf(s, "PSE Queue Empty Status:\n");
+	seq_printf(s, "\tQUEUE_EMPTY: 0x%08x, QUEUE_EMPTY2: 0x%08x\n", pse_stat[0], pse_stat[1]);
+	seq_printf(s, "\t\tCPU Q0/1/2/3/4 empty=%d/%d/%d/%d/%d\n",
+			  (pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_CPU_Q0_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_CPU_Q0_EMPTY_SHFT,
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_CPU_Q1_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_CPU_Q1_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_CPU_Q2_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_CPU_Q2_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_CPU_Q3_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_CPU_Q3_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_CPU_Q4_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_CPU_Q4_EMPTY_SHFT));
+	seq_printf(s, "\t\tHIF Q0/1/2/3/4/5/6/7/8/9/10/11/12/13 empty=%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d\n",
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_0_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_0_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_1_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_1_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_2_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_2_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_3_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_3_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_4_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_4_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_5_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_5_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_6_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_6_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_7_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_7_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_8_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_8_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_9_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_9_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_10_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_10_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_11_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_11_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_12_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_12_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_13_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_13_EMPTY_SHFT));
+	seq_printf(s, "\t\tLMAC TX Q empty=%d\n",
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_LMAC_TX_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_LMAC_TX_QUEUE_EMPTY_SHFT));
+	seq_printf(s, "\t\tMDP TX Q0/Q1/Q2/RX Q empty=%d/%d/%d/%d\n",
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_MDP_TX_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_MDP_TX_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_MDP_TX1_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_MDP_TX1_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TX2_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TX2_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_MDP_RX_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_MDP_RX_QUEUE_EMPTY_SHFT));
+	seq_printf(s, "\t\tSEC TX Q0/Q1/Q2/RX Q empty=%d/%d/%d/%d\n",
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_SEC_TX_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_SEC_TX_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_SEC_TX1_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_SEC_TX1_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_SEC_TX2_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_SEC_TX2_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_SEC_RX_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_SEC_RX_QUEUE_EMPTY_SHFT));
+	seq_printf(s, "\t\tSFD PARK Q empty=%d\n",
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_SFD_PARK_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_SFD_PARK_QUEUE_EMPTY_SHFT));
+	seq_printf(s, "\t\tMDP TXIOC Q0/Q1/Q2 empty=%d/%d/%d\n",
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC1_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC1_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TXIOC2_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TXIOC2_QUEUE_EMPTY_SHFT));
+	seq_printf(s, "\t\tMDP RXIOC Q0/Q1/Q2/Q3 empty=%d/%d/%d/%d\n",
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC1_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC1_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC2_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC2_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC3_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC3_QUEUE_EMPTY_SHFT));
+	seq_printf(s, "\t\tRLS Q empty=%d\n",
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_RLS_Q_EMTPY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_RLS_Q_EMTPY_SHFT));
+	seq_printf(s, "Nonempty Q info:\n");
+
+	for (i = 0; i < 31; i++) {
+		if (((pse_stat[0] & (0x1 << i)) >> i) == 0) {
+			u32 hfid, tfid, pktcnt, fl_que_ctrl[3] = {0};
+
+			if (pse_queue_empty_info[i].QueueName != NULL) {
+				seq_printf(s, "\t%s: ", pse_queue_empty_info[i].QueueName);
+				fl_que_ctrl[0] |= WF_PSE_TOP_FL_QUE_CTRL_0_EXECUTE_MASK;
+				fl_que_ctrl[0] |= (pse_queue_empty_info[i].Portid << WF_PSE_TOP_FL_QUE_CTRL_0_Q_BUF_PID_SHFT);
+				fl_que_ctrl[0] |= (pse_queue_empty_info[i].Queueid << WF_PSE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_SHFT);
+			} else
+				continue;
+
+			fl_que_ctrl[0] |= (0x1 << 31);
+			mt76_wr(dev, WF_PSE_TOP_FL_QUE_CTRL_0_ADDR, fl_que_ctrl[0]);
+			fl_que_ctrl[1] = mt76_rr(dev, WF_PSE_TOP_FL_QUE_CTRL_2_ADDR);
+			fl_que_ctrl[2] = mt76_rr(dev, WF_PSE_TOP_FL_QUE_CTRL_3_ADDR);
+			hfid = (fl_que_ctrl[1] & WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_MASK) >> WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_SHFT;
+			tfid = (fl_que_ctrl[1] & WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_MASK) >> WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_SHFT;
+			pktcnt = (fl_que_ctrl[2] & WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_MASK) >> WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_SHFT;
+			seq_printf(s, "tail/head fid = 0x%03x/0x%03x, pkt cnt = 0x%03x\n",
+					  tfid, hfid, pktcnt);
+		}
+	}
+
+	for (i = 0; i < 31; i++) {
+		if (((pse_stat[1] & (0x1 << i)) >> i) == 0) {
+			u32 hfid, tfid, pktcnt, fl_que_ctrl[3] = {0};
+
+			if (pse_queue_empty2_info[i].QueueName != NULL) {
+				seq_printf(s, "\t%s: ", pse_queue_empty2_info[i].QueueName);
+				fl_que_ctrl[0] |= WF_PSE_TOP_FL_QUE_CTRL_0_EXECUTE_MASK;
+				fl_que_ctrl[0] |= (pse_queue_empty2_info[i].Portid << WF_PSE_TOP_FL_QUE_CTRL_0_Q_BUF_PID_SHFT);
+				fl_que_ctrl[0] |= (pse_queue_empty2_info[i].Queueid << WF_PSE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_SHFT);
+			} else
+				continue;
+
+			fl_que_ctrl[0] |= (0x1 << 31);
+			mt76_wr(dev, WF_PSE_TOP_FL_QUE_CTRL_0_ADDR, fl_que_ctrl[0]);
+			fl_que_ctrl[1] = mt76_rr(dev, WF_PSE_TOP_FL_QUE_CTRL_2_ADDR);
+			fl_que_ctrl[2] = mt76_rr(dev, WF_PSE_TOP_FL_QUE_CTRL_3_ADDR);
+			hfid = (fl_que_ctrl[1] & WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_MASK) >> WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_SHFT;
+			tfid = (fl_que_ctrl[1] & WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_MASK) >> WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_SHFT;
+			pktcnt = (fl_que_ctrl[2] & WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_MASK) >> WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_SHFT;
+			seq_printf(s, "tail/head fid = 0x%03x/0x%03x, pkt cnt = 0x%03x\n",
+					  tfid, hfid, pktcnt);
+		}
+	}
+
+	return 0;
+}
+
+/* PLE INFO */
+static char *sta_ctrl_reg[] = {"ENABLE", "DISABLE", "PAUSE", "TWT_PAUSE"};
+static struct bmac_queue_info ple_queue_empty_info[] = {
+	{"CPU Q0",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_0, 0},
+	{"CPU Q1",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_1, 0},
+	{"CPU Q2",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_2, 0},
+	{"CPU Q3",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_3, 0},
+	{"ALTX Q0", ENUM_UMAC_LMAC_PORT_2,    0x10, 0},
+	{"BMC Q0",  ENUM_UMAC_LMAC_PORT_2,    0x11, 0},
+	{"BCN Q0",  ENUM_UMAC_LMAC_PORT_2,    0x12, 0},
+	{"PSMP Q0", ENUM_UMAC_LMAC_PORT_2,    0x13, 0},
+	{"ALTX Q1", ENUM_UMAC_LMAC_PORT_2,    0x10, 1},
+	{"BMC Q1",  ENUM_UMAC_LMAC_PORT_2,    0x11, 1},
+	{"BCN Q1",  ENUM_UMAC_LMAC_PORT_2,    0x12, 1},
+	{"PSMP Q1", ENUM_UMAC_LMAC_PORT_2,    0x13, 1},
+	{"ALTX Q2", ENUM_UMAC_LMAC_PORT_2,    0x10, 2},
+	{"BMC Q2",  ENUM_UMAC_LMAC_PORT_2,    0x11, 2},
+	{"BCN Q2",  ENUM_UMAC_LMAC_PORT_2,    0x12, 2},
+	{"PSMP Q2", ENUM_UMAC_LMAC_PORT_2,    0x13, 2},
+	{"NAF Q",   ENUM_UMAC_LMAC_PORT_2,    0x18, 0},
+	{"NBCN Q",  ENUM_UMAC_LMAC_PORT_2,    0x19, 0},
+	{NULL, 0, 0, 0}, {NULL, 0, 0, 0}, /* 18, 19 not defined */
+	{"FIXFID Q", ENUM_UMAC_LMAC_PORT_2, 0x1a, 0},
+	{NULL, 0, 0, 0}, {NULL, 0, 0, 0}, {NULL, 0, 0, 0}, {NULL, 0, 0, 0}, {NULL, 0, 0, 0},
+	{NULL, 0, 0, 0}, {NULL, 0, 0, 0},
+	{"RLS4 Q",   ENUM_PLE_CTRL_PSE_PORT_3, 0x7c, 0},
+	{"RLS3 Q",   ENUM_PLE_CTRL_PSE_PORT_3, 0x7d, 0},
+	{"RLS2 Q",   ENUM_PLE_CTRL_PSE_PORT_3, 0x7e, 0},
+	{"RLS Q",  ENUM_PLE_CTRL_PSE_PORT_3, 0x7f, 0}
+};
+
+static struct bmac_queue_info_t ple_txcmd_queue_empty_info[__MT_MAX_BAND][32] = {
+	{{"AC00Q", ENUM_UMAC_LMAC_PORT_2, 0x40},
+	 {"AC01Q", ENUM_UMAC_LMAC_PORT_2, 0x41},
+	 {"AC02Q", ENUM_UMAC_LMAC_PORT_2, 0x42},
+	 {"AC03Q", ENUM_UMAC_LMAC_PORT_2, 0x43},
+	 {"AC10Q", ENUM_UMAC_LMAC_PORT_2, 0x44},
+	 {"AC11Q", ENUM_UMAC_LMAC_PORT_2, 0x45},
+	 {"AC12Q", ENUM_UMAC_LMAC_PORT_2, 0x46},
+	 {"AC13Q", ENUM_UMAC_LMAC_PORT_2, 0x47},
+	 {"AC20Q", ENUM_UMAC_LMAC_PORT_2, 0x48},
+	 {"AC21Q", ENUM_UMAC_LMAC_PORT_2, 0x49},
+	 {"AC22Q", ENUM_UMAC_LMAC_PORT_2, 0x4a},
+	 {"AC23Q", ENUM_UMAC_LMAC_PORT_2, 0x4b},
+	 {"AC30Q", ENUM_UMAC_LMAC_PORT_2, 0x4c},
+	 {"AC31Q", ENUM_UMAC_LMAC_PORT_2, 0x4d},
+	 {"AC32Q", ENUM_UMAC_LMAC_PORT_2, 0x4e},
+	 {"AC33Q", ENUM_UMAC_LMAC_PORT_2, 0x4f},
+	 {"ALTX Q0", ENUM_UMAC_LMAC_PORT_2, 0x70},
+	 {"TF Q0", ENUM_UMAC_LMAC_PORT_2, 0x71},
+	 {"TWT TSF-TF Q0", ENUM_UMAC_LMAC_PORT_2, 0x72},
+	 {"TWT DL Q0", ENUM_UMAC_LMAC_PORT_2, 0x73},
+	 {"TWT UL Q0", ENUM_UMAC_LMAC_PORT_2, 0x74},
+	 {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0},
+	 {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0},
+	 {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}},
+
+	{{"AC00Q", ENUM_UMAC_LMAC_PORT_2, 0x50},
+	 {"AC01Q", ENUM_UMAC_LMAC_PORT_2, 0x51},
+	 {"AC02Q", ENUM_UMAC_LMAC_PORT_2, 0x52},
+	 {"AC03Q", ENUM_UMAC_LMAC_PORT_2, 0x53},
+	 {"AC10Q", ENUM_UMAC_LMAC_PORT_2, 0x54},
+	 {"AC11Q", ENUM_UMAC_LMAC_PORT_2, 0x55},
+	 {"AC12Q", ENUM_UMAC_LMAC_PORT_2, 0x56},
+	 {"AC13Q", ENUM_UMAC_LMAC_PORT_2, 0x57},
+	 {"AC20Q", ENUM_UMAC_LMAC_PORT_2, 0x58},
+	 {"AC21Q", ENUM_UMAC_LMAC_PORT_2, 0x59},
+	 {"AC22Q", ENUM_UMAC_LMAC_PORT_2, 0x5a},
+	 {"AC23Q", ENUM_UMAC_LMAC_PORT_2, 0x5b},
+	 {"AC30Q", ENUM_UMAC_LMAC_PORT_2, 0x5c},
+	 {"AC31Q", ENUM_UMAC_LMAC_PORT_2, 0x5d},
+	 {"AC32Q", ENUM_UMAC_LMAC_PORT_2, 0x5e},
+	 {"AC33Q", ENUM_UMAC_LMAC_PORT_2, 0x5f},
+	 {"ALTX Q0", ENUM_UMAC_LMAC_PORT_2, 0x75},
+	 {"TF Q0", ENUM_UMAC_LMAC_PORT_2, 0x76},
+	 {"TWT TSF-TF Q0", ENUM_UMAC_LMAC_PORT_2, 0x77},
+	 {"TWT DL Q0", ENUM_UMAC_LMAC_PORT_2, 0x78},
+	 {"TWT UL Q0", ENUM_UMAC_LMAC_PORT_2, 0x79},
+	 {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0},
+	 {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0},
+	 {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}},
+
+	{{"AC00Q", ENUM_UMAC_LMAC_PORT_2, 0x60},
+	 {"AC01Q", ENUM_UMAC_LMAC_PORT_2, 0x61},
+	 {"AC02Q", ENUM_UMAC_LMAC_PORT_2, 0x62},
+	 {"AC03Q", ENUM_UMAC_LMAC_PORT_2, 0x63},
+	 {"AC10Q", ENUM_UMAC_LMAC_PORT_2, 0x64},
+	 {"AC11Q", ENUM_UMAC_LMAC_PORT_2, 0x65},
+	 {"AC12Q", ENUM_UMAC_LMAC_PORT_2, 0x66},
+	 {"AC13Q", ENUM_UMAC_LMAC_PORT_2, 0x67},
+	 {"AC20Q", ENUM_UMAC_LMAC_PORT_2, 0x68},
+	 {"AC21Q", ENUM_UMAC_LMAC_PORT_2, 0x69},
+	 {"AC22Q", ENUM_UMAC_LMAC_PORT_2, 0x6a},
+	 {"AC23Q", ENUM_UMAC_LMAC_PORT_2, 0x6b},
+	 {"AC30Q", ENUM_UMAC_LMAC_PORT_2, 0x6c},
+	 {"AC31Q", ENUM_UMAC_LMAC_PORT_2, 0x6d},
+	 {"AC32Q", ENUM_UMAC_LMAC_PORT_2, 0x6e},
+	 {"AC33Q", ENUM_UMAC_LMAC_PORT_2, 0x6f},
+	 {"ALTX Q0", ENUM_UMAC_LMAC_PORT_2, 0x7a},
+	 {"TF Q0", ENUM_UMAC_LMAC_PORT_2, 0x7b},
+	 {"TWT TSF-TF Q0", ENUM_UMAC_LMAC_PORT_2, 0x7c},
+	 {"TWT DL Q0", ENUM_UMAC_LMAC_PORT_2, 0x7d},
+	 {"TWT UL Q0", ENUM_UMAC_LMAC_PORT_2, 0x7e},
+	 {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0},
+	 {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0},
+	 {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}}
+};
+
+static size_t
+ple_cr_num_of_ac(struct mt76_dev *dev)
+{
+	switch (mt76_chip(dev)) {
+	case 0x7990:
+		return CR_NUM_OF_AC_MT7996;
+	case 0x7992:
+	default:
+		return CR_NUM_OF_AC_MT7992;
+	}
+}
+
+static void
+mt7996_show_ple_pg_info(struct mt7996_dev *dev, struct seq_file *s)
+{
+	u32 val[2];
+
+	seq_printf(s, "PLE Configuration Info:\n");
+
+	val[0] = mt76_rr(dev, WF_PLE_TOP_PBUF_CTRL_ADDR);
+	seq_printf(s, "\tPacket Buffer Control: 0x%08x\n", val[0]);
+	seq_printf(s, "\t\tPage size: %u bytes\n",
+		   u32_get_bits(val[0], WF_PLE_TOP_PBUF_CTRL_PAGE_SIZE_CFG_MASK) ? 128 : 64);
+	seq_printf(s, "\t\tPacket buffer offset: %u (unit: 2KB)\n",
+		   u32_get_bits(val[0], WF_PLE_TOP_PBUF_CTRL_PBUF_OFFSET_MASK));
+	seq_printf(s, "\t\tTotal number of pages: %u pages\n",
+		   u32_get_bits(val[0], WF_PLE_TOP_PBUF_CTRL_TOTAL_PAGE_NUM_MASK));
+
+	seq_printf(s, "PLE Page Flow Control:\n");
+
+	val[0] = mt76_rr(dev, WF_PLE_TOP_FREEPG_CNT_ADDR);
+	val[1] = mt76_rr(dev, WF_PLE_TOP_FREEPG_HEAD_TAIL_ADDR);
+	seq_printf(s, "\tFree Page Counter: 0x%08x\n", val[0]);
+	seq_printf(s, "\tFree Page Head and Tail: 0x%08x\n", val[1]);
+	seq_printf(s, "\t\tNumber of free pages: 0x%04x\n",
+		   u32_get_bits(val[0], WF_PLE_TOP_FREEPG_CNT_FREEPG_CNT_MASK));
+	seq_printf(s, "\t\tNumber of unassigned pages: 0x%04x\n",
+		   u32_get_bits(val[0], WF_PLE_TOP_FREEPG_CNT_FFA_CNT_MASK));
+	seq_printf(s, "\t\tFID of tail/head free page: 0x%04x/0x%04x\n",
+		   u32_get_bits(val[1], WF_PLE_TOP_FREEPG_HEAD_TAIL_FREEPG_TAIL_MASK),
+		   u32_get_bits(val[1], WF_PLE_TOP_FREEPG_HEAD_TAIL_FREEPG_HEAD_MASK));
+
+	val[0] = mt76_rr(dev, WF_PLE_TOP_PG_HIF_GROUP_ADDR);
+	val[1] = mt76_rr(dev, WF_PLE_TOP_HIF_PG_INFO_ADDR);
+	seq_printf(s, "\tReserved Page Counter of HIF Group: 0x%08x\n", val[0]);
+	seq_printf(s, "\tHIF Group Page Status: 0x%08x\n", val[1]);
+	seq_printf(s, "\t\tMax/min page quota for HIF group: 0x%04x/0x%04x\n",
+		   u32_get_bits(val[0], WF_PLE_TOP_PG_HIF_GROUP_HIF_MAX_QUOTA_MASK),
+		   u32_get_bits(val[0], WF_PLE_TOP_PG_HIF_GROUP_HIF_MIN_QUOTA_MASK));
+	seq_printf(s, "\t\tUsed/free page count for HIF group: 0x%04x/0x%04x\n",
+		   u32_get_bits(val[1], WF_PLE_TOP_HIF_PG_INFO_HIF_SRC_CNT_MASK),
+		   u32_get_bits(val[1], WF_PLE_TOP_HIF_PG_INFO_HIF_RSV_CNT_MASK));
+
+	val[0] = mt76_rr(dev, WF_PLE_TOP_PG_HIF_WMTXD_GROUP_ADDR);
+	val[1] = mt76_rr(dev, WF_PLE_TOP_HIF_WMTXD_PG_INFO_ADDR);
+	seq_printf(s, "\tReserved Page Counter of HIF WMCPU TXD Group: 0x%08x\n", val[0]);
+	seq_printf(s, "\tHIF WMCPU TXD Group Page Status: 0x%08x\n", val[1]);
+	seq_printf(s, "\t\tMax/min page quota for HIF WMCPU TXD group: 0x%04x/0x%04x\n",
+		   u32_get_bits(val[0], WF_PLE_TOP_PG_HIF_WMTXD_GROUP_HIF_WMTXD_MAX_QUOTA_MASK),
+		   u32_get_bits(val[0], WF_PLE_TOP_PG_HIF_WMTXD_GROUP_HIF_WMTXD_MIN_QUOTA_MASK));
+	seq_printf(s, "\t\tUsed/free page count for HIF WMCPU TXD group: 0x%04x/0x%04x\n",
+		   u32_get_bits(val[1], WF_PLE_TOP_HIF_WMTXD_PG_INFO_HIF_WMTXD_SRC_CNT_MASK),
+		   u32_get_bits(val[1], WF_PLE_TOP_HIF_WMTXD_PG_INFO_HIF_WMTXD_RSV_CNT_MASK));
+
+	val[0] = mt76_rr(dev, WF_PLE_TOP_PG_HIF_TXCMD_GROUP_ADDR);
+	val[1] = mt76_rr(dev, WF_PLE_TOP_HIF_TXCMD_PG_INFO_ADDR);
+	seq_printf(s, "\tReserved Page Counter of HIF TXCMD Group: 0x%08x\n", val[0]);
+	seq_printf(s, "\tHIF TXCMD Group Page Status: 0x%08x\n", val[1]);
+	seq_printf(s, "\t\tMax/min page quota for HIF TXCMD group: 0x%04x/0x%04x\n",
+		   u32_get_bits(val[0], WF_PLE_TOP_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MAX_QUOTA_MASK),
+		   u32_get_bits(val[0], WF_PLE_TOP_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MIN_QUOTA_MASK));
+	seq_printf(s, "\t\tUsed/free page count for HIF TXCMD group: 0x%04x/0x%04x\n",
+		   u32_get_bits(val[1], WF_PLE_TOP_HIF_TXCMD_PG_INFO_HIF_TXCMD_SRC_CNT_MASK),
+		   u32_get_bits(val[1], WF_PLE_TOP_HIF_TXCMD_PG_INFO_HIF_TXCMD_RSV_CNT_MASK));
+
+	val[0] = mt76_rr(dev, WF_PLE_TOP_PG_CPU_GROUP_ADDR);
+	val[1] = mt76_rr(dev, WF_PLE_TOP_CPU_PG_INFO_ADDR);
+	seq_printf(s, "\tReserved Page Counter of CPU Group: 0x%08x\n", val[0]);
+	seq_printf(s, "\tCPU Group Page Status: 0x%08x\n", val[1]);
+	seq_printf(s, "\t\tMax/min page quota for CPU group: 0x%04x/0x%04x\n",
+		   u32_get_bits(val[0], WF_PLE_TOP_PG_CPU_GROUP_CPU_MAX_QUOTA_MASK),
+		   u32_get_bits(val[0], WF_PLE_TOP_PG_CPU_GROUP_CPU_MIN_QUOTA_MASK));
+	seq_printf(s, "\t\tUsed/free page count for CPU group: 0x%04x/0x%04x\n",
+		   u32_get_bits(val[1], WF_PLE_TOP_CPU_PG_INFO_CPU_SRC_CNT_MASK),
+		   u32_get_bits(val[1], WF_PLE_TOP_CPU_PG_INFO_CPU_RSV_CNT_MASK));
+}
+
+static void
+mt7996_get_ple_acq_stat(struct mt7996_dev *dev, unsigned long *ple_stat)
+{
+	u32 i, addr;
+	size_t cr_num_of_ac = ple_cr_num_of_ac(&dev->mt76);
+
+	ple_stat[0] = mt76_rr(dev, WF_PLE_TOP_QUEUE_EMPTY_ADDR);
+
+	/* Legacy */
+	addr = WF_PLE_TOP_AC0_QUEUE_EMPTY0_ADDR;
+	for (i = 1; i <= cr_num_of_ac; i++, addr += 4) {
+		if (i == cr_num_of_ac && is_mt7992(&dev->mt76))
+			ple_stat[i] = mt76_rr(dev, WF_PLE_TOP_AC0_QUEUE_EMPTY_EXT0_ADDR);
+		else
+			ple_stat[i] = mt76_rr(dev, addr);
+	}
+
+	addr = WF_PLE_TOP_AC1_QUEUE_EMPTY0_ADDR;
+	for (; i <= cr_num_of_ac * 2; i++, addr += 4) {
+		if (i == cr_num_of_ac * 2 && is_mt7992(&dev->mt76))
+			ple_stat[i] = mt76_rr(dev, WF_PLE_TOP_AC1_QUEUE_EMPTY_EXT0_ADDR);
+		else
+			ple_stat[i] = mt76_rr(dev, addr);
+	}
+
+	addr = WF_PLE_TOP_AC2_QUEUE_EMPTY0_ADDR;
+	for (; i <= cr_num_of_ac * 3; i++, addr += 4) {
+		if (i == cr_num_of_ac * 3 && is_mt7992(&dev->mt76))
+			ple_stat[i] = mt76_rr(dev, WF_PLE_TOP_AC2_QUEUE_EMPTY_EXT0_ADDR);
+		else
+			ple_stat[i] = mt76_rr(dev, addr);
+	}
+
+	addr = WF_PLE_TOP_AC3_QUEUE_EMPTY0_ADDR;
+	for (; i <= cr_num_of_ac * 4; i++, addr += 4) {
+		if (i == cr_num_of_ac * 4 && is_mt7992(&dev->mt76))
+			ple_stat[i] = mt76_rr(dev, WF_PLE_TOP_AC3_QUEUE_EMPTY_EXT0_ADDR);
+		else
+			ple_stat[i] = mt76_rr(dev, addr);
+	}
+}
+
+static void
+mt7996_get_sta_pause(struct mt7996_dev *dev, u8 band, u32 *sta_pause, u32 *twt_pause)
+{
+	u32 i, addr;
+	size_t cr_num_of_ac = ple_cr_num_of_ac(&dev->mt76);
+
+	/* switch to target band */
+	mt76_wr(dev, WF_DRR_TOP_SBRR_ADDR, u32_encode_bits(band, WF_DRR_TOP_SBRR_TARGET_BAND_MASK));
+
+	/* Legacy */
+	addr = WF_DRR_TOP_AC0_STATION_PAUSE00_ADDR;
+	for (i = 0; i < cr_num_of_ac; i++, addr += 4) {
+		if (i == cr_num_of_ac - 1 && is_mt7992(&dev->mt76))
+			sta_pause[i] = mt76_rr(dev, WF_DRR_TOP_AC0_STATION_PAUSE_EXT_00_ADDR);
+		else
+			sta_pause[i] = mt76_rr(dev, addr);
+	}
+
+	addr = WF_DRR_TOP_AC1_STATION_PAUSE00_ADDR;
+	for (; i < cr_num_of_ac * 2; i++, addr += 4) {
+		if (i == cr_num_of_ac * 2 - 1 && is_mt7992(&dev->mt76))
+			sta_pause[i] = mt76_rr(dev, WF_DRR_TOP_AC1_STATION_PAUSE_EXT_00_ADDR);
+		else
+			sta_pause[i] = mt76_rr(dev, addr);
+	}
+
+	addr = WF_DRR_TOP_AC2_STATION_PAUSE00_ADDR;
+	for (; i < cr_num_of_ac * 3; i++, addr += 4) {
+		if (i == cr_num_of_ac * 3 - 1 && is_mt7992(&dev->mt76))
+			sta_pause[i] = mt76_rr(dev, WF_DRR_TOP_AC2_STATION_PAUSE_EXT_00_ADDR);
+		else
+			sta_pause[i] = mt76_rr(dev, addr);
+	}
+
+	addr = WF_DRR_TOP_AC3_STATION_PAUSE00_ADDR;
+	for (; i < cr_num_of_ac * 4; i++, addr += 4) {
+		if (i == cr_num_of_ac * 4 - 1 && is_mt7992(&dev->mt76))
+			sta_pause[i] = mt76_rr(dev, WF_DRR_TOP_AC3_STATION_PAUSE_EXT_00_ADDR);
+		else
+			sta_pause[i] = mt76_rr(dev, addr);
+	}
+
+	/* TWT */
+	addr = WF_DRR_TOP_TWT_STA_MAP00_ADDR;
+	for (i = 0; i < cr_num_of_ac; i++, addr += 4) {
+		if (i == cr_num_of_ac - 1 && is_mt7992(&dev->mt76))
+			twt_pause[i] = mt76_rr(dev, WF_DRR_TOP_TWT_STA_MAP_EXT_00_ADDR);
+		else
+			twt_pause[i] = mt76_rr(dev, addr);
+	}
+}
+
+static void
+mt7996_get_ple_queue_info(struct mt7996_dev *dev, u32 pid, u32 qid, u32 tgid,
+			  u16 wlan_idx, u16 *hfid, u16 *tfid, u16 *pktcnt)
+{
+	u32 val = WF_PLE_TOP_FL_QUE_CTRL_0_EXECUTE_MASK |
+		  u32_encode_bits(pid, WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_PID_MASK) |
+		  u32_encode_bits(tgid, WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_TGID_MASK) |
+		  u32_encode_bits(qid, WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_MASK) |
+		  u32_encode_bits(wlan_idx, WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_WLANID_MASK);
+	mt76_wr(dev, WF_PLE_TOP_FL_QUE_CTRL_0_ADDR, val);
+
+	val = mt76_rr(dev, WF_PLE_TOP_FL_QUE_CTRL_2_ADDR);
+	*hfid = u32_get_bits(val, WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_MASK);
+	*tfid = u32_get_bits(val, WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_MASK);
+
+	val = mt76_rr(dev, WF_PLE_TOP_FL_QUE_CTRL_3_ADDR);
+	*pktcnt = u32_get_bits(val, WF_PLE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_MASK);
+}
+
+static void
+mt7996_show_sta_acq_info(struct seq_file *s, unsigned long *ple_stat,
+			 u32 *sta_pause, u32 *twt_sta_pause)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	size_t cr_num_of_ac = ple_cr_num_of_ac(&dev->mt76);
+	size_t cr_num_of_all_ac = cr_num_of_ac * IEEE80211_NUM_ACS;
+	int i, j;
+
+	for (j = 0; j < cr_num_of_all_ac; j++) { /* show AC Q info */
+		for (i = 0; i < 32; i++) {
+			if (!test_bit(i, &ple_stat[j + 1])) {
+				u16 hfid, tfid, pktcnt, wlan_idx = i + (j % cr_num_of_ac) * 32;
+				u8 wmmidx, ctrl = 0, acq_idx = j / cr_num_of_ac;
+				struct mt7996_sta_link *msta_link;
+				struct mt76_wcid *wcid;
+				size_t idx;
+
+				if (wlan_idx >= MT76_N_WCIDS) {
+					seq_printf(s, "Error: WCID %hu exceeded threshold.\n", wlan_idx);
+					continue;
+				}
+				wcid = rcu_dereference(dev->mt76.wcid[wlan_idx]);
+				if (!wcid) {
+					seq_printf(s, "Error: STA %hu does not exist.\n", wlan_idx);
+					continue;
+				}
+				msta_link = container_of(wcid, struct mt7996_sta_link, wcid);
+				wmmidx = msta_link->sta->vif->deflink.mt76.wmm_idx;
+
+				seq_printf(s, "\tSTA%hu AC%hhu: ", wlan_idx, acq_idx);
+				mt7996_get_ple_queue_info(dev, ENUM_UMAC_LMAC_PORT_2, acq_idx,
+							  0, wlan_idx, &hfid, &tfid, &pktcnt);
+				seq_printf(s, "tail/head fid = 0x%04x/0x%04x, pkt cnt = 0x%04x",
+					   tfid, hfid, pktcnt);
+
+				idx = wcid->phy_idx * cr_num_of_all_ac + j;
+				if (sta_pause[idx] & BIT(i))
+					ctrl = 2;
+
+				idx = wcid->phy_idx * cr_num_of_ac + j % cr_num_of_ac;
+				if (twt_sta_pause[idx] & BIT(i))
+					ctrl = 3;
+
+				seq_printf(s, ", ctrl = %s (wmmidx=%hhu, band=%hhu)\n",
+					   sta_ctrl_reg[ctrl], wmmidx, wcid->phy_idx);
+			}
+		}
+	}
+}
+
+static void
+mt7996_show_txcmdq_info(struct seq_file *s)
+{
+	const u32 txcmd_queue_empty_addr[__MT_MAX_BAND][2] = {
+		[MT_BAND0] = {WF_PLE_TOP_TXCMD_QUEUE_EMPTY_ADDR,
+			      WF_PLE_TOP_NATIVE_TXCMD_QUEUE_EMPTY_ADDR},
+		[MT_BAND1] = {WF_PLE_TOP_BN1_TXCMD_QUEUE_EMPTY_ADDR,
+			      WF_PLE_TOP_BN1_NATIVE_TXCMD_QUEUE_EMPTY_ADDR},
+		[MT_BAND2] = {WF_PLE_TOP_BN2_TXCMD_QUEUE_EMPTY_ADDR,
+			      WF_PLE_TOP_BN2_NATIVE_TXCMD_QUEUE_EMPTY_ADDR}
+	};
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	u8 band;
+
+	for (band = MT_BAND0; band < __MT_MAX_BAND; ++band) {
+		unsigned long txcmdq_stat, native_txcmdq_stat;
+		int i;
+
+		if (!dev->mt76.phys[band])
+			continue;
+
+		txcmdq_stat = mt76_rr(dev, txcmd_queue_empty_addr[band][0]);
+		native_txcmdq_stat = mt76_rr(dev, txcmd_queue_empty_addr[band][1]);
+
+		seq_printf(s, "Band%hhu Non-native/native TXCMD Queue Empty: 0x%08lx/0x%08lx\n",
+			   band, txcmdq_stat, native_txcmdq_stat);
+
+		for (i = 0; i < 32 ; i++) {
+			if (!test_bit(i, &native_txcmdq_stat)) {
+				struct bmac_queue_info_t *queue = &ple_txcmd_queue_empty_info[band][i];
+				u16 hfid, tfid, pktcnt;
+
+				if (!queue->QueueName)
+					continue;
+
+				seq_printf(s, "\t%s: ", queue->QueueName);
+				mt7996_get_ple_queue_info(dev, queue->Portid, queue->Queueid,
+							  0, 0, &hfid, &tfid, &pktcnt);
+				seq_printf(s, "tail/head fid = 0x%04x/0x%04x, pkt cnt = 0x%04x\n",
+					   tfid, hfid, pktcnt);
+			}
+		}
+	}
+}
+
+static int
+mt7996_pleinfo_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	size_t cr_num_of_ac = ple_cr_num_of_ac(&dev->mt76);
+	size_t cr_num_of_all_ac = cr_num_of_ac * IEEE80211_NUM_ACS;
+	u32 *sta_pause, *twt_sta_pause;
+	unsigned long *ple_stat;
+	int i, j, ret = 0;
+
+	ple_stat = kzalloc((cr_num_of_all_ac + 1) * sizeof(unsigned long), GFP_KERNEL);
+	if (!ple_stat)
+		return -ENOMEM;
+
+	sta_pause = kzalloc(__MT_MAX_BAND * cr_num_of_all_ac * sizeof(u32), GFP_KERNEL);
+	if (!sta_pause) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	twt_sta_pause = kzalloc(__MT_MAX_BAND * cr_num_of_ac * sizeof(u32), GFP_KERNEL);
+	if (!twt_sta_pause) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	mt7996_show_ple_pg_info(dev, s);
+	mt7996_get_ple_acq_stat(dev, ple_stat);
+
+	for (i = MT_BAND0; i < __MT_MAX_BAND; i++) {
+		if (dev->mt76.phys[i])
+			mt7996_get_sta_pause(dev, i,
+					     sta_pause + i * cr_num_of_all_ac,
+					     twt_sta_pause + i * cr_num_of_ac);
+	}
+
+	if ((ple_stat[0] & WF_PLE_TOP_QUEUE_EMPTY_ALL_AC_EMPTY_MASK) == 0) {
+		for (j = 0; j < cr_num_of_all_ac; j++) {
+			if (j % cr_num_of_ac == 0)
+				seq_printf(s, "\n\tSTA in nonempty AC%ld TXD queue: ", j / cr_num_of_ac);
+
+			for (i = 0; i < 32; i++) {
+				if (!test_bit(i, &ple_stat[j + 1]))
+					seq_printf(s, "%lu ", i + (j % cr_num_of_ac) * 32);
+			}
+		}
+		seq_printf(s, "\n");
+	}
+
+	seq_printf(s, "Nonempty TXD Queue Info:\n");
+
+	for (i = 0; i < 32; i++) {
+		if (!test_bit(i, &ple_stat[0])) {
+			struct bmac_queue_info *queue = &ple_queue_empty_info[i];
+			u16 hfid, tfid, pktcnt;
+
+			if (!queue->QueueName)
+				continue;
+
+			seq_printf(s, "\t%s: ", queue->QueueName);
+			mt7996_get_ple_queue_info(dev, queue->Portid, queue->Queueid,
+						  queue->tgid, 0, &hfid, &tfid, &pktcnt);
+			seq_printf(s, "tail/head fid = 0x%04x/0x%04x, pkt cnt = 0x%04x\n",
+				   tfid, hfid, pktcnt);
+		}
+	}
+
+	mt7996_show_sta_acq_info(s, ple_stat, sta_pause, twt_sta_pause);
+	mt7996_show_txcmdq_info(s);
+
+	kfree(twt_sta_pause);
+out:
+	kfree(sta_pause);
+	kfree(ple_stat);
+	return ret;
+}
+
+static int
+mt7996_tx_drop_show(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = s->private;
+	struct mt76_dev *mdev = &dev->mt76;
+	struct mt76_tx_debug *dev_stats = &mdev->tx_dbg_stats;
+	struct mt76_tx_debug *phy_stats[__MT_MAX_BAND];
+	int i = 0;
+
+	seq_printf(s, "\t\t\t\t       dev");
+	for (i = 0; i < __MT_MAX_BAND; i++) {
+		seq_printf(s, "       Band%d", i);
+		if (mdev->phys[i]) {
+			phy_stats[i] = &mdev->phys[i]->tx_dbg_stats;
+		} else {
+			phy_stats[i] = kzalloc(sizeof(struct mt76_tx_debug),
+					       GFP_KERNEL);
+			if (!phy_stats[i])
+				goto out;
+		}
+
+	}
+	seq_printf(s, "       total\n");
+
+	seq_printf(s, "%-30s%12d%12d%12d%12d%12d\n", "Receive from mac80211",
+		       dev_stats->tx_from_mac80211,
+		       phy_stats[0]->tx_from_mac80211,
+		       phy_stats[1]->tx_from_mac80211,
+		       phy_stats[2]->tx_from_mac80211,
+		       dev_stats->tx_from_mac80211 +
+		       phy_stats[0]->tx_from_mac80211 +
+		       phy_stats[1]->tx_from_mac80211 +
+		       phy_stats[2]->tx_from_mac80211);
+	seq_printf(s, "%-30s%12d%12d%12d%12d%12d\n\n", "Send to hw",
+		       dev_stats->tx_to_hw,
+		       phy_stats[0]->tx_to_hw,
+		       phy_stats[1]->tx_to_hw,
+		       phy_stats[2]->tx_to_hw,
+		       dev_stats->tx_to_hw +
+		       phy_stats[0]->tx_to_hw +
+		       phy_stats[1]->tx_to_hw +
+		       phy_stats[2]->tx_to_hw);
+#define __pr(t) seq_printf(s, "Drop due to %-18s%12d%12d%12d%12d%12d\n",\
+			   #t, dev_stats->tx_drop[MT_TX_DROP_##t],	\
+			   phy_stats[0]->tx_drop[MT_TX_DROP_##t],	\
+			   phy_stats[1]->tx_drop[MT_TX_DROP_##t],	\
+			   phy_stats[2]->tx_drop[MT_TX_DROP_##t],	\
+			   dev_stats->tx_drop[MT_TX_DROP_##t] +		\
+			   phy_stats[0]->tx_drop[MT_TX_DROP_##t] + 	\
+			   phy_stats[1]->tx_drop[MT_TX_DROP_##t] +	\
+			   phy_stats[2]->tx_drop[MT_TX_DROP_##t])
+
+	__pr(IN_TESTMODE);
+	__pr(WCID_NOT_INIT);
+	__pr(STOPPED_QUEUE);
+	__pr(RESET_STATE);
+	__pr(GET_TXWI_FAIL);
+	__pr(DMA_FAIL);
+	__pr(AGG_EXCEEDED);
+	__pr(RING_FULL);
+	__pr(INVALID_SKB);
+	__pr(GET_TOKEN_FAIL);
+	__pr(ADDR_TRANS_FAIL);
+	__pr(INVALID_WCID);
+	__pr(INVALID_LINK);
+
+#undef __pr
+out:
+	for (i = 0; i < __MT_MAX_BAND; i++) {
+		if (!mdev->phys[i] && phy_stats[i])
+			kfree(phy_stats[i]);
+	}
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_tx_drop);
+
+static int
+mt7996_rx_drop_show(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = s->private;
+	struct mt76_dev *mdev = &dev->mt76;
+	struct mt76_rx_debug *stats[__MT_MAX_BAND];
+	struct mt76_queue *q[2];
+	int i = 0;
+
+	q[0] = &mdev->q_rx[MT_RXQ_MAIN];
+	q[1] = is_mt7996(mdev) ? &mdev->q_rx[MT_RXQ_BAND2] :
+				 &mdev->q_rx[MT_RXQ_BAND1];
+
+	seq_printf(s, "\t\t\t\t   ");
+	for (i = 0; i < 2; i++) {
+		seq_printf(s, "        RXQ%d", q[i]->hw_idx);
+	}
+	seq_printf(s, "\n");
+
+#define __pr(t) seq_printf(s, "Drop due to %-22s%12d%12d\n", #t, \
+			   q[0]->rx_drop[MT_RX_DROP_##t],	\
+			   q[1]->rx_drop[MT_RX_DROP_##t]);
+	__pr(DMAD_RRO_REPEAT);
+	__pr(DMAD_RRO_OLDPKT);
+	__pr(DMAD_RRO_PN_CHK_FAIL);
+	__pr(DMAD_WO_FRAG);
+	__pr(DMAD_WO_DROP);
+	__pr(DMAD_ADDR_NOT_FOUND);
+	__pr(DMAD_TOKEN_NOT_FOUND);
+	__pr(DMAD_GET_TOKEN_FAIL);
+	__pr(DMAD_GET_RXWI_FAIL);
+	__pr(DMAD_NOMEM);
+	__pr(DMAD_DMA_MAPPING_FAIL);
+	__pr(FRAG);
+	__pr(BUILD_SKB_FAIL);
+#undef __pr
+
+	seq_printf(s, "\n\t\t\t\t   ");
+	for (i = 0; i < __MT_MAX_BAND; i++) {
+		seq_printf(s, "       Band%d", i);
+		if (mdev->phys[i]) {
+			stats[i] = &mdev->phys[i]->rx_dbg_stats;
+		} else {
+			stats[i] = kzalloc(sizeof(struct mt76_rx_debug),
+					       GFP_KERNEL);
+			if (!stats[i])
+				goto out;
+		}
+	}
+	seq_printf(s, "\n");
+	seq_printf(s, "%-35s%12d%12d%12d\n", "Receive from hw",
+		       stats[MT_BAND0]->rx_from_hw,
+		       stats[MT_BAND1]->rx_from_hw,
+		       stats[MT_BAND2]->rx_from_hw);
+	seq_printf(s, "%-35s%12d%12d%12d\n\n", "Send to mac80211",
+		       stats[MT_BAND0]->rx_to_mac80211,
+		       stats[MT_BAND1]->rx_to_mac80211,
+		       stats[MT_BAND2]->rx_to_mac80211);
+#define __pr(t) seq_printf(s, "Drop due to %-22s%12d%12d%12d\n", #t, \
+			   stats[MT_BAND0]->rx_drop[MT_RX_DROP_##t],	\
+			   stats[MT_BAND1]->rx_drop[MT_RX_DROP_##t],	\
+			   stats[MT_BAND2]->rx_drop[MT_RX_DROP_##t])
+	__pr(RXD_ERR);
+	__pr(STATE_ERR);
+	__pr(RFC_PKT);
+	__pr(AGG_SN_LESS);
+	__pr(AGG_DUP);
+#undef __pr
+
+out:
+	for (i = 0; i < __MT_MAX_BAND; i++) {
+		if (!mdev->phys[i] && stats[i])
+			kfree(stats[i]);
+	}
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_rx_drop);
+/* DRR */
+static int
+mt7996_drr_info(struct seq_file *s, void *data)
+{
+	/* TODO: Wait MIB counter API implement complete */
+	return 0;
+}
+
+static ssize_t mt7996_muru_dbg_info_set(struct file *file,
+					const char __user *user_buf,
+					size_t count, loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+	char buf[10];
+	u16 item;
+	u8 val;
+	int ret;
+
+	if (count >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (count && buf[count - 1] == '\n')
+		buf[count - 1] = '\0';
+	else
+		buf[count] = '\0';
+
+	if (sscanf(buf, "%hu-%hhu", &item, &val) != 2) {
+		dev_warn(dev->mt76.dev,"format: item-value\n");
+		return -EINVAL;
+	}
+
+	ret = mt7996_mcu_muru_dbg_info(dev, item, val);
+	if (ret) {
+		dev_warn(dev->mt76.dev, "Fail to send mcu cmd.\n");
+		return -EFAULT;
+	}
+
+	return count;
+}
+
+static const struct file_operations fops_muru_dbg_info = {
+	.write = mt7996_muru_dbg_info_set,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+void mt7996_mtk_init_band_debugfs(struct mt7996_phy *phy, struct dentry *dir)
+{
+	/* agg */
+	debugfs_create_file("agginfo", 0400, dir, phy, &mt7996_agginfo_fops);
+	debugfs_create_file("mibinfo", 0400, dir, phy, &mt7996_mibinfo_fops);
+	debugfs_create_file("txpower_level", 0600, dir, phy, &fops_txpower_level);
+	debugfs_create_file("txpower_info", 0600, dir, phy, &mt7996_txpower_info_fops);
+	debugfs_create_file("txpower_sku", 0600, dir, phy, &mt7996_txpower_sku_fops);
+	debugfs_create_file("txpower_path", 0600, dir, phy, &mt7996_txpower_path_fops);
+
+	debugfs_create_file("sr_enable", 0600, dir, phy, &fops_sr_enable);
+	debugfs_create_file("sr_enhanced_enable", 0600, dir, phy, &fops_sr_enhanced_enable);
+	debugfs_create_file("sr_stats", 0400, dir, phy, &mt7996_sr_stats_fops);
+	debugfs_create_file("sr_scene_cond", 0400, dir, phy, &mt7996_sr_scene_cond_fops);
+
+	debugfs_create_file("bf_txsnd_info", 0600, dir, phy, &fops_bf_txsnd_info);
+	debugfs_create_file("bf_starec_read", 0600, dir, phy, &fops_starec_bf_read);
+	debugfs_create_file("bf_fbk_rpt", 0600, dir, phy, &fops_bf_fbk_rpt);
+	debugfs_create_file("pfmu_tag_read", 0600, dir, phy, &fops_bf_pfmu_tag_read);
+
+	debugfs_create_file("thermal_enable", 0600, dir, phy, &fops_thermal_enable);
+	debugfs_create_file("scs_enable", 0200, dir, phy, &fops_scs_enable);
+}
+
+void mt7996_mtk_init_dev_debugfs(struct mt7996_dev *dev, struct dentry *dir)
+{
+	u32 device_id = (dev->mt76.rev) >> 16;
+	int i = 0;
+	static const struct mt7996_dbg_reg_desc dbg_reg_s[] = {
+		{ 0x7990, mt7996_dbg_offs },
+		{ 0x7992, mt7992_dbg_offs },
+	};
+
+	for (i = 0; i < ARRAY_SIZE(dbg_reg_s); i++) {
+		if (device_id == dbg_reg_s[i].id) {
+			dev->dbg_reg = &dbg_reg_s[i];
+			break;
+		}
+	}
+
+	if (is_mt7996(&dev->mt76)) {
+		WTBL_LMAC_DW2 = WTBL_LMAC_DW2_7996;
+		WTBL_LMAC_DW5 = WTBL_LMAC_DW5_7996;
+		WTBL_LMAC_DW9 = WTBL_LMAC_DW9_7996;
+	} else {
+		WTBL_LMAC_DW2 = WTBL_LMAC_DW2_7992;
+		WTBL_LMAC_DW5 = WTBL_LMAC_DW5_7992;
+		WTBL_LMAC_DW9 = WTBL_LMAC_DW9_7992;
+	}
+
+	/* amsdu */
+	debugfs_create_devm_seqfile(dev->mt76.dev, "amsdu_info", dir,
+				    mt7996_amsdu_result_read);
+
+	debugfs_create_file("fw_debug_module", 0600, dir, dev,
+			    &fops_fw_debug_module);
+	debugfs_create_file("fw_debug_level", 0600, dir, dev,
+			    &fops_fw_debug_level);
+	debugfs_create_file("fw_wa_query", 0600, dir, dev, &fops_wa_query);
+	debugfs_create_file("fw_wa_set", 0600, dir, dev, &fops_wa_set);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "fw_version", dir,
+				    mt7996_dump_version);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "fw_wa_info", dir,
+				    mt7996_fw_wa_info_read);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "fw_wm_info", dir,
+				    mt7996_fw_wm_info_read);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "sta_info", dir,
+				    mt7996_sta_info);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "tr_info", dir,
+				    mt7996_trinfo_read);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "eeprom_mode", dir,
+				    mt7996_show_eeprom_mode);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "wtbl_info", dir,
+				    mt7996_wtbl_read);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "token", dir, mt7996_token_read);
+	debugfs_create_file("red", 0600, dir, dev, &fops_red_config);
+	debugfs_create_file("vow_drr_dbg", 0200, dir, dev, &fops_vow_drr_dbg);
+
+	dev->dbg.sku_disable = true; /* For SQC */
+	debugfs_create_u8("sku_disable", 0600, dir, &dev->dbg.sku_disable);
+
+	debugfs_create_file("muru_prot_thr", 0200, dir, dev, &fops_muru_prot_thr);
+	debugfs_create_file("muru_fixed_rate_enable", 0600, dir, dev,
+			    &fops_muru_fixed_rate_enable);
+	debugfs_create_file("muru_fixed_group_rate", 0600, dir, dev,
+			    &fops_muru_fixed_group_rate);
+
+	if (dev->has_rro) {
+		debugfs_create_u32("rro_sid", 0600, dir, &dev->dbg.sid);
+		debugfs_create_devm_seqfile(dev->mt76.dev, "rro_sid_info", dir,
+					    mt7996_rro_session_read);
+		debugfs_create_devm_seqfile(dev->mt76.dev, "rro_mib", dir,
+					    mt7996_show_rro_mib);
+	}
+
+	debugfs_create_file("thermal_recal", 0200, dir, dev, &fops_thermal_recal);
+	debugfs_create_file("reset_counter", 0200, dir, dev, &fops_reset_counter);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "drr_info", dir,
+				    mt7996_drr_info);
+
+	debugfs_create_u32("token_idx", 0600, dir, &dev->dbg.token_idx);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "rx_token", dir,
+				    mt7996_rx_token_read);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "ple_info", dir,
+				    mt7996_pleinfo_read);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "pse_info", dir,
+				    mt7996_pseinfo_read);
+	/* amsdu */
+	debugfs_create_file("amsdu_algo", 0600, dir, dev, &fops_amsdu_algo);
+	debugfs_create_file("amsdu_para", 0600, dir, dev, &fops_amsdu_para);
+
+	/* Drop counters */
+	debugfs_create_file("tx_drop_stats", 0400, dir, dev, &mt7996_tx_drop_fops);
+	debugfs_create_file("rx_drop_stats", 0400, dir, dev, &mt7996_rx_drop_fops);
+
+	debugfs_create_file("muru_dbg", 0200, dir, dev, &fops_muru_dbg_info);
+}
+
+#endif
diff --git a/mt7996/mtk_debugfs_i.c b/mt7996/mtk_debugfs_i.c
new file mode 100644
index 00000000..c9224eee
--- /dev/null
+++ b/mt7996/mtk_debugfs_i.c
@@ -0,0 +1,1017 @@
+#include <linux/inet.h>
+#include "mt7996.h"
+#include "../mt76.h"
+#include "mcu.h"
+#include "mac.h"
+#include "eeprom.h"
+#include "mtk_debug.h"
+#include "mtk_debug_i.h"
+#include "mtk_mcu.h"
+
+#ifdef CONFIG_MTK_DEBUG
+
+#define info_or_seq_printf(seq, fmt, ...)	do {	\
+	if (seq)					\
+		seq_printf(seq, fmt, ##__VA_ARGS__);	\
+	else						\
+		pr_info(fmt, ##__VA_ARGS__);		\
+} while (0)
+
+static void info_or_seq_hex_dump(struct seq_file *seq, int prefix_type,
+				 int rowsize, int groupsize, const void *buf,
+				 size_t len, bool ascii)
+{
+	if (seq)
+		seq_hex_dump(seq, "", prefix_type, rowsize, groupsize,
+			     buf, len, ascii);
+	else
+		print_hex_dump(KERN_INFO, "", prefix_type,
+			       rowsize, groupsize, buf, len, ascii);
+}
+
+//bmac dump mac txp
+static void mt7996_dump_bmac_mac_txp_info(struct seq_file *s, struct mt7996_dev *dev,
+					  __le32 *txp)
+{
+	struct mt7996_txp_token {
+		__le16 msdu[4];
+	} *msdu;
+	struct mt7996_txp_ptr {
+		__le32 addr1;
+		__le32 addr_info;
+		__le32 addr2;
+	} *ptr;
+	int i = 0;
+
+	for (i = 0; i < 12; i = i+2 ) {
+		if (i == 0 || i == 4) {
+			msdu = (struct mt7996_txp_token *) txp;
+			info_or_seq_printf(s, "msdu token(%d-%d)=%ld %ld %ld %ld (0x%08x-0x%08x)\n", i, i+3,
+				(msdu->msdu[0] & GENMASK(14, 0)),
+				(msdu->msdu[1] & GENMASK(14, 0)),
+				(msdu->msdu[2] & GENMASK(14, 0)),
+				(msdu->msdu[3] & GENMASK(14, 0)), *txp, *(txp+1));
+			txp = txp + 2;
+		}
+		ptr = (struct mt7996_txp_ptr *) txp;
+		info_or_seq_printf(s, "ptr%02d : addr(0x%08x) len(%ld) addr_h(%02lx) SRC(%d) ML(%d) \n",
+			i, ptr->addr1,
+			FIELD_GET(GENMASK(11, 0), ptr->addr_info),
+			FIELD_GET(GENMASK(13, 12), ptr->addr_info),
+			!!(ptr->addr_info & BIT(14)),
+			!!(ptr->addr_info & BIT(15)));
+		info_or_seq_printf(s, "ptr%02d : addr(0x%08x) len(%ld) addr_h(%02lx) SRC(%d) ML(%d) \n",
+			i+1, ptr->addr2,
+			FIELD_GET(GENMASK(27, 16), ptr->addr_info),
+			FIELD_GET(GENMASK(29, 28), ptr->addr_info),
+			!!(ptr->addr_info & BIT(30)),
+			!!(ptr->addr_info & BIT(31)));
+		txp = txp + 3;
+	}
+}
+
+//bmac dump hif txp
+void mt7996_dump_bmac_hif_txp_info(struct seq_file *s, struct mt7996_dev *dev,
+				   __le32 *txp, u32 hif_txp_ver)
+{
+	int i, j = 0;
+	u32 dw;
+
+	info_or_seq_printf(s, "txp raw data: size=%d\n", HIF_TXP_V2_SIZE);
+	info_or_seq_hex_dump(s, DUMP_PREFIX_OFFSET, 16, 1, (u8 *)txp, HIF_TXP_V2_SIZE, false);
+
+	info_or_seq_printf(s, "BMAC_TXP Fields:\n");
+
+	/* dw0 */
+	if (hif_txp_ver == 2) {
+		dw = le32_to_cpu(txp[0]);
+		info_or_seq_printf(s, "HIF_TXP_PRIORITY = %d\n",
+				GET_FIELD(HIF_TXP_PRIORITY, dw));
+		info_or_seq_printf(s, "HIF_TXP_FIXED_RATE = %d\n",
+				GET_FIELD(HIF_TXP_FIXED_RATE, dw));
+		info_or_seq_printf(s, "HIF_TXP_TCP = %d\n",
+				GET_FIELD(HIF_TXP_TCP, dw));
+		info_or_seq_printf(s, "HIF_TXP_NON_CIPHER = %d\n",
+				GET_FIELD(HIF_TXP_NON_CIPHER, dw));
+		info_or_seq_printf(s, "HIF_TXP_VLAN = %d\n",
+				GET_FIELD(HIF_TXP_VLAN, dw));
+		info_or_seq_printf(s, "HIF_TXP_BC_MC_FLAG = %d\n",
+				GET_FIELD(HIF_TXP_BC_MC_FLAG, dw));
+		info_or_seq_printf(s, "HIF_TXP_FR_HOST = %d\n",
+				GET_FIELD(HIF_TXP_FR_HOST, dw));
+		info_or_seq_printf(s, "HIF_TXP_ETYPE = %d\n",
+				GET_FIELD(HIF_TXP_ETYPE, dw));
+		info_or_seq_printf(s, "HIF_TXP_TXP_AMSDU = %d\n",
+				GET_FIELD(HIF_TXP_TXP_AMSDU, dw));
+		info_or_seq_printf(s, "HIF_TXP_TXP_MC_CLONE = %d\n",
+				GET_FIELD(HIF_TXP_TXP_MC_CLONE, dw));
+		info_or_seq_printf(s, "HIF_TXP_TOKEN_ID = %d\n",
+				GET_FIELD(HIF_TXP_TOKEN_ID, dw));
+
+		/* dw1 */
+		dw = le32_to_cpu(txp[1]);
+		info_or_seq_printf(s, "HIF_TXP_BSS_IDX = %d\n",
+				GET_FIELD(HIF_TXP_BSS_IDX, dw));
+		info_or_seq_printf(s, "HIF_TXP_USER_PRIORITY = %d\n",
+				GET_FIELD(HIF_TXP_USER_PRIORITY, dw));
+		info_or_seq_printf(s, "HIF_TXP_BUF_NUM = %d\n",
+				GET_FIELD(HIF_TXP_BUF_NUM, dw));
+		info_or_seq_printf(s, "HIF_TXP_MSDU_CNT = %d\n",
+				GET_FIELD(HIF_TXP_MSDU_CNT, dw));
+		info_or_seq_printf(s, "HIF_TXP_SRC = %d\n",
+				GET_FIELD(HIF_TXP_SRC, dw));
+
+		/* dw2 */
+		dw = le32_to_cpu(txp[2]);
+		info_or_seq_printf(s, "HIF_TXP_ETH_TYPE(network-endian) = 0x%x\n",
+				GET_FIELD(HIF_TXP_ETH_TYPE, dw));
+		info_or_seq_printf(s, "HIF_TXP_WLAN_IDX = %d\n",
+				GET_FIELD(HIF_TXP_WLAN_IDX, dw));
+
+		/* dw3 */
+		dw = le32_to_cpu(txp[3]);
+		info_or_seq_printf(s, "HIF_TXP_PPE_INFO = 0x%x\n",
+				GET_FIELD(HIF_TXP_PPE_INFO, dw));
+
+		for (i = 0; i < 13; i++) {
+			if (i % 2 == 0) {
+				info_or_seq_printf(s, "HIF_TXP_BUF_PTR%d_L = 0x%x\n",
+						i, GET_FIELD(HIF_TXP_BUF_PTR0_L,
+						le32_to_cpu(txp[4 + j])));
+				j++;
+				info_or_seq_printf(s, "HIF_TXP_BUF_LEN%d = %d\n",
+						i, GET_FIELD(HIF_TXP_BUF_LEN0, le32_to_cpu(txp[4 + j])));
+				info_or_seq_printf(s, "HIF_TXP_BUF_PTR%d_H = 0x%x\n",
+						i, GET_FIELD(HIF_TXP_BUF_PTR0_H, le32_to_cpu(txp[4 + j])));
+				if (i <= 10) {
+					info_or_seq_printf(s, "HIF_TXP_BUF_LEN%d = %d\n",
+							i + 1, GET_FIELD(HIF_TXP_BUF_LEN1, le32_to_cpu(txp[4 + j])));
+					info_or_seq_printf(s, "HIF_TXP_BUF_PTR%d_H = 0x%x\n",
+							i + 1, GET_FIELD(HIF_TXP_BUF_PTR1_H, le32_to_cpu(txp[4 + j])));
+				}
+				j++;
+			} else {
+				info_or_seq_printf(s, "HIF_TXP_BUF_PTR%d_L = 0x%x\n",
+					i, GET_FIELD(HIF_TXP_BUF_PTR1_L,
+					le32_to_cpu(txp[4 + j])));
+				j++;
+			}
+		}
+
+		info_or_seq_printf(s, "ml = 0x%x\n",
+			GET_FIELD(HIF_TXP_ML, le32_to_cpu(txp[23])));
+	} else {
+		struct mt76_connac_txp_common *txp_v1 = (struct mt76_connac_txp_common *)txp;
+
+		info_or_seq_printf(s, "FLAGS = (%04x)\n", txp_v1->fw.flags);
+
+		info_or_seq_printf(s, "MSDU = %d\n", txp_v1->fw.token);
+
+		info_or_seq_printf(s, "BSS_IDX = %d\n", txp_v1->fw.bss_idx);
+
+		info_or_seq_printf(s, "WCID = %d\n",txp_v1->fw.rept_wds_wcid);
+
+		info_or_seq_printf(s, "MSDU_CNT = %d\n", txp_v1->fw.nbuf);
+
+		for (i = 0; i < MT_TXP_MAX_BUF_NUM; i++)
+			info_or_seq_printf(s, "ptr%02d : addr(0x%08x) len(%d)\n", i, le32_to_cpu(txp_v1->fw.buf[i]),
+				le16_to_cpu(txp_v1->fw.len[i]));
+	}
+}
+
+/* bmac txd dump */
+void mt7996_dump_bmac_txd_info(struct seq_file *s, struct mt7996_dev *dev,
+			       __le32 *txd, bool is_hif_txd, bool dump_txp)
+{
+	u32 hif_txp_ver = 0;
+
+	/* dump stop */
+	if (!dev->dbg.txd_read_cnt)
+		return;
+
+	/* force dump */
+	if (dev->dbg.txd_read_cnt > 8)
+		dev->dbg.txd_read_cnt = 8;
+
+	/* dump txd_read_cnt times */
+	if (dev->dbg.txd_read_cnt != 8)
+		dev->dbg.txd_read_cnt--;
+
+	info_or_seq_printf(s, "txd raw data: size=%d\n", MT_TXD_SIZE);
+	info_or_seq_hex_dump(s, DUMP_PREFIX_OFFSET, 16, 1, (u8 *)txd, MT_TXD_SIZE, false);
+
+	info_or_seq_printf(s, "BMAC_TXD Fields:\n");
+	/* dw0 */
+	if (is_hif_txd) {
+		hif_txp_ver = FIELD_GET(GENMASK(22, 19), txd[0]);
+		info_or_seq_printf(s, "HIF TXD VER = %d\n", hif_txp_ver);
+	}
+	info_or_seq_printf(s, "TX_BYTE_COUNT = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TX_BYTE_COUNT, txd[0]));
+	info_or_seq_printf(s, "ETHER_TYPE_OFFSET(word) = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_ETHER_TYPE_OFFSET, txd[0]));
+	info_or_seq_printf(s, "PKT_FT = %d%s%s%s%s\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_PKT_FT, txd[0]),
+			GET_FIELD(WF_TX_DESCRIPTOR_PKT_FT, txd[0]) == 0 ? "(ct)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_PKT_FT, txd[0]) == 1 ? "(s&f)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_PKT_FT, txd[0]) == 2 ? "(cmd)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_PKT_FT, txd[0]) == 3 ? "(redirect)" : "");
+	info_or_seq_printf(s, "Q_IDX = %d%s%s%s\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_Q_IDX, txd[0]),
+			GET_FIELD(WF_TX_DESCRIPTOR_Q_IDX, txd[0]) == 0x10 ? "(ALTX)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_Q_IDX, txd[0]) == 0x11 ? "(BMC)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_Q_IDX, txd[0]) == 0x12 ? "(BCN)" : "");
+
+	/* dw1 */
+	info_or_seq_printf(s, "MLD_ID = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_MLD_ID, txd[1]));
+	info_or_seq_printf(s, "TGID = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TGID, txd[1]));
+	info_or_seq_printf(s, "HF = %d%s%s%s%s\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]),
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 0 ? "(eth/802.3)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 1 ? "(cmd)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 2 ? "(802.11)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 3 ? "(802.11 enhanced" : "");
+	info_or_seq_printf(s, "802.11 HEADER_LENGTH = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 2 ?
+			GET_FIELD(WF_TX_DESCRIPTOR_HEADER_LENGTH, txd[1]) : 0);
+	info_or_seq_printf(s, "MRD = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 0 ?
+			GET_FIELD(WF_TX_DESCRIPTOR_MRD, txd[1]) : 0);
+	info_or_seq_printf(s, "EOSP = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 0 ?
+			GET_FIELD(WF_TX_DESCRIPTOR_EOSP, txd[1]) : 0);
+	info_or_seq_printf(s, "AMS = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 3 ?
+			GET_FIELD(WF_TX_DESCRIPTOR_AMS, txd[1]) : 0);
+	info_or_seq_printf(s, "RMVL = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 0 ?
+			GET_FIELD(WF_TX_DESCRIPTOR_RMVL, txd[1]): 0);
+	info_or_seq_printf(s, "VLAN = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 0 ?
+			GET_FIELD(WF_TX_DESCRIPTOR_VLAN, txd[1]) : 0);
+	info_or_seq_printf(s, "ETYP = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 0 ?
+			GET_FIELD(WF_TX_DESCRIPTOR_ETYP, txd[1]) : 0);
+	info_or_seq_printf(s, "TID_MGMT_TYPE = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TID_MGMT_TYPE, txd[1]));
+	info_or_seq_printf(s, "OM = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_OM, txd[1]));
+	info_or_seq_printf(s, "FR = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_FR, txd[1]));
+
+	/* dw2 */
+	info_or_seq_printf(s, "SUBTYPE = %d%s%s%s%s\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_SUBTYPE, txd[2]),
+			(GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]) == 0) &&
+			(GET_FIELD(WF_TX_DESCRIPTOR_SUBTYPE, txd[2]) == 13) ?
+			"(action)" : "",
+			(GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]) == 1) &&
+			(GET_FIELD(WF_TX_DESCRIPTOR_SUBTYPE, txd[2]) == 8) ?
+			"(bar)" : "",
+			(GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]) == 2) &&
+			(GET_FIELD(WF_TX_DESCRIPTOR_SUBTYPE, txd[2]) == 4) ?
+			"(null)" : "",
+			(GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]) == 2) &&
+			(GET_FIELD(WF_TX_DESCRIPTOR_SUBTYPE, txd[2]) == 12) ?
+			"(qos null)" : "");
+
+	info_or_seq_printf(s, "FTYPE = %d%s%s%s\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]),
+			GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]) == 0 ? "(mgmt)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]) == 1 ? "(ctl)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]) == 2 ? "(data)" : "");
+	info_or_seq_printf(s, "BF_TYPE = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_BF_TYPE, txd[2]));
+	info_or_seq_printf(s, "OM_MAP = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_OM_MAP, txd[2]));
+	info_or_seq_printf(s, "RTS = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_RTS, txd[2]));
+	info_or_seq_printf(s, "HEADER_PADDING = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HEADER_PADDING, txd[2]));
+	info_or_seq_printf(s, "DU = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_DU, txd[2]));
+	info_or_seq_printf(s, "HE = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HE, txd[2]));
+	info_or_seq_printf(s, "FRAG = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_FRAG, txd[2]));
+	info_or_seq_printf(s, "REMAINING_TX_TIME = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_REMAINING_TX_TIME, txd[2]));
+	info_or_seq_printf(s, "POWER_OFFSET = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_POWER_OFFSET, txd[2]));
+
+	/* dw3 */
+	info_or_seq_printf(s, "NA = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_NA, txd[3]));
+	info_or_seq_printf(s, "PF = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_PF, txd[3]));
+	info_or_seq_printf(s, "EMRD = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_EMRD, txd[3]));
+	info_or_seq_printf(s, "EEOSP = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_EEOSP, txd[3]));
+	info_or_seq_printf(s, "BM = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_BM, txd[3]));
+	info_or_seq_printf(s, "HW_AMSDU_CAP = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HW_AMSDU_CAP, txd[3]));
+	info_or_seq_printf(s, "TX_COUNT = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TX_COUNT, txd[3]));
+	info_or_seq_printf(s, "REMAINING_TX_COUNT = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_REMAINING_TX_COUNT, txd[3]));
+	info_or_seq_printf(s, "SN = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_SN, txd[3]));
+	info_or_seq_printf(s, "BA_DIS = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_BA_DIS, txd[3]));
+	info_or_seq_printf(s, "PM = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_PM, txd[3]));
+	info_or_seq_printf(s, "PN_VLD = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_PN_VLD, txd[3]));
+	info_or_seq_printf(s, "SN_VLD = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_SN_VLD, txd[3]));
+
+	/* dw4 */
+	info_or_seq_printf(s, "PN_31_0 = 0x%x\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_PN_31_0_, txd[4]));
+
+	/* dw5 */
+	info_or_seq_printf(s, "PID = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_PID, txd[5]));
+	info_or_seq_printf(s, "TXSFM = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TXSFM, txd[5]));
+	info_or_seq_printf(s, "TXS2M = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TXS2M, txd[5]));
+	info_or_seq_printf(s, "TXS2H = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TXS2H, txd[5]));
+	info_or_seq_printf(s, "FBCZ = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_FBCZ, txd[5]));
+	info_or_seq_printf(s, "BYPASS_RBB = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_BYPASS_RBB, txd[5]));
+
+	info_or_seq_printf(s, "FL = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_FL, txd[5]));
+	info_or_seq_printf(s, "PN_47_32 = 0x%x\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_PN_47_32_, txd[5]));
+
+	/* dw6 */
+	info_or_seq_printf(s, "AMSDU_CAP_UTXB = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_AMSDU_CAP_UTXB, txd[6]));
+	info_or_seq_printf(s, "DAS = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_DAS, txd[6]));
+	info_or_seq_printf(s, "DIS_MAT = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_DIS_MAT, txd[6]));
+	info_or_seq_printf(s, "MSDU_COUNT = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_MSDU_COUNT, txd[6]));
+	info_or_seq_printf(s, "TIMESTAMP_OFFSET = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TIMESTAMP_OFFSET_IDX, txd[6]));
+	info_or_seq_printf(s, "FIXED_RATE_IDX = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_FIXED_RATE_IDX, txd[6]));
+	info_or_seq_printf(s, "BW = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_BW, txd[6]));
+	info_or_seq_printf(s, "VTA = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_VTA, txd[6]));
+	info_or_seq_printf(s, "SRC = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_SRC, txd[6]));
+
+	/* dw7 */
+	info_or_seq_printf(s, "SW_TX_TIME(unit:65536ns) = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_SW_TX_TIME , txd[7]));
+	info_or_seq_printf(s, "UT = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_UT, txd[7]));
+	info_or_seq_printf(s, "CTXD_CNT = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_CTXD_CNT, txd[7]));
+	info_or_seq_printf(s, "HM = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HM, txd[7]));
+	info_or_seq_printf(s, "DP = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_DP, txd[7]));
+	info_or_seq_printf(s, "IP = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_IP, txd[7]));
+	info_or_seq_printf(s, "TXD_LEN = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TXD_LEN, txd[7]));
+
+	if (dump_txp) {
+		__le32 *txp = txd + 8;
+
+		if (is_hif_txd)
+			mt7996_dump_bmac_hif_txp_info(s, dev, txp, hif_txp_ver);
+		else
+			mt7996_dump_bmac_mac_txp_info(s, dev, txp);
+	}
+}
+
+static void
+mt7996_dump_mac_fid(struct seq_file *s, struct mt7996_dev *dev, u32 fid, bool is_ple)
+{
+#define PLE_MEM_SIZE	 128
+#define PSE_MEM_SIZE	 256
+	 u8 data[PSE_MEM_SIZE] = {0};
+	 u32 addr = 0;
+	 int i = 0, cr_cnt = PSE_MEM_SIZE;
+	 u32 *ptr = (u32 *) data;
+
+	 if (is_ple) {
+		cr_cnt = PLE_MEM_SIZE;
+		seq_printf(s, "dump ple: fid = 0x%08x\n", fid);
+	 } else {
+		seq_printf(s, "dump pse: fid = 0x%08x\n", fid);
+	 }
+
+	 for (i = 0; i < cr_cnt; i = i + 4) {
+		if (is_ple)
+			addr = (0xa << 28 | fid << 15) + i;
+		else
+			addr = (0xb << 28 | fid << 15) + i;
+		*ptr = mt76_rr(dev, addr);
+		ptr++;
+	 }
+
+	 seq_printf(s, "raw data: size=%d\n", cr_cnt);
+
+	 seq_hex_dump(s, "", DUMP_PREFIX_OFFSET, 16, 1, (u8 *)data, cr_cnt, false);
+	 /* dump one txd info */
+	 if (is_ple) {
+		 dev->dbg.txd_read_cnt = 1;
+		 mt7996_dump_bmac_txd_info(s, dev, (__le32 *)&data[0], false, true);
+	 }
+}
+
+static int
+mt7996_ple_fid_read(struct seq_file *s, void *data) {
+	 struct mt7996_dev *dev = dev_get_drvdata(s->private);
+
+	 mt7996_dump_mac_fid(s, dev, dev->dbg.fid_idx, true);
+	 return 0;
+}
+
+static int
+mt7996_pse_fid_read(struct seq_file *s, void *data) {
+	 struct mt7996_dev *dev = dev_get_drvdata(s->private);
+
+	 mt7996_dump_mac_fid(s, dev, dev->dbg.fid_idx, false);
+	 return 0;
+}
+
+void mt7996_dump_bmac_rxd_info(struct mt7996_dev *dev, __le32 *rxd)
+{
+	/* dump stop */
+	if (!dev->dbg.rxd_read_cnt)
+		return;
+
+	/* force dump */
+	if (dev->dbg.rxd_read_cnt > 8)
+		dev->dbg.rxd_read_cnt = 8;
+
+	/* dump txd_read_cnt times */
+	if (dev->dbg.rxd_read_cnt != 8)
+		dev->dbg.rxd_read_cnt--;
+
+	printk("rxd raw data: size=%d\n", MT_TXD_SIZE);
+	print_hex_dump(KERN_ERR , "", DUMP_PREFIX_OFFSET, 16, 1, (u8 *)rxd, 96, false);
+
+	printk("BMAC_RXD Fields:\n");
+
+	/* group0 */
+	/* dw0 */
+	printk("RX_BYTE_COUNT = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_RX_BYTE_COUNT, le32_to_cpu(rxd[0])));
+	printk("PACKET_TYPE = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_PACKET_TYPE, le32_to_cpu(rxd[0])));
+
+	/* dw1 */
+	printk("MLD_ID = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_MLD_ID, le32_to_cpu(rxd[1])));
+	printk("GROUP_VLD = 0x%x%s%s%s%s%s\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1])),
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_1 ? "[group1]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_2 ? "[group2]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_3 ? "[group3]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ? "[group4]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_5 ? "[group5]" : "");
+	printk("KID = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_KID, le32_to_cpu(rxd[1])));
+	printk("CM = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_CM, le32_to_cpu(rxd[1])));
+	printk("CLM = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_CLM, le32_to_cpu(rxd[1])));
+	printk("I = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_I, le32_to_cpu(rxd[1])));
+	printk("T = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_T, le32_to_cpu(rxd[1])));
+	printk("BN = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_BN, le32_to_cpu(rxd[1])));
+	printk("BIPN_FAIL = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_BIPN_FAIL, le32_to_cpu(rxd[1])));
+
+	/* dw2 */
+	printk("BSSID = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_BSSID, le32_to_cpu(rxd[2])));
+	printk("H = %d%s\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_H, le32_to_cpu(rxd[2])),
+			GET_FIELD(WF_RX_DESCRIPTOR_H, le32_to_cpu(rxd[2])) == 0 ?
+			"802.11 frame" : "eth/802.3 frame");
+	printk("HEADER_LENGTH(word) = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_HEADER_LENGTH, le32_to_cpu(rxd[2])));
+	printk("HO(word) = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_HO, le32_to_cpu(rxd[2])));
+	printk("SEC_MODE = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_SEC_MODE, le32_to_cpu(rxd[2])));
+	printk("MUBAR = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_MUBAR, le32_to_cpu(rxd[2])));
+	printk("SWBIT = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_SWBIT, le32_to_cpu(rxd[2])));
+	printk("DAF = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_DAF, le32_to_cpu(rxd[2])));
+	printk("EL = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_EL, le32_to_cpu(rxd[2])));
+	printk("HTF = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_HTF, le32_to_cpu(rxd[2])));
+	printk("INTF = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_INTF, le32_to_cpu(rxd[2])));
+	printk("FRAG = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_FRAG, le32_to_cpu(rxd[2])));
+	printk("NUL = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_NUL, le32_to_cpu(rxd[2])));
+	printk("NDATA = %d%s\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_NDATA, le32_to_cpu(rxd[2])),
+			GET_FIELD(WF_RX_DESCRIPTOR_NDATA, le32_to_cpu(rxd[2])) == 0 ?
+			"[data frame]" : "[mgmt/ctl frame]");
+	printk("NAMP = %d%s\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_NAMP, le32_to_cpu(rxd[2])),
+			GET_FIELD(WF_RX_DESCRIPTOR_NAMP, le32_to_cpu(rxd[2])) == 0 ?
+			"[ampdu frame]" : "[mpdu frame]");
+	printk("BF_RPT = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_BF_RPT, le32_to_cpu(rxd[2])));
+
+	/* dw3 */
+	printk("RXV_SN = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_RXV_SN, le32_to_cpu(rxd[3])));
+	printk("CH_FREQUENCY = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_CH_FREQUENCY, le32_to_cpu(rxd[3])));
+	printk("A1_TYPE = %d%s%s%s%s\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_A1_TYPE, le32_to_cpu(rxd[3])),
+			GET_FIELD(WF_RX_DESCRIPTOR_A1_TYPE, le32_to_cpu(rxd[3])) == 0 ?
+			"[reserved]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_A1_TYPE, le32_to_cpu(rxd[3])) == 1 ?
+			"[uc2me]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_A1_TYPE, le32_to_cpu(rxd[3])) == 2 ?
+			"[mc]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_A1_TYPE, le32_to_cpu(rxd[3])) == 3 ?
+			"[bc]" : "");
+	printk("HTC = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_HTC, le32_to_cpu(rxd[3])));
+	printk("TCL = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_TCL, le32_to_cpu(rxd[3])));
+	printk("BBM = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_BBM, le32_to_cpu(rxd[3])));
+	printk("BU = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_BU, le32_to_cpu(rxd[3])));
+	printk("CO_ANT = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_CO_ANT, le32_to_cpu(rxd[3])));
+	printk("BF_CQI = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_BF_CQI, le32_to_cpu(rxd[3])));
+	printk("FC = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_FC, le32_to_cpu(rxd[3])));
+	printk("VLAN = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_VLAN, le32_to_cpu(rxd[3])));
+
+	/* dw4 */
+	printk("PF = %d%s%s%s%s\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_PF, le32_to_cpu(rxd[4])),
+			GET_FIELD(WF_RX_DESCRIPTOR_PF, le32_to_cpu(rxd[4])) == 0 ?
+			"[msdu]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_PF, le32_to_cpu(rxd[4])) == 1 ?
+			"[final amsdu]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_PF, le32_to_cpu(rxd[4])) == 2 ?
+			"[middle amsdu]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_PF, le32_to_cpu(rxd[4])) == 3 ?
+			"[first amsdu]" : "");
+	printk("MAC = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_MAC, le32_to_cpu(rxd[4])));
+	printk("TID = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_TID, le32_to_cpu(rxd[4])));
+	printk("ETHER_TYPE_OFFSET = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_ETHER_TYPE_OFFSET, le32_to_cpu(rxd[4])));
+	printk("IP = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_IP, le32_to_cpu(rxd[4])));
+	printk("UT = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_UT, le32_to_cpu(rxd[4])));
+	printk("PSE_FID = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_PSE_FID, le32_to_cpu(rxd[4])));
+
+	/* group4 */
+	/* dw0 */
+	printk("FRAME_CONTROL_FIELD = 0x%x\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ?
+			GET_FIELD(WF_RX_DESCRIPTOR_FRAME_CONTROL_FIELD, le32_to_cpu(rxd[8])) : 0);
+	printk("PEER_MLD_ADDRESS_15_0 = 0x%x\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ?
+			GET_FIELD(WF_RX_DESCRIPTOR_PEER_MLD_ADDRESS_15_0_,
+			le32_to_cpu(rxd[8])) : 0);
+
+	/* dw1 */
+	printk("PEER_MLD_ADDRESS_47_16 = 0x%x\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ?
+			GET_FIELD(WF_RX_DESCRIPTOR_PEER_MLD_ADDRESS_47_16_,
+			le32_to_cpu(rxd[9])) : 0);
+
+	/* dw2 */
+	printk("FRAGMENT_NUMBER = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ?
+			GET_FIELD(WF_RX_DESCRIPTOR_FRAGMENT_NUMBER,
+			le32_to_cpu(rxd[10])) : 0);
+	printk("SEQUENCE_NUMBER = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ?
+			GET_FIELD(WF_RX_DESCRIPTOR_SEQUENCE_NUMBER,
+			le32_to_cpu(rxd[10])) : 0);
+	printk("QOS_CONTROL_FIELD = 0x%x\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ?
+			GET_FIELD(WF_RX_DESCRIPTOR_QOS_CONTROL_FIELD,
+			le32_to_cpu(rxd[10])) : 0);
+
+	/* dw3 */
+	printk("HT_CONTROL_FIELD = 0x%x\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ?
+			GET_FIELD(WF_RX_DESCRIPTOR_HT_CONTROL_FIELD,
+			le32_to_cpu(rxd[11])) : 0);
+}
+
+static int mt7996_token_txd_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	struct mt76_txwi_cache *t;
+	u8* txwi;
+
+	seq_printf(s, "\n");
+	spin_lock_bh(&dev->mt76.token_lock);
+
+	t = idr_find(&dev->mt76.token, dev->dbg.token_idx);
+	if (t != NULL) {
+		struct mt76_dev *mdev = &dev->mt76;
+		txwi = ((u8*)(t)) - (mdev->drv->txwi_size);
+		/* dump one txd info */
+		dev->dbg.txd_read_cnt = 1;
+		mt7996_dump_bmac_txd_info(s, dev, (__le32 *)txwi, true, true);
+		seq_printf(s, "\n");
+		seq_printf(s, "[SKB]\n");
+		seq_hex_dump(s, "", DUMP_PREFIX_OFFSET, 16, 1, (u8 *)t->skb->data, t->skb->len, false);
+		seq_printf(s, "\n");
+	}
+	spin_unlock_bh(&dev->mt76.token_lock);
+	return 0;
+}
+
+static int mt7996_rx_msdu_pg_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	struct list_head *p;
+	int i, count = 0, total = 0;
+
+	seq_printf(s, "Rx Msdu page:\n");
+	spin_lock(&dev->wed_rro.lock);
+	for (i = 0; i < MT7996_RRO_MSDU_PG_HASH_SIZE; i++) {
+		list_for_each(p, &dev->wed_rro.pg_hash_head[i]) {
+			count++;
+		}
+	}
+
+	total = count;
+	list_for_each(p, &dev->wed_rro.pg_addr_cache) {
+		total++;
+	}
+	seq_printf(s, "\ttotal:%8d used:%8d\n", total, count);
+	spin_unlock(&dev->wed_rro.lock);
+
+	return 0;
+}
+
+static int
+mt7996_mat_table_show(struct seq_file *s, void *data)
+{
+#define MT_MAX_MAT_TABLE_SIZE	63
+	struct mt7996_dev *dev = s->private;
+	int i;
+
+	for (i = 0; i < MT_MAX_MAT_TABLE_SIZE; i++) {
+		u32 req = MT_WF_UWTBL_ITCR_SET |
+			  u32_encode_bits(i, MT_WF_UWTBL_ITCR_INDEX);
+		u32 dw[2];
+		u8 *addr = (u8 *)dw;
+
+		mt76_wr(dev, MT_WF_UWTBL_ITCR, req);
+		dw[0] = mt76_rr(dev, MT_WF_UWTBL_ITCR0);
+		dw[1] = mt76_rr(dev, MT_WF_UWTBL_ITCR1);
+
+		if (dw[0] || dw[1])
+			seq_printf(s, "own_mld_id%d\tAddr: %pM\n", i, addr);
+	}
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_mat_table);
+
+static int
+mt7996_rmac_table_show(struct seq_file *s, void *data)
+{
+	struct mt7996_phy *phy = s->private;
+	struct mt7996_dev *dev = phy->dev;
+	unsigned long usage_bitmap[2] = {0};
+	int i, j;
+	u8 band = phy->mt76->band_idx;
+
+	usage_bitmap[0] = (unsigned long)mt76_rr(dev, MT_WF_RMAC_SRAM_BITMAP0(band));
+	usage_bitmap[1] = (unsigned long)mt76_rr(dev, MT_WF_RMAC_SRAM_BITMAP1(band));
+
+	for (i = 0; i < 2; i++) {
+		for_each_set_bit(j, &usage_bitmap[i], 32) {
+			u32 req = MT_WF_RMAC_MEM_CRTL_TRIG |
+				  u32_encode_bits(i * 32 + j, MT_WF_RMAC_MEM_CRTL_TDX);
+			u32 dw[2];
+			u8 *addr = (u8 *)dw;
+
+			mt76_wr(dev, MT_WF_RMAC_MEM_CTRL(band), req);
+			dw[0] = mt76_rr(dev, MT_WF_RMAC_SRAM_DATA0(band));
+			dw[1] = mt76_rr(dev, MT_WF_RMAC_SRAM_DATA1(band));
+
+			seq_printf(s, "omac_idx%d\tAddr: %pM\n", i * 32 + j, addr);
+		}
+	}
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_rmac_table);
+
+static int
+mt7996_agg_table_show(struct seq_file *s, void *data)
+{
+	struct mt7996_phy *phy = s->private;
+	struct mt7996_dev *dev = phy->dev;
+	int i, j;
+	u8 band = phy->mt76->band_idx;
+
+	for (i = 0; i < 4; i++) {
+		u32 value = mt76_rr(dev, MT_AGG_REMAP_CTRL(band) + 4 * i);
+
+		for (j = 0; j < 4; j++) {
+			u8 shift = 8 * j;
+			u32 mask = MT_AGG_REMAP_CTRL_OM_REMAP << shift;
+
+			seq_printf(s, "idx%d: %d\n", i * 4 + j,
+				      (value & mask) >> shift);
+		}
+	}
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_agg_table);
+
+static ssize_t mt7996_mlo_agc_tx_set(struct file *file,
+				     const char __user *user_buf,
+				     size_t count, loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+	struct mt7996_mlo_agc_set req;
+	char buf[100];
+	int ret;
+	u16 mgf;
+
+	memset(&req, 0, sizeof(req));
+
+	if (count >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (count && buf[count - 1] == '\n')
+		buf[count - 1] = '\0';
+	else
+		buf[count] = '\0';
+
+	if (sscanf(buf, "%hhu %hhu %hhu %hhu %hu %hhu %hhu",
+		   &req.mld_id, &req.link_id, &req.ac, &req.disp_pol,
+		   &mgf, &req.ratio, &req.order) != 7) {
+		dev_warn(dev->mt76.dev,
+			 "format: [MldRecIdx] [Link] [Ac] [DispPol] [MGF] [Ratio] [Order]\n");
+		goto out;
+	}
+
+	req.tag = cpu_to_le16(UNI_CMD_MLO_AGC_TX);
+	req.len = cpu_to_le16(sizeof(req) - 4);
+	req.mgf = cpu_to_le16(mgf);
+
+	ret = mt7996_mcu_mlo_agc(dev, &req, sizeof(req));
+	if (ret)
+		return -EFAULT;
+
+out:
+	return count;
+}
+
+static const struct file_operations fops_mlo_agc_tx = {
+	.write = mt7996_mlo_agc_tx_set,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static ssize_t mt7996_be_txop_set(struct file *file,
+			       const char __user *user_buf,
+			       size_t count, loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+	char buf[100], role[4];
+	u32 ofs;
+	u16 txop, decimal;
+	int i = 0;
+
+	if (count >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (count && buf[count - 1] == '\n')
+		buf[count - 1] = '\0';
+	else
+		buf[count] = '\0';
+
+	if (sscanf(buf, "%3s %hu.%hu", role, &txop, &decimal) != 3)
+		goto err;
+
+	if (!strncmp(role, "ap", 2))
+		ofs = MT_WF_TMAC_WMM0_OFFSET;
+	else if (!strncmp(role, "sta", 3))
+		ofs = MT_WF_TMAC_WMM3_OFFSET;
+	else
+		goto err;
+
+	/* Change unit to 32 us */
+	txop = (txop * 1000 + decimal * 100 + 16) >> 5;
+
+	for (i = 0; i < __MT_MAX_BAND; i++) {
+		if (!dev->mt76.phys[i])
+			continue;
+
+		mt76_rmw(dev, MT_WF_TMAC(i, ofs), MT_WF_TMAC_WMM_TXOP_MASK,
+			 txop << MT_WF_TMAC_WMM_TXOP_SHIFT);
+	}
+
+	return count;
+err:
+	dev_warn(dev->mt76.dev,
+		 "format: [ap|sta] [tx_queue_data2_burst]\n");
+	return -EINVAL;
+}
+
+static ssize_t mt7996_be_txop_dump(struct file *file, char __user *user_buf,
+				size_t count, loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+	static const size_t size = 2048;
+	int len = 0, i, ret;
+	char *buf;
+	enum {
+		AP,
+		STA,
+		MAX_IF_TYPE,
+	};
+
+	buf = kzalloc(size, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	len += scnprintf(buf + len, size - len, "Band\tAP (WMM0)\t\tSTA (WMM3)\n");
+
+	for (i = 0; i < __MT_MAX_BAND; i++) {
+		u32 txop[MAX_IF_TYPE], tx_burst[MAX_IF_TYPE];
+
+		if (!dev->mt76.phys[i])
+			continue;
+
+#define MT7996_READ_TXOP(role, base)						\
+do {										\
+	txop[role] = mt76_rr(dev, MT_WF_TMAC(i, base));				\
+	tx_burst[role] = u32_get_bits(txop[role], MT_WF_TMAC_WMM_TXOP_MASK);	\
+	tx_burst[role] = tx_burst[role] ? ((tx_burst[role] << 5) - 16) / 100 : 0;\
+} while (0)
+		MT7996_READ_TXOP(AP, MT_WF_TMAC_WMM0_OFFSET);
+		MT7996_READ_TXOP(STA, MT_WF_TMAC_WMM3_OFFSET);
+#undef MT7996_READ_TXOP
+
+		len += scnprintf(buf + len, size - len,
+			"%d\t0x%08x (%1u.%1u) \t0x%08x (%1u.%1u)\n", i,
+			txop[AP], tx_burst[AP] / 10, tx_burst[AP] % 10,
+			txop[STA], tx_burst[STA] / 10, tx_burst[STA] % 10);
+	}
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+
+	kfree(buf);
+	return ret;
+}
+
+static const struct file_operations fops_mt7996_txop = {
+	.write = mt7996_be_txop_set,
+	.read = mt7996_be_txop_dump,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static ssize_t mt7996_mlo_agc_trig_set(struct file *file,
+				       const char __user *user_buf,
+				       size_t count, loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+	struct mt7996_mlo_agc_set req;
+	char buf[100];
+	int ret;
+	u16 mgf;
+
+	memset(&req, 0, sizeof(req));
+
+	if (count >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (count && buf[count - 1] == '\n')
+		buf[count - 1] = '\0';
+	else
+		buf[count] = '\0';
+
+	if (sscanf(buf, "%hhu %hhu %hhu %hhu %hu %hhu",
+		   &req.mld_id, &req.link_id, &req.ac, &req.disp_pol,
+		   &mgf, &req.ratio) != 6) {
+		dev_warn(dev->mt76.dev,
+			 "format: [MldRecIdx] [Link] [Ac] [DispPol] [MGF] [Ratio]\n");
+		goto out;
+	}
+
+	req.tag = cpu_to_le16(UNI_CMD_MLO_AGC_TRIG);
+	req.len = cpu_to_le16(sizeof(req) - 4);
+	req.mgf = cpu_to_le16(mgf);
+
+	ret = mt7996_mcu_mlo_agc(dev, &req, sizeof(req));
+	if (ret)
+		return -EFAULT;
+
+out:
+	return count;
+}
+
+static const struct file_operations fops_mlo_agc_trig = {
+	.write = mt7996_mlo_agc_trig_set,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+int mt7996_mtk_init_dev_debugfs_internal(struct mt7996_phy *phy, struct dentry *dir)
+{
+	struct mt7996_dev *dev = phy->dev;
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "token_txd", dir,
+				    mt7996_token_txd_read);
+	debugfs_create_u32("txd_dump", 0600, dir, &dev->dbg.txd_read_cnt);
+	debugfs_create_u32("rxd_dump", 0600, dir, &dev->dbg.rxd_read_cnt);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "rx_msdu_pg", dir,
+				    mt7996_rx_msdu_pg_read);
+
+	/* ple/pse fid raw data dump */
+	debugfs_create_u32("fid_idx", 0600, dir, &dev->dbg.fid_idx);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "ple_fid", dir,
+				    mt7996_ple_fid_read);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "pse_fid", dir,
+				    mt7996_pse_fid_read);
+
+	debugfs_create_u8("dump_ple_txd", 0600, dir, &dev->dbg.dump_ple_txd);
+	debugfs_create_file("txop", 0600, dir, dev, &fops_mt7996_txop);
+
+	/* MLO related Table */
+	debugfs_create_file("mat_table", 0400, dir, dev, &mt7996_mat_table_fops);
+	debugfs_create_file("mlo_agc_tx", 0200, dir, dev, &fops_mlo_agc_tx);
+	debugfs_create_file("mlo_agc_trig", 0200, dir, dev, &fops_mlo_agc_trig);
+
+	return 0;
+}
+
+int mt7996_mtk_init_band_debugfs_internal(struct mt7996_phy *phy, struct dentry *dir)
+{
+	/* MLO related Table */
+	debugfs_create_file("rmac_table", 0400, dir, phy, &mt7996_rmac_table_fops);
+	debugfs_create_file("agg_table", 0400, dir, phy, &mt7996_agg_table_fops);
+
+	return 0;
+}
+#endif
diff --git a/mt7996/mtk_mcu.c b/mt7996/mtk_mcu.c
new file mode 100644
index 00000000..62e35888
--- /dev/null
+++ b/mt7996/mtk_mcu.c
@@ -0,0 +1,1374 @@
+// SPDX-License-Identifier: ISC
+/*
+ * Copyright (C) 2023 MediaTek Inc.
+ */
+
+#include <linux/firmware.h>
+#include <linux/fs.h>
+#include "mt7996.h"
+#include "mcu.h"
+#include "mac.h"
+#include "mtk_mcu.h"
+
+#ifdef CONFIG_MTK_DEBUG
+
+int mt7996_mcu_get_tx_power_info(struct mt7996_phy *phy, u8 category, void *event)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct tx_power_ctrl req = {
+		.tag = cpu_to_le16(UNI_TXPOWER_SHOW_INFO),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.power_ctrl_id = UNI_TXPOWER_SHOW_INFO,
+		.show_info_category = category,
+		.band_idx = phy->mt76->band_idx,
+	};
+	struct sk_buff *skb;
+	int ret;
+
+	ret = mt76_mcu_send_and_get_msg(&dev->mt76,
+					MCU_WM_UNI_CMD_QUERY(TXPOWER),
+					&req, sizeof(req), true, &skb);
+	if (ret)
+		return ret;
+
+	memcpy(event, skb->data, sizeof(struct mt7996_mcu_txpower_event));
+
+	dev_kfree_skb(skb);
+
+	return 0;
+}
+
+int mt7996_mcu_muru_dbg_info(struct mt7996_dev *dev, u16 item, u8 val)
+{
+	struct {
+		u8 __rsv1[4];
+
+		__le16 tag;
+		__le16 len;
+
+		__le16 item;
+		u8 __rsv2[2];
+		__le32 value;
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_CMD_MURU_DBG_INFO),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.item = cpu_to_le16(item),
+		.value = cpu_to_le32(val),
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MURU), &req,
+				 sizeof(req), true);
+}
+
+int mt7996_mcu_edcca_enable(struct mt7996_phy *phy, bool enable)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct cfg80211_chan_def *chandef = &phy->mt76->chandef;
+	enum nl80211_band band = chandef->chan->band;
+	struct {
+		u8 band_idx;
+		u8 _rsv[3];
+
+		__le16 tag;
+		__le16 len;
+		u8 enable;
+		u8 std;
+		u8 _rsv2[2];
+	} __packed req = {
+		.band_idx = phy->mt76->band_idx,
+		.tag = cpu_to_le16(UNI_BAND_CONFIG_EDCCA_ENABLE),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.enable = enable,
+		.std = EDCCA_DEFAULT,
+	};
+
+	switch (dev->mt76.region) {
+	case NL80211_DFS_JP:
+		req.std = EDCCA_JAPAN;
+		break;
+	case NL80211_DFS_FCC:
+		if (band == NL80211_BAND_6GHZ)
+			req.std = EDCCA_FCC;
+		break;
+	case NL80211_DFS_ETSI:
+		if (band == NL80211_BAND_6GHZ)
+			req.std = EDCCA_ETSI;
+		break;
+	default:
+		break;
+	}
+
+	return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(BAND_CONFIG),
+				 &req, sizeof(req), true);
+}
+
+int mt7996_mcu_edcca_threshold_ctrl(struct mt7996_phy *phy, u8 *value, bool set)
+{
+	struct {
+		u8 band_idx;
+		u8 _rsv[3];
+
+		__le16 tag;
+		__le16 len;
+		u8 threshold[4];
+		bool init;
+		u8 _rsv2[3];
+	} __packed *res, req = {
+		.band_idx = phy->mt76->band_idx,
+		.tag = cpu_to_le16(UNI_BAND_CONFIG_EDCCA_THRESHOLD),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.init = false,
+	};
+	struct sk_buff *skb;
+	int ret;
+	int i;
+
+	for (i = 0; i < EDCCA_MAX_BW_NUM; i++)
+		req.threshold[i] = value[i];
+
+	if (set)
+		return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(BAND_CONFIG),
+					 &req, sizeof(req), true);
+
+	ret = mt76_mcu_send_and_get_msg(&phy->dev->mt76,
+					MCU_WM_UNI_CMD_QUERY(BAND_CONFIG),
+					&req, sizeof(req), true, &skb);
+
+	if (ret)
+		return ret;
+
+	res = (void *)skb->data;
+
+	for (i = 0; i < EDCCA_MAX_BW_NUM; i++)
+		value[i] = res->threshold[i];
+
+	dev_kfree_skb(skb);
+
+	return 0;
+}
+
+int mt7996_mcu_set_sr_enable(struct mt7996_phy *phy, u8 action, u64 val, bool set)
+{
+	struct {
+		u8 band_idx;
+		u8 _rsv[3];
+
+		__le16 tag;
+		__le16 len;
+
+		__le32 val;
+
+	} __packed req = {
+		.band_idx = phy->mt76->band_idx,
+
+		.tag = cpu_to_le16(action),
+		.len = cpu_to_le16(sizeof(req) - 4),
+
+		.val = cpu_to_le32((u32) val),
+	};
+
+	if (set)
+		return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(SR), &req,
+					 sizeof(req), false);
+	else
+		return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD_QUERY(SR), &req,
+					 sizeof(req), false);
+}
+
+void mt7996_mcu_rx_sr_swsd(struct mt7996_dev *dev, struct sk_buff *skb)
+{
+#define SR_SCENE_DETECTION_TIMER_PERIOD_MS 500
+	struct mt7996_mcu_sr_swsd_event *event;
+	static const char * const rules[] = {"1 - NO CONNECTED", "2 - NO CONGESTION",
+					     "3 - NO INTERFERENCE", "4 - SR ON"};
+	u8 idx;
+
+	event = (struct mt7996_mcu_sr_swsd_event *)skb->data;
+	idx = event->basic.band_idx;
+
+	dev_info(dev->mt76.dev, "Band index = %u\n", le16_to_cpu(event->basic.band_idx));
+	dev_info(dev->mt76.dev, "Hit Rule = %s\n", rules[event->tlv[idx].rule]);
+	dev_info(dev->mt76.dev, "Timer Period = %d(us)\n"
+		 "Congestion Ratio  = %d.%1d%%\n",
+		 SR_SCENE_DETECTION_TIMER_PERIOD_MS * 1000,
+		 le32_to_cpu(event->tlv[idx].total_airtime_ratio) / 10,
+		 le32_to_cpu(event->tlv[idx].total_airtime_ratio) % 10);
+	dev_info(dev->mt76.dev,
+		 "Total Airtime = %d(us)\n"
+		 "ChBusy = %d\n"
+		 "SrTx = %d\n"
+		 "OBSS = %d\n"
+		 "MyTx = %d\n"
+		 "MyRx = %d\n"
+		 "Interference Ratio = %d.%1d%%\n",
+		 le32_to_cpu(event->tlv[idx].total_airtime),
+		 le32_to_cpu(event->tlv[idx].channel_busy_time),
+		 le32_to_cpu(event->tlv[idx].sr_tx_airtime),
+		 le32_to_cpu(event->tlv[idx].obss_airtime),
+		 le32_to_cpu(event->tlv[idx].my_tx_airtime),
+		 le32_to_cpu(event->tlv[idx].my_rx_airtime),
+		 le32_to_cpu(event->tlv[idx].obss_airtime_ratio) / 10,
+		 le32_to_cpu(event->tlv[idx].obss_airtime_ratio) % 10);
+}
+
+void mt7996_mcu_rx_sr_hw_indicator(struct mt7996_dev *dev, struct sk_buff *skb)
+{
+	struct mt7996_mcu_sr_hw_ind_event *event;
+
+	event = (struct mt7996_mcu_sr_hw_ind_event *)skb->data;
+
+	dev_info(dev->mt76.dev, "Inter PPDU Count = %u\n",
+		 le16_to_cpu(event->inter_bss_ppdu_cnt));
+	dev_info(dev->mt76.dev, "SR Valid Count = %u\n",
+		 le16_to_cpu(event->non_srg_valid_cnt));
+	dev_info(dev->mt76.dev, "SR Tx Count = %u\n",
+		 le32_to_cpu(event->sr_ampdu_mpdu_cnt));
+	dev_info(dev->mt76.dev, "SR Tx Acked Count = %u\n",
+		 le32_to_cpu(event->sr_ampdu_mpdu_acked_cnt));
+}
+
+void mt7996_mcu_rx_sr_event(struct mt7996_dev *dev, struct sk_buff *skb)
+{
+	struct mt76_phy *mphy = &dev->mt76.phy;
+	struct mt7996_phy *phy;
+	struct mt7996_mcu_sr_common_event *event;
+
+	event = (struct mt7996_mcu_sr_common_event *)skb->data;
+	mphy = dev->mt76.phys[event->basic.band_idx];
+	if (!mphy)
+		return;
+
+	phy = (struct mt7996_phy *)mphy->priv;
+
+	switch (le16_to_cpu(event->basic.tag)) {
+	case UNI_EVENT_SR_CFG_SR_ENABLE:
+		phy->sr_enable = le32_to_cpu(event->value) ? true : false;
+		break;
+	case UNI_EVENT_SR_HW_ESR_ENABLE:
+		phy->enhanced_sr_enable = le32_to_cpu(event->value) ? true : false;
+		break;
+	case UNI_EVENT_SR_SW_SD:
+		mt7996_mcu_rx_sr_swsd(dev, skb);
+		break;
+	case UNI_EVENT_SR_HW_IND:
+		mt7996_mcu_rx_sr_hw_indicator(dev, skb);
+		break;
+	default:
+		dev_info(dev->mt76.dev, "Unknown SR event tag %d\n",
+			 le16_to_cpu(event->basic.tag));
+	}
+}
+
+int mt7996_mcu_set_dup_wtbl(struct mt7996_dev *dev)
+{
+#define CHIP_CONFIG_DUP_WTBL	4
+#define DUP_WTBL_NUM	80
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+		__le16 base;
+		__le16 num;
+		u8 _rsv2[4];
+	} __packed req = {
+		.tag = cpu_to_le16(CHIP_CONFIG_DUP_WTBL),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.base = cpu_to_le16(MT7996_WTBL_STA - DUP_WTBL_NUM + 1),
+		.num = cpu_to_le16(DUP_WTBL_NUM),
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(CHIP_CONFIG), &req,
+				 sizeof(req), true);
+}
+
+static struct tlv *
+__mt7996_mcu_add_uni_tlv(struct sk_buff *skb, u16 tag, u16 len)
+{
+	struct tlv *ptlv, tlv = {
+		.tag = cpu_to_le16(tag),
+		.len = cpu_to_le16(len),
+	};
+
+	ptlv = skb_put(skb, len);
+	memcpy(ptlv, &tlv, sizeof(tlv));
+
+	return ptlv;
+}
+
+int mt7996_mcu_set_txbf_internal(struct mt7996_phy *phy, u8 action, int idx, bool bfer)
+{
+	struct mt7996_dev *dev = phy->dev;
+#define MT7996_MTK_BF_MAX_SIZE	sizeof(struct bf_starec_read)
+	struct uni_header hdr;
+	struct sk_buff *skb;
+	struct tlv *tlv;
+	int len = sizeof(hdr) + MT7996_MTK_BF_MAX_SIZE;
+
+	memset(&hdr, 0, sizeof(hdr));
+
+	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL, len);
+	if (!skb)
+		return -ENOMEM;
+
+	skb_put_data(skb, &hdr, sizeof(hdr));
+
+	switch (action) {
+	case BF_PFMU_TAG_READ: {
+		struct bf_pfmu_tag *req;
+
+		tlv = __mt7996_mcu_add_uni_tlv(skb, action, sizeof(*req));
+		req = (struct bf_pfmu_tag *)tlv;
+		req->pfmu_id = idx;
+		req->bfer = bfer;
+		req->band_idx = phy->mt76->band_idx;
+		break;
+	}
+	case BF_STA_REC_READ: {
+		struct bf_starec_read *req;
+
+		tlv = __mt7996_mcu_add_uni_tlv(skb, action, sizeof(*req));
+		req = (struct bf_starec_read *)tlv;
+		req->wlan_idx = idx;
+		break;
+	}
+	case BF_FBRPT_DBG_INFO_READ: {
+		struct bf_fbk_rpt_info *req;
+
+		if (idx != 0) {
+			dev_info(dev->mt76.dev, "Invalid input");
+			return 0;
+		}
+
+		tlv = __mt7996_mcu_add_uni_tlv(skb, action, sizeof(*req));
+		req = (struct bf_fbk_rpt_info *)tlv;
+		req->action = idx;
+		req->band_idx = phy->mt76->band_idx;
+		break;
+	}
+	default:
+		return -EINVAL;
+	}
+
+	return mt76_mcu_skb_send_msg(&phy->dev->mt76, skb, MCU_WM_UNI_CMD(BF), false);
+}
+
+int mt7996_mcu_set_txbf_snd_info(struct mt7996_phy *phy, void *para)
+{
+	char *buf = (char *)para;
+	__le16 input[5] = {0};
+	u8 recv_arg = 0;
+	struct bf_txsnd_info *req;
+	struct uni_header hdr;
+	struct sk_buff *skb;
+	struct tlv *tlv;
+	int len = sizeof(hdr) + MT7996_MTK_BF_MAX_SIZE;
+
+	memset(&hdr, 0, sizeof(hdr));
+
+	skb = mt76_mcu_msg_alloc(&phy->dev->mt76, NULL, len);
+	if (!skb)
+		return -ENOMEM;
+
+	skb_put_data(skb, &hdr, sizeof(hdr));
+
+	recv_arg = sscanf(buf, "%hx:%hx:%hx:%hx:%hx", &input[0], &input[1], &input[2],
+						      &input[3], &input[4]);
+
+	if (!recv_arg)
+		return -EINVAL;
+
+	tlv = __mt7996_mcu_add_uni_tlv(skb, BF_TXSND_INFO, sizeof(*req));
+	req = (struct bf_txsnd_info *)tlv;
+	req->action = input[0];
+
+	switch (req->action) {
+	case BF_SND_READ_INFO: {
+		req->read_clr = input[1];
+		break;
+	}
+	case BF_SND_CFG_OPT: {
+		req->vht_opt = input[1];
+		req->he_opt = input[2];
+		req->glo_opt = input[3];
+		break;
+	}
+	case BF_SND_CFG_INTV: {
+		req->wlan_idx = input[1];
+		req->snd_intv = input[2];
+		break;
+	}
+	case BF_SND_STA_STOP: {
+		req->wlan_idx = input[1];
+		req->snd_stop = input[2];
+		break;
+	}
+	case BF_SND_CFG_MAX_STA: {
+		req->max_snd_stas = input[1];
+		break;
+	}
+	case BF_SND_CFG_BFRP: {
+		req->man = input[1];
+		req->tx_time = input[2];
+		req->mcs = input[3];
+		req->ldpc = input[4];
+		break;
+	}
+	case BF_SND_CFG_INF: {
+		req->inf = input[1];
+		break;
+	}
+	case BF_SND_CFG_TXOP_SND: {
+		req->man = input[1];
+		req->ac_queue = input[2];
+		req->sxn_protect = input[3];
+		req->direct_fbk = input[4];
+		break;
+	}
+	default:
+		return -EINVAL;
+	}
+
+	return mt76_mcu_skb_send_msg(&phy->dev->mt76, skb, MCU_WM_UNI_CMD(BF), false);
+}
+
+static inline void
+mt7996_ibf_phase_assign(struct mt7996_dev *dev,
+			struct mt7996_ibf_cal_info *cal,
+			struct mt7996_txbf_phase *phase)
+{
+	/* fw return ibf calibrated data with
+	 * the mt7996_txbf_phase_info_5g struct for both 2G and 5G.
+	 * (return struct mt7992_txbf_phase_info_5g for ibf 2.0)
+	 * Therefore, memcpy cannot be used here.
+	 */
+	if (get_ibf_version(dev) != IBF_VER_2) {
+		phase_assign(cal->group, v1, m_t0_h, true);
+		phase_assign(cal->group, v1, m_t1_h, true);
+		phase_assign(cal->group, v1, m_t2_h, true);
+		phase_assign(cal->group, v1, m_t2_h_sx2, false);
+		phase_assign_rx_v1(cal->group, v1, r0);
+		phase_assign_rx_v1(cal->group, v1, r1);
+		phase_assign_rx_v1(cal->group, v1, r2);
+		phase_assign_rx_v1(cal->group, v1, r3);
+		phase_assign_rx(cal->group, v1, r2_sx2, false);
+		phase_assign_rx(cal->group, v1, r3_sx2, false);
+		phase_assign(cal->group, v1, r0_reserved, false);
+		phase_assign(cal->group, v1, r1_reserved, false);
+		phase_assign(cal->group, v1, r2_reserved, false);
+		phase_assign(cal->group, v1, r3_reserved, false);
+		phase_assign(cal->group, v1, r2_sx2_reserved, false);
+		phase_assign(cal->group, v1, r3_sx2_reserved, false);
+	} else {
+		phase_assign(cal->group, v2, m_t0_h, true);
+		phase_assign(cal->group, v2, m_t1_h, true);
+		phase_assign(cal->group, v2, m_t2_h, true);
+		if (cal->group) {
+			phase->v2.phase_5g.m_t3_h = cal->v2.phase_5g.m_t3_h;
+			dev_info(dev->mt76.dev, "m_t3_h = %d\n", phase->v2.phase_5g.m_t3_h);
+		}
+		phase_assign_rx_ext(cal->group, v2, r0, true);
+		phase_assign_rx_ext(cal->group, v2, r1, true);
+		phase_assign_rx_ext(cal->group, v2, r2, true);
+		phase_assign_rx_ext(cal->group, v2, r3, true);
+		if (cal->group) {
+			memcpy(&phase->v2.phase_5g.r4, &cal->v2.phase_5g.r4,
+			       sizeof(struct txbf_rx_phase_ext));
+			dev_info(dev->mt76.dev, "r4.rx_uh = %d\n", phase->v2.phase_5g.r4.rx_uh);
+			dev_info(dev->mt76.dev, "r4.rx_h = %d\n", phase->v2.phase_5g.r4.rx_h);
+			dev_info(dev->mt76.dev, "r4.rx_mh = %d\n", phase->v2.phase_5g.r4.rx_mh);
+			dev_info(dev->mt76.dev, "r4.rx_m = %d\n", phase->v2.phase_5g.r4.rx_m);
+			dev_info(dev->mt76.dev, "r4.rx_l = %d\n", phase->v2.phase_5g.r4.rx_l);
+			dev_info(dev->mt76.dev, "r4.rx_ul = %d\n", phase->v2.phase_5g.r4.rx_ul);
+		}
+	}
+}
+
+void
+mt7996_mcu_rx_bf_event(struct mt7996_dev *dev, struct sk_buff *skb)
+{
+	struct mt7996_mcu_bf_basic_event *event;
+
+	event = (struct mt7996_mcu_bf_basic_event *)skb->data;
+
+	dev_info(dev->mt76.dev, " bf_event tag = %d\n", event->tag);
+
+	switch (event->tag) {
+	case UNI_EVENT_BF_PFMU_TAG: {
+
+		struct mt7996_pfmu_tag_event *tag;
+		u32 *raw_t1, *raw_t2;
+
+		tag = (struct mt7996_pfmu_tag_event *) skb->data;
+
+		raw_t1 = (u32 *)&tag->t1;
+		raw_t2 = (u32 *)&tag->t2;
+
+		dev_info(dev->mt76.dev, "=================== TXBf Profile Tag1 Info ==================\n");
+		dev_info(dev->mt76.dev,
+			 "DW0 = 0x%08x, DW1 = 0x%08x, DW2 = 0x%08x\n",
+			 raw_t1[0], raw_t1[1], raw_t1[2]);
+		dev_info(dev->mt76.dev,
+			 "DW4 = 0x%08x, DW5 = 0x%08x, DW6 = 0x%08x\n\n",
+			 raw_t1[3], raw_t1[4], raw_t1[5]);
+		dev_info(dev->mt76.dev, "PFMU ID = %d              Invalid status = %d\n",
+			 tag->t1.pfmu_idx, tag->t1.invalid_prof);
+		dev_info(dev->mt76.dev, "iBf/eBf = %d\n\n", tag->t1.ebf);
+		dev_info(dev->mt76.dev, "DBW   = %d\n", tag->t1.data_bw);
+		dev_info(dev->mt76.dev, "SU/MU = %d\n", tag->t1.is_mu);
+		dev_info(dev->mt76.dev,
+			 "nrow = %d, ncol = %d, ng = %d, LM = %d, CodeBook = %d MobCalEn = %d\n",
+			 tag->t1.nr, tag->t1.nc, tag->t1.ngroup, tag->t1.lm, tag->t1.codebook,
+			 tag->t1.mob_cal_en);
+
+		if (tag->t1.lm <= BF_LM_HE)
+			dev_info(dev->mt76.dev, "RU start = %d, RU end = %d\n",
+				 tag->t1.field.ru_start_id, tag->t1.field.ru_end_id);
+		else
+			dev_info(dev->mt76.dev, "PartialBW = %d\n",
+				 tag->t1.bw_info.partial_bw_info);
+
+		dev_info(dev->mt76.dev, "Mem Col1 = %d, Mem Row1 = %d, Mem Col2 = %d, Mem Row2 = %d\n",
+			 tag->t1.col_id1, tag->t1.row_id1, tag->t1.col_id2, tag->t1.row_id2);
+		dev_info(dev->mt76.dev, "Mem Col3 = %d, Mem Row3 = %d, Mem Col4 = %d, Mem Row4 = %d\n\n",
+			 tag->t1.col_id3, tag->t1.row_id3, tag->t1.col_id4, tag->t1.row_id4);
+		dev_info(dev->mt76.dev,
+			 "STS0_SNR = 0x%02x, STS1_SNR = 0x%02x, STS2_SNR = 0x%02x, STS3_SNR = 0x%02x\n",
+			 tag->t1.snr_sts0, tag->t1.snr_sts1, tag->t1.snr_sts2, tag->t1.snr_sts3);
+		dev_info(dev->mt76.dev,
+			 "STS4_SNR = 0x%02x, STS5_SNR = 0x%02x, STS6_SNR = 0x%02x, STS7_SNR = 0x%02x\n",
+			 tag->t1.snr_sts4, tag->t1.snr_sts5, tag->t1.snr_sts6, tag->t1.snr_sts7);
+		dev_info(dev->mt76.dev, "=============================================================\n");
+
+		dev_info(dev->mt76.dev, "=================== TXBf Profile Tag2 Info ==================\n");
+		dev_info(dev->mt76.dev,
+			 "DW0 = 0x%08x, DW1 = 0x%08x, DW2 = 0x%08x\n",
+			 raw_t2[0], raw_t2[1], raw_t2[2]);
+		dev_info(dev->mt76.dev,
+			 "DW3 = 0x%08x, DW4 = 0x%08x, DW5 = 0x%08x\n\n",
+			 raw_t2[3], raw_t2[4], raw_t2[5]);
+		dev_info(dev->mt76.dev, "Smart antenna ID = 0x%x,  SE index = %d\n",
+			 tag->t2.smart_ant, tag->t2.se_idx);
+		dev_info(dev->mt76.dev, "Timeout = 0x%x\n", tag->t2.ibf_timeout);
+		dev_info(dev->mt76.dev, "Desired BW = %d, Desired Ncol = %d, Desired Nrow = %d\n",
+			 tag->t2.ibf_data_bw, tag->t2.ibf_nc, tag->t2.ibf_nr);
+		dev_info(dev->mt76.dev, "Desired RU Allocation = %d\n", tag->t2.ibf_ru);
+		dev_info(dev->mt76.dev, "Mobility DeltaT = %d, Mobility LQ = %d\n",
+			 tag->t2.mob_delta_t, tag->t2.mob_lq_result);
+		dev_info(dev->mt76.dev, "=============================================================\n");
+		break;
+	}
+	case UNI_EVENT_BF_STAREC: {
+
+		struct mt7996_mcu_bf_starec_read *r;
+
+		r = (struct mt7996_mcu_bf_starec_read *)skb->data;
+		dev_info(dev->mt76.dev, "=================== BF StaRec ===================\n"
+					"rStaRecBf.u2PfmuId      = %d\n"
+					"rStaRecBf.fgSU_MU       = %d\n"
+					"rStaRecBf.u1TxBfCap     = %d\n"
+					"rStaRecBf.ucSoundingPhy = %d\n"
+					"rStaRecBf.ucNdpaRate    = %d\n"
+					"rStaRecBf.ucNdpRate     = %d\n"
+					"rStaRecBf.ucReptPollRate= %d\n"
+					"rStaRecBf.ucTxMode      = %d\n"
+					"rStaRecBf.ucNc          = %d\n"
+					"rStaRecBf.ucNr          = %d\n"
+					"rStaRecBf.ucCBW         = %d\n"
+					"rStaRecBf.ucMemRequire20M = %d\n"
+					"rStaRecBf.ucMemRow0     = %d\n"
+					"rStaRecBf.ucMemCol0     = %d\n"
+					"rStaRecBf.ucMemRow1     = %d\n"
+					"rStaRecBf.ucMemCol1     = %d\n"
+					"rStaRecBf.ucMemRow2     = %d\n"
+					"rStaRecBf.ucMemCol2     = %d\n"
+					"rStaRecBf.ucMemRow3     = %d\n"
+					"rStaRecBf.ucMemCol3     = %d\n",
+					r->pfmu_id,
+					r->is_su_mu,
+					r->txbf_cap,
+					r->sounding_phy,
+					r->ndpa_rate,
+					r->ndp_rate,
+					r->rpt_poll_rate,
+					r->tx_mode,
+					r->nc,
+					r->nr,
+					r->bw,
+					r->mem_require_20m,
+					r->mem_row0,
+					r->mem_col0,
+					r->mem_row1,
+					r->mem_col1,
+					r->mem_row2,
+					r->mem_col2,
+					r->mem_row3,
+					r->mem_col3);
+
+		dev_info(dev->mt76.dev, "rStaRecBf.u2SmartAnt    = 0x%x\n"
+					"rStaRecBf.ucSEIdx       = %d\n"
+					"rStaRecBf.uciBfTimeOut  = 0x%x\n"
+					"rStaRecBf.uciBfDBW      = %d\n"
+					"rStaRecBf.uciBfNcol     = %d\n"
+					"rStaRecBf.uciBfNrow     = %d\n"
+					"rStaRecBf.nr_bw160      = %d\n"
+					"rStaRecBf.nc_bw160 	  = %d\n"
+					"rStaRecBf.ru_start_idx  = %d\n"
+					"rStaRecBf.ru_end_idx 	  = %d\n"
+					"rStaRecBf.trigger_su 	  = %d\n"
+					"rStaRecBf.trigger_mu 	  = %d\n"
+					"rStaRecBf.ng16_su 	  = %d\n"
+					"rStaRecBf.ng16_mu 	  = %d\n"
+					"rStaRecBf.codebook42_su = %d\n"
+					"rStaRecBf.codebook75_mu = %d\n"
+					"rStaRecBf.he_ltf 	      = %d\n"
+					"======================================\n",
+					r->smart_ant,
+					r->se_idx,
+					r->bf_timeout,
+					r->bf_dbw,
+					r->bf_ncol,
+					r->bf_nrow,
+					r->nr_lt_bw80,
+					r->nc_lt_bw80,
+					r->ru_start_idx,
+					r->ru_end_idx,
+					r->trigger_su,
+					r->trigger_mu,
+					r->ng16_su,
+					r->ng16_mu,
+					r->codebook42_su,
+					r->codebook75_mu,
+					r->he_ltf);
+		break;
+	}
+	case UNI_EVENT_BF_FBK_INFO: {
+		struct mt7996_mcu_txbf_fbk_info *info;
+		__le32 total, i;
+
+		info = (struct mt7996_mcu_txbf_fbk_info *)skb->data;
+
+		total = info->u4PFMUWRDoneCnt + info->u4PFMUWRFailCnt;
+		total += info->u4PFMUWRTimeoutFreeCnt + info->u4FbRptPktDropCnt;
+
+		dev_info(dev->mt76.dev, "\n");
+		dev_info(dev->mt76.dev, "\x1b[32m =================================\x1b[m\n");
+		dev_info(dev->mt76.dev, "\x1b[32m PFMUWRDoneCnt              = %u\x1b[m\n",
+			info->u4PFMUWRDoneCnt);
+		dev_info(dev->mt76.dev, "\x1b[32m PFMUWRFailCnt              = %u\x1b[m\n",
+			info->u4PFMUWRFailCnt);
+		dev_info(dev->mt76.dev, "\x1b[32m PFMUWRTimeOutCnt           = %u\x1b[m\n",
+			info->u4PFMUWRTimeOutCnt);
+		dev_info(dev->mt76.dev, "\x1b[32m PFMUWRTimeoutFreeCnt       = %u\x1b[m\n",
+			info->u4PFMUWRTimeoutFreeCnt);
+		dev_info(dev->mt76.dev, "\x1b[32m FbRptPktDropCnt            = %u\x1b[m\n",
+			info->u4FbRptPktDropCnt);
+		dev_info(dev->mt76.dev, "\x1b[32m TotalFbRptPkt              = %u\x1b[m\n", total);
+		dev_info(dev->mt76.dev, "\x1b[32m PollPFMUIntrStatTimeOut    = %u(micro-sec)\x1b[m\n",
+			info->u4PollPFMUIntrStatTimeOut);
+		dev_info(dev->mt76.dev, "\x1b[32m FbRptDeQInterval           = %u(milli-sec)\x1b[m\n",
+			info->u4DeQInterval);
+		dev_info(dev->mt76.dev, "\x1b[32m PktCntInFbRptTimeOutQ      = %u\x1b[m\n",
+			info->u4RptPktTimeOutListNum);
+		dev_info(dev->mt76.dev, "\x1b[32m PktCntInFbRptQ             = %u\x1b[m\n",
+			info->u4RptPktListNum);
+
+		// [ToDo] Check if it is valid entry
+		for (i = 0; ((i < 5) && (i < CFG_BF_STA_REC_NUM)); i++) {
+
+			// [ToDo] AID needs to be refined
+			dev_info(dev->mt76.dev,"\x1b[32m AID%u  RxFbRptCnt           = %u\x1b[m\n"
+				, i, info->au4RxPerStaFbRptCnt[i]);
+		}
+
+		break;
+	}
+	case UNI_EVENT_BF_TXSND_INFO: {
+		struct mt7996_mcu_tx_snd_info *info;
+		struct uni_event_bf_txsnd_sta_info *snd_sta_info;
+		int Idx;
+		int max_wtbl_size = mt7996_wtbl_size(dev);
+
+		info = (struct mt7996_mcu_tx_snd_info *)skb->data;
+		dev_info(dev->mt76.dev, "=================== Global Setting ===================\n");
+
+		dev_info(dev->mt76.dev, "VhtOpt = 0x%02X, HeOpt = 0x%02X, GloOpt = 0x%02X\n",
+			info->vht_opt, info->he_opt, info->glo_opt);
+
+		for (Idx = 0; Idx < BF_SND_CTRL_STA_DWORD_CNT; Idx++) {
+			dev_info(dev->mt76.dev, "SuSta[%d] = 0x%08X,", Idx,
+				 info->snd_rec_su_sta[Idx]);
+			if ((Idx & 0x03) == 0x03)
+				dev_info(dev->mt76.dev, "\n");
+		}
+
+		if ((Idx & 0x03) != 0x03)
+			dev_info(dev->mt76.dev, "\n");
+
+
+		for (Idx = 0; Idx < BF_SND_CTRL_STA_DWORD_CNT; Idx++) {
+			dev_info(dev->mt76.dev, "VhtMuSta[%d] = 0x%08X,", Idx, info->snd_rec_vht_mu_sta[Idx]);
+			if ((Idx & 0x03) == 0x03)
+				dev_info(dev->mt76.dev, "\n");
+		}
+
+		if ((Idx & 0x03) != 0x03)
+			dev_info(dev->mt76.dev, "\n");
+
+		for (Idx = 0; Idx < BF_SND_CTRL_STA_DWORD_CNT; Idx++) {
+			dev_info(dev->mt76.dev, "HeTBSta[%d] = 0x%08X,", Idx, info->snd_rec_he_tb_sta[Idx]);
+			if ((Idx & 0x03) == 0x03)
+				dev_info(dev->mt76.dev, "\n");
+		}
+
+		if ((Idx & 0x03) != 0x03)
+			dev_info(dev->mt76.dev, "\n");
+
+		for (Idx = 0; Idx < BF_SND_CTRL_STA_DWORD_CNT; Idx++) {
+			dev_info(dev->mt76.dev, "EhtTBSta[%d] = 0x%08X,", Idx, info->snd_rec_eht_tb_sta[Idx]);
+			if ((Idx & 0x03) == 0x03)
+				dev_info(dev->mt76.dev, "\n");
+		}
+
+		if ((Idx & 0x03) != 0x03)
+			dev_info(dev->mt76.dev, "\n");
+
+		for (Idx = 0; Idx < CFG_WIFI_RAM_BAND_NUM; Idx++) {
+			dev_info(dev->mt76.dev, "Band%u:\n", Idx);
+			dev_info(dev->mt76.dev, "	 Wlan Idx For VHT MC Sounding = %u\n", info->wlan_idx_for_mc_snd[Idx]);
+			dev_info(dev->mt76.dev, "	 Wlan Idx For HE TB Sounding = %u\n", info->wlan_idx_for_he_tb_snd[Idx]);
+			dev_info(dev->mt76.dev, "	 Wlan Idx For EHT TB Sounding = %u\n", info->wlan_idx_for_eht_tb_snd[Idx]);
+		}
+
+		dev_info(dev->mt76.dev, "ULLen = %d, ULMcs = %d, ULLDCP = %d\n",
+			info->ul_length, info->mcs, info->ldpc);
+
+		dev_info(dev->mt76.dev, "=================== STA Info ===================\n");
+
+		for (Idx = 1; (Idx < 5 && (Idx < CFG_BF_STA_REC_NUM)); Idx++) {
+			snd_sta_info = &info->snd_sta_info[Idx];
+			dev_info(dev->mt76.dev, "Idx%2u Interval = %d, interval counter = %d, TxCnt = %d, StopReason = 0x%02X\n",
+				Idx,
+				snd_sta_info->snd_intv,
+				snd_sta_info->snd_intv_cnt,
+				snd_sta_info->snd_tx_cnt,
+				snd_sta_info->snd_stop_reason);
+		}
+
+		dev_info(dev->mt76.dev, "=================== STA Info Connected ===================\n");
+		// [ToDo] How to iterate and get AID info of station
+		// Check UniEventBFCtrlTxSndHandle() on Logan
+
+		//hardcode max_wtbl_size as 5
+		max_wtbl_size = 5;
+		for (Idx = 1; ((Idx < max_wtbl_size) && (Idx < CFG_BF_STA_REC_NUM)); Idx++) {
+
+			// [ToDo] We do not show AID info here
+			snd_sta_info = &info->snd_sta_info[Idx];
+			dev_info(dev->mt76.dev, " Interval = %d (%u ms), interval counter = %d (%u ms), TxCnt = %d, StopReason = 0x%02X\n",
+				snd_sta_info->snd_intv,
+				snd_sta_info->snd_intv * 10,
+				snd_sta_info->snd_intv_cnt,
+				snd_sta_info->snd_intv_cnt * 10,
+				snd_sta_info->snd_tx_cnt,
+				snd_sta_info->snd_stop_reason);
+		}
+
+		dev_info(dev->mt76.dev, "======================================\n");
+
+		break;
+	}
+	case UNI_EVENT_BF_CAL_PHASE: {
+		struct mt7996_ibf_cal_info *cal;
+		struct mt7996_txbf_phase *phase;
+		union {
+			struct mt7996_txbf_phase_out v1;
+			struct mt7992_txbf_phase_out v2;
+		} phase_out;
+		int phase_out_size = sizeof(struct mt7996_txbf_phase_out);
+
+		cal = (struct mt7996_ibf_cal_info *)skb->data;
+		phase = (struct mt7996_txbf_phase *)dev->test.txbf_phase_cal;
+		if (get_ibf_version(dev) == IBF_VER_2)
+			phase_out_size = sizeof(struct mt7992_txbf_phase_out);
+		memcpy(&phase_out, &cal->buf, phase_out_size);
+		switch (cal->cal_type) {
+		case IBF_PHASE_CAL_NORMAL:
+		case IBF_PHASE_CAL_NORMAL_INSTRUMENT:
+			/* Only calibrate group M */
+			if (cal->group_l_m_n != GROUP_M)
+				break;
+			phase = &phase[cal->group];
+			phase->status = cal->status;
+			dev_info(dev->mt76.dev, "Calibrated result = %d\n", phase->status);
+			dev_info(dev->mt76.dev, "Group %d and Group M\n", cal->group);
+			mt7996_ibf_phase_assign(dev, cal, phase);
+			break;
+		case IBF_PHASE_CAL_VERIFY:
+		case IBF_PHASE_CAL_VERIFY_INSTRUMENT:
+			dev_info(dev->mt76.dev, "Verification result = %d\n", cal->status);
+			break;
+		default:
+			break;
+		}
+
+		if (get_ibf_version(dev) == IBF_VER_2) {
+			dev_info(dev->mt76.dev,
+				 "c0_uh = %d, c1_uh = %d, c2_uh = %d, c3_uh = %d c4_uh = %d\n",
+				 phase_out.v2.c0_uh, phase_out.v2.c1_uh, phase_out.v2.c2_uh,
+				 phase_out.v2.c3_uh, phase_out.v2.c4_uh);
+			dev_info(dev->mt76.dev,
+				 "c0_h = %d, c1_h = %d, c2_h = %d, c3_h = %d c4_h = %d\n",
+				 phase_out.v2.c0_h, phase_out.v2.c1_h, phase_out.v2.c2_h,
+				 phase_out.v2.c3_h, phase_out.v2.c4_h);
+			dev_info(dev->mt76.dev,
+				 "c0_mh = %d, c1_mh = %d, c2_mh = %d, c3_mh = %d c4_mh = %d\n",
+				 phase_out.v2.c0_mh, phase_out.v2.c1_mh, phase_out.v2.c2_mh,
+				 phase_out.v2.c3_mh, phase_out.v2.c4_mh);
+			dev_info(dev->mt76.dev,
+				 "c0_m = %d, c1_m = %d, c2_m = %d, c3_m = %d c4_m = %d\n",
+				 phase_out.v2.c0_m, phase_out.v2.c1_m, phase_out.v2.c2_m,
+				 phase_out.v2.c3_m, phase_out.v2.c4_m);
+			dev_info(dev->mt76.dev,
+				 "c0_l = %d, c1_l = %d, c2_l = %d, c3_l = %d c4_l = %d\n",
+				 phase_out.v2.c0_l, phase_out.v2.c1_l, phase_out.v2.c2_l,
+				 phase_out.v2.c3_l, phase_out.v2.c4_l);
+		} else {
+			dev_info(dev->mt76.dev,
+				 "c0_uh = %d, c1_uh = %d, c2_uh = %d, c3_uh = %d\n",
+				 phase_out.v1.c0_uh, phase_out.v1.c1_uh,
+				 phase_out.v1.c2_uh, phase_out.v1.c3_uh);
+			dev_info(dev->mt76.dev,
+				 "c0_h = %d, c1_h = %d, c2_h = %d, c3_h = %d\n",
+				 phase_out.v1.c0_h, phase_out.v1.c1_h,
+				 phase_out.v1.c2_h, phase_out.v1.c3_h);
+			dev_info(dev->mt76.dev,
+				 "c0_mh = %d, c1_mh = %d, c2_mh = %d, c3_mh = %d\n",
+				 phase_out.v1.c0_mh, phase_out.v1.c1_mh,
+				 phase_out.v1.c2_mh, phase_out.v1.c3_mh);
+			dev_info(dev->mt76.dev,
+				 "c0_m = %d, c1_m = %d, c2_m = %d, c3_m = %d\n",
+				 phase_out.v1.c0_m, phase_out.v1.c1_m,
+				 phase_out.v1.c2_m, phase_out.v1.c3_m);
+			dev_info(dev->mt76.dev,
+				 "c0_l = %d, c1_l = %d, c2_l = %d, c3_l = %d\n",
+				 phase_out.v1.c0_l, phase_out.v1.c1_l,
+				 phase_out.v1.c2_l, phase_out.v1.c3_l);
+		}
+
+		break;
+	}
+	default:
+		dev_info(dev->mt76.dev, "%s: unknown bf event tag %d\n",
+			 __func__, event->tag);
+	}
+
+}
+
+
+int mt7996_mcu_set_muru_fixed_rate_enable(struct mt7996_dev *dev, u8 action, int val)
+{
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+
+		__le16 value;
+		__le16 rsv;
+	} __packed data = {
+		.tag = cpu_to_le16(action),
+		.len = cpu_to_le16(sizeof(data) - 4),
+		.value = cpu_to_le16(!!val),
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MURU), &data, sizeof(data),
+				 false);
+}
+
+int mt7996_mcu_set_muru_fixed_rate_parameter(struct mt7996_dev *dev, u8 action, void *para)
+{
+	char *buf = (char *)para;
+	u8 num_user = 0, recv_arg = 0, max_mcs = 0, usr_mcs[4] = {0};
+	__le16 bw;
+	int i;
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+
+		u8 cmd_version;
+		u8 cmd_revision;
+		__le16 rsv;
+
+		struct uni_muru_mum_set_group_tbl_entry entry;
+	} __packed data = {
+		.tag = cpu_to_le16(action),
+		.len = cpu_to_le16(sizeof(data) - 4),
+	};
+
+#define __RUALLOC_TYPE_CHECK_HE(BW) ((BW == RUALLOC_BW20) || (BW == RUALLOC_BW40) || (BW == RUALLOC_BW80) || (BW == RUALLOC_BW160))
+#define __RUALLOC_TYPE_CHECK_EHT(BW) (__RUALLOC_TYPE_CHECK_HE(BW) || (BW == RUALLOC_BW320))
+	/* [Num of user] - 1~4
+	 * [RUAlloc] - BW320: 395, BW160: 137, BW80: 134, BW40: 130, BW20: 122
+	 * [LTF/GI] - For VHT, short GI: 0, Long GI: 1; 	 *
+	 * For HE/EHT, 4xLTF+3.2us: 0, 4xLTF+0.8us: 1, 2xLTF+0.8us:2
+	 * [Phy/FullBW] - VHT: 0 / HEFullBw: 1 / HEPartialBw: 2 / EHTFullBW: 3, EHTPartialBW: 4
+	 * [DL/UL] DL: 0, UL: 1, DL_UL: 2
+	 * [Wcid User0] - WCID 0
+	 * [MCS of WCID0] - For HE/VHT, 0-11: 1ss MCS0-MCS11, 12-23: 2SS MCS0-MCS11
+	 * For EHT, 0-13: 1ss MCS0-MCS13, 14-27: 2SS MCS0-MCS13
+	 * [WCID 1]
+	 * [MCS of WCID1]
+	 * [WCID 2]
+	 * [MCS of WCID2]
+	 * [WCID 3]
+	 * [MCS of WCID3]
+	 */
+
+	recv_arg = sscanf(buf, "%hhu %hu %hhu %hhu %hhu %hu %hhu %hu %hhu %hu %hhu %hu %hhu",
+			  &num_user, &bw, &data.entry.gi, &data.entry.capa, &data.entry.dl_ul,
+			  &data.entry.wlan_idx0, &usr_mcs[0],
+			  &data.entry.wlan_idx1, &usr_mcs[1],
+			  &data.entry.wlan_idx2, &usr_mcs[2],
+			  &data.entry.wlan_idx3, &usr_mcs[3]);
+
+	if (recv_arg != (5 + (2 * num_user))) {
+		dev_err(dev->mt76.dev, "The number of argument is invalid\n");
+		goto error;
+	}
+
+	if (num_user > 0 && num_user < 5)
+		data.entry.num_user = num_user - 1;
+	else {
+		dev_err(dev->mt76.dev, "The number of user count is invalid\n");
+		goto error;
+	}
+
+	/**
+	 * Older chip shall be set as HE. Refer to getHWSupportByChip() in Logan
+	 * driver to know the value for differnt chips
+	 */
+	data.cmd_version = UNI_CMD_MURU_VER_EHT;
+
+	if (data.cmd_version == UNI_CMD_MURU_VER_EHT)
+		max_mcs = UNI_MAX_MCS_SUPPORT_EHT;
+	else
+		max_mcs = UNI_MAX_MCS_SUPPORT_HE;
+
+
+	// Parameter Check
+	if (data.cmd_version != UNI_CMD_MURU_VER_EHT) {
+		if ((data.entry.capa > MAX_MODBF_HE) || (bw == RUALLOC_BW320))
+			goto error;
+	} else {
+		if ((data.entry.capa <= MAX_MODBF_HE) && (bw == RUALLOC_BW320))
+			goto error;
+	}
+
+	if (data.entry.capa <= MAX_MODBF_HE)
+		max_mcs = UNI_MAX_MCS_SUPPORT_HE;
+
+	if (__RUALLOC_TYPE_CHECK_EHT(bw)) {
+		data.entry.ru_alloc = (u8)(bw & 0xFF);
+		if (bw == RUALLOC_BW320)
+			data.entry.ru_alloc_ext = (u8)(bw >> 8);
+	} else {
+		dev_err(dev->mt76.dev, "RU_ALLOC argument is invalid\n");
+		goto error;
+	}
+
+	if ((data.entry.gi > 2) ||
+	    ((data.entry.gi > 1) && (data.entry.capa == MAX_MODBF_VHT))) {
+		dev_err(dev->mt76.dev, "GI argument is invalid\n");
+		goto error;
+	}
+
+	if (data.entry.dl_ul > 2) {
+		dev_err(dev->mt76.dev, "DL_UL argument is invalid\n");
+		goto error;
+	}
+
+#define __mcs_handler(_n)							\
+	do {									\
+		if (usr_mcs[_n] > max_mcs) {					\
+			usr_mcs[_n] -= (max_mcs + 1);				\
+			data.entry.nss##_n = 1;					\
+			if (usr_mcs[_n] > max_mcs)				\
+				usr_mcs[_n] = max_mcs;				\
+		}								\
+		if ((data.entry.dl_ul & 0x1) == 0)				\
+			data.entry.dl_mcs_user##_n = usr_mcs[_n];		\
+		if ((data.entry.dl_ul & 0x3) > 0)				\
+			data.entry.ul_mcs_user##_n = usr_mcs[_n];		\
+	}									\
+	while (0)
+
+	for (i=0; i<= data.entry.num_user; i++) {
+		switch (i) {
+			case 0:
+				__mcs_handler(0);
+				break;
+			case 1:
+				__mcs_handler(1);
+				break;
+			case 2:
+				__mcs_handler(2);
+				break;
+			case 3:
+				__mcs_handler(3);
+				break;
+			default:
+				break;
+		}
+	}
+#undef __mcs_handler
+
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MURU), &data,
+				 sizeof(data), false);
+
+error:
+	dev_err(dev->mt76.dev, "Command failed!\n");
+	return -EINVAL;
+}
+
+/**
+ * This function can be used to build the following commands
+ * MURU_SUTX_CTRL (0x10)
+ * SET_FORCE_MU (0x33)
+ * SET_MUDL_ACK_POLICY (0xC8)
+ * SET_TRIG_TYPE (0xC9)
+ * SET_20M_DYN_ALGO (0xCA)
+ * SET_CERT_MU_EDCA_OVERRIDE (0xCD)
+ */
+int mt7996_mcu_set_muru_cmd(struct mt7996_dev *dev, u16 action, int val)
+{
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+
+		u8 config;
+		u8 rsv[3];
+	} __packed data = {
+		.tag = cpu_to_le16(action),
+		.len = cpu_to_le16(sizeof(data) - 4),
+		.config = (u8) val,
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MURU), &data, sizeof(data),
+				 false);
+}
+
+int mt7996_mcu_muru_set_prot_frame_thr(struct mt7996_dev *dev, u32 val)
+{
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+
+		__le32 prot_frame_thr;
+	} __packed data = {
+		.tag = cpu_to_le16(UNI_CMD_MURU_PROT_FRAME_THR),
+		.len = cpu_to_le16(sizeof(data) - 4),
+		.prot_frame_thr = cpu_to_le32(val),
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MURU), &data, sizeof(data),
+				 false);
+}
+
+int mt7996_mcu_set_bypass_smthint(struct mt7996_phy *phy, u8 val)
+{
+#define BF_PHY_SMTH_INT_BYPASS 0
+#define BYPASS_VAL 1
+	struct mt7996_dev *dev = phy->dev;
+	struct {
+		u8 _rsv[4];
+
+		u16 tag;
+		u16 len;
+
+		u8 action;
+		u8 band_idx;
+		u8 smthintbypass;
+		u8 __rsv2[5];
+	} __packed data = {
+		.tag = cpu_to_le16(BF_CFG_PHY),
+		.len = cpu_to_le16(sizeof(data) - 4),
+		.action = BF_PHY_SMTH_INT_BYPASS,
+		.band_idx = phy->mt76->band_idx,
+		.smthintbypass = val,
+	};
+
+	if (val != BYPASS_VAL)
+		return -EINVAL;
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &data, sizeof(data),
+				 true);
+}
+
+int mt7996_mcu_set_bsrp_ctrl(struct mt7996_phy *phy, u16 interval,
+			     u16 ru_alloc, u32 trig_type, u8 trig_flow, u8 ext_cmd)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+
+		__le16 interval;
+		__le16 ru_alloc;
+		__le32 trigger_type;
+		u8 trigger_flow;
+		u8 ext_cmd_bsrp;
+		u8 band_bitmap;
+		u8 _rsv2;
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_CMD_MURU_BSRP_CTRL),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.interval = cpu_to_le16(interval),
+		.ru_alloc = cpu_to_le16(ru_alloc),
+		.trigger_type = cpu_to_le32(trig_type),
+		.trigger_flow = trig_flow,
+		.ext_cmd_bsrp = ext_cmd,
+		.band_bitmap = mt7996_band_valid(dev, MT_BAND2) ?
+			       GENMASK(2, 0) : GENMASK(1, 0),
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MURU), &req,
+				 sizeof(req), false);
+}
+
+int mt7996_mcu_set_rfeature_trig_type(struct mt7996_phy *phy, u8 enable, u8 trig_type)
+{
+	struct mt7996_dev *dev = phy->dev;
+	int ret = 0;
+	char buf[] = "01:00:00:1B";
+
+	if (enable) {
+		ret = mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SET_TRIG_TYPE, trig_type);
+		if (ret)
+			return ret;
+	}
+
+	switch (trig_type) {
+	case CAPI_BASIC:
+		return mt7996_mcu_set_bsrp_ctrl(phy, 5, 67, 0, 0, enable);
+	case CAPI_BRP:
+		return mt7996_mcu_set_txbf_snd_info(phy, buf);
+	case CAPI_MU_BAR:
+		return mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SET_MUDL_ACK_POLICY,
+					       MU_DL_ACK_POLICY_MU_BAR);
+	case CAPI_BSRP:
+		return mt7996_mcu_set_bsrp_ctrl(phy, 5, 67, 4, 0, enable);
+	default:
+		return 0;
+	}
+}
+
+int mt7996_mcu_set_muru_cfg(struct mt7996_phy *phy, void *data)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_muru *muru;
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+
+		u8 version;
+		u8 revision;
+		u8 _rsv2[2];
+
+		struct mt7996_muru muru;
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_CMD_MURU_MUNUAL_CONFIG),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.version = UNI_CMD_MURU_VER_EHT,
+	};
+
+	muru = (struct mt7996_muru *) data;
+	memcpy(&req.muru, muru, sizeof(struct mt7996_muru));
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MURU), &req,
+				 sizeof(req), false);
+}
+
+int mt7996_set_muru_cfg(struct mt7996_phy *phy, u8 action, u8 val)
+{
+	struct mt7996_muru *muru;
+	struct mt7996_muru_dl *dl;
+	struct mt7996_muru_ul *ul;
+	struct mt7996_muru_comm *comm;
+	int ret = 0;
+
+	muru = kzalloc(sizeof(struct mt7996_muru), GFP_KERNEL);
+	dl = &muru->dl;
+	ul = &muru->ul;
+	comm = &muru->comm;
+
+	switch (action) {
+	case MU_CTRL_DL_USER_CNT:
+		dl->user_num = val;
+		comm->ppdu_format = MURU_PPDU_HE_MU;
+		comm->sch_type = MURU_OFDMA_SCH_TYPE_DL;
+		muru->cfg_comm = cpu_to_le32(MURU_COMM_SET);
+		muru->cfg_dl = cpu_to_le32(MURU_FIXED_DL_TOTAL_USER_CNT);
+		ret = mt7996_mcu_set_muru_cfg(phy, muru);
+		break;
+	case MU_CTRL_UL_USER_CNT:
+		ul->user_num = val;
+		comm->ppdu_format = MURU_PPDU_HE_TRIG;
+		comm->sch_type = MURU_OFDMA_SCH_TYPE_UL;
+		muru->cfg_comm = cpu_to_le32(MURU_COMM_SET);
+		muru->cfg_ul = cpu_to_le32(MURU_FIXED_UL_TOTAL_USER_CNT);
+		ret = mt7996_mcu_set_muru_cfg(phy, muru);
+		break;
+	default:
+		break;
+	}
+
+	kfree(muru);
+	return ret;
+}
+
+void mt7996_mcu_set_ppdu_tx_type(struct mt7996_phy *phy, u8 ppdu_type)
+{
+	struct mt7996_dev *dev = phy->dev;
+	int enable_su;
+
+	switch (ppdu_type) {
+	case CAPI_SU:
+		enable_su = 1;
+		mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SUTX_CTRL, enable_su);
+		mt7996_set_muru_cfg(phy, MU_CTRL_DL_USER_CNT, 0);
+		break;
+	case CAPI_MU:
+		enable_su = 0;
+		mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SUTX_CTRL, enable_su);
+		break;
+	default:
+		break;
+	}
+}
+
+void mt7996_mcu_set_nusers_ofdma(struct mt7996_phy *phy, u8 type, u8 user_cnt)
+{
+	struct mt7996_dev *dev = phy->dev;
+	int enable_su = 0;
+
+	mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SUTX_CTRL, enable_su);
+	mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SET_MUDL_ACK_POLICY, MU_DL_ACK_POLICY_SU_BAR);
+	mt7996_mcu_muru_set_prot_frame_thr(dev, 9999);
+
+	mt7996_set_muru_cfg(phy, type, user_cnt);
+}
+
+void mt7996_mcu_set_mimo(struct mt7996_phy *phy)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct cfg80211_chan_def *chandef = &phy->mt76->chandef;
+	int disable_ra = 1;
+	char buf[] = "2 134 0 1 0 1 2 2 2";
+	int force_mu = 1;
+
+	switch (chandef->width) {
+	case NL80211_CHAN_WIDTH_20_NOHT:
+	case NL80211_CHAN_WIDTH_20:
+		strscpy(buf, "2 122 0 1 0 1 2 2 2", sizeof(buf));
+		break;
+	case NL80211_CHAN_WIDTH_80:
+		break;
+	case NL80211_CHAN_WIDTH_160:
+		strscpy(buf, "2 137 0 1 0 1 2 2 2", sizeof(buf));
+		break;
+	default:
+		break;
+	}
+
+	mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SET_MUDL_ACK_POLICY, MU_DL_ACK_POLICY_SU_BAR);
+	mt7996_mcu_set_muru_fixed_rate_enable(dev, UNI_CMD_MURU_FIXED_RATE_CTRL, disable_ra);
+	mt7996_mcu_set_muru_fixed_rate_parameter(dev, UNI_CMD_MURU_FIXED_GROUP_RATE_CTRL, buf);
+	mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SET_FORCE_MU, force_mu);
+}
+
+void mt7996_mcu_set_cert(struct mt7996_phy *phy, u8 type)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+		u8 action;
+		u8 _rsv2[3];
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_CMD_CERT_CFG),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.action = type, /* 1: CAPI Enable */
+	};
+
+	mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(WSYS_CONFIG), &req,
+			  sizeof(req), false);
+}
+
+int mt7996_mcu_set_vow_drr_dbg(struct mt7996_dev *dev, u32 val)
+{
+#define MT7996_VOW_DEBUG_MODE	0xe
+	struct {
+		u8 __rsv1[4];
+
+		__le16 tag;
+		__le16 len;
+		u8 __rsv2[4];
+		__le32 action;
+		__le32 val;
+		u8 __rsv3[8];
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_VOW_DRR_CTRL),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.action = cpu_to_le32(MT7996_VOW_DEBUG_MODE),
+		.val = cpu_to_le32(val),
+	};
+
+	if (val & ~VOW_DRR_DBG_FLAGS)
+		return -EINVAL;
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(VOW), &req,
+				 sizeof(req), true);
+}
+
+int mt7996_mcu_thermal_debug(struct mt7996_dev *dev, u8 mode, u8 action)
+{
+	struct {
+		u8 __rsv1[4];
+
+		__le16 tag;
+		__le16 len;
+
+		u8 mode;
+		u8 action;
+		u8 __rsv2[2];
+	} __packed req = {
+		.tag = cpu_to_le16(mode),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.mode = mode,
+		.action = action,
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(THERMAL_CAL), &req,
+	                         sizeof(req), true);
+}
+
+int mt7996_mcu_mlo_agc(struct mt7996_dev *dev, const void *data, int len)
+{
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MLO), data,
+	                        len, true);
+}
+#endif
diff --git a/mt7996/mtk_mcu.h b/mt7996/mtk_mcu.h
new file mode 100644
index 00000000..2cffc893
--- /dev/null
+++ b/mt7996/mtk_mcu.h
@@ -0,0 +1,1167 @@
+/* SPDX-License-Identifier: ISC */
+/*
+ * Copyright (C) 2023 MediaTek Inc.
+ */
+
+#ifndef __MT7996_MTK_MCU_H
+#define __MT7996_MTK_MCU_H
+
+#include "../mt76_connac_mcu.h"
+
+#ifdef CONFIG_MTK_DEBUG
+
+enum {
+	UNI_CMD_MURU_DBG_INFO = 0x18,
+};
+
+struct txpower_basic_info {
+	u8 category;
+	u8 rsv1;
+
+	/* basic info */
+	u8 band_idx;
+	u8 band;
+
+	/* board type info */
+	bool is_epa;
+	bool is_elna;
+
+	/* power percentage info */
+	bool percentage_ctrl_enable;
+	s8 power_drop_level;
+
+	/* frond-end loss TX info */
+	s8 front_end_loss_tx[4];
+
+	/* frond-end loss RX info */
+	s8 front_end_loss_rx[4];
+
+	/* thermal info */
+	bool thermal_compensate_enable;
+	s8 thermal_compensate_value;
+	u8 rsv2;
+
+	/* TX power max/min limit info */
+	s8 max_power_bound;
+	s8 min_power_bound;
+
+	/* power limit info */
+	bool sku_enable;
+	bool bf_backoff_enable;
+
+	/* MU TX power info */
+	bool mu_tx_power_manual_enable;
+	s8 mu_tx_power_auto;
+	s8 mu_tx_power_manual;
+	u8 rsv3;
+};
+
+struct txpower_phy_rate_info {
+	u8 category;
+	u8 band_idx;
+	u8 band;
+	u8 epa_gain;
+
+	/* rate power info [dBm] */
+	s8 frame_power[MT7996_SKU_RATE_NUM][__MT_MAX_BAND];
+
+	/* TX power max/min limit info */
+	s8 max_power_bound;
+	s8 min_power_bound;
+	u8 rsv1;
+};
+
+struct txpower_backoff_table_info {
+	u8 category;
+	u8 band_idx;
+	u8 band;
+	u8 backoff_en;
+
+	s8 frame_power[MT7996_SKU_PATH_NUM];
+	u8 rsv[3];
+};
+
+struct mt7996_mcu_txpower_event {
+	u8 _rsv[4];
+
+	__le16 tag;
+	__le16 len;
+
+	union {
+		struct txpower_basic_info basic_info;
+		struct txpower_phy_rate_info phy_rate_info;
+		struct txpower_backoff_table_info backoff_table_info;
+	};
+};
+
+enum txpower_category {
+	BASIC_INFO,
+	BACKOFF_TABLE_INFO,
+	PHY_RATE_INFO,
+};
+
+enum txpower_event {
+	UNI_TXPOWER_BASIC_INFO = 0,
+	UNI_TXPOWER_BACKOFF_TABLE_SHOW_INFO = 3,
+	UNI_TXPOWER_PHY_RATE_INFO = 5,
+};
+
+enum {
+	EDCCA_CTRL_SET_EN = 0,
+	EDCCA_CTRL_SET_THRES,
+	EDCCA_CTRL_GET_EN,
+	EDCCA_CTRL_GET_THRES,
+	EDCCA_CTRL_NUM,
+};
+
+enum {
+	EDCCA_DEFAULT = 0,
+	EDCCA_FCC = 1,
+	EDCCA_ETSI = 2,
+	EDCCA_JAPAN = 3
+};
+
+enum {
+	UNI_CMD_MURU_BSRP_CTRL = 0x01,
+	UNI_CMD_MURU_SUTX_CTRL = 0x10,
+	UNI_CMD_MURU_FIXED_RATE_CTRL = 0x11,
+	UNI_CMD_MURU_FIXED_GROUP_RATE_CTRL = 0x12,
+	UNI_CMD_MURU_SET_FORCE_MU = 0x33,
+	UNI_CMD_MURU_MUNUAL_CONFIG = 0x64,
+	UNI_CMD_MURU_SET_MUDL_ACK_POLICY = 0xC8,
+	UNI_CMD_MURU_SET_TRIG_TYPE = 0xC9,
+	UNI_CMD_MURU_SET_20M_DYN_ALGO = 0xCA,
+	UNI_CMD_MURU_PROT_FRAME_THR = 0xCC,
+	UNI_CMD_MURU_SET_CERT_MU_EDCA_OVERRIDE,
+};
+
+struct bf_pfmu_tag {
+	__le16 tag;
+	__le16 len;
+
+	u8 pfmu_id;
+	bool bfer;
+	u8 band_idx;
+	u8 __rsv[5];
+	u8 buf[56];
+} __packed;
+
+struct bf_starec_read {
+	__le16 tag;
+	__le16 len;
+
+	__le16 wlan_idx;
+	u8 __rsv[2];
+} __packed;
+
+struct bf_fbk_rpt_info {
+	__le16 tag;
+	__le16 len;
+
+	__le16 wlan_idx; // Only need for dynamic_pfmu_update 0x4
+	u8 action;
+	u8 band_idx;
+	u8 __rsv[4];
+
+} __packed;
+
+struct bf_txsnd_info {
+	__le16 tag;
+	__le16 len;
+
+	u8 action;
+	u8 read_clr;
+	u8 vht_opt;
+	u8 he_opt;
+	__le16 wlan_idx;
+	u8 glo_opt;
+	u8 snd_intv;
+	u8 snd_stop;
+	u8 max_snd_stas;
+	u8 tx_time;
+	u8 mcs;
+	u8 ldpc;
+	u8 inf;
+	u8 man;
+	u8 ac_queue;
+	u8 sxn_protect;
+	u8 direct_fbk;
+	u8 __rsv[2];
+} __packed;
+
+#define MAX_PHASE_GROUP_NUM	13
+
+struct bf_phase_comp {
+	__le16 tag;
+	__le16 len;
+
+	u8 bw;
+	u8 jp_band;
+	u8 band_idx;
+	bool read_from_e2p;
+	bool disable;
+	u8 group;
+	u8 rsv[2];
+	u8 buf[44];
+} __packed;
+
+struct bf_tx_apply {
+	__le16 tag;
+	__le16 len;
+
+	__le16 wlan_idx;
+	bool ebf;
+	bool ibf;
+	bool mu_txbf;
+	bool phase_cal;
+	u8 rsv[2];
+} __packed;
+
+struct bf_phase_cal {
+	__le16 tag;
+	__le16 len;
+
+	u8 group_l_m_n;
+	u8 group;
+	u8 sx2;
+	u8 cal_type;
+	u8 lna_gain_level;
+	u8 band_idx;
+	u8 version;
+	u8 rsv[1];
+} __packed;
+
+struct bf_txcmd {
+	__le16 tag;
+	__le16 len;
+
+	u8 action;
+	u8 bf_manual;
+	u8 bf_bit;
+	u8 rsv[5];
+} __packed;
+
+struct bf_pfmu_data_all {
+	__le16 tag;
+	__le16 len;
+
+	u8 pfmu_id;
+	u8 band_idx;
+	u8 rsv[2];
+
+	u8 buf[640];
+} __packed;
+
+#define TXBF_DUT_MAC_SUBADDR		0x22
+#define TXBF_GOLDEN_MAC_SUBADDR		0x11
+
+struct mt7996_tm_bf_req {
+	u8 _rsv[4];
+
+	union {
+		struct bf_sounding_on sounding;
+		struct bf_tx_apply tx_apply;
+		struct bf_pfmu_tag pfmu_tag;
+		struct bf_pfmu_data_all pfmu_data_all;
+		struct bf_phase_cal phase_cal;
+		struct bf_phase_comp phase_comp;
+		struct bf_txcmd txcmd;
+	};
+} __packed;
+
+enum tm_trx_mac_type {
+	TM_TRX_MAC_TX = 1,
+	TM_TRX_MAC_RX,
+	TM_TRX_MAC_TXRX,
+	TM_TRX_MAC_TXRX_RXV,
+	TM_TRX_MAC_RXV,
+	TM_TRX_MAC_RX_RXV,
+};
+
+enum tm_trx_param_idx {
+	TM_TRX_PARAM_RSV,
+	/* MAC */
+	TM_TRX_PARAM_SET_TRX,
+	TM_TRX_PARAM_RX_FILTER,
+	TM_TRX_PARAM_RX_FILTER_PKT_LEN,
+	TM_TRX_PARAM_SLOT_TIME,
+	TM_TRX_PARAM_CLEAN_PERSTA_TXQUEUE,
+	TM_TRX_PARAM_AMPDU_WTBL,
+	TM_TRX_PARAM_MU_RX_AID,
+	TM_TRX_PARAM_PHY_MANUAL_TX,
+
+	/* PHY */
+	TM_TRX_PARAM_RX_PATH,
+	TM_TRX_PARAM_TX_STREAM,
+	TM_TRX_PARAM_TSSI_STATUS,
+	TM_TRX_PARAM_DPD_STATUS,
+	TM_TRX_PARAM_RATE_POWER_OFFSET_ON_OFF,
+	TM_TRX_PARAM_THERMO_COMP_STATUS,
+	TM_TRX_PARAM_FREQ_OFFSET,
+	TM_TRX_PARAM_FAGC_RSSI_PATH,
+	TM_TRX_PARAM_PHY_STATUS_COUNT,
+	TM_TRX_PARAM_RXV_INDEX,
+
+	TM_TRX_PARAM_ANTENNA_PORT,
+	TM_TRX_PARAM_THERMAL_ONOFF,
+	TM_TRX_PARAM_TX_POWER_CONTROL_ALL_RF,
+	TM_TRX_PARAM_RATE_POWER_OFFSET,
+	TM_TRX_PARAM_SLT_CMD_TEST,
+	TM_TRX_PARAM_SKU,
+	TM_TRX_PARAM_POWER_PERCENTAGE_ON_OFF,
+	TM_TRX_PARAM_BF_BACKOFF_ON_OFF,
+	TM_TRX_PARAM_POWER_PERCENTAGE_LEVEL,
+	TM_TRX_PARAM_FRTBL_CFG,
+	TM_TRX_PARAM_PREAMBLE_PUNC_ON_OFF,
+
+	TM_TRX_PARAM_MAX_NUM,
+};
+
+enum trx_action {
+	TM_TRX_ACTION_SET,
+	TM_TRX_ACTION_GET,
+};
+
+struct tm_trx_set {
+	u8 type;
+	u8 enable;
+	u8 band_idx;
+	u8 rsv;
+} __packed;
+
+struct mt7996_tm_trx_req {
+	u8 param_num;
+	u8 _rsv[3];
+
+	__le16 tag;
+	__le16 len;
+
+	__le16 param_idx;
+	u8 band_idx;
+	u8 testmode_en;
+	u8 action;
+	u8 rsv[3];
+
+	u32 data;
+	struct tm_trx_set set_trx;
+
+	u8 buf[220];
+} __packed;
+
+struct mt7996_mcu_bf_basic_event {
+	struct mt7996_mcu_rxd rxd;
+
+	u8 __rsv1[4];
+
+	__le16 tag;
+	__le16 len;
+};
+
+struct mt7996_mcu_bf_starec_read {
+
+	struct mt7996_mcu_bf_basic_event event;
+
+	__le16 pfmu_id;
+	bool is_su_mu;
+	u8 txbf_cap;
+	u8 sounding_phy;
+	u8 ndpa_rate;
+	u8 ndp_rate;
+	u8 rpt_poll_rate;
+	u8 tx_mode;
+	u8 nc;
+	u8 nr;
+	u8 bw;
+	u8 total_mem_require;
+	u8 mem_require_20m;
+	u8 mem_row0;
+	u8 mem_col0:6;
+	u8 mem_row0_msb:2;
+	u8 mem_row1;
+	u8 mem_col1:6;
+	u8 mem_row1_msb:2;
+	u8 mem_row2;
+	u8 mem_col2:6;
+	u8 mem_row2_msb:2;
+	u8 mem_row3;
+	u8 mem_col3:6;
+	u8 mem_row3_msb:2;
+
+	__le16 smart_ant;
+	u8 se_idx;
+	u8 auto_sounding_ctrl;
+
+	u8 bf_timeout;
+	u8 bf_dbw;
+	u8 bf_ncol;
+	u8 bf_nrow;
+
+	u8 nr_lt_bw80;
+	u8 nc_lt_bw80;
+	u8 ru_start_idx;
+	u8 ru_end_idx;
+
+	bool trigger_su;
+	bool trigger_mu;
+
+	bool ng16_su;
+	bool ng16_mu;
+
+	bool codebook42_su;
+	bool codebook75_mu;
+
+	u8 he_ltf;
+	u8 rsv[3];
+};
+
+#define TXBF_PFMU_ID_NUM_MAX 48
+
+#define TXBF_PFMU_ID_NUM_MAX_TBTC_BAND0 TXBF_PFMU_ID_NUM_MAX
+#define TXBF_PFMU_ID_NUM_MAX_TBTC_BAND1 TXBF_PFMU_ID_NUM_MAX
+#define TXBF_PFMU_ID_NUM_MAX_TBTC_BAND2 TXBF_PFMU_ID_NUM_MAX
+
+/* CFG_BF_STA_REC shall be varied based on BAND Num */
+#define CFG_BF_STA_REC_NUM (TXBF_PFMU_ID_NUM_MAX_TBTC_BAND0 + TXBF_PFMU_ID_NUM_MAX_TBTC_BAND1 + TXBF_PFMU_ID_NUM_MAX_TBTC_BAND2)
+
+#define BF_SND_CTRL_STA_DWORD_CNT   ((CFG_BF_STA_REC_NUM + 0x1F) >> 5)
+
+#ifndef ALIGN_4
+	#define ALIGN_4(_value)             (((_value) + 3) & ~3u)
+#endif /* ALIGN_4 */
+
+#define CFG_WIFI_RAM_BAND_NUM 3
+
+struct uni_event_bf_txsnd_sta_info {
+	u8 snd_intv;       /* Sounding interval upper bound, unit:15ms */
+	u8 snd_intv_cnt;   /* Sounding interval counter */
+	u8 snd_tx_cnt;     /* Tx sounding count for debug */
+	u8 snd_stop_reason;  /* Bitwise reason to put in Stop Queue */
+};
+
+struct mt7996_mcu_tx_snd_info {
+
+	struct mt7996_mcu_bf_basic_event event;
+
+	u8 vht_opt;
+	u8 he_opt;
+	u8 glo_opt;
+	u8 __rsv;
+	__le32 snd_rec_su_sta[BF_SND_CTRL_STA_DWORD_CNT];
+	__le32 snd_rec_vht_mu_sta[BF_SND_CTRL_STA_DWORD_CNT];
+	__le32 snd_rec_he_tb_sta[BF_SND_CTRL_STA_DWORD_CNT];
+	__le32 snd_rec_eht_tb_sta[BF_SND_CTRL_STA_DWORD_CNT];
+	__le16 wlan_idx_for_mc_snd[ALIGN_4(CFG_WIFI_RAM_BAND_NUM)];
+	__le16 wlan_idx_for_he_tb_snd[ALIGN_4(CFG_WIFI_RAM_BAND_NUM)];
+	__le16 wlan_idx_for_eht_tb_snd[ALIGN_4(CFG_WIFI_RAM_BAND_NUM)];
+	__le16 ul_length;
+	u8 mcs;
+	u8 ldpc;
+	struct uni_event_bf_txsnd_sta_info snd_sta_info[CFG_BF_STA_REC_NUM];
+};
+
+struct mt7996_mcu_txbf_fbk_info {
+
+	struct mt7996_mcu_bf_basic_event event;
+
+	__le32 u4DeQInterval;     /* By ms */
+	__le32 u4PollPFMUIntrStatTimeOut; /* micro-sec */
+	__le32 u4RptPktTimeOutListNum;
+	__le32 u4RptPktListNum;
+	__le32 u4PFMUWRTimeOutCnt;
+	__le32 u4PFMUWRFailCnt;
+	__le32 u4PFMUWRDoneCnt;
+	__le32 u4PFMUWRTimeoutFreeCnt;
+	__le32 u4FbRptPktDropCnt;
+	__le32 au4RxPerStaFbRptCnt[CFG_BF_STA_REC_NUM];
+};
+
+struct pfmu_ru_field {
+	__le32 ru_start_id:7;
+	__le32 _rsv1:1;
+	__le32 ru_end_id:7;
+	__le32 _rsv2:1;
+} __packed;
+
+struct pfmu_partial_bw_info {
+	__le32 partial_bw_info:9;
+	__le32 _rsv1:7;
+} __packed;
+
+struct mt7996_pfmu_tag1 {
+	__le32 pfmu_idx:10;
+	__le32 ebf:1;
+	__le32 data_bw:3;
+	__le32 lm:3;
+	__le32 is_mu:1;
+	__le32 nr:3;
+	__le32 nc:3;
+	__le32 codebook:2;
+	__le32 ngroup:2;
+	__le32 invalid_prof:1;
+	__le32 _rsv:3;
+
+	__le32 col_id1:7, row_id1:9;
+	__le32 col_id2:7, row_id2:9;
+	__le32 col_id3:7, row_id3:9;
+	__le32 col_id4:7, row_id4:9;
+
+	union {
+		struct pfmu_ru_field field;
+		struct pfmu_partial_bw_info bw_info;
+	};
+	__le32 mob_cal_en:1;
+	__le32 _rsv2:3;
+	__le32 mob_ru_alloc:9;	/* EHT profile uses full 9 bit */
+	__le32 _rsv3:3;
+
+	__le32 snr_sts0:8, snr_sts1:8, snr_sts2:8, snr_sts3:8;
+	__le32 snr_sts4:8, snr_sts5:8, snr_sts6:8, snr_sts7:8;
+
+	__le32 _rsv4;
+} __packed;
+
+struct mt7996_pfmu_tag2 {
+	__le32 smart_ant:24;
+	__le32 se_idx:5;
+	__le32 _rsv:3;
+
+	__le32 _rsv1:16;
+	__le32 ibf_timeout:8;
+	__le32 _rsv2:8;
+
+	__le32 ibf_data_bw:3;
+	__le32 ibf_nc:3;
+	__le32 ibf_nr:3;
+	__le32 ibf_ru:9;
+	__le32 _rsv3:14;
+
+	__le32 mob_delta_t:8;
+	__le32 mob_lq_result:7;
+	__le32 _rsv5:1;
+	__le32 _rsv6:16;
+
+	__le32 _rsv7;
+} __packed;
+
+struct mt7996_pfmu_tag_event {
+	struct mt7996_mcu_bf_basic_event event;
+
+	u8 bfer;
+	u8 __rsv[3];
+
+	struct mt7996_pfmu_tag1 t1;
+	struct mt7996_pfmu_tag2 t2;
+};
+
+struct mt7996_pfmu_tag {
+	struct mt7996_pfmu_tag1 t1;
+	struct mt7996_pfmu_tag2 t2;
+};
+
+enum bf_lm_type {
+	BF_LM_LEGACY,
+	BF_LM_HT,
+	BF_LM_VHT,
+	BF_LM_HE,
+	BF_LM_EHT,
+};
+
+struct mt7996_txbf_phase_out {
+	u8 c0_l;
+	u8 c1_l;
+	u8 c2_l;
+	u8 c3_l;
+	u8 c0_m;
+	u8 c1_m;
+	u8 c2_m;
+	u8 c3_m;
+	u8 c0_mh;
+	u8 c1_mh;
+	u8 c2_mh;
+	u8 c3_mh;
+	u8 c0_h;
+	u8 c1_h;
+	u8 c2_h;
+	u8 c3_h;
+	u8 c0_uh;
+	u8 c1_uh;
+	u8 c2_uh;
+	u8 c3_uh;
+};
+
+struct mt7992_txbf_phase_out {
+	u8 c0_l;
+	u8 c1_l;
+	u8 c2_l;
+	u8 c3_l;
+	u8 c4_l;
+	u8 c0_m;
+	u8 c1_m;
+	u8 c2_m;
+	u8 c3_m;
+	u8 c4_m;
+	u8 c0_mh;
+	u8 c1_mh;
+	u8 c2_mh;
+	u8 c3_mh;
+	u8 c4_mh;
+	u8 c0_h;
+	u8 c1_h;
+	u8 c2_h;
+	u8 c3_h;
+	u8 c4_h;
+	u8 c0_uh;
+	u8 c1_uh;
+	u8 c2_uh;
+	u8 c3_uh;
+	u8 c4_uh;
+};
+
+struct txbf_rx_phase {
+	u8 rx_uh;
+	u8 rx_h;
+	u8 rx_m;
+	u8 rx_l;
+	u8 rx_ul;
+};
+
+struct txbf_rx_phase_ext {
+	u8 rx_uh;
+	u8 rx_h;
+	u8 rx_mh;
+	u8 rx_m;
+	u8 rx_l;
+	u8 rx_ul;
+};
+
+struct mt7996_txbf_phase_info_2g {
+	struct txbf_rx_phase r0;
+	struct txbf_rx_phase r1;
+	struct txbf_rx_phase r2;
+	struct txbf_rx_phase r3;
+	struct txbf_rx_phase r2_sx2;
+	struct txbf_rx_phase r3_sx2;
+	u8 m_t0_h;
+	u8 m_t1_h;
+	u8 m_t2_h;
+	u8 m_t2_h_sx2;
+	u8 r0_reserved;
+	u8 r1_reserved;
+	u8 r2_reserved;
+	u8 r3_reserved;
+	u8 r2_sx2_reserved;
+	u8 r3_sx2_reserved;
+};
+
+struct mt7996_txbf_phase_info_5g {
+	struct txbf_rx_phase_ext r0;
+	struct txbf_rx_phase_ext r1;
+	struct txbf_rx_phase_ext r2;
+	struct txbf_rx_phase_ext r3;
+	struct txbf_rx_phase r2_sx2;	/* no middle-high in r2_sx2 */
+	struct txbf_rx_phase r3_sx2;	/* no middle-high in r3_sx2 */
+	u8 m_t0_h;
+	u8 m_t1_h;
+	u8 m_t2_h;
+	u8 m_t2_h_sx2;
+	u8 r0_reserved;
+	u8 r1_reserved;
+	u8 r2_reserved;
+	u8 r3_reserved;
+	u8 r2_sx2_reserved;
+	u8 r3_sx2_reserved;
+};
+
+struct mt7992_txbf_phase_info_2g {
+	struct txbf_rx_phase_ext r0;
+	struct txbf_rx_phase_ext r1;
+	struct txbf_rx_phase_ext r2;
+	struct txbf_rx_phase_ext r3;
+	u8 m_t0_h;
+	u8 m_t1_h;
+	u8 m_t2_h;
+};
+
+struct mt7992_txbf_phase_info_5g {
+	struct txbf_rx_phase_ext r0;
+	struct txbf_rx_phase_ext r1;
+	struct txbf_rx_phase_ext r2;
+	struct txbf_rx_phase_ext r3;
+	struct txbf_rx_phase_ext r4;
+	u8 m_t0_h;
+	u8 m_t1_h;
+	u8 m_t2_h;
+	u8 m_t3_h;
+};
+
+struct mt7996_txbf_phase {
+	u8 status;
+	union {
+		union {
+			struct mt7996_txbf_phase_info_2g phase_2g;
+			struct mt7996_txbf_phase_info_5g phase_5g;
+		} v1;
+		union {
+			struct mt7992_txbf_phase_info_2g phase_2g;
+			struct mt7992_txbf_phase_info_5g phase_5g;
+		} v2;
+		u8 buf[44];
+	};
+};
+
+#define phase_assign(group, v, field, dump, ...)	({					\
+	if (group) {										\
+		phase->v.phase_5g.field = cal->v.phase_5g.field;				\
+		if (dump)									\
+			dev_info(dev->mt76.dev, "%s = %d\n", #field, phase->v.phase_5g.field);	\
+	} else {										\
+		phase->v.phase_2g.field = cal->v.phase_5g.field;				\
+		if (dump)									\
+			dev_info(dev->mt76.dev, "%s = %d\n", #field, phase->v.phase_2g.field);	\
+	}											\
+})
+
+#define phase_assign_rx(group, v, rx, dump, ...)	({					\
+	phase_assign(group, v, rx.rx_uh, dump);							\
+	phase_assign(group, v, rx.rx_h, dump);							\
+	phase_assign(group, v, rx.rx_m, dump);							\
+	phase_assign(group, v, rx.rx_l, dump);							\
+	phase_assign(group, v, rx.rx_ul, dump);							\
+})
+
+#define phase_assign_rx_ext(group, v, rx, dump, ...)	({					\
+	phase_assign(group, v, rx.rx_uh, dump);							\
+	phase_assign(group, v, rx.rx_h, dump);							\
+	phase_assign(group, v, rx.rx_mh, dump);							\
+	phase_assign(group, v, rx.rx_m, dump);							\
+	phase_assign(group, v, rx.rx_l, dump);							\
+	phase_assign(group, v, rx.rx_ul, dump);							\
+})
+
+#define phase_assign_rx_v1(group, v, rx, ...)	({						\
+	if (group) {										\
+		phase_assign(group, v, rx.rx_uh, true);						\
+		phase_assign(group, v, rx.rx_h, true);						\
+		phase->v.phase_5g.rx.rx_mh = cal->v.phase_5g.rx.rx_mh;				\
+		dev_info(dev->mt76.dev, "%s.rx_mh = %d\n", #rx, phase->v.phase_5g.rx.rx_mh);	\
+		phase_assign(group, v, rx.rx_m, true);						\
+		phase_assign(group, v, rx.rx_l, true);						\
+		phase_assign(group, v, rx.rx_ul, true);						\
+	} else {										\
+		phase_assign_rx(group, v, rx, true, ...);					\
+	}											\
+})
+
+#define GROUP_L		0
+#define GROUP_M		1
+#define GROUP_H		2
+
+struct mt7996_pfmu_data {
+	__le16 subc_idx;
+	__le16 phi11;
+	__le16 phi21;
+	__le16 phi31;
+};
+
+struct mt7996_pfmu_data_5x5 {
+	__le16 subc_idx;
+	__le16 phi11;
+	__le16 phi21;
+	__le16 phi31;
+	__le16 phi41;
+};
+
+struct mt7996_ibf_cal_info {
+	struct mt7996_mcu_bf_basic_event event;
+
+	u8 category_id;
+	u8 group_l_m_n;
+	u8 group;
+	bool sx2;
+	u8 status;
+	u8 cal_type;
+	u8 nsts;
+	u8 version;
+	union {
+		struct {
+			struct mt7996_txbf_phase_out phase_out;
+			union {
+				struct mt7996_txbf_phase_info_2g phase_2g;
+				struct mt7996_txbf_phase_info_5g phase_5g;
+			};
+		} v1;
+		struct {
+			struct mt7992_txbf_phase_out phase_out;
+			union {
+				struct mt7992_txbf_phase_info_2g phase_2g;
+				struct mt7992_txbf_phase_info_5g phase_5g;
+			};
+		} v2;
+		u8 buf[64];
+	};
+} __packed;
+
+enum {
+	IBF_PHASE_CAL_UNSPEC,
+	IBF_PHASE_CAL_NORMAL,
+	IBF_PHASE_CAL_VERIFY,
+	IBF_PHASE_CAL_NORMAL_INSTRUMENT,
+	IBF_PHASE_CAL_VERIFY_INSTRUMENT,
+};
+
+enum ibf_version {
+	IBF_VER_1,
+	IBF_VER_2 = 3,
+};
+
+static inline int get_ibf_version(struct mt7996_dev *dev)
+{
+	switch (mt76_chip(&dev->mt76)) {
+	case 0x7990:
+		return IBF_VER_1;
+	case 0x7992:
+	default:
+		return IBF_VER_2;
+	}
+}
+
+#define MT7996_TXBF_SUBCAR_NUM		64
+#define MT7996_TXBF_PFMU_DATA_LEN	(MT7996_TXBF_SUBCAR_NUM * sizeof(struct mt7996_pfmu_data))
+#define MT7996_TXBF_PFMU_DATA_LEN_5X5	(MT7996_TXBF_SUBCAR_NUM * \
+					 sizeof(struct mt7996_pfmu_data_5x5))
+
+enum {
+	UNI_EVENT_BF_PFMU_TAG = 0x5,
+	UNI_EVENT_BF_PFMU_DATA = 0x7,
+	UNI_EVENT_BF_STAREC = 0xB,
+	UNI_EVENT_BF_CAL_PHASE = 0xC,
+	UNI_EVENT_BF_FBK_INFO = 0x17,
+	UNI_EVENT_BF_TXSND_INFO = 0x18,
+	UNI_EVENT_BF_PLY_INFO = 0x19,
+	UNI_EVENT_BF_METRIC_INFO = 0x1A,
+	UNI_EVENT_BF_TXCMD_CFG_INFO = 0x1B,
+	UNI_EVENT_BF_SND_CNT_INFO = 0x1D,
+	UNI_EVENT_BF_MAX_NUM
+};
+
+struct uni_muru_mum_set_group_tbl_entry {
+	__le16 wlan_idx0;
+	__le16 wlan_idx1;
+	__le16 wlan_idx2;
+	__le16 wlan_idx3;
+
+	u8 dl_mcs_user0:4;
+	u8 dl_mcs_user1:4;
+	u8 dl_mcs_user2:4;
+	u8 dl_mcs_user3:4;
+	u8 ul_mcs_user0:4;
+	u8 ul_mcs_user1:4;
+	u8 ul_mcs_user2:4;
+	u8 ul_mcs_user3:4;
+
+	u8 num_user:2;
+	u8 rsv:6;
+	u8 nss0:2;
+	u8 nss1:2;
+	u8 nss2:2;
+	u8 nss3:2;
+	u8 ru_alloc;
+	u8 ru_alloc_ext;
+
+	u8 capa;
+	u8 gi;
+	u8 dl_ul;
+	u8 _rsv2;
+};
+
+enum UNI_CMD_MURU_VER_T {
+	UNI_CMD_MURU_VER_LEG = 0,
+	UNI_CMD_MURU_VER_HE,
+	UNI_CMD_MURU_VER_EHT,
+	UNI_CMD_MURU_VER_MAX
+};
+
+#define UNI_MAX_MCS_SUPPORT_HE 11
+#define UNI_MAX_MCS_SUPPORT_EHT 13
+
+enum {
+	RUALLOC_BW20 = 122,
+	RUALLOC_BW40 = 130,
+	RUALLOC_BW80 = 134,
+	RUALLOC_BW160 = 137,
+	RUALLOC_BW320 = 395,
+};
+
+enum {
+	MAX_MODBF_VHT = 0,
+	MAX_MODBF_HE = 2,
+	MAX_MODBF_EHT = 4,
+};
+
+enum {
+	BF_SND_READ_INFO = 0,
+	BF_SND_CFG_OPT,
+	BF_SND_CFG_INTV,
+	BF_SND_STA_STOP,
+	BF_SND_CFG_MAX_STA,
+	BF_SND_CFG_BFRP,
+	BF_SND_CFG_INF,
+	BF_SND_CFG_TXOP_SND
+};
+
+enum {
+	UNI_EVENT_SR_CFG_SR_ENABLE = 0x1,
+	UNI_EVENT_SR_SW_SD = 0x83,
+	UNI_EVENT_SR_HW_IND = 0xC9,
+	UNI_EVENT_SR_HW_ESR_ENABLE = 0xD8,
+};
+enum {
+	UNI_CMD_SR_CFG_SR_ENABLE = 0x1,
+	UNI_CMD_SR_SW_SD = 0x84,
+	UNI_CMD_SR_HW_IND = 0xCB,
+	UNI_CMD_SR_HW_ENHANCE_SR_ENABLE = 0xDA,
+};
+
+struct mt7996_mcu_sr_basic_event {
+	struct mt7996_mcu_rxd rxd;
+
+	u8 band_idx;
+	u8 _rsv[3];
+
+	__le16 tag;
+	__le16 len;
+};
+
+struct sr_sd_tlv {
+	u8 _rsv[16];
+	__le32 sr_tx_airtime;
+	__le32 obss_airtime;
+	__le32 my_tx_airtime;
+	__le32 my_rx_airtime;
+	__le32 channel_busy_time;
+	__le32 total_airtime;
+	__le32 total_airtime_ratio;
+	__le32 obss_airtime_ratio;
+	u8 rule;
+	u8 _rsv2[59];
+} __packed;
+
+struct mt7996_mcu_sr_swsd_event {
+	struct mt7996_mcu_sr_basic_event basic;
+	struct sr_sd_tlv tlv[3];
+} __packed;
+
+struct mt7996_mcu_sr_common_event {
+	struct mt7996_mcu_sr_basic_event basic;
+	__le32 value;
+};
+
+struct mt7996_mcu_sr_hw_ind_event {
+	struct mt7996_mcu_sr_basic_event basic;
+	__le16 non_srg_valid_cnt;
+	u8 _rsv[4];
+	__le16 inter_bss_ppdu_cnt;
+	u8 _rsv2[4];
+	__le32 sr_ampdu_mpdu_cnt;
+	__le32 sr_ampdu_mpdu_acked_cnt;
+};
+
+struct mt7996_muru_comm {
+	u8 pda_pol;
+	u8 band;
+	u8 spe_idx;
+	u8 proc_type;
+
+	__le16 mlo_ctrl;
+	u8 sch_type;
+	u8 ppdu_format;
+	u8 ac;
+	u8 _rsv[3];
+};
+
+struct mt7996_muru_dl {
+	u8 user_num;
+	u8 tx_mode;
+	u8 bw;
+	u8 gi;
+
+	u8 ltf;
+	u8 mcs;
+	u8 dcm;
+	u8 cmprs;
+
+	__le16 ru[16];
+
+	u8 c26[2];
+	u8 ack_policy;
+	u8 tx_power;
+
+	__le16 mu_ppdu_duration;
+	u8 agc_disp_order;
+	u8 _rsv1;
+
+	u8 agc_disp_pol;
+	u8 agc_disp_ratio;
+	__le16 agc_disp_linkMFG;
+
+	__le16 prmbl_punc_bmp;
+	u8 _rsv2[2];
+
+	struct {
+		__le16 wlan_idx;
+		u8 ru_alloc_seg;
+		u8 ru_idx;
+		u8 ldpc;
+		u8 nss;
+		u8 mcs;
+		u8 mu_group_idx;
+		u8 vht_groud_id;
+		u8 vht_up;
+		u8 he_start_stream;
+		u8 he_mu_spatial;
+		__le16 tx_power_alpha;
+		u8 ack_policy;
+		u8 ru_allo_ps160;
+	} usr[16];
+};
+
+struct mt7996_muru_ul {
+	u8 user_num;
+	u8 tx_mode;
+
+	u8 ba_type;
+	u8 _rsv;
+
+	u8 bw;
+	u8 gi_ltf;
+	__le16 ul_len;
+
+	__le16 trig_cnt;
+	u8 pad;
+	u8 trig_type;
+
+	__le16 trig_intv;
+	u8 trig_ta[ETH_ALEN];
+	__le16 ul_ru[16];
+
+	u8 c26[2];
+	__le16 agc_disp_linkMFG;
+
+	u8 agc_disp_mu_len;
+	u8 agc_disp_pol;
+	u8 agc_disp_ratio;
+	u8 agc_disp_pu_idx;
+
+	struct {
+		__le16 wlan_idx;
+		u8 ru_alloc_seg;
+		u8 ru_idx;
+		u8 ldpc;
+		u8 nss;
+		u8 mcs;
+		u8 target_rssi;
+		__le32 trig_pkt_size;
+		u8 ru_allo_ps160;
+		u8 _rsv2[3];
+	} usr[16];
+};
+
+struct mt7996_muru_dbg {
+	/* HE TB RX Debug */
+	__le32 rx_hetb_nonsf_en_bitmap;
+	__le32 rx_hetb_cfg[2];
+};
+
+struct mt7996_muru {
+	__le32 cfg_comm;
+	__le32 cfg_dl;
+	__le32 cfg_ul;
+	__le32 cfg_dbg;
+
+	struct mt7996_muru_comm comm;
+	struct mt7996_muru_dl dl;
+	struct mt7996_muru_ul ul;
+	struct mt7996_muru_dbg dbg;
+};
+
+
+#define MURU_PPDU_HE_TRIG	BIT(2)
+#define MURU_PPDU_HE_MU		BIT(3)
+
+#define MURU_OFDMA_SCH_TYPE_DL	BIT(0)
+#define MURU_OFDMA_SCH_TYPE_UL	BIT(1)
+
+/* Common Config */
+#define MURU_COMM_PPDU_FMT	BIT(0)
+#define MURU_COMM_SCH_TYPE	BIT(1)
+#define MURU_COMM_BAND		BIT(2)
+#define MURU_COMM_WMM		BIT(3)
+#define MURU_COMM_SPE_IDX	BIT(4)
+#define MURU_COMM_PROC_TYPE	BIT(5)
+#define MURU_COMM_SET		(MURU_COMM_PPDU_FMT | MURU_COMM_SCH_TYPE)
+#define MURU_COMM_SET_TM	(MURU_COMM_PPDU_FMT | MURU_COMM_BAND | \
+				 MURU_COMM_WMM | MURU_COMM_SPE_IDX)
+
+/* DL Common config */
+#define MURU_FIXED_DL_TOTAL_USER_CNT	BIT(4)
+
+/* UL Common Config */
+#define MURU_FIXED_UL_TOTAL_USER_CNT	BIT(4)
+
+enum {
+	CAPI_SU,
+	CAPI_MU,
+	CAPI_ER_SU,
+	CAPI_TB,
+	CAPI_LEGACY
+};
+
+enum {
+	CAPI_BASIC,
+	CAPI_BRP,
+	CAPI_MU_BAR,
+	CAPI_MU_RTS,
+	CAPI_BSRP,
+	CAPI_GCR_MU_BAR,
+	CAPI_BQRP,
+	CAPI_NDP_FRP,
+};
+
+enum {
+	MU_DL_ACK_POLICY_MU_BAR = 3,
+	MU_DL_ACK_POLICY_TF_FOR_ACK = 4,
+	MU_DL_ACK_POLICY_SU_BAR = 5,
+};
+
+enum muru_vendor_ctrl {
+	MU_CTRL_UPDATE,
+	MU_CTRL_DL_USER_CNT,
+	MU_CTRL_UL_USER_CNT,
+};
+
+enum {
+	VOW_DRR_DBG_DUMP_BMP = BIT(0),
+	VOW_DRR_DBG_EST_AT_PRINT = BIT(1),
+	VOW_DRR_DBG_ADJ_GLOBAL_THLD = BIT(21),
+	VOW_DRR_DBG_PRN_LOUD = BIT(22),
+	VOW_DRR_DBG_PRN_ADJ_STA = BIT(23),
+	VOW_DRR_DBG_FIX_CR = GENMASK(27, 24),
+	VOW_DRR_DBG_CLR_FIX_CR = BIT(28),
+	VOW_DRR_DBG_DISABLE = BIT(29),
+	VOW_DRR_DBG_DUMP_CR = BIT(30),
+	VOW_DRR_DBG_PRN = BIT(31)
+};
+
+#define VOW_DRR_DBG_FLAGS (VOW_DRR_DBG_DUMP_BMP |	\
+			  VOW_DRR_DBG_EST_AT_PRINT |	\
+			  VOW_DRR_DBG_ADJ_GLOBAL_THLD |	\
+			  VOW_DRR_DBG_PRN_LOUD |	\
+			  VOW_DRR_DBG_PRN_ADJ_STA |	\
+			  VOW_DRR_DBG_FIX_CR |		\
+			  VOW_DRR_DBG_CLR_FIX_CR |	\
+			  VOW_DRR_DBG_DISABLE |		\
+			  VOW_DRR_DBG_DUMP_CR |		\
+			  VOW_DRR_DBG_PRN)
+#endif
+
+#endif
diff --git a/mt7996/pci.c b/mt7996/pci.c
index 19e99bc1..4465f37c 100644
--- a/mt7996/pci.c
+++ b/mt7996/pci.c
@@ -5,12 +5,14 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/pci.h>
 
 #include "mt7996.h"
 #include "mac.h"
 #include "../trace.h"
 
+static bool hif2_enable = false;
+module_param(hif2_enable, bool, 0644);
+
 static LIST_HEAD(hif_list);
 static DEFINE_SPINLOCK(hif_lock);
 static u32 hif_idx;
@@ -65,6 +67,9 @@ static struct mt7996_hif *mt7996_pci_init_hif2(struct pci_dev *pdev)
 {
 	hif_idx++;
 
+	if (!hif2_enable)
+		return NULL;
+
 	if (!pci_get_device(PCI_VENDOR_ID_MEDIATEK, MT7996_DEVICE_ID_2, NULL) &&
 	    !pci_get_device(PCI_VENDOR_ID_MEDIATEK, MT7992_DEVICE_ID_2, NULL) &&
 	    !pci_get_device(PCI_VENDOR_ID_MEDIATEK, MT7990_DEVICE_ID_2, NULL))
@@ -80,6 +85,9 @@ static int mt7996_pci_hif2_probe(struct pci_dev *pdev)
 {
 	struct mt7996_hif *hif;
 
+	if (!hif2_enable)
+		return 0;
+
 	hif = devm_kzalloc(&pdev->dev, sizeof(*hif), GFP_KERNEL);
 	if (!hif)
 		return -ENOMEM;
@@ -87,6 +95,7 @@ static int mt7996_pci_hif2_probe(struct pci_dev *pdev)
 	hif->dev = &pdev->dev;
 	hif->regs = pcim_iomap_table(pdev)[0];
 	hif->irq = pdev->irq;
+	pcie_bandwidth_available(pdev, NULL, &hif->speed, &hif->width);
 	spin_lock_bh(&hif_lock);
 	list_add(&hif->list, &hif_list);
 	spin_unlock_bh(&hif_lock);
@@ -101,9 +110,11 @@ static int mt7996_pci_probe(struct pci_dev *pdev,
 	struct pci_dev *hif2_dev;
 	struct mt7996_hif *hif2;
 	struct mt7996_dev *dev;
-	int irq, hif2_irq, ret;
+	int irq, ret;
 	struct mt76_dev *mdev;
 
+	hif2_enable |= (id->device == 0x7990 || id->device == 0x7991 || id->device == 0x799a);
+
 	ret = pcim_enable_device(pdev);
 	if (ret)
 		return ret;
@@ -137,6 +148,8 @@ static int mt7996_pci_probe(struct pci_dev *pdev,
 	mdev = &dev->mt76;
 	mt7996_wfsys_reset(dev);
 	hif2 = mt7996_pci_init_hif2(pdev);
+	if (hif2)
+		dev->hif2 = hif2;
 
 	ret = mt7996_mmio_wed_init(dev, pdev, false, &irq);
 	if (ret < 0)
@@ -161,11 +174,12 @@ static int mt7996_pci_probe(struct pci_dev *pdev,
 
 	if (hif2) {
 		hif2_dev = container_of(hif2->dev, struct pci_dev, dev);
-		dev->hif2 = hif2;
+		ret = 0;
+
+		ret = mt7996_mmio_wed_init(dev, hif2_dev, true, &irq);
 
-		ret = mt7996_mmio_wed_init(dev, hif2_dev, true, &hif2_irq);
 		if (ret < 0)
-			goto free_hif2_wed_irq_vector;
+			goto free_wed_or_irq_vector;
 
 		if (!ret) {
 			ret = pci_alloc_irq_vectors(hif2_dev, 1, 1,
@@ -174,14 +188,15 @@ static int mt7996_pci_probe(struct pci_dev *pdev,
 				goto free_hif2;
 
 			dev->hif2->irq = hif2_dev->irq;
-			hif2_irq = dev->hif2->irq;
+		} else {
+			dev->hif2->irq = irq;
 		}
 
-		ret = devm_request_irq(mdev->dev, hif2_irq, mt7996_irq_handler,
-				       IRQF_SHARED, KBUILD_MODNAME "-hif",
-				       dev);
+		ret = devm_request_irq(mdev->dev, dev->hif2->irq,
+				       mt7996_irq_handler, IRQF_SHARED,
+				       KBUILD_MODNAME "-hif", dev);
 		if (ret)
-			goto free_hif2_wed_irq_vector;
+			goto free_hif2_irq_vector;
 
 		mt76_wr(dev, MT_INT1_MASK_CSR, 0);
 		/* master switch of PCIe tnterrupt enable */
@@ -196,8 +211,8 @@ static int mt7996_pci_probe(struct pci_dev *pdev,
 
 free_hif2_irq:
 	if (dev->hif2)
-		devm_free_irq(mdev->dev, hif2_irq, dev);
-free_hif2_wed_irq_vector:
+		devm_free_irq(mdev->dev, dev->hif2->irq, dev);
+free_hif2_irq_vector:
 	if (dev->hif2) {
 		if (mtk_wed_device_active(&dev->mt76.mmio.wed_hif2))
 			mtk_wed_device_detach(&dev->mt76.mmio.wed_hif2);
diff --git a/mt7996/regs.h b/mt7996/regs.h
index e942c005..fcf0e504 100644
--- a/mt7996/regs.h
+++ b/mt7996/regs.h
@@ -88,6 +88,8 @@ enum offs_rev {
 #define MT_RRO_BA_BITMAP_BASE1			MT_RRO_TOP(0xC)
 #define WF_RRO_AXI_MST_CFG			MT_RRO_TOP(0xB8)
 #define WF_RRO_AXI_MST_CFG_DIDX_OK		BIT(12)
+
+#define MT_RRO_ADDR_ARRAY_BASE0			MT_RRO_TOP(0x30)
 #define MT_RRO_ADDR_ARRAY_BASE1			MT_RRO_TOP(0x34)
 #define MT_RRO_ADDR_ARRAY_ELEM_ADDR_SEG_MODE	BIT(31)
 
@@ -108,6 +110,14 @@ enum offs_rev {
 
 #define MT_RRO_ADDR_ELEM_SEG_ADDR0		MT_RRO_TOP(0x400)
 
+#define MT_RRO_3_0_EMU_CONF			MT_RRO_TOP(0x600)
+#define MT_RRO_3_0_EMU_CONF_EN_MASK		BIT(11)
+
+#define MT_RRO_3_1_GLOBAL_CONFIG		MT_RRO_TOP(0x604)
+#define MT_RRO_3_1_GLOBAL_CONFIG_INTERLEAVE_EN	BIT(0)
+
+#define MT_RRO_MSDU_PG_SEG_ADDR0		MT_RRO_TOP(0x620)
+
 #define MT_RRO_ACK_SN_CTRL			MT_RRO_TOP(0x50)
 #define MT_RRO_ACK_SN_CTRL_SN_MASK		GENMASK(27, 16)
 #define MT_RRO_ACK_SN_CTRL_SESSION_MASK		GENMASK(11, 0)
@@ -123,6 +133,8 @@ enum offs_rev {
 #define MT_MCU_INT_EVENT_DMA_INIT		BIT(1)
 #define MT_MCU_INT_EVENT_RESET_DONE		BIT(3)
 
+#define WF_RRO_TOP_STATISTIC(_n)		MT_RRO_TOP(0x180 + _n * 0x4)
+
 /* PLE */
 #define MT_PLE_BASE				0x820c0000
 #define MT_PLE(ofs)				(MT_PLE_BASE + (ofs))
@@ -340,6 +352,9 @@ enum offs_rev {
 #define MT_ARB_SCR_TX_DISABLE			BIT(8)
 #define MT_ARB_SCR_RX_DISABLE			BIT(9)
 
+#define MT_ARB_TQSAXM0(_band)			MT_WF_ARB(_band, 0x180)
+#define MT_ARB_TQSAXM_ALTX_START_MASK		GENMASK(12, 8)
+
 /* RMAC: band 0(0x820e5000), band 1(0x820f5000), band 2(0x830e5000), */
 #define MT_WF_RMAC_BASE(_band)			__BASE(WF_RMAC_BASE, (_band))
 #define MT_WF_RMAC(_band, ofs)			(MT_WF_RMAC_BASE(_band) + (ofs))
@@ -412,7 +427,9 @@ enum offs_rev {
 
 #define MT_WFDMA0_RX_INT_PCIE_SEL		MT_WFDMA0(0x154)
 #define MT_WFDMA0_RX_INT_SEL_RING3		BIT(3)
+#define MT_WFDMA0_RX_INT_SEL_RING5		BIT(5)
 #define MT_WFDMA0_RX_INT_SEL_RING6		BIT(6)
+#define MT_WFDMA0_RX_INT_SEL_RING9		BIT(9)
 
 #define MT_WFDMA0_MCU_HOST_INT_ENA		MT_WFDMA0(0x1f4)
 
@@ -432,6 +449,7 @@ enum offs_rev {
 #define WF_WFDMA0_GLO_CFG_EXT0			MT_WFDMA0(0x2b0)
 #define WF_WFDMA0_GLO_CFG_EXT0_RX_WB_RXD	BIT(18)
 #define WF_WFDMA0_GLO_CFG_EXT0_WED_MERGE_MODE	BIT(14)
+#define WF_WFDMA0_GLO_CFG_EXT0_OUTSTAND_MASK	GENMASK(27, 24)
 
 #define WF_WFDMA0_GLO_CFG_EXT1			MT_WFDMA0(0x2b4)
 #define WF_WFDMA0_GLO_CFG_EXT1_CALC_MODE	BIT(31)
@@ -451,6 +469,8 @@ enum offs_rev {
 
 #define MT_WFDMA_HOST_CONFIG			MT_WFDMA_EXT_CSR(0x30)
 #define MT_WFDMA_HOST_CONFIG_PDMA_BAND		BIT(0)
+#define MT_WFDMA_HOST_CONFIG_BAND0_PCIE1	BIT(20)
+#define MT_WFDMA_HOST_CONFIG_BAND1_PCIE1	BIT(21)
 #define MT_WFDMA_HOST_CONFIG_BAND2_PCIE1	BIT(22)
 
 #define MT_WFDMA_EXT_CSR_HIF_MISC		MT_WFDMA_EXT_CSR(0x44)
@@ -459,6 +479,9 @@ enum offs_rev {
 #define MT_WFDMA_AXI_R2A_CTRL			MT_WFDMA_EXT_CSR(0x500)
 #define MT_WFDMA_AXI_R2A_CTRL_OUTSTAND_MASK	GENMASK(4, 0)
 
+#define MT_WFDMA_AXI_R2A_CTRL2			MT_WFDMA_EXT_CSR(0x508)
+#define MT_WFDMA_AXI_R2A_CTRL2_OUTSTAND_MASK	GENMASK(31, 28)
+
 #define MT_PCIE_RECOG_ID			0xd7090
 #define MT_PCIE_RECOG_ID_MASK			GENMASK(30, 0)
 #define MT_PCIE_RECOG_ID_SEM			BIT(31)
@@ -514,7 +537,9 @@ enum offs_rev {
 #define MT_INT_RX_DONE_WA_EXT			BIT(3) /* for mt7992 */
 #define MT_INT_RX_DONE_WA_TRI			BIT(3)
 #define MT_INT_RX_TXFREE_MAIN			BIT(17)
+#define MT_INT_RX_TXFREE_BAND1			BIT(15)
 #define MT_INT_RX_TXFREE_TRI			BIT(15)
+#define MT_INT_RX_TXFREE_BAND1_EXT		BIT(19) /* for mt7992 two PCIE*/
 #define MT_INT_RX_TXFREE_BAND0_MT7990		BIT(14)
 #define MT_INT_RX_TXFREE_BAND1_MT7990		BIT(15)
 #define MT_INT_RX_DONE_BAND2_EXT		BIT(23)
@@ -522,7 +547,7 @@ enum offs_rev {
 #define MT_INT_MCU_CMD				BIT(29)
 
 #define MT_INT_RX_DONE_RRO_BAND0		BIT(16)
-#define MT_INT_RX_DONE_RRO_BAND1		BIT(16)
+#define MT_INT_RX_DONE_RRO_BAND1		BIT(17)
 #define MT_INT_RX_DONE_RRO_BAND2		BIT(14)
 #define MT_INT_RX_DONE_RRO_IND			BIT(11)
 #define MT_INT_RX_DONE_MSDU_PG_BAND0		BIT(18)
@@ -625,7 +650,8 @@ enum offs_rev {
 
 /* FW MODE SYNC */
 #define MT_FW_ASSERT_CNT			0x02208274
-#define MT_FW_DUMP_STATE			0x02209e90
+#define MT_FW_WM_DUMP_STATE			0x02209e90
+#define MT_FW_WA_DUMP_STATE			0x7C05B080
 
 #define MT_SWDEF_BASE				0x00401400
 
@@ -722,33 +748,42 @@ enum offs_rev {
 						 ((_wf) << 16) + (ofs))
 #define MT_WF_PHYRX_CSD_IRPI(_band, _wf)	MT_WF_PHYRX_CSD(_band, _wf, 0x1000)
 
-/* PHYRX CTRL */
-#define MT_WF_PHYRX_BAND_BASE			0x83080000
-#define MT_WF_PHYRX_BAND(_band, ofs)		(MT_WF_PHYRX_BAND_BASE + \
+/* PHYDFE CTRL */
+#define MT_WF_PHYDFE_TSSI_TXCTRL01(_band)	MT_WF_PHYRX_CSD(_band, 0, 0xc718)
+#define MT_WF_PHYDFE_TSSI_TXCTRL_POWER_TMAC	GENMASK(31, 24)
+
+/* PHY CTRL */
+#define MT_WF_PHY_BAND_BASE			0x83080000
+#define MT_WF_PHY_BAND(_band, ofs)		(MT_WF_PHY_BAND_BASE + \
 						 ((_band) << 20) + (ofs))
 
-#define MT_WF_PHYRX_BAND_GID_TAB_VLD0(_band)	MT_WF_PHYRX_BAND(_band, 0x1054)
-#define MT_WF_PHYRX_BAND_GID_TAB_VLD1(_band)	MT_WF_PHYRX_BAND(_band, 0x1058)
-#define MT_WF_PHYRX_BAND_GID_TAB_POS0(_band)	MT_WF_PHYRX_BAND(_band, 0x105c)
-#define MT_WF_PHYRX_BAND_GID_TAB_POS1(_band)	MT_WF_PHYRX_BAND(_band, 0x1060)
-#define MT_WF_PHYRX_BAND_GID_TAB_POS2(_band)	MT_WF_PHYRX_BAND(_band, 0x1064)
-#define MT_WF_PHYRX_BAND_GID_TAB_POS3(_band)	MT_WF_PHYRX_BAND(_band, 0x1068)
+#define MT_WF_PHYRX_BAND_GID_TAB_VLD0(_band)	MT_WF_PHY_BAND(_band, 0x1054)
+#define MT_WF_PHYRX_BAND_GID_TAB_VLD1(_band)	MT_WF_PHY_BAND(_band, 0x1058)
+#define MT_WF_PHYRX_BAND_GID_TAB_POS0(_band)	MT_WF_PHY_BAND(_band, 0x105c)
+#define MT_WF_PHYRX_BAND_GID_TAB_POS1(_band)	MT_WF_PHY_BAND(_band, 0x1060)
+#define MT_WF_PHYRX_BAND_GID_TAB_POS2(_band)	MT_WF_PHY_BAND(_band, 0x1064)
+#define MT_WF_PHYRX_BAND_GID_TAB_POS3(_band)	MT_WF_PHY_BAND(_band, 0x1068)
 
-#define MT_WF_PHYRX_BAND_RX_CTRL1(_band)	MT_WF_PHYRX_BAND(_band, 0x2004)
+/* PHYRX CTRL */
+#define MT_WF_PHYRX_BAND_RX_CTRL1(_band)	MT_WF_PHY_BAND(_band, 0x2004)
 #define MT_WF_PHYRX_BAND_RX_CTRL1_IPI_EN	GENMASK(2, 0)
 #define MT_WF_PHYRX_BAND_RX_CTRL1_STSCNT_EN	GENMASK(11, 9)
 
 /* PHYRX CSD BAND */
-#define MT_WF_PHYRX_CSD_BAND_RXTD12(_band)		MT_WF_PHYRX_BAND(_band, 0x8230)
+#define MT_WF_PHYRX_CSD_BAND_RXTD12(_band)		MT_WF_PHY_BAND(_band, 0x8230)
 #define MT_WF_PHYRX_CSD_BAND_RXTD12_IRPI_SW_CLR_ONLY	BIT(18)
 #define MT_WF_PHYRX_CSD_BAND_RXTD12_IRPI_SW_CLR		BIT(29)
 
 /* CONN MCU EXCP CON */
+#define MT_MCU_WA_EXCP_BASE			0x890d0000
 #define MT_MCU_WM_EXCP_BASE			0x89050000
+
 #define MT_MCU_WM_EXCP(ofs)			(MT_MCU_WM_EXCP_BASE + (ofs))
 #define MT_MCU_WM_EXCP_PC_CTRL			MT_MCU_WM_EXCP(0x100)
+#define MT_MCU_WM_EXCP_PC_CTRL_IDX_STATUS	GENMASK(20, 16)
 #define MT_MCU_WM_EXCP_PC_LOG			MT_MCU_WM_EXCP(0x104)
 #define MT_MCU_WM_EXCP_LR_CTRL			MT_MCU_WM_EXCP(0x200)
+#define MT_MCU_WM_EXCP_LR_CTRL_IDX_STATUS	GENMASK(20, 16)
 #define MT_MCU_WM_EXCP_LR_LOG			MT_MCU_WM_EXCP(0x204)
 
 /* CONN AFE CTL CON */
diff --git a/mt7996/testmode.c b/mt7996/testmode.c
new file mode 100644
index 00000000..c39ffb73
--- /dev/null
+++ b/mt7996/testmode.c
@@ -0,0 +1,2198 @@
+// SPDX-License-Identifier: ISC
+/*
+ * Copyright (C) 2022 MediaTek Inc.
+ */
+
+#include "mt7996.h"
+#include "mac.h"
+#include "mcu.h"
+#include "testmode.h"
+#include "eeprom.h"
+#include "mtk_mcu.h"
+
+enum {
+	TM_CHANGED_TXPOWER,
+	TM_CHANGED_FREQ_OFFSET,
+	TM_CHANGED_SKU_EN,
+	TM_CHANGED_TX_LENGTH,
+	TM_CHANGED_TX_TIME,
+	TM_CHANGED_CFG,
+	TM_CHANGED_OFF_CHAN_CH,
+	TM_CHANGED_OFF_CHAN_CENTER_CH,
+	TM_CHANGED_OFF_CHAN_BW,
+	TM_CHANGED_IPI_THRESHOLD,
+	TM_CHANGED_IPI_PERIOD,
+	TM_CHANGED_IPI_RESET,
+	TM_CHANGED_TXBF_ACT,
+	TM_CHANGED_TX_ANTENNA,
+	TM_CHANGED_TX_RATE_NSS,
+	TM_CHANGED_TX_RATE_IDX,
+
+	/* must be last */
+	NUM_TM_CHANGED
+};
+
+static const u8 tm_change_map[] = {
+	[TM_CHANGED_TXPOWER] = MT76_TM_ATTR_TX_POWER,
+	[TM_CHANGED_FREQ_OFFSET] = MT76_TM_ATTR_FREQ_OFFSET,
+	[TM_CHANGED_SKU_EN] = MT76_TM_ATTR_SKU_EN,
+	[TM_CHANGED_TX_LENGTH] = MT76_TM_ATTR_TX_LENGTH,
+	[TM_CHANGED_TX_TIME] = MT76_TM_ATTR_TX_TIME,
+	[TM_CHANGED_CFG] = MT76_TM_ATTR_CFG,
+	[TM_CHANGED_OFF_CHAN_CH] = MT76_TM_ATTR_OFF_CH_SCAN_CH,
+	[TM_CHANGED_OFF_CHAN_CENTER_CH] = MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH,
+	[TM_CHANGED_OFF_CHAN_BW] = MT76_TM_ATTR_OFF_CH_SCAN_BW,
+	[TM_CHANGED_IPI_THRESHOLD] = MT76_TM_ATTR_IPI_THRESHOLD,
+	[TM_CHANGED_IPI_PERIOD] = MT76_TM_ATTR_IPI_PERIOD,
+	[TM_CHANGED_IPI_RESET] = MT76_TM_ATTR_IPI_RESET,
+	[TM_CHANGED_TXBF_ACT] = MT76_TM_ATTR_TXBF_ACT,
+	[TM_CHANGED_TX_ANTENNA] = MT76_TM_ATTR_TX_ANTENNA,
+	[TM_CHANGED_TX_RATE_NSS] = MT76_TM_ATTR_TX_RATE_NSS,
+	[TM_CHANGED_TX_RATE_IDX] = MT76_TM_ATTR_TX_RATE_IDX,
+};
+
+static void mt7996_tm_ipi_work(struct work_struct *work);
+static int mt7996_tm_txbf_apply_tx(struct mt7996_phy *phy, u16 wlan_idx,
+				   bool ebf, bool ibf, bool phase_cal);
+
+static u32 mt7996_tm_bw_mapping(enum nl80211_chan_width width, enum bw_mapping_method method)
+{
+	static const u32 width_to_bw[][NUM_BW_MAP] = {
+		[NL80211_CHAN_WIDTH_40] = {FW_CDBW_40MHZ, TM_CBW_40MHZ, BF_CDBW_40MHZ, 40,
+					   FIRST_CONTROL_CHAN_BITMAP_BW40},
+		[NL80211_CHAN_WIDTH_80] = {FW_CDBW_80MHZ, TM_CBW_80MHZ, BF_CDBW_80MHZ, 80,
+					   FIRST_CONTROL_CHAN_BITMAP_BW80},
+		[NL80211_CHAN_WIDTH_80P80] = {FW_CDBW_8080MHZ, TM_CBW_8080MHZ, BF_CDBW_8080MHZ,
+					      80, 0x0},
+		[NL80211_CHAN_WIDTH_160] = {FW_CDBW_160MHZ, TM_CBW_160MHZ, BF_CDBW_160MHZ, 160,
+					    FIRST_CONTROL_CHAN_BITMAP_BW160},
+		[NL80211_CHAN_WIDTH_5] = {FW_CDBW_5MHZ, TM_CBW_5MHZ, BF_CDBW_5MHZ, 5, 0x0},
+		[NL80211_CHAN_WIDTH_10] = {FW_CDBW_10MHZ, TM_CBW_10MHZ, BF_CDBW_10MHZ, 10, 0x0},
+		[NL80211_CHAN_WIDTH_20] = {FW_CDBW_20MHZ, TM_CBW_20MHZ, BF_CDBW_20MHZ, 20, 0x0},
+		[NL80211_CHAN_WIDTH_20_NOHT] = {FW_CDBW_20MHZ, TM_CBW_20MHZ, BF_CDBW_20MHZ,
+						20, 0x0},
+		[NL80211_CHAN_WIDTH_320] = {FW_CDBW_320MHZ, TM_CBW_320MHZ, BF_CDBW_320MHZ,
+					    320, 0x0},
+	};
+
+	if (width >= ARRAY_SIZE(width_to_bw))
+		return 0;
+
+	return width_to_bw[width][method];
+}
+
+static u8 mt7996_tm_rate_mapping(u8 tx_rate_mode, enum rate_mapping_type type)
+{
+	static const u8 rate_to_phy[][NUM_RATE_MAP] = {
+		[MT76_TM_TX_MODE_CCK] = {MT_PHY_TYPE_CCK, BF_LM_LEGACY},
+		[MT76_TM_TX_MODE_OFDM] = {MT_PHY_TYPE_OFDM, BF_LM_LEGACY},
+		[MT76_TM_TX_MODE_HT] = {MT_PHY_TYPE_HT, BF_LM_HT},
+		[MT76_TM_TX_MODE_VHT] = {MT_PHY_TYPE_VHT, BF_LM_VHT},
+		[MT76_TM_TX_MODE_HE_SU] = {MT_PHY_TYPE_HE_SU, BF_LM_HE},
+		[MT76_TM_TX_MODE_HE_EXT_SU] = {MT_PHY_TYPE_HE_EXT_SU, BF_LM_HE},
+		[MT76_TM_TX_MODE_HE_TB] = {MT_PHY_TYPE_HE_TB, BF_LM_HE},
+		[MT76_TM_TX_MODE_HE_MU] = {MT_PHY_TYPE_HE_MU, BF_LM_HE},
+		[MT76_TM_TX_MODE_EHT_SU] = {MT_PHY_TYPE_EHT_SU, BF_LM_EHT},
+		[MT76_TM_TX_MODE_EHT_TRIG] = {MT_PHY_TYPE_EHT_TRIG, BF_LM_EHT},
+		[MT76_TM_TX_MODE_EHT_MU] = {MT_PHY_TYPE_EHT_MU, BF_LM_EHT},
+	};
+
+	if (tx_rate_mode > MT76_TM_TX_MODE_MAX)
+		return -EINVAL;
+
+	return rate_to_phy[tx_rate_mode][type];
+}
+
+static int
+mt7996_tm_check_antenna(struct mt7996_phy *phy)
+{
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+	u8 band_idx = phy->mt76->band_idx;
+	u32 chainmask = phy->mt76->chainmask;
+	u32 aux_rx_mask;
+
+	chainmask = chainmask >> dev->chainshift[band_idx];
+	aux_rx_mask = BIT(fls(chainmask)) * phy->has_aux_rx;
+	if (td->tx_antenna_mask & ~(chainmask | aux_rx_mask)) {
+		dev_err(dev->mt76.dev,
+			"tx antenna mask 0x%x exceeds hw limit (chainmask 0x%x, has aux rx: %s)\n",
+			td->tx_antenna_mask, chainmask, phy->has_aux_rx ? "yes" : "no");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_set(struct mt7996_dev *dev, u32 func_idx, u32 data)
+{
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_SET,
+			.op.rf.func_idx = func_idx,
+			.op.rf.param.func_data = cpu_to_le32(data),
+		},
+	};
+	bool wait = (data == RF_CMD(START_TX)) ? true : false;
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_CTRL), &req,
+				 sizeof(req), wait);
+}
+
+static int
+mt7996_tm_get(struct mt7996_dev *dev, u32 func_idx, u32 data, u32 *result)
+{
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_GET,
+			.op.rf.func_idx = func_idx,
+			.op.rf.param.func_data = cpu_to_le32(data),
+		},
+	};
+	struct mt7996_tm_event *event;
+	struct sk_buff *skb;
+	int ret;
+
+	ret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_WM_UNI_CMD_QUERY(TESTMODE_CTRL),
+					&req, sizeof(req), true, &skb);
+	if (ret)
+		return ret;
+
+	event = (struct mt7996_tm_event *)skb->data;
+	*result = event->result.payload_length;
+
+	dev_kfree_skb(skb);
+
+	return ret;
+}
+
+static void
+mt7996_tm_set_antenna(struct mt7996_phy *phy, u32 func_idx)
+{
+#define SPE_INDEX_MASK		BIT(31)
+#define TX_ANTENNA_MASK		GENMASK(4, 0)
+#define RX_ANTENNA_MASK		GENMASK(20, 16)
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	u32 antenna_mask;
+
+	if (!mt76_testmode_param_present(td, MT76_TM_ATTR_TX_ANTENNA))
+		return;
+
+	if (func_idx == SET_ID(TX_PATH))
+		antenna_mask = td->tx_spe_idx ? (SPE_INDEX_MASK | td->tx_spe_idx) :
+						td->tx_antenna_mask & TX_ANTENNA_MASK;
+	else if (func_idx == SET_ID(RX_PATH))
+		antenna_mask = u32_encode_bits(td->tx_antenna_mask, RX_ANTENNA_MASK);
+	else
+		return;
+
+	mt7996_tm_set(dev, func_idx, antenna_mask);
+}
+
+static void
+mt7996_tm_set_mac_addr(struct mt7996_dev *dev, u8 *addr, u32 func_idx)
+{
+#define REMAIN_PART_TAG		BIT(18)
+	u32 own_mac_first = 0, own_mac_remain = 0;
+	int len = sizeof(u32);
+
+	memcpy(&own_mac_first, addr, len);
+	mt7996_tm_set(dev, func_idx, own_mac_first);
+	/* Set the remain part of mac address */
+	memcpy(&own_mac_remain, addr + len, ETH_ALEN - len);
+	mt7996_tm_set(dev, func_idx | REMAIN_PART_TAG, own_mac_remain);
+}
+
+static int
+mt7996_tm_rf_switch_mode(struct mt7996_dev *dev, u32 op_mode)
+{
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_SWITCH_TO_RF_TEST,
+			.op.op_mode = cpu_to_le32(op_mode),
+		},
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_CTRL), &req,
+				 sizeof(req), false);
+}
+
+static void
+mt7996_tm_init(struct mt7996_phy *phy, bool en)
+{
+	struct ieee80211_vif *vif = phy->mt76->monitor_vif;
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	u8 rf_test_mode = en ? RF_OPER_RF_TEST : RF_OPER_NORMAL;
+	int state;
+
+	if (!test_bit(MT76_STATE_RUNNING, &phy->mt76->state))
+		return;
+
+	mt7996_mcu_set_tx_power_ctrl(phy, POWER_CTRL(ATE_MODE), en);
+	mt7996_mcu_set_tx_power_ctrl(phy, POWER_CTRL(SKU_POWER_LIMIT), !en);
+	mt7996_mcu_set_tx_power_ctrl(phy, POWER_CTRL(BACKOFF_POWER_LIMIT), !en);
+
+	mt7996_tm_rf_switch_mode(dev, rf_test_mode);
+
+	mt7996_mcu_add_bss_info(phy, vif, &vif->bss_conf, &mvif->deflink,
+				&mvif->sta.deflink, en);
+	state = en ? CONN_STATE_PORT_SECURE : CONN_STATE_DISCONNECT;
+	mt7996_mcu_add_sta(dev, &vif->bss_conf, &mvif->deflink,
+			   NULL, &mvif->sta.deflink, state, false);
+
+	mt7996_tm_set(dev, SET_ID(BAND_IDX), phy->mt76->band_idx);
+
+	/* use firmware counter for RX stats */
+	phy->mt76->test.flag |= MT_TM_FW_RX_COUNT;
+
+	if (en)
+		INIT_DELAYED_WORK(&phy->ipi_work, mt7996_tm_ipi_work);
+}
+
+void
+mt7996_tm_update_channel(struct mt7996_phy *phy)
+{
+#define CHAN_FREQ_BW_80P80_TAG		(SET_ID(CHAN_FREQ) | BIT(16))
+	struct mt7996_dev *dev = phy->dev;
+	struct cfg80211_chan_def *chandef = &phy->mt76->chandef;
+	struct ieee80211_channel *chan = chandef->chan;
+	u8 width = chandef->width;
+	static const u8 ch_band[] = {
+		[NL80211_BAND_2GHZ] = 0,
+		[NL80211_BAND_5GHZ] = 1,
+		[NL80211_BAND_6GHZ] = 2,
+	};
+
+	if (!chan) {
+		dev_info(dev->mt76.dev, "no channel found, update failed!\n");
+		return;
+	}
+
+	/* system bw */
+	mt7996_tm_set(dev, SET_ID(CBW), mt7996_tm_bw_mapping(width, BW_MAP_NL_TO_FW));
+
+	if (width == NL80211_CHAN_WIDTH_80P80) {
+		width = NL80211_CHAN_WIDTH_160;
+		mt7996_tm_set(dev, CHAN_FREQ_BW_80P80_TAG, chandef->center_freq2 * 1000);
+	}
+
+	/* TODO: define per-packet bw */
+	/* per-packet bw */
+	mt7996_tm_set(dev, SET_ID(DBW), mt7996_tm_bw_mapping(width, BW_MAP_NL_TO_FW));
+
+	/* control channel selection index */
+	mt7996_tm_set(dev, SET_ID(PRIMARY_CH), 0);
+	mt7996_tm_set(dev, SET_ID(BAND), ch_band[chan->band]);
+
+	/* trigger switch channel calibration */
+	mt7996_tm_set(dev, SET_ID(CHAN_FREQ), chandef->center_freq1 * 1000);
+
+	// TODO: update power limit table
+}
+
+static void
+mt7996_tm_tx_stop(struct mt76_phy *mphy)
+{
+	struct mt76_testmode_data *td = &mphy->test;
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+
+	mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(STOP_TEST));
+	td->tx_pending = 0;
+}
+
+static void
+mt7996_tm_set_tx_frames(struct mt7996_phy *phy, bool en)
+{
+#define FRAME_CONTROL		0x88
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+
+	//TODO: RU operation, replace mcs, nss, and ldpc
+	if (en) {
+		mt7996_tm_set(dev, SET_ID(MAC_HEADER), FRAME_CONTROL);
+		mt7996_tm_set(dev, SET_ID(SEQ_CTRL), 0);
+		mt7996_tm_set(dev, SET_ID(TX_COUNT), td->tx_count);
+		mt7996_tm_set(dev, SET_ID(TX_MODE),
+			      mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_PHY));
+		mt7996_tm_set(dev, SET_ID(TX_RATE), td->tx_rate_idx);
+
+		if (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_POWER))
+			mt7996_tm_set(dev, SET_ID(POWER), td->tx_power[0]);
+
+		if (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_TIME)) {
+			mt7996_tm_set(dev, SET_ID(TX_LEN), 0);
+			mt7996_tm_set(dev, SET_ID(TX_TIME), td->tx_time);
+		} else {
+			mt7996_tm_set(dev, SET_ID(TX_LEN), td->tx_mpdu_len);
+			mt7996_tm_set(dev, SET_ID(TX_TIME), 0);
+		}
+
+		mt7996_tm_set_antenna(phy, SET_ID(TX_PATH));
+		mt7996_tm_set_antenna(phy, SET_ID(RX_PATH));
+		mt7996_tm_set(dev, SET_ID(STBC), td->tx_rate_stbc);
+		mt7996_tm_set(dev, SET_ID(ENCODE_MODE), td->tx_rate_ldpc);
+		mt7996_tm_set(dev, SET_ID(IBF_ENABLE), td->ibf);
+		mt7996_tm_set(dev, SET_ID(EBF_ENABLE), td->ebf);
+		mt7996_tm_set(dev, SET_ID(IPG), td->tx_ipg);
+		mt7996_tm_set(dev, SET_ID(GI), td->tx_rate_sgi);
+		mt7996_tm_set(dev, SET_ID(NSS), td->tx_rate_nss);
+		mt7996_tm_set(dev, SET_ID(AID_OFFSET), 0);
+		mt7996_tm_set(dev, SET_ID(PUNCTURE), td->tx_preamble_puncture);
+
+		mt7996_tm_set(dev, SET_ID(MAX_PE), 2);
+		mt7996_tm_set(dev, SET_ID(HW_TX_MODE), 0);
+		if (!td->bf_en)
+			mt7996_tm_update_channel(phy);
+
+		/* trigger firmware to start TX */
+		mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(START_TX));
+	} else {
+		mt7996_tm_tx_stop(phy->mt76);
+	}
+}
+
+static int
+mt7996_tm_rx_stats_user_ctrl(struct mt7996_phy *phy, u16 user_idx)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_rx_req req = {
+		.band = phy->mt76->band_idx,
+		.user_ctrl = {
+			.tag = cpu_to_le16(UNI_TM_RX_STAT_SET_USER_CTRL),
+			.len = cpu_to_le16(sizeof(req.user_ctrl)),
+			.band_idx = phy->mt76->band_idx,
+			.user_idx = cpu_to_le16(user_idx),
+		},
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_RX_STAT), &req,
+				 sizeof(req), false);
+}
+
+static void
+mt7996_tm_set_rx_frames(struct mt7996_phy *phy, bool en)
+{
+#define RX_MU_DISABLE	0xf800
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+	int ret;
+
+	if (en) {
+		ret = mt7996_tm_rx_stats_user_ctrl(phy, td->aid);
+		if (ret) {
+			dev_info(dev->mt76.dev, "Set RX stats user control failed!\n");
+			return;
+		}
+
+		if (!td->bf_en)
+			mt7996_tm_update_channel(phy);
+
+		if (td->tx_rate_mode >= MT76_TM_TX_MODE_HE_MU) {
+			if (td->aid)
+				ret = mt7996_tm_set(dev, SET_ID(RX_MU_AID), td->aid);
+			else
+				ret = mt7996_tm_set(dev, SET_ID(RX_MU_AID), RX_MU_DISABLE);
+		}
+		mt7996_tm_set(dev, SET_ID(TX_MODE),
+			      mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_PHY));
+		mt7996_tm_set(dev, SET_ID(GI), td->tx_rate_sgi);
+		mt7996_tm_set_antenna(phy, SET_ID(RX_PATH));
+		mt7996_tm_set(dev, SET_ID(MAX_PE), 2);
+
+		mt7996_tm_set_mac_addr(dev, td->addr[1], SET_ID(SA));
+
+		/* trigger firmware to start RX */
+		mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(START_RX));
+	} else {
+		/* trigger firmware to stop RX */
+		mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(STOP_TEST));
+	}
+}
+
+static void
+mt7996_tm_set_tx_cont(struct mt7996_phy *phy, bool en)
+{
+#define CONT_WAVE_MODE_OFDM	3
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+
+	if (en) {
+		mt7996_tm_update_channel(phy);
+		mt7996_tm_set(dev, SET_ID(TX_MODE),
+			      mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_PHY));
+		mt7996_tm_set(dev, SET_ID(TX_RATE), td->tx_rate_idx);
+		/* fix payload is OFDM */
+		mt7996_tm_set(dev, SET_ID(CONT_WAVE_MODE), CONT_WAVE_MODE_OFDM);
+		mt7996_tm_set(dev, SET_ID(ANT_MASK), td->tx_antenna_mask);
+
+		/* trigger firmware to start CONT TX */
+		mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(CONT_WAVE));
+	} else {
+		/* trigger firmware to stop CONT TX  */
+		mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(STOP_TEST));
+	}
+}
+
+static int
+mt7996_tm_group_prek(struct mt7996_phy *phy, enum mt76_testmode_state state)
+{
+	u8 *eeprom, do_precal;
+	u32 i, group_size, dpd_size, size, offs, *pre_cal;
+	int ret = 0;
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_dev *mdev = &dev->mt76;
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_IN_RF_TEST,
+			.icap_len = RF_TEST_ICAP_LEN,
+			.op.rf.func_idx = cpu_to_le32(RF_TEST_RE_CAL),
+			.op.rf.param.cal_param.func_data = cpu_to_le32(RF_PRE_CAL),
+			.op.rf.param.cal_param.band_idx = phy->mt76->band_idx,
+		},
+	};
+
+	if (!dev->flash_mode) {
+		dev_err(dev->mt76.dev, "Currently not in FLASH or BIN FILE mode, return!\n");
+		return -EOPNOTSUPP;
+	}
+
+	eeprom = mdev->eeprom.data;
+	dev->cur_prek_offset = 0;
+	group_size = MT_EE_CAL_GROUP_SIZE;
+	dpd_size = MT_EE_CAL_DPD_SIZE;
+	size = group_size + dpd_size;
+	offs = MT_EE_DO_PRE_CAL;
+	do_precal = (MT_EE_WIFI_CAL_GROUP_2G * !!PREK(GROUP_SIZE_2G)) |
+		    (MT_EE_WIFI_CAL_GROUP_5G * !!PREK(GROUP_SIZE_5G)) |
+		    (MT_EE_WIFI_CAL_GROUP_6G * !!PREK(GROUP_SIZE_6G));
+
+	switch (state) {
+	case MT76_TM_STATE_GROUP_PREK:
+		if (!dev->cal) {
+			dev->cal = devm_kzalloc(mdev->dev, size, GFP_KERNEL);
+			if (!dev->cal)
+				return -ENOMEM;
+		}
+
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_CTRL), &req,
+					sizeof(req), false);
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == group_size,
+				   30 * HZ);
+
+		if (ret)
+			dev_err(dev->mt76.dev, "Group Pre-cal: mcu send msg failed!\n");
+		else
+			eeprom[offs] |= do_precal;
+		break;
+	case MT76_TM_STATE_GROUP_PREK_DUMP:
+		pre_cal = (u32 *)dev->cal;
+		if (!pre_cal) {
+			dev_info(dev->mt76.dev, "Not group pre-cal yet!\n");
+			return ret;
+		}
+		dev_info(dev->mt76.dev, "Group Pre-Cal:\n");
+		for (i = 0; i < (group_size / sizeof(u32)); i += 4) {
+			dev_info(dev->mt76.dev, "[0x%08lx] 0x%8x 0x%8x 0x%8x 0x%8x\n",
+				 i * sizeof(u32), pre_cal[i], pre_cal[i + 1],
+				 pre_cal[i + 2], pre_cal[i + 3]);
+		}
+		break;
+	case MT76_TM_STATE_GROUP_PREK_CLEAN:
+		pre_cal = (u32 *)dev->cal;
+		if (!pre_cal)
+			return ret;
+		memset(pre_cal, 0, group_size);
+		eeprom[offs] &= ~MT_EE_WIFI_CAL_GROUP;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int
+mt7996_tm_dpd_prek_send_req(struct mt7996_phy *phy, struct mt7996_tm_req *req,
+			    const struct ieee80211_channel *chan_list, u32 channel_size,
+			    enum nl80211_chan_width width, u32 func_data)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_phy *mphy = phy->mt76;
+	struct cfg80211_chan_def chandef_backup, *chandef = &mphy->chandef;
+	struct ieee80211_channel chan_backup;
+	int i, ret, skip_ch_num = DPD_CH_NUM(BW20_5G_SKIP);
+
+	if (!chan_list)
+		return -EOPNOTSUPP;
+	if (!channel_size)
+		return 0;
+
+	req->rf_test.op.rf.param.cal_param.func_data = cpu_to_le32(func_data);
+
+	memcpy(&chan_backup, chandef->chan, sizeof(struct ieee80211_channel));
+	memcpy(&chandef_backup, chandef, sizeof(struct cfg80211_chan_def));
+
+	for (i = 0; i < channel_size; i++) {
+		if (chan_list[i].band == NL80211_BAND_5GHZ &&
+		    chan_list[i].hw_value >= dpd_5g_skip_ch_list[0].hw_value &&
+		    chan_list[i].hw_value <= dpd_5g_skip_ch_list[skip_ch_num - 1].hw_value)
+			continue;
+
+		memcpy(chandef->chan, &chan_list[i], sizeof(struct ieee80211_channel));
+		chandef->width = width;
+
+		/* set channel switch reason */
+		mphy->hw->conf.flags |= IEEE80211_CONF_OFFCHANNEL;
+		mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_SWITCH);
+
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_CTRL), req,
+					sizeof(*req), false);
+		if (ret) {
+			dev_err(dev->mt76.dev, "DPD Pre-cal: mcu send msg failed!\n");
+			goto out;
+		}
+	}
+
+out:
+	mphy->hw->conf.flags &= ~IEEE80211_CONF_OFFCHANNEL;
+	memcpy(chandef, &chandef_backup, sizeof(struct cfg80211_chan_def));
+	memcpy(chandef->chan, &chan_backup, sizeof(struct ieee80211_channel));
+	mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_SWITCH);
+
+	return ret;
+}
+
+static int
+mt7996_tm_dpd_prek(struct mt7996_phy *phy, enum mt76_testmode_state state)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_dev *mdev = &dev->mt76;
+	struct mt76_phy *mphy = phy->mt76;
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_IN_RF_TEST,
+			.icap_len = RF_TEST_ICAP_LEN,
+			.op.rf.func_idx = cpu_to_le32(RF_TEST_RE_CAL),
+			.op.rf.param.cal_param.band_idx = phy->mt76->band_idx,
+		},
+	};
+	u32 i, j, group_size, dpd_size, size, offs, *pre_cal;
+	u32 wait_on_prek_offset = 0;
+	u8 do_precal, *eeprom;
+	int ret = 0;
+
+	if (!dev->flash_mode) {
+		dev_err(dev->mt76.dev, "Currently not in FLASH or BIN FILE mode, return!\n");
+		return -EOPNOTSUPP;
+	}
+
+	eeprom = mdev->eeprom.data;
+	dev->cur_prek_offset = 0;
+	group_size = MT_EE_CAL_GROUP_SIZE;
+	dpd_size = MT_EE_CAL_DPD_SIZE;
+	size = group_size + dpd_size;
+	offs = MT_EE_DO_PRE_CAL;
+
+	if (!dev->cal && state < MT76_TM_STATE_DPD_DUMP) {
+		dev->cal = devm_kzalloc(mdev->dev, size, GFP_KERNEL);
+		if (!dev->cal)
+			return -ENOMEM;
+	}
+
+	switch (state) {
+	case MT76_TM_STATE_DPD_2G:
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_2g_ch_list_bw20,
+						  DPD_CH_NUM(BW20_2G),
+						  NL80211_CHAN_WIDTH_20, RF_DPD_FLAT_CAL);
+		wait_on_prek_offset += DPD_CH_NUM(BW20_2G) * DPD_PER_CH_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		do_precal = MT_EE_WIFI_CAL_DPD_2G;
+		break;
+	case MT76_TM_STATE_DPD_5G:
+		/* 5g channel bw20 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, mphy->sband_5g.sband.channels,
+						  mphy->sband_5g.sband.n_channels,
+						  NL80211_CHAN_WIDTH_20, RF_DPD_FLAT_5G_CAL);
+		if (ret)
+			return ret;
+		wait_on_prek_offset += DPD_CH_NUM(BW20_5G) * DPD_PER_CH_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		/* 5g channel bw80 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_5g_ch_list_bw80,
+						  DPD_CH_NUM(BW80_5G),
+						  NL80211_CHAN_WIDTH_80, RF_DPD_FLAT_5G_MEM_CAL);
+		if (ret)
+			return ret;
+		wait_on_prek_offset += DPD_CH_NUM(BW80_5G) * DPD_PER_CH_GT_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		/* 5g channel bw160 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_5g_ch_list_bw160,
+						  DPD_CH_NUM(BW160_5G),
+						  NL80211_CHAN_WIDTH_160, RF_DPD_FLAT_5G_MEM_CAL);
+		wait_on_prek_offset += DPD_CH_NUM(BW160_5G) * DPD_PER_CH_GT_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		do_precal = MT_EE_WIFI_CAL_DPD_5G;
+		break;
+	case MT76_TM_STATE_DPD_6G:
+		/* 6g channel bw20 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, mphy->sband_6g.sband.channels,
+						  mphy->sband_6g.sband.n_channels,
+						  NL80211_CHAN_WIDTH_20, RF_DPD_FLAT_6G_CAL);
+		if (ret)
+			return ret;
+		wait_on_prek_offset += DPD_CH_NUM(BW20_6G) * DPD_PER_CH_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		/* 6g channel bw80 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_6g_ch_list_bw80,
+						  DPD_CH_NUM(BW80_6G),
+						  NL80211_CHAN_WIDTH_80, RF_DPD_FLAT_6G_MEM_CAL);
+		if (ret)
+			return ret;
+		wait_on_prek_offset += DPD_CH_NUM(BW80_6G) * DPD_PER_CH_GT_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		/* 6g channel bw160 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_6g_ch_list_bw160,
+						  DPD_CH_NUM(BW160_6G),
+						  NL80211_CHAN_WIDTH_160, RF_DPD_FLAT_6G_MEM_CAL);
+		if (ret)
+			return ret;
+		wait_on_prek_offset += DPD_CH_NUM(BW160_6G) * DPD_PER_CH_GT_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		/* 6g channel bw320 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_6g_ch_list_bw320,
+						  DPD_CH_NUM(BW320_6G),
+						  NL80211_CHAN_WIDTH_320, RF_DPD_FLAT_6G_MEM_CAL);
+		wait_on_prek_offset += DPD_CH_NUM(BW320_6G) * DPD_PER_CH_GT_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		do_precal = MT_EE_WIFI_CAL_DPD_6G;
+		break;
+	case MT76_TM_STATE_DPD_DUMP:
+		if (!dev->cal) {
+			dev_info(dev->mt76.dev, "Not DPD pre-cal yet!\n");
+			return ret;
+		}
+		pre_cal = (u32 *)dev->cal;
+		dev_info(dev->mt76.dev, "DPD Pre-Cal:\n");
+		for (i = 0; i < dpd_size / sizeof(u32); i += 4) {
+			j = i + (group_size / sizeof(u32));
+			dev_info(dev->mt76.dev, "[0x%08lx] 0x%8x 0x%8x 0x%8x 0x%8x\n",
+				 j * sizeof(u32), pre_cal[j], pre_cal[j + 1],
+				 pre_cal[j + 2], pre_cal[j + 3]);
+		}
+		return 0;
+	case MT76_TM_STATE_DPD_CLEAN:
+		pre_cal = (u32 *)dev->cal;
+		if (!pre_cal)
+			return ret;
+		memset(pre_cal + (group_size / sizeof(u32)), 0, dpd_size);
+		do_precal = MT_EE_WIFI_CAL_DPD;
+		eeprom[offs] &= ~do_precal;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+
+	if (!ret)
+		eeprom[offs] |= do_precal;
+
+	return ret;
+}
+
+static int
+mt7996_tm_dump_precal(struct mt76_phy *mphy, struct sk_buff *msg, int flag, int type)
+{
+#define DPD_PER_CHAN_SIZE_MASK		GENMASK(31, 30)
+#define DPD_2G_RATIO_MASK		GENMASK(29, 20)
+#define DPD_5G_RATIO_MASK		GENMASK(19, 10)
+#define DPD_6G_RATIO_MASK		GENMASK(9, 0)
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+	u32 i, group_size, dpd_size, total_size, size, dpd_info = 0;
+	u32 dpd_size_2g, dpd_size_5g, dpd_size_6g;
+	u32 base, offs, transmit_size = 1000;
+	u8 *pre_cal, *eeprom;
+	void *precal;
+	enum prek_ops {
+		PREK_GET_INFO,
+		PREK_SYNC_ALL,
+		PREK_SYNC_GROUP,
+		PREK_SYNC_DPD_2G,
+		PREK_SYNC_DPD_5G,
+		PREK_SYNC_DPD_6G,
+		PREK_CLEAN_GROUP,
+		PREK_CLEAN_DPD,
+	};
+
+	if (!dev->cal) {
+		dev_info(dev->mt76.dev, "Not pre-cal yet!\n");
+		return 0;
+	}
+
+	group_size = MT_EE_CAL_GROUP_SIZE;
+	dpd_size = MT_EE_CAL_DPD_SIZE;
+	total_size = group_size + dpd_size;
+	pre_cal = dev->cal;
+	eeprom = dev->mt76.eeprom.data;
+	offs = MT_EE_DO_PRE_CAL;
+
+	dpd_size_2g = MT_EE_CAL_DPD_SIZE_2G;
+	dpd_size_5g = MT_EE_CAL_DPD_SIZE_5G;
+	dpd_size_6g = MT_EE_CAL_DPD_SIZE_6G;
+
+	switch (type) {
+	case PREK_SYNC_ALL:
+		base = 0;
+		size = total_size;
+		break;
+	case PREK_SYNC_GROUP:
+		base = 0;
+		size = group_size;
+		break;
+	case PREK_SYNC_DPD_2G:
+		base = group_size;
+		size = dpd_size_2g;
+		break;
+	case PREK_SYNC_DPD_5G:
+		base = group_size + dpd_size_2g;
+		size = dpd_size_5g;
+		break;
+	case PREK_SYNC_DPD_6G:
+		base = group_size + dpd_size_2g + dpd_size_5g;
+		size = dpd_size_6g;
+		break;
+	case PREK_GET_INFO:
+		break;
+	default:
+		return 0;
+	}
+
+	if (!flag) {
+		if (eeprom[offs] & MT_EE_WIFI_CAL_DPD) {
+			dpd_info |= u32_encode_bits(1, DPD_PER_CHAN_SIZE_MASK) |
+				    u32_encode_bits(dpd_size_2g / MT_EE_CAL_UNIT,
+						    DPD_2G_RATIO_MASK) |
+				    u32_encode_bits(dpd_size_5g / MT_EE_CAL_UNIT,
+						    DPD_5G_RATIO_MASK) |
+				    u32_encode_bits(dpd_size_6g / MT_EE_CAL_UNIT,
+						    DPD_6G_RATIO_MASK);
+		}
+		dev->cur_prek_offset = 0;
+		precal = nla_nest_start(msg, MT76_TM_ATTR_PRECAL_INFO);
+		if (!precal)
+			return -ENOMEM;
+		nla_put_u32(msg, 0, group_size);
+		nla_put_u32(msg, 1, dpd_size);
+		nla_put_u32(msg, 2, dpd_info);
+		nla_put_u32(msg, 3, transmit_size);
+		nla_put_u32(msg, 4, eeprom[offs]);
+		nla_nest_end(msg, precal);
+	} else {
+		precal = nla_nest_start(msg, MT76_TM_ATTR_PRECAL);
+		if (!precal)
+			return -ENOMEM;
+
+		transmit_size = (dev->cur_prek_offset + transmit_size < size) ?
+				transmit_size : (size - dev->cur_prek_offset);
+		for (i = 0; i < transmit_size; i++) {
+			if (nla_put_u8(msg, i, pre_cal[base + dev->cur_prek_offset + i]))
+				return -ENOMEM;
+		}
+		dev->cur_prek_offset += transmit_size;
+
+		nla_nest_end(msg, precal);
+	}
+
+	return 0;
+}
+
+static void
+mt7996_tm_re_cal_event(struct mt7996_dev *dev, struct mt7996_tm_rf_test_result *result,
+		       struct mt7996_tm_rf_test_data *data)
+{
+	u32 base, dpd_size_2g, dpd_size_5g, dpd_size_6g, cal_idx, cal_type, len = 0;
+	u8 *pre_cal;
+
+	pre_cal = dev->cal;
+	dpd_size_2g = MT_EE_CAL_DPD_SIZE_2G;
+	dpd_size_5g = MT_EE_CAL_DPD_SIZE_5G;
+	dpd_size_6g = MT_EE_CAL_DPD_SIZE_6G;
+
+	cal_idx = le32_to_cpu(data->cal_idx);
+	cal_type = le32_to_cpu(data->cal_type);
+	len = le32_to_cpu(result->payload_length);
+	len = len - sizeof(struct mt7996_tm_rf_test_data);
+
+	switch (cal_type) {
+	case RF_PRE_CAL:
+		base = 0;
+		break;
+	case RF_DPD_FLAT_CAL:
+		base = MT_EE_CAL_GROUP_SIZE;
+		break;
+	case RF_DPD_FLAT_5G_CAL:
+	case RF_DPD_FLAT_5G_MEM_CAL:
+		base = MT_EE_CAL_GROUP_SIZE + dpd_size_2g;
+		break;
+	case RF_DPD_FLAT_6G_CAL:
+	case RF_DPD_FLAT_6G_MEM_CAL:
+		base = MT_EE_CAL_GROUP_SIZE + dpd_size_2g + dpd_size_5g;
+		break;
+	default:
+		dev_info(dev->mt76.dev, "Unknown calibration type!\n");
+		return;
+	}
+	pre_cal += (base + dev->cur_prek_offset);
+
+	memcpy(pre_cal, data->cal_data, len);
+	dev->cur_prek_offset += len;
+}
+
+void mt7996_tm_rf_test_event(struct mt7996_dev *dev, struct sk_buff *skb)
+{
+	struct mt7996_tm_event *event;
+	struct mt7996_tm_rf_test_result *result;
+	struct mt7996_tm_rf_test_data *data;
+	static u32 event_type;
+
+	skb_pull(skb, sizeof(struct mt7996_mcu_rxd));
+	event = (struct mt7996_tm_event *)skb->data;
+	result = (struct mt7996_tm_rf_test_result *)&event->result;
+	data = (struct mt7996_tm_rf_test_data *)result->data;
+
+	event_type = le32_to_cpu(result->func_idx);
+
+	switch (event_type) {
+	case RF_TEST_RE_CAL:
+		mt7996_tm_re_cal_event(dev, result, data);
+		break;
+	default:
+		break;
+	}
+}
+
+static u8
+mt7996_tm_get_center_chan(struct mt7996_phy *phy, struct cfg80211_chan_def *chandef)
+{
+	struct mt76_phy *mphy = phy->mt76;
+	const struct ieee80211_channel *chan = mphy->sband_5g.sband.channels;
+	u32 bitmap, i, offset, width_mhz, size = mphy->sband_5g.sband.n_channels;
+	u16 first_control = 0, control_chan = chandef->chan->hw_value;
+	bool not_first;
+
+	bitmap = mt7996_tm_bw_mapping(chandef->width, BW_MAP_NL_TO_CONTROL_BITMAP_5G);
+	if (!bitmap)
+		return control_chan;
+
+	width_mhz = mt7996_tm_bw_mapping(chandef->width, BW_MAP_NL_TO_MHZ);
+	offset = width_mhz / 10 - 2;
+
+	for (i = 0; i < size; i++) {
+		not_first = (chandef->width != NL80211_CHAN_WIDTH_160) ?
+			    (i % bitmap) : (i >= 32) || !((1 << i) & bitmap);
+		if (not_first)
+			continue;
+
+		if (control_chan >= chan[i].hw_value)
+			first_control = chan[i].hw_value;
+		else
+			break;
+	}
+
+	if (first_control == 0)
+		return control_chan;
+
+	return first_control + offset;
+}
+
+static int
+mt7996_tm_set_offchan(struct mt7996_phy *phy, bool no_center)
+{
+	struct mt76_phy *mphy = phy->mt76;
+	struct mt7996_dev *dev = phy->dev;
+	struct ieee80211_hw *hw = mphy->hw;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct cfg80211_chan_def chandef = {};
+	struct ieee80211_channel *chan;
+	int ret, freq = ieee80211_channel_to_frequency(td->offchan_ch, NL80211_BAND_5GHZ);
+
+	if (!mphy->cap.has_5ghz || !freq) {
+		ret = -EINVAL;
+		dev_info(dev->mt76.dev, "Failed to set offchan (invalid band or channel)!\n");
+		goto out;
+	}
+
+	chandef.width = td->offchan_bw;
+	chan = ieee80211_get_channel(hw->wiphy, freq);
+	chandef.chan = chan;
+	if (no_center)
+		td->offchan_center_ch = mt7996_tm_get_center_chan(phy, &chandef);
+	chandef.center_freq1 = ieee80211_channel_to_frequency(td->offchan_center_ch,
+							      NL80211_BAND_5GHZ);
+	if (!cfg80211_chandef_valid(&chandef)) {
+		ret = -EINVAL;
+		dev_info(dev->mt76.dev, "Failed to set offchan, chandef is invalid!\n");
+		goto out;
+	}
+
+	memset(&dev->rdd2_chandef, 0, sizeof(struct cfg80211_chan_def));
+
+	ret = mt7996_mcu_rdd_background_enable(phy, &chandef);
+
+	if (ret)
+		goto out;
+
+	dev->rdd2_phy = phy;
+	dev->rdd2_chandef = chandef;
+
+	return 0;
+
+out:
+	td->offchan_ch = 0;
+	td->offchan_center_ch = 0;
+	td->offchan_bw = 0;
+
+	return ret;
+}
+
+static void
+mt7996_tm_ipi_hist_ctrl(struct mt7996_phy *phy, struct mt7996_tm_rdd_ipi_ctrl *data, u8 cmd)
+{
+#define MT_IPI_RESET		0x830a5dfc
+#define MT_IPI_RESET_MASK	BIT(28)
+#define MT_IPI_COUNTER_BASE	0x83041000
+#define MT_IPI_COUNTER(idx)	(MT_IPI_COUNTER_BASE + ((idx) * 4))
+	struct mt7996_dev *dev = phy->dev;
+	bool val;
+	int i;
+
+	if (cmd == RDD_SET_IPI_HIST_RESET) {
+		val = mt76_rr(dev, MT_IPI_RESET) & MT_IPI_RESET_MASK;
+		mt76_rmw_field(dev, MT_IPI_RESET, MT_IPI_RESET_MASK, !val);
+		return;
+	}
+
+	for (i = 0; i < POWER_INDICATE_HIST_MAX; i++)
+		data->ipi_hist_val[i] = mt76_rr(dev, MT_IPI_COUNTER(i));
+}
+
+static void
+mt7996_tm_ipi_work(struct work_struct *work)
+{
+#define PRECISION	100
+	struct mt7996_phy *phy = container_of(work, struct mt7996_phy, ipi_work.work);
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_tm_rdd_ipi_ctrl data;
+	u32 ipi_idx, ipi_free_count, ipi_percentage;
+	u32 ipi_hist_count_th = 0, ipi_hist_total_count = 0;
+	u32 self_idle_ratio, ipi_idle_ratio, channel_load;
+	u32 *ipi_hist_data;
+	const char *power_lower_bound, *power_upper_bound;
+	static const char * const ipi_idx_to_power_bound[] = {
+		[RDD_IPI_HIST_0] = "-92",
+		[RDD_IPI_HIST_1] = "-89",
+		[RDD_IPI_HIST_2] = "-86",
+		[RDD_IPI_HIST_3] = "-83",
+		[RDD_IPI_HIST_4] = "-80",
+		[RDD_IPI_HIST_5] = "-75",
+		[RDD_IPI_HIST_6] = "-70",
+		[RDD_IPI_HIST_7] = "-65",
+		[RDD_IPI_HIST_8] = "-60",
+		[RDD_IPI_HIST_9] = "-55",
+		[RDD_IPI_HIST_10] = "inf",
+	};
+
+	memset(&data, 0, sizeof(data));
+	mt7996_tm_ipi_hist_ctrl(phy, &data, RDD_IPI_HIST_ALL_CNT);
+
+	ipi_hist_data = data.ipi_hist_val;
+	for (ipi_idx = 0; ipi_idx < POWER_INDICATE_HIST_MAX; ipi_idx++) {
+		power_lower_bound = ipi_idx ? ipi_idx_to_power_bound[ipi_idx - 1] : "-inf";
+		power_upper_bound = ipi_idx_to_power_bound[ipi_idx];
+
+		dev_info(dev->mt76.dev, "IPI %d (power range: (%s, %s] dBm): ipi count = %d\n",
+			 ipi_idx, power_lower_bound, power_upper_bound, ipi_hist_data[ipi_idx]);
+
+		if (td->ipi_threshold <= ipi_idx && ipi_idx <= RDD_IPI_HIST_10)
+			ipi_hist_count_th += ipi_hist_data[ipi_idx];
+
+		ipi_hist_total_count += ipi_hist_data[ipi_idx];
+	}
+
+	ipi_free_count = ipi_hist_data[RDD_IPI_FREE_RUN_CNT];
+
+	dev_info(dev->mt76.dev, "IPI threshold %d: ipi_hist_count_th = %d, ipi_free_count = %d\n",
+		 td->ipi_threshold, ipi_hist_count_th, ipi_free_count);
+	dev_info(dev->mt76.dev, "TX assert time =  %d [ms]\n", data.tx_assert_time / 1000);
+
+	/* calculate channel load = (self idle ratio - idle ratio) / self idle ratio */
+	if (ipi_hist_count_th >= UINT_MAX / (100 * PRECISION))
+		ipi_percentage = 100 * PRECISION *
+				 (ipi_hist_count_th / (100 * PRECISION)) /
+				 (ipi_free_count / (100 * PRECISION));
+	else
+		ipi_percentage = PRECISION * 100 * ipi_hist_count_th / ipi_free_count;
+
+	ipi_idle_ratio = ((100 * PRECISION) - ipi_percentage) / PRECISION;
+
+	self_idle_ratio = PRECISION * 100 *
+			  (td->ipi_period - (data.tx_assert_time / 1000)) /
+			  td->ipi_period / PRECISION;
+
+	if (self_idle_ratio < ipi_idle_ratio)
+		channel_load = 0;
+	else
+		channel_load = self_idle_ratio - ipi_idle_ratio;
+
+	if (self_idle_ratio <= td->ipi_threshold) {
+		dev_info(dev->mt76.dev, "band[%d]: self idle ratio = %d%%, idle ratio = %d%%\n",
+			 phy->mt76->band_idx, self_idle_ratio, ipi_idle_ratio);
+		return;
+	}
+
+	channel_load = (100 * channel_load) / self_idle_ratio;
+	dev_info(dev->mt76.dev,
+		 "band[%d]: chan load = %d%%, self idle ratio = %d%%, idle ratio = %d%%\n",
+		 phy->mt76->band_idx, channel_load, self_idle_ratio, ipi_idle_ratio);
+}
+
+static int
+mt7996_tm_set_ipi(struct mt7996_phy *phy)
+{
+	struct mt76_testmode_data *td = &phy->mt76->test;
+
+	/* reset IPI CR */
+	mt7996_tm_ipi_hist_ctrl(phy, NULL, RDD_SET_IPI_HIST_RESET);
+
+	cancel_delayed_work(&phy->ipi_work);
+	ieee80211_queue_delayed_work(phy->mt76->hw, &phy->ipi_work,
+				     msecs_to_jiffies(td->ipi_period));
+
+	return 0;
+}
+
+static int
+mt7996_tm_set_trx_mac(struct mt7996_phy *phy, u8 type, bool en)
+{
+#define UNI_TM_TRX_CTRL 0
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_trx_req req = {
+		.param_num = 1,
+		.tag = cpu_to_le16(UNI_TM_TRX_CTRL),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.param_idx = cpu_to_le16(TM_TRX_PARAM_SET_TRX),
+		.band_idx = phy->mt76->band_idx,
+		.testmode_en = 1,
+		.action = TM_TRX_ACTION_SET,
+		.set_trx = {
+			.type = type,
+			.enable = en,
+			.band_idx = phy->mt76->band_idx,
+		}
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_TRX_PARAM),
+				 &req, sizeof(req), false);
+}
+
+static int
+mt7996_tm_txbf_init(struct mt7996_phy *phy, u16 *val)
+{
+#define EBF_BBP_RX_OFFSET	0x10280
+#define EBF_BBP_RX_ENABLE	(BIT(0) | BIT(15))
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	bool enable = val[0];
+	void *phase_cal, *pfmu_data, *pfmu_tag;
+	u8 nss, band_idx = phy->mt76->band_idx;
+	enum nl80211_chan_width width = NL80211_CHAN_WIDTH_20;
+	u8 sub_addr = td->is_txbf_dut ? TXBF_DUT_MAC_SUBADDR : TXBF_GOLDEN_MAC_SUBADDR;
+	u8 peer_addr = td->is_txbf_dut ? TXBF_GOLDEN_MAC_SUBADDR : TXBF_DUT_MAC_SUBADDR;
+	u8 bss_addr = TXBF_DUT_MAC_SUBADDR;
+	u8 addr[ETH_ALEN] = {0x00, sub_addr, sub_addr, sub_addr, sub_addr, sub_addr};
+	u8 bssid[ETH_ALEN] = {0x00, bss_addr, bss_addr, bss_addr, bss_addr, bss_addr};
+	u8 peer_addrs[ETH_ALEN] = {0x00, peer_addr, peer_addr, peer_addr, peer_addr, peer_addr};
+	struct ieee80211_vif *vif = phy->mt76->monitor_vif;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+
+	if (!enable) {
+		td->bf_en = false;
+		return 0;
+	}
+
+	if (!dev->test.txbf_phase_cal) {
+		phase_cal = devm_kzalloc(dev->mt76.dev,
+					 sizeof(struct mt7996_txbf_phase) *
+					 MAX_PHASE_GROUP_NUM,
+					 GFP_KERNEL);
+		if (!phase_cal)
+			return -ENOMEM;
+
+		dev->test.txbf_phase_cal = phase_cal;
+	}
+
+	if (!dev->test.txbf_pfmu_data) {
+		/* allocate max size for 5x5 pfmu data */
+		pfmu_data = devm_kzalloc(dev->mt76.dev,
+					 MT7996_TXBF_PFMU_DATA_LEN_5X5,
+					 GFP_KERNEL);
+		if (!pfmu_data)
+			return -ENOMEM;
+
+		dev->test.txbf_pfmu_data = pfmu_data;
+	}
+
+	if (!dev->test.txbf_pfmu_tag) {
+		pfmu_tag = devm_kzalloc(dev->mt76.dev,
+					sizeof(struct mt7996_pfmu_tag), GFP_KERNEL);
+		if (!pfmu_tag)
+			return -ENOMEM;
+
+		dev->test.txbf_pfmu_tag = pfmu_tag;
+	}
+
+	td->bf_en = true;
+	dev->ibf = td->ibf;
+	memcpy(td->addr[0], peer_addrs, ETH_ALEN);
+	memcpy(td->addr[1], addr, ETH_ALEN);
+	memcpy(td->addr[2], bssid, ETH_ALEN);
+	memcpy(phy->mt76->monitor_vif->addr, addr, ETH_ALEN);
+	mt7996_tm_set_mac_addr(dev, td->addr[0], SET_ID(DA));
+	mt7996_tm_set_mac_addr(dev, td->addr[1], SET_ID(SA));
+	mt7996_tm_set_mac_addr(dev, td->addr[2], SET_ID(BSSID));
+
+	/* bss idx & omac idx should be set to band idx for ibf cal */
+	mvif->deflink.mt76.idx = band_idx;
+	dev->mt76.vif_mask |= BIT_ULL(mvif->deflink.mt76.idx);
+	mvif->deflink.mt76.omac_idx = band_idx;
+	phy->omac_mask |= BIT_ULL(mvif->deflink.mt76.omac_idx);
+
+	mt7996_mcu_add_dev_info(phy, phy->mt76->monitor_vif, &phy->mt76->monitor_vif->bss_conf, &mvif->deflink.mt76, true);
+	mt7996_mcu_add_bss_info(phy, vif, &vif->bss_conf, &mvif->deflink, &mvif->sta.deflink, true);
+
+	if (td->ibf) {
+		if (td->is_txbf_dut) {
+			/* Enable ITxBF Capability */
+			mt7996_mcu_set_txbf(dev, BF_HW_EN_UPDATE);
+			mt7996_tm_set_trx_mac(phy, TM_TRX_MAC_TX, true);
+
+			td->tx_ipg = 999;
+			td->tx_mpdu_len = 1024;
+			td->tx_antenna_mask = phy->mt76->chainmask >> dev->chainshift[band_idx];
+			nss = hweight8(td->tx_antenna_mask);
+			if (nss > 1 && nss <= 4)
+				td->tx_rate_idx = 15 + 8 * (nss - 2);
+			else
+				td->tx_rate_idx = 31;
+		} else {
+			td->tx_antenna_mask = 1;
+			td->tx_mpdu_len = 1024;
+			td->tx_rate_idx = 0;
+			mt76_set(dev, EBF_BBP_RX_OFFSET, EBF_BBP_RX_ENABLE);
+			dev_info(dev->mt76.dev, "Set BBP RX CR = %x\n",
+				 mt76_rr(dev, EBF_BBP_RX_OFFSET));
+		}
+
+		td->tx_rate_mode = MT76_TM_TX_MODE_HT;
+		td->tx_rate_sgi = 0;
+		/* 5T5R ibf */
+		if (nss == 5) {
+			td->tx_rate_mode = MT76_TM_TX_MODE_VHT;
+			td->tx_rate_idx = 7;
+			td->tx_rate_nss = 4;
+		}
+	} else {
+		if (td->is_txbf_dut) {
+			/* Enable ETxBF Capability */
+			mt7996_mcu_set_txbf(dev, BF_HW_EN_UPDATE);
+			td->tx_antenna_mask = phy->mt76->chainmask >> dev->chainshift[band_idx];
+			td->tx_spe_idx = 24 + phy->mt76->band_idx;
+			if (td->tx_rate_mode == MT76_TM_TX_MODE_VHT ||
+			    td->tx_rate_mode == MT76_TM_TX_MODE_HE_SU)
+				mt7996_tm_set(dev, SET_ID(NSS), td->tx_rate_nss);
+
+			mt7996_tm_set(dev, SET_ID(ENCODE_MODE), td->tx_rate_ldpc);
+			mt7996_tm_set(dev, SET_ID(TX_COUNT), td->tx_count);
+		} else {
+			/* Turn On BBP CR for RX */
+			mt76_set(dev, EBF_BBP_RX_OFFSET, EBF_BBP_RX_ENABLE);
+			dev_info(dev->mt76.dev, "Set BBP RX CR = %x\n",
+				 mt76_rr(dev, EBF_BBP_RX_OFFSET));
+
+			td->tx_antenna_mask = 1;
+		}
+		width = phy->mt76->chandef.width;
+
+		if (td->tx_rate_mode == MT76_TM_TX_MODE_EHT_MU)
+			td->tx_rate_mode = MT76_TM_TX_MODE_EHT_SU;
+	}
+	mt76_testmode_param_set(td, MT76_TM_ATTR_TX_ANTENNA);
+
+	mt7996_tm_set(dev, SET_ID(TX_MODE),
+		      mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_PHY));
+	mt7996_tm_set(dev, SET_ID(TX_RATE), td->tx_rate_idx);
+	mt7996_tm_set(dev, SET_ID(GI), td->tx_rate_sgi);
+	mt7996_tm_set(dev, SET_ID(CBW),
+		      mt7996_tm_bw_mapping(width, BW_MAP_NL_TO_FW));
+	mt7996_tm_set(dev, SET_ID(DBW),
+		      mt7996_tm_bw_mapping(width, BW_MAP_NL_TO_FW));
+	mt7996_tm_set_antenna(phy, SET_ID(TX_PATH));
+	mt7996_tm_set_antenna(phy, SET_ID(RX_PATH));
+	mt7996_tm_set(dev, SET_ID(IPG), td->tx_ipg);
+	mt7996_tm_set(dev, SET_ID(TX_LEN), td->tx_mpdu_len);
+	mt7996_tm_set(dev, SET_ID(TX_TIME), 0);
+	mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(TX_COMMIT));
+
+	return 0;
+}
+
+static inline void
+mt7996_tm_txbf_phase_copy(struct mt7996_dev *dev, void *des, void *src, int group)
+{
+	int phase_size;
+
+	if (group && get_ibf_version(dev) == IBF_VER_1)
+		phase_size = sizeof(struct mt7996_txbf_phase_info_5g);
+	else if (get_ibf_version(dev) == IBF_VER_1)
+		phase_size = sizeof(struct mt7996_txbf_phase_info_2g);
+	else if (group)
+		phase_size = sizeof(struct mt7992_txbf_phase_info_5g);
+	else
+		phase_size = sizeof(struct mt7992_txbf_phase_info_2g);
+
+	memcpy(des, src, phase_size);
+}
+
+static int
+mt7996_tm_txbf_phase_comp(struct mt7996_phy *phy, u16 *val)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_bf_req req = {
+		.phase_comp = {
+			.tag = cpu_to_le16(BF_IBF_PHASE_COMP),
+			.len = cpu_to_le16(sizeof(req.phase_comp)),
+			.bw = val[0],
+			.jp_band = (val[2] == 1) ? 1 : 0,
+			.band_idx = phy->mt76->band_idx,
+			.read_from_e2p = val[3],
+			.disable = val[4],
+			.group = val[2],
+		}
+	};
+	struct mt7996_txbf_phase *phase = (struct mt7996_txbf_phase *)dev->test.txbf_phase_cal;
+	int group = val[2];
+
+	wait_event_timeout(dev->mt76.tx_wait, phase[group].status != 0, HZ);
+	mt7996_tm_txbf_phase_copy(dev, req.phase_comp.buf, phase[group].buf, group);
+
+	pr_info("ibf cal process: phase comp info\n");
+	print_hex_dump(KERN_INFO, "", DUMP_PREFIX_NONE, 16, 1,
+		       &req, sizeof(req), 0);
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &req,
+				 sizeof(req), false);
+}
+
+static int
+mt7996_tm_txbf_profile_tag_write(struct mt7996_phy *phy, u8 pfmu_idx, struct mt7996_pfmu_tag *tag)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_bf_req req = {
+		.pfmu_tag = {
+			.tag = cpu_to_le16(BF_PFMU_TAG_WRITE),
+			.len = cpu_to_le16(sizeof(req.pfmu_tag)),
+			.pfmu_id = pfmu_idx,
+			.bfer = true,
+			.band_idx = phy->mt76->band_idx,
+		}
+	};
+
+	memcpy(req.pfmu_tag.buf, tag, sizeof(*tag));
+	wait_event_timeout(dev->mt76.tx_wait, tag->t1.pfmu_idx != 0, HZ);
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &req,
+				 sizeof(req), false);
+}
+
+static int
+mt7996_tm_add_txbf_sta(struct mt7996_phy *phy, u8 pfmu_idx, u8 nr, u8 nc, bool ebf)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct {
+		struct sta_req_hdr hdr;
+		struct sta_rec_bf bf;
+	} __packed req = {
+		.hdr = {
+			.bss_idx = phy->mt76->band_idx,
+			.wlan_idx_lo = to_wcid_lo(phy->mt76->band_idx + 1),
+			.tlv_num = 1,
+			.is_tlv_append = 1,
+			.muar_idx = 0,
+			.wlan_idx_hi = to_wcid_hi(phy->mt76->band_idx + 1),
+		},
+		.bf = {
+			.tag = cpu_to_le16(STA_REC_BF),
+			.len = cpu_to_le16(sizeof(req.bf)),
+			.pfmu = cpu_to_le16(pfmu_idx),
+			.sounding_phy = 1,
+			.bf_cap = ebf,
+			.ncol = nc,
+			.nrow = nr,
+			.ibf_timeout = 0xff,
+			.tx_mode = mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_PHY),
+		},
+	};
+	u8 ndp_rate, ndpa_rate, rept_poll_rate, bf_bw;
+
+	if ((td->tx_rate_mode == MT76_TM_TX_MODE_HE_SU ||
+	     td->tx_rate_mode == MT76_TM_TX_MODE_EHT_SU) && !td->ibf) {
+		rept_poll_rate = 0x49;
+		ndpa_rate = 0x49;
+		ndp_rate = 0;
+	} else if (td->tx_rate_mode == MT76_TM_TX_MODE_VHT && !td->ibf) {
+		rept_poll_rate = 0x9;
+		ndpa_rate = 0x9;
+		ndp_rate = 0;
+	} else {
+		rept_poll_rate = 0;
+		ndpa_rate = 0;
+		if (nr == 1)
+			ndp_rate = 8;
+		else if (nr == 2)
+			ndp_rate = 16;
+		else if (nr == 4)
+			ndp_rate = 32;
+		else
+			ndp_rate = 24;
+
+		/* 5T5R ebf profile for ibf cal */
+		if (nr == 4 && td->ibf && ebf) {
+			ndp_rate = 0;
+			ndpa_rate = 11;
+		}
+	}
+
+	bf_bw = mt7996_tm_bw_mapping(phy->mt76->chandef.width, BW_MAP_NL_TO_BF);
+	req.bf.ndp_rate = ndp_rate;
+	req.bf.ndpa_rate = ndpa_rate;
+	req.bf.rept_poll_rate = rept_poll_rate;
+	req.bf.bw = bf_bw;
+	req.bf.tx_mode = (td->tx_rate_mode == MT76_TM_TX_MODE_EHT_SU) ? 0xf : req.bf.tx_mode;
+
+	if (ebf) {
+		req.bf.mem[0].row = 0;
+		req.bf.mem[1].row = 1;
+		req.bf.mem[2].row = 2;
+		req.bf.mem[3].row = 3;
+	} else {
+		req.bf.mem[0].row = 4;
+		req.bf.mem[1].row = 5;
+		req.bf.mem[2].row = 6;
+		req.bf.mem[3].row = 7;
+	}
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WMWA_UNI_CMD(STA_REC_UPDATE), &req,
+				 sizeof(req), true);
+}
+
+static int
+mt7996_tm_txbf_profile_update(struct mt7996_phy *phy, u16 *val, bool ebf)
+{
+#define MT_ARB_IBF_ENABLE			(BIT(0) | GENMASK(9, 8))
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_pfmu_tag *tag = dev->test.txbf_pfmu_tag;
+	u8 rate, pfmu_idx = val[0], nc = val[2], nr;
+	int ret;
+	bool is_atenl = val[5];
+
+	if (td->tx_antenna_mask == 3)
+		nr = 1;
+	else if (td->tx_antenna_mask == 7)
+		nr = 2;
+	else if (td->tx_antenna_mask == 31)
+		nr = 4;
+	else
+		nr = 3;
+
+	memset(tag, 0, sizeof(*tag));
+	tag->t1.pfmu_idx = pfmu_idx;
+	tag->t1.ebf = ebf;
+	tag->t1.nr = nr;
+	tag->t1.nc = nc;
+	tag->t1.invalid_prof = true;
+	tag->t1.data_bw = mt7996_tm_bw_mapping(phy->mt76->chandef.width, BW_MAP_NL_TO_BF);
+	tag->t2.se_idx = td->tx_spe_idx;
+
+	if (ebf) {
+		tag->t1.row_id1 = 0;
+		tag->t1.row_id2 = 1;
+		tag->t1.row_id3 = 2;
+		tag->t1.row_id4 = 3;
+		tag->t1.lm = mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_LM);
+	} else {
+		tag->t1.row_id1 = 4;
+		tag->t1.row_id2 = 5;
+		tag->t1.row_id3 = 6;
+		tag->t1.row_id4 = 7;
+		rate = nr == 4 ? td->tx_rate_mode : MT76_TM_TX_MODE_OFDM;
+		tag->t1.lm = mt7996_tm_rate_mapping(rate, RATE_MODE_TO_LM);
+
+		tag->t2.ibf_timeout = 0xff;
+		tag->t2.ibf_nr = nr;
+		tag->t2.ibf_nc = nc;
+	}
+
+	ret = mt7996_tm_txbf_profile_tag_write(phy, pfmu_idx, tag);
+	if (ret)
+		return ret;
+
+	ret = mt7996_tm_add_txbf_sta(phy, pfmu_idx, nr, nc, ebf);
+	if (ret)
+		return ret;
+
+	if (!is_atenl && !td->ibf) {
+		mt76_set(dev, MT_ARB_TQSAXM0(phy->mt76->band_idx), MT_ARB_TQSAXM_ALTX_START_MASK);
+		dev_info(dev->mt76.dev, "Set TX queue start CR for AX management (0x%x) = 0x%x\n",
+			 MT_ARB_TQSAXM0(phy->mt76->band_idx),
+			 mt76_rr(dev, MT_ARB_TQSAXM0(phy->mt76->band_idx)));
+	} else if (!is_atenl && td->ibf && ebf) {
+		/* iBF's ebf profile update */
+		mt76_set(dev, MT_ARB_TQSAXM0(phy->mt76->band_idx), MT_ARB_IBF_ENABLE);
+		dev_info(dev->mt76.dev, "Set TX queue start CR for AX management (0x%x) = 0x%x\n",
+			 MT_ARB_TQSAXM0(phy->mt76->band_idx),
+			 mt76_rr(dev, MT_ARB_TQSAXM0(phy->mt76->band_idx)));
+	}
+
+	if (!ebf && is_atenl)
+		return mt7996_tm_txbf_apply_tx(phy, 1, false, true, true);
+
+	return 0;
+}
+
+static int
+mt7996_tm_txbf_phase_cal(struct mt7996_phy *phy, u16 *val)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_bf_req req = {
+		.phase_cal = {
+			.tag = cpu_to_le16(BF_PHASE_CALIBRATION),
+			.len = cpu_to_le16(sizeof(req.phase_cal)),
+			.group = val[0],
+			.group_l_m_n = val[1],
+			.sx2 = val[2],
+			.cal_type = val[3],
+			.lna_gain_level = val[4],
+			.band_idx = phy->mt76->band_idx,
+			.version = val[5],
+		},
+	};
+	struct mt7996_txbf_phase *phase = (struct mt7996_txbf_phase *)dev->test.txbf_phase_cal;
+
+	/* reset phase status before update phase cal data */
+	phase[req.phase_cal.group].status = 0;
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &req,
+				 sizeof(req), false);
+}
+
+static int
+mt7996_tm_txbf_profile_update_all(struct mt7996_phy *phy, u16 *val)
+{
+	struct mt7996_dev *dev = phy->dev;
+	u8 nss = hweight16(phy->mt76->chainmask);
+	u16 pfmu_idx = val[0];
+	u16 subc_id = val[1];
+	u16 angle11 = val[2];
+	u16 angle21 = val[3];
+	u16 angle31 = val[4];
+	u16 angle41 = val[5];
+	u16 angle51 = val[6];
+	s16 phi11 = 0, phi21 = 0, phi31 = 0, phi41 = 0;
+	s16 *pfmu_data;
+	int offs = subc_id * sizeof(struct mt7996_pfmu_data) / sizeof(*pfmu_data);
+
+	if (subc_id > MT7996_TXBF_SUBCAR_NUM - 1)
+		return -EINVAL;
+
+	if (nss == 2) {
+		phi11 = (s16)(angle21 - angle11);
+	} else if (nss == 3) {
+		phi11 = (s16)(angle31 - angle11);
+		phi21 = (s16)(angle31 - angle21);
+	} else if (nss == 5) {
+		phi11 = (s16)(angle51 - angle11);
+		phi21 = (s16)(angle51 - angle21);
+		phi31 = (s16)(angle51 - angle31);
+		phi41 = (s16)(angle51 - angle41);
+		offs = subc_id * sizeof(struct mt7996_pfmu_data_5x5) / sizeof(*pfmu_data);
+	} else {
+		phi11 = (s16)(angle41 - angle11);
+		phi21 = (s16)(angle41 - angle21);
+		phi31 = (s16)(angle41 - angle31);
+	}
+
+	pfmu_data = (s16 *)dev->test.txbf_pfmu_data;
+	pfmu_data += offs;
+
+	if (subc_id < 32)
+		pfmu_data[0] = cpu_to_le16(subc_id + 224);
+	else
+		pfmu_data[0] = cpu_to_le16(subc_id - 32);
+
+	pfmu_data[1] = cpu_to_le16(phi11);
+	pfmu_data[2] = cpu_to_le16(phi21);
+	pfmu_data[3] = cpu_to_le16(phi31);
+	if (nss == 5)
+		pfmu_data[4] = cpu_to_le16(phi41);
+
+	if (subc_id == MT7996_TXBF_SUBCAR_NUM - 1) {
+		struct mt7996_tm_bf_req req = {
+			.pfmu_data_all = {
+				.tag = cpu_to_le16(BF_PROFILE_WRITE_20M_ALL_5X5),
+				.len = cpu_to_le16(sizeof(req.pfmu_data_all)),
+				.pfmu_id = pfmu_idx,
+				.band_idx = phy->mt76->band_idx,
+			},
+		};
+		int size = MT7996_TXBF_PFMU_DATA_LEN_5X5;
+
+		if (nss != 5) {
+			size = MT7996_TXBF_PFMU_DATA_LEN;
+			req.pfmu_data_all.tag = cpu_to_le16(BF_PROFILE_WRITE_20M_ALL);
+			req.pfmu_data_all.len = cpu_to_le16(sizeof(req.pfmu_data_all) -
+							    MT7996_TXBF_PFMU_DATA_LEN_5X5 + size);
+		}
+		memcpy(req.pfmu_data_all.buf, dev->test.txbf_pfmu_data, size);
+
+		return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF),
+					 &req, sizeof(req), true);
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_txbf_e2p_update(struct mt7996_phy *phy)
+{
+#define TXBF_PHASE_EEPROM_START_OFFSET		0xc00
+#define TXBF_PHASE_GROUP_EEPROM_OFFSET_VER_1	46
+#define TXBF_PHASE_G0_EEPROM_OFFSET_VER_2	29
+#define TXBF_PHASE_GX_EEPROM_OFFSET_VER_2	sizeof(struct mt7992_txbf_phase_info_5g)
+	struct mt7996_txbf_phase *phase, *p;
+	struct mt7996_dev *dev = phy->dev;
+	u8 *eeprom = dev->mt76.eeprom.data;
+	u16 offset;
+	int i;
+
+	offset = TXBF_PHASE_EEPROM_START_OFFSET;
+	phase = (struct mt7996_txbf_phase *)dev->test.txbf_phase_cal;
+	for (i = 0; i < MAX_PHASE_GROUP_NUM; i++) {
+		p = &phase[i];
+
+		if (!p->status)
+			continue;
+
+		/* copy phase cal data to eeprom */
+		mt7996_tm_txbf_phase_copy(dev, eeprom + offset, p->buf, i);
+		if (get_ibf_version(dev) == IBF_VER_1)
+			offset += TXBF_PHASE_GROUP_EEPROM_OFFSET_VER_1;
+		else
+			offset += i ? TXBF_PHASE_GX_EEPROM_OFFSET_VER_2 :
+				      TXBF_PHASE_G0_EEPROM_OFFSET_VER_2;
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_txbf_apply_tx(struct mt7996_phy *phy, u16 wlan_idx, bool ebf,
+			bool ibf, bool phase_cal)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_bf_req req = {
+		.tx_apply = {
+			.tag = cpu_to_le16(BF_DATA_PACKET_APPLY),
+			.len = cpu_to_le16(sizeof(req.tx_apply)),
+			.wlan_idx = cpu_to_le16(wlan_idx),
+			.ebf = ebf,
+			.ibf = ibf,
+			.phase_cal = phase_cal,
+		},
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &req, sizeof(req), false);
+}
+
+static int
+mt7996_tm_txbf_set_tx(struct mt7996_phy *phy, u16 *val)
+{
+	bool bf_on = val[0], update = val[3];
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_pfmu_tag *tag = dev->test.txbf_pfmu_tag;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+
+	if (bf_on) {
+		mt7996_tm_set_rx_frames(phy, false);
+		mt7996_tm_set_tx_frames(phy, false);
+		mt7996_mcu_set_txbf_internal(phy, BF_PFMU_TAG_READ, 2, true);
+		tag->t1.invalid_prof = false;
+		mt7996_tm_txbf_profile_tag_write(phy, 2, tag);
+		td->bf_ever_en = true;
+
+		if (update)
+			mt7996_tm_txbf_apply_tx(phy, 1, 0, 1, 1);
+	} else {
+		if (!td->bf_ever_en) {
+			mt7996_tm_set_rx_frames(phy, false);
+			mt7996_tm_set_tx_frames(phy, false);
+
+			if (update)
+				mt7996_tm_txbf_apply_tx(phy, 1, 0, 0, 0);
+		} else {
+			td->bf_ever_en = false;
+
+			mt7996_mcu_set_txbf_internal(phy, BF_PFMU_TAG_READ, 2, true);
+			tag->t1.invalid_prof = true;
+			mt7996_tm_txbf_profile_tag_write(phy, 2, tag);
+		}
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_trigger_sounding(struct mt7996_phy *phy, u16 *val, bool en)
+{
+	struct mt7996_dev *dev = phy->dev;
+	u8 sounding_mode = val[0];
+	u8 sta_num = val[1];
+	u32 sounding_interval = (u32)val[2] << 2;	/* input unit: 4ms */
+	u16 tag = en ? BF_SOUNDING_ON : BF_SOUNDING_OFF;
+	struct mt7996_tm_bf_req req = {
+		.sounding = {
+			.tag = cpu_to_le16(tag),
+			.len = cpu_to_le16(sizeof(req.sounding)),
+			.snd_mode = sounding_mode,
+			.sta_num = sta_num,
+			.wlan_id = {
+				cpu_to_le16(val[3]),
+				cpu_to_le16(val[4]),
+				cpu_to_le16(val[5]),
+				cpu_to_le16(val[6])
+			},
+			.snd_period = cpu_to_le32(sounding_interval),
+		},
+	};
+
+	if (sounding_mode > SOUNDING_MODE_MAX)
+		return -EINVAL;
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF),
+				 &req, sizeof(req), false);
+}
+
+static int
+mt7996_tm_txbf_txcmd(struct mt7996_phy *phy, u16 *val)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_bf_req req = {
+		.txcmd = {
+			.tag = cpu_to_le16(BF_CMD_TXCMD),
+			.len = cpu_to_le16(sizeof(req.txcmd)),
+			.action = val[0],
+			.bf_manual = val[1],
+			.bf_bit = val[2],
+		},
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &req, sizeof(req), false);
+}
+
+static int
+mt7996_tm_set_txbf(struct mt7996_phy *phy)
+{
+#define TXBF_IS_DUT_MASK	BIT(0)
+#define TXBF_IBF_MASK		BIT(1)
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	u16 *val = td->txbf_param;
+
+	dev_info(phy->dev->mt76.dev,
+		 "ibf cal process: act = %u, val = %u, %u, %u, %u, %u, %u, %u, %u\n",
+		 td->txbf_act, val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7]);
+
+	switch (td->txbf_act) {
+	case MT76_TM_TXBF_ACT_GOLDEN_INIT:
+	case MT76_TM_TXBF_ACT_INIT:
+	case MT76_TM_TX_EBF_ACT_GOLDEN_INIT:
+	case MT76_TM_TX_EBF_ACT_INIT:
+		td->ibf = !u32_get_bits(td->txbf_act, TXBF_IBF_MASK);
+		td->ebf = true;
+		td->is_txbf_dut = !!u32_get_bits(td->txbf_act, TXBF_IS_DUT_MASK);
+		return mt7996_tm_txbf_init(phy, val);
+	case MT76_TM_TXBF_ACT_UPDATE_CH:
+		mt7996_tm_update_channel(phy);
+		break;
+	case MT76_TM_TXBF_ACT_PHASE_COMP:
+		return mt7996_tm_txbf_phase_comp(phy, val);
+	case MT76_TM_TXBF_ACT_TX_PREP:
+		return mt7996_tm_txbf_set_tx(phy, val);
+	case MT76_TM_TXBF_ACT_IBF_PROF_UPDATE:
+		return mt7996_tm_txbf_profile_update(phy, val, false);
+	case MT76_TM_TXBF_ACT_EBF_PROF_UPDATE:
+		return mt7996_tm_txbf_profile_update(phy, val, true);
+	case MT76_TM_TXBF_ACT_PHASE_CAL:
+		return mt7996_tm_txbf_phase_cal(phy, val);
+	case MT76_TM_TXBF_ACT_PROF_UPDATE_ALL_CMD:
+	case MT76_TM_TXBF_ACT_PROF_UPDATE_ALL:
+		return mt7996_tm_txbf_profile_update_all(phy, val);
+	case MT76_TM_TXBF_ACT_E2P_UPDATE:
+		return mt7996_tm_txbf_e2p_update(phy);
+	case MT76_TM_TXBF_ACT_APPLY_TX: {
+		u16 wlan_idx = val[0];
+		bool ebf = !!val[1], ibf = !!val[2], phase_cal = !!val[4];
+
+		return mt7996_tm_txbf_apply_tx(phy, wlan_idx, ebf, ibf, phase_cal);
+	}
+	case MT76_TM_TXBF_ACT_TRIGGER_SOUNDING:
+		return mt7996_tm_trigger_sounding(phy, val, true);
+	case MT76_TM_TXBF_ACT_STOP_SOUNDING:
+		memset(val, 0, sizeof(td->txbf_param));
+		return mt7996_tm_trigger_sounding(phy, val, false);
+	case MT76_TM_TXBF_ACT_PROFILE_TAG_READ:
+	case MT76_TM_TXBF_ACT_PROFILE_TAG_WRITE:
+	case MT76_TM_TXBF_ACT_PROFILE_TAG_INVALID: {
+		u8 pfmu_idx = val[0];
+		bool bfer = !!val[1];
+		struct mt7996_dev *dev = phy->dev;
+		struct mt7996_pfmu_tag *tag = dev->test.txbf_pfmu_tag;
+
+		if (!tag) {
+			dev_err(dev->mt76.dev,
+				"pfmu tag is not initialized!\n");
+			return 0;
+		}
+
+		if (td->txbf_act == MT76_TM_TXBF_ACT_PROFILE_TAG_WRITE)
+			return mt7996_tm_txbf_profile_tag_write(phy, pfmu_idx, tag);
+		else if (td->txbf_act == MT76_TM_TXBF_ACT_PROFILE_TAG_READ)
+			return mt7996_mcu_set_txbf_internal(phy, BF_PFMU_TAG_READ, pfmu_idx, bfer);
+
+		tag->t1.invalid_prof = !!val[0];
+
+		return 0;
+	}
+	case MT76_TM_TXBF_ACT_STA_REC_READ:
+		return mt7996_mcu_set_txbf_internal(phy, BF_STA_REC_READ, val[0], 0);
+	case MT76_TM_TXBF_ACT_TXCMD:
+		return mt7996_tm_txbf_txcmd(phy, val);
+	default:
+		break;
+	};
+
+	return 0;
+}
+
+static void
+mt7996_tm_update_params(struct mt7996_phy *phy, u32 changed)
+{
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+
+	if (changed & BIT(TM_CHANGED_FREQ_OFFSET)) {
+		mt7996_tm_set(dev, SET_ID(FREQ_OFFSET), td->freq_offset);
+		mt7996_tm_set(dev, SET_ID(FREQ_OFFSET_C2), td->freq_offset);
+	}
+	if (changed & BIT(TM_CHANGED_TXPOWER))
+		mt7996_tm_set(dev, SET_ID(POWER), td->tx_power[0]);
+	if (changed & BIT(TM_CHANGED_SKU_EN)) {
+		mt7996_tm_update_channel(phy);
+		mt7996_mcu_set_tx_power_ctrl(phy, POWER_CTRL(SKU_POWER_LIMIT), td->sku_en);
+		mt7996_mcu_set_tx_power_ctrl(phy, POWER_CTRL(BACKOFF_POWER_LIMIT), td->sku_en);
+		mt7996_mcu_set_txpower_sku(phy, &phy->mt76->monitor_vif->bss_conf);
+	}
+	if (changed & BIT(TM_CHANGED_TX_LENGTH)) {
+		mt7996_tm_set(dev, SET_ID(TX_LEN), td->tx_mpdu_len);
+		mt7996_tm_set(dev, SET_ID(TX_TIME), 0);
+	}
+	if (changed & BIT(TM_CHANGED_TX_TIME)) {
+		mt7996_tm_set(dev, SET_ID(TX_LEN), 0);
+		mt7996_tm_set(dev, SET_ID(TX_TIME), td->tx_time);
+	}
+	if (changed & BIT(TM_CHANGED_CFG)) {
+		u32 func_idx = td->cfg.enable ? SET_ID(CFG_ON) : SET_ID(CFG_OFF);
+
+		mt7996_tm_set(dev, func_idx, td->cfg.type);
+	}
+	if ((changed & BIT(TM_CHANGED_OFF_CHAN_CH)) &&
+	    (changed & BIT(TM_CHANGED_OFF_CHAN_BW)))
+		mt7996_tm_set_offchan(phy, !(changed & BIT(TM_CHANGED_OFF_CHAN_CENTER_CH)));
+	if ((changed & BIT(TM_CHANGED_IPI_THRESHOLD)) &&
+	    (changed & BIT(TM_CHANGED_IPI_PERIOD)))
+		mt7996_tm_set_ipi(phy);
+	if (changed & BIT(TM_CHANGED_IPI_RESET))
+		mt7996_tm_ipi_hist_ctrl(phy, NULL, RDD_SET_IPI_HIST_RESET);
+	if (changed & BIT(TM_CHANGED_TXBF_ACT))
+		mt7996_tm_set_txbf(phy);
+	if (changed & BIT(TM_CHANGED_TX_ANTENNA)) {
+		mt7996_tm_set_antenna(phy, SET_ID(TX_PATH));
+		mt7996_tm_set_antenna(phy, SET_ID(RX_PATH));
+	}
+	if (changed & BIT(TM_CHANGED_TX_RATE_NSS))
+		mt7996_tm_set(dev, SET_ID(NSS), td->tx_rate_nss);
+	if (changed & BIT(TM_CHANGED_TX_RATE_IDX))
+		mt7996_tm_set(dev, SET_ID(TX_RATE), td->tx_rate_idx);
+}
+
+static int
+mt7996_tm_set_state(struct mt76_phy *mphy, enum mt76_testmode_state state)
+{
+	struct mt76_testmode_data *td = &mphy->test;
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+	enum mt76_testmode_state prev_state = td->state;
+
+	if (!dev->testmode_enable)
+		return -EPERM;
+
+	mphy->test.state = state;
+
+	if (prev_state != MT76_TM_STATE_OFF)
+		mt7996_tm_set(dev, SET_ID(BAND_IDX), mphy->band_idx);
+
+	if (prev_state == MT76_TM_STATE_TX_FRAMES ||
+	    state == MT76_TM_STATE_TX_FRAMES)
+		mt7996_tm_set_tx_frames(phy, state == MT76_TM_STATE_TX_FRAMES);
+	else if (prev_state == MT76_TM_STATE_RX_FRAMES ||
+		 state == MT76_TM_STATE_RX_FRAMES)
+		mt7996_tm_set_rx_frames(phy, state == MT76_TM_STATE_RX_FRAMES);
+	else if (prev_state == MT76_TM_STATE_TX_CONT ||
+		 state == MT76_TM_STATE_TX_CONT)
+		mt7996_tm_set_tx_cont(phy, state == MT76_TM_STATE_TX_CONT);
+	else if (prev_state == MT76_TM_STATE_OFF ||
+		 state == MT76_TM_STATE_OFF)
+		mt7996_tm_init(phy, !(state == MT76_TM_STATE_OFF));
+	else if (state >= MT76_TM_STATE_GROUP_PREK && state <= MT76_TM_STATE_GROUP_PREK_CLEAN)
+		return mt7996_tm_group_prek(phy, state);
+	else if (state >= MT76_TM_STATE_DPD_2G && state <= MT76_TM_STATE_DPD_CLEAN)
+		return mt7996_tm_dpd_prek(phy, state);
+
+	if ((state == MT76_TM_STATE_IDLE &&
+	     prev_state == MT76_TM_STATE_OFF) ||
+	    (state == MT76_TM_STATE_OFF &&
+	     prev_state == MT76_TM_STATE_IDLE)) {
+		u32 changed = 0;
+		int i, ret;
+
+		for (i = 0; i < ARRAY_SIZE(tm_change_map); i++) {
+			u16 cur = tm_change_map[i];
+
+			if (mt76_testmode_param_present(td, cur))
+				changed |= BIT(i);
+		}
+
+		ret = mt7996_tm_check_antenna(phy);
+		if (ret)
+			return ret;
+
+		mt7996_tm_update_params(phy, changed);
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_set_params(struct mt76_phy *mphy, struct nlattr **tb,
+		     enum mt76_testmode_state new_state)
+{
+	struct mt76_testmode_data *td = &mphy->test;
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+	u32 changed = 0;
+	int i, ret;
+
+	BUILD_BUG_ON(NUM_TM_CHANGED >= 32);
+
+	if (new_state == MT76_TM_STATE_OFF ||
+	    td->state == MT76_TM_STATE_OFF)
+		return 0;
+
+	ret = mt7996_tm_check_antenna(phy);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < ARRAY_SIZE(tm_change_map); i++) {
+		if (tb[tm_change_map[i]])
+			changed |= BIT(i);
+	}
+
+	mt7996_tm_set(dev, SET_ID(BAND_IDX), mphy->band_idx);
+	mt7996_tm_update_params(phy, changed);
+
+	return 0;
+}
+
+static int
+mt7996_tm_get_rx_stats(struct mt7996_phy *phy)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_rx_req req = {
+		.band = phy->mt76->band_idx,
+		.rx_stat_all = {
+			.tag = cpu_to_le16(UNI_TM_RX_STAT_GET_ALL_V2),
+			.len = cpu_to_le16(sizeof(req.rx_stat_all)),
+			.band_idx = phy->mt76->band_idx,
+		},
+	};
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_tm_rx_event *rx_stats;
+	struct mt7996_tm_rx_event_stat_all *rx_stats_all;
+	struct sk_buff *skb;
+	enum mt76_rxq_id qid;
+	int i, ret = 0;
+	u32 mac_rx_mdrdy_cnt;
+	u16 mac_rx_len_mismatch, fcs_err_count;
+
+	if (td->state != MT76_TM_STATE_RX_FRAMES)
+		return 0;
+
+	ret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_WM_UNI_CMD_QUERY(TESTMODE_RX_STAT),
+					&req, sizeof(req), true, &skb);
+
+	if (ret)
+		return ret;
+
+	rx_stats = (struct mt7996_tm_rx_event *)skb->data;
+	rx_stats_all = &rx_stats->rx_stat_all;
+
+	phy->test.last_freq_offset = le32_to_cpu(rx_stats_all->user_info[0].freq_offset);
+	phy->test.last_snr = le32_to_cpu(rx_stats_all->user_info[0].snr);
+	for (i = 0; i < ARRAY_SIZE(phy->test.last_rcpi); i++) {
+		phy->test.last_rcpi[i] = le16_to_cpu(rx_stats_all->rxv_info[i].rcpi);
+		phy->test.last_rssi[i] = le16_to_cpu(rx_stats_all->rxv_info[i].rssi);
+		phy->test.last_ib_rssi[i] = rx_stats_all->fagc[i].ib_rssi;
+		phy->test.last_wb_rssi[i] = rx_stats_all->fagc[i].wb_rssi;
+	}
+
+	if (phy->mt76->band_idx == 2)
+		qid = MT_RXQ_BAND2;
+	else if (phy->mt76->band_idx == 1)
+		qid = MT_RXQ_BAND1;
+	else
+		qid = MT_RXQ_MAIN;
+
+	fcs_err_count = le16_to_cpu(rx_stats_all->band_info.mac_rx_fcs_err_cnt);
+	mac_rx_len_mismatch = le16_to_cpu(rx_stats_all->band_info.mac_rx_len_mismatch);
+	mac_rx_mdrdy_cnt = le32_to_cpu(rx_stats_all->band_info.mac_rx_mdrdy_cnt);
+	td->rx_stats.packets[qid] += mac_rx_mdrdy_cnt;
+	td->rx_stats.packets[qid] += fcs_err_count;
+	td->rx_stats.fcs_error[qid] += fcs_err_count;
+	td->rx_stats.len_mismatch += mac_rx_len_mismatch;
+
+	dev_kfree_skb(skb);
+
+	return ret;
+}
+
+static void
+mt7996_tm_reset_trx_stats(struct mt76_phy *mphy)
+{
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+
+	memset(&mphy->test.rx_stats, 0, sizeof(mphy->test.rx_stats));
+	mt7996_tm_set(dev, SET_ID(TRX_COUNTER_RESET), 0);
+}
+
+static int
+mt7996_tm_get_tx_stats(struct mt7996_phy *phy)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	int ret;
+
+	if (td->state != MT76_TM_STATE_TX_FRAMES)
+		return 0;
+
+	ret = mt7996_tm_get(dev, GET_ID(TXED_COUNT), 0, &td->tx_done);
+	if (ret)
+		return ret;
+
+	td->tx_pending = td->tx_count - td->tx_done;
+
+	return ret;
+}
+
+static int
+mt7996_tm_dump_stats(struct mt76_phy *mphy, struct sk_buff *msg)
+{
+	struct mt7996_phy *phy = mphy->priv;
+	void *rx, *rssi;
+	int i;
+
+	mt7996_tm_set(phy->dev, SET_ID(BAND_IDX), mphy->band_idx);
+	mt7996_tm_get_rx_stats(phy);
+	mt7996_tm_get_tx_stats(phy);
+
+	rx = nla_nest_start(msg, MT76_TM_STATS_ATTR_LAST_RX);
+	if (!rx)
+		return -ENOMEM;
+
+	if (nla_put_s32(msg, MT76_TM_RX_ATTR_FREQ_OFFSET, phy->test.last_freq_offset))
+		return -ENOMEM;
+
+	rssi = nla_nest_start(msg, MT76_TM_RX_ATTR_RCPI);
+	if (!rssi)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(phy->test.last_rcpi); i++)
+		if (nla_put_u8(msg, i, phy->test.last_rcpi[i]))
+			return -ENOMEM;
+
+	nla_nest_end(msg, rssi);
+
+	rssi = nla_nest_start(msg, MT76_TM_RX_ATTR_RSSI);
+	if (!rssi)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(phy->test.last_rssi); i++)
+		if (nla_put_s8(msg, i, phy->test.last_rssi[i]))
+			return -ENOMEM;
+
+	nla_nest_end(msg, rssi);
+
+	rssi = nla_nest_start(msg, MT76_TM_RX_ATTR_IB_RSSI);
+	if (!rssi)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(phy->test.last_ib_rssi); i++)
+		if (nla_put_s8(msg, i, phy->test.last_ib_rssi[i]))
+			return -ENOMEM;
+
+	nla_nest_end(msg, rssi);
+
+	rssi = nla_nest_start(msg, MT76_TM_RX_ATTR_WB_RSSI);
+	if (!rssi)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(phy->test.last_wb_rssi); i++)
+		if (nla_put_s8(msg, i, phy->test.last_wb_rssi[i]))
+			return -ENOMEM;
+
+	nla_nest_end(msg, rssi);
+
+	if (nla_put_u8(msg, MT76_TM_RX_ATTR_SNR, phy->test.last_snr))
+		return -ENOMEM;
+
+	nla_nest_end(msg, rx);
+
+	return 0;
+}
+
+static int
+mt7996_tm_write_back_to_efuse(struct mt7996_dev *dev)
+{
+	struct mt7996_mcu_eeprom_info req = {
+		.tag = cpu_to_le16(UNI_EFUSE_ACCESS),
+		.len = cpu_to_le16(sizeof(req) - 4),
+	};
+	u8 read_buf[MT76_TM_EEPROM_BLOCK_SIZE], *eeprom = dev->mt76.eeprom.data;
+	int i, ret = -EINVAL;
+
+	/* prevent from damaging chip id in efuse */
+	if (mt76_chip(&dev->mt76) != get_unaligned_le16(eeprom))
+		goto out;
+
+	for (i = 0; i < MT7996_EEPROM_SIZE; i += MT76_TM_EEPROM_BLOCK_SIZE) {
+		req.addr = cpu_to_le32(i);
+		memcpy(req.data, eeprom + i, MT76_TM_EEPROM_BLOCK_SIZE);
+
+		ret = mt7996_mcu_get_eeprom(dev, i, read_buf, sizeof(read_buf));
+		if (ret) {
+			if (ret != -EINVAL)
+				return ret;
+
+			memset(read_buf, 0, MT76_TM_EEPROM_BLOCK_SIZE);
+		}
+
+		if (!memcmp(req.data, read_buf, MT76_TM_EEPROM_BLOCK_SIZE))
+			continue;
+
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(EFUSE_CTRL),
+					&req, sizeof(req), true);
+		if (ret)
+			return ret;
+	}
+
+out:
+	return ret;
+}
+
+static int
+mt7996_tm_set_eeprom(struct mt76_phy *mphy, u32 offset, u8 *val, u8 action)
+{
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+	u8 *eeprom = dev->mt76.eeprom.data;
+	int ret = 0;
+
+	if (offset >= MT7996_EEPROM_SIZE)
+		return -EINVAL;
+
+	switch (action) {
+	case MT76_TM_EEPROM_ACTION_UPDATE_DATA:
+		memcpy(eeprom + offset, val, MT76_TM_EEPROM_BLOCK_SIZE);
+		break;
+	case MT76_TM_EEPROM_ACTION_UPDATE_BUFFER_MODE:
+		ret = mt7996_mcu_set_eeprom(dev);
+		break;
+	case MT76_TM_EEPROM_ACTION_WRITE_TO_EFUSE:
+		ret = mt7996_tm_write_back_to_efuse(dev);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+const struct mt76_testmode_ops mt7996_testmode_ops = {
+	.set_state = mt7996_tm_set_state,
+	.set_params = mt7996_tm_set_params,
+	.dump_stats = mt7996_tm_dump_stats,
+	.reset_rx_stats = mt7996_tm_reset_trx_stats,
+	.tx_stop = mt7996_tm_tx_stop,
+	.set_eeprom = mt7996_tm_set_eeprom,
+	.dump_precal = mt7996_tm_dump_precal,
+};
diff --git a/mt7996/testmode.h b/mt7996/testmode.h
new file mode 100644
index 00000000..ba1767ae
--- /dev/null
+++ b/mt7996/testmode.h
@@ -0,0 +1,378 @@
+/* SPDX-License-Identifier: ISC */
+/* Copyright (C) 2020 MediaTek Inc. */
+
+#ifndef __MT7996_TESTMODE_H
+#define __MT7996_TESTMODE_H
+
+enum {
+	TM_CBW_20MHZ,
+	TM_CBW_40MHZ,
+	TM_CBW_80MHZ,
+	TM_CBW_10MHZ,
+	TM_CBW_5MHZ,
+	TM_CBW_160MHZ,
+	TM_CBW_8080MHZ,
+	TM_CBW_320MHZ = 12,
+};
+
+/* BW defined in FW hal_cal_flow_rom.h */
+enum {
+	FW_CDBW_20MHZ,
+	FW_CDBW_40MHZ,
+	FW_CDBW_80MHZ,
+	FW_CDBW_160MHZ,
+	FW_CDBW_320MHZ,
+	FW_CDBW_5MHZ,
+	FW_CDBW_10MHZ,
+	FW_CDBW_8080MHZ,
+};
+
+enum {
+	BF_CDBW_20MHZ,
+	BF_CDBW_40MHZ,
+	BF_CDBW_80MHZ,
+	BF_CDBW_160MHZ,
+	BF_CDBW_320MHZ,
+	BF_CDBW_10MHZ = BF_CDBW_320MHZ,
+	BF_CDBW_5MHZ,
+	BF_CDBW_8080MHZ,
+};
+
+#define FIRST_CONTROL_CHAN_BITMAP_BW40		2
+#define FIRST_CONTROL_CHAN_BITMAP_BW80		4
+#define FIRST_CONTROL_CHAN_BITMAP_BW160		0x10010101
+
+enum bw_mapping_method {
+	BW_MAP_NL_TO_FW,
+	BW_MAP_NL_TO_TM,
+	BW_MAP_NL_TO_BF,
+	BW_MAP_NL_TO_MHZ,
+	BW_MAP_NL_TO_CONTROL_BITMAP_5G,
+
+	NUM_BW_MAP,
+};
+
+enum rate_mapping_type {
+	RATE_MODE_TO_PHY,
+	RATE_MODE_TO_LM,
+
+	NUM_RATE_MAP,
+};
+
+struct tm_cal_param {
+	__le32 func_data;
+	u8 band_idx;
+	u8 rsv[3];
+};
+
+struct mt7996_tm_rf_test {
+	__le16 tag;
+	__le16 len;
+
+	u8 action;
+	u8 icap_len;
+	u8 _rsv[2];
+	union {
+		__le32 op_mode;
+		__le32 freq;
+
+		struct {
+			__le32 func_idx;
+			union {
+				__le32 func_data;
+				__le32 cal_dump;
+				struct tm_cal_param cal_param;
+				u8 _pad[80];
+			} param;
+		} rf;
+	} op;
+} __packed;
+
+struct mt7996_tm_req {
+	u8 _rsv[4];
+
+	struct mt7996_tm_rf_test rf_test;
+} __packed;
+
+struct mt7996_tm_rf_test_data {
+	__le32 cal_idx;
+	__le32 cal_type;
+	u8 cal_data[0];
+} __packed;
+
+struct mt7996_tm_rf_test_result {
+	__le32 func_idx;
+	__le32 payload_length;
+	u8 data[0];
+};
+
+struct mt7996_tm_event {
+	u8 _rsv[4];
+
+	__le16 tag;
+	__le16 len;
+	struct mt7996_tm_rf_test_result result;
+} __packed;
+
+#define RF_TEST_RE_CAL		0x01
+
+enum {
+	RF_ACTION_SWITCH_TO_RF_TEST,
+	RF_ACTION_IN_RF_TEST,
+	RF_ACTION_SET = 3,
+	RF_ACTION_GET,
+};
+
+#define RF_TEST_ICAP_LEN	120
+
+enum {
+	RF_OPER_NORMAL,
+	RF_OPER_RF_TEST,
+	RF_OPER_ICAP,
+	RF_OPER_ICAP_OVERLAP,
+	RF_OPER_WIFI_SPECTRUM,
+};
+
+enum {
+	UNI_RF_TEST_CTRL,
+};
+
+#define RF_CMD(cmd)		RF_TEST_CMD_##cmd
+
+enum {
+	RF_TEST_CMD_STOP_TEST = 0,
+	RF_TEST_CMD_START_TX = 1,
+	RF_TEST_CMD_START_RX = 2,
+	RF_TEST_CMD_CONT_WAVE = 10,
+	RF_TEST_CMD_TX_COMMIT = 18,
+	RF_TEST_CMD_RX_COMMIT = 19,
+};
+
+#define SET_ID(id)		RF_TEST_ID_SET_##id
+#define GET_ID(id)		RF_TEST_ID_GET_##id
+
+enum {
+	RF_TEST_ID_SET_COMMAND = 1,
+	RF_TEST_ID_SET_POWER = 2,
+	RF_TEST_ID_SET_TX_RATE = 3,
+	RF_TEST_ID_SET_TX_MODE = 4,
+	RF_TEST_ID_SET_TX_LEN = 6,
+	RF_TEST_ID_SET_TX_COUNT = 7,
+	RF_TEST_ID_SET_IPG = 8,
+	RF_TEST_ID_SET_GI = 16,
+	RF_TEST_ID_SET_STBC = 17,
+	RF_TEST_ID_SET_CHAN_FREQ = 18,
+	RF_TEST_ID_GET_TXED_COUNT = 32,
+	RF_TEST_ID_SET_CONT_WAVE_MODE = 65,
+	RF_TEST_ID_SET_DA = 68,
+	RF_TEST_ID_SET_SA = 69,
+	RF_TEST_ID_SET_CBW = 71,
+	RF_TEST_ID_SET_DBW = 72,
+	RF_TEST_ID_SET_PRIMARY_CH = 73,
+	RF_TEST_ID_SET_ENCODE_MODE = 74,
+	RF_TEST_ID_SET_BAND = 90,
+	RF_TEST_ID_SET_TRX_COUNTER_RESET = 91,
+	RF_TEST_ID_SET_MAC_HEADER = 101,
+	RF_TEST_ID_SET_SEQ_CTRL = 102,
+	RF_TEST_ID_SET_PAYLOAD = 103,
+	RF_TEST_ID_SET_BAND_IDX = 104,
+	RF_TEST_ID_SET_RX_PATH = 106,
+	RF_TEST_ID_SET_FREQ_OFFSET = 107,
+	RF_TEST_ID_GET_FREQ_OFFSET = 108,
+	RF_TEST_ID_SET_TX_PATH = 113,
+	RF_TEST_ID_SET_NSS = 114,
+	RF_TEST_ID_SET_ANT_MASK = 115,
+	RF_TEST_ID_SET_IBF_ENABLE = 126,
+	RF_TEST_ID_SET_EBF_ENABLE = 127,
+	RF_TEST_ID_GET_TX_POWER = 136,
+	RF_TEST_ID_SET_RX_MU_AID = 157,
+	RF_TEST_ID_SET_HW_TX_MODE = 167,
+	RF_TEST_ID_SET_PUNCTURE = 168,
+	RF_TEST_ID_SET_FREQ_OFFSET_C2 = 171,
+	RF_TEST_ID_GET_FREQ_OFFSET_C2 = 172,
+	RF_TEST_ID_SET_CFG_ON = 176,
+	RF_TEST_ID_SET_CFG_OFF = 177,
+	RF_TEST_ID_SET_BSSID = 189,
+	RF_TEST_ID_SET_TX_TIME = 190,
+	RF_TEST_ID_SET_MAX_PE = 191,
+	RF_TEST_ID_SET_AID_OFFSET = 204,
+};
+
+#define POWER_CTRL(type)	UNI_TXPOWER_##type##_CTRL
+
+struct mt7996_tm_rx_stat_user_ctrl {
+	__le16 tag;
+	__le16 len;
+
+	u8 band_idx;
+	u8 rsv;
+	__le16 user_idx;
+} __packed;
+
+struct mt7996_tm_rx_stat_all {
+	__le16 tag;
+	__le16 len;
+
+	u8 band_idx;
+	u8 rsv[3];
+} __packed;
+
+struct mt7996_tm_rx_req {
+	u8 band;
+	u8 _rsv[3];
+
+	union {
+		struct mt7996_tm_rx_stat_user_ctrl user_ctrl;
+		struct mt7996_tm_rx_stat_all rx_stat_all;
+	};
+} __packed;
+
+enum {
+	UNI_TM_RX_STAT_SET_USER_CTRL = 7,
+	UNI_TM_RX_STAT_GET_ALL_V2 = 9,
+};
+
+struct rx_band_info {
+	/* mac part */
+	__le16 mac_rx_fcs_err_cnt;
+	__le16 mac_rx_len_mismatch;
+	__le16 mac_rx_fcs_ok_cnt;
+	u8 rsv1[2];
+	__le32 mac_rx_mdrdy_cnt;
+
+	/* phy part */
+	__le16 phy_rx_fcs_err_cnt_cck;
+	__le16 phy_rx_fcs_err_cnt_ofdm;
+	__le16 phy_rx_pd_cck;
+	__le16 phy_rx_pd_ofdm;
+	__le16 phy_rx_sig_err_cck;
+	__le16 phy_rx_sfd_err_cck;
+	__le16 phy_rx_sig_err_ofdm;
+	__le16 phy_rx_tag_err_ofdm;
+	__le16 phy_rx_mdrdy_cnt_cck;
+	__le16 phy_rx_mdrdy_cnt_ofdm;
+} __packed;
+
+struct rx_band_info_ext {
+	/* mac part */
+	__le32 mac_rx_mpdu_cnt;
+
+	/* phy part */
+	u8 rsv[4];
+} __packed;
+
+struct rx_common_info {
+	__le16 rx_fifo_full;
+	u8 rsv[2];
+	__le32 aci_hit_low;
+	__le32 aci_hit_high;
+} __packed;
+
+struct rx_common_info_ext {
+	__le32 driver_rx_count;
+	__le32 sinr;
+	__le32 mu_pkt_count;
+
+	/* mac part */
+	u8 _rsv[4];
+
+	/* phy part */
+	u8 sig_mcs;
+	u8 rsv[3];
+} __packed;
+
+struct rx_rxv_info {
+	__le16 rcpi;
+	s16 rssi;
+	s16 snr;
+	s16 adc_rssi;
+} __packed;
+
+struct rx_rssi_info {
+	s8 ib_rssi;
+	s8 wb_rssi;
+	u8 rsv[2];
+} __packed;
+
+struct rx_user_info {
+	s32 freq_offset;
+	s32 snr;
+	__le32 fcs_err_count;
+} __packed;
+
+struct rx_user_info_ext {
+	s8 ne_var_db_all_user;
+	u8 rsv[3];
+} __packed;
+
+#define MAX_ANTENNA_NUM		8
+#define MAX_USER_NUM		16
+
+struct mt7996_tm_rx_event_stat_all {
+	__le16 tag;
+	__le16 len;
+
+	struct rx_band_info band_info;
+	struct rx_band_info_ext band_info_ext;
+	struct rx_common_info common_info;
+	struct rx_common_info_ext common_info_ext;
+
+	/* RXV info */
+	struct rx_rxv_info rxv_info[MAX_ANTENNA_NUM];
+
+	/* RSSI info */
+	struct rx_rssi_info fagc[MAX_ANTENNA_NUM];
+	struct rx_rssi_info inst[MAX_ANTENNA_NUM];
+
+	/* User info */
+	struct rx_user_info user_info[MAX_USER_NUM];
+	struct rx_user_info_ext user_info_ext[MAX_USER_NUM];
+} __packed;
+
+struct mt7996_tm_rx_event {
+	u8 _rsv[4];
+
+	union {
+		struct mt7996_tm_rx_event_stat_all rx_stat_all;
+	};
+} __packed;
+
+enum {
+	RDD_SET_IPI_CR_INIT,		/* CR initialization */
+	RDD_SET_IPI_HIST_RESET,		/* Reset IPI histogram counter */
+	RDD_SET_IDLE_POWER,		/* Idle power info */
+	RDD_SET_IPI_HIST_NUM
+};
+
+enum {
+	RDD_IPI_HIST_0,			/* IPI count for power <= -92 (dBm) */
+	RDD_IPI_HIST_1,			/* IPI count for -92 < power <= -89 (dBm) */
+	RDD_IPI_HIST_2,			/* IPI count for -89 < power <= -86 (dBm) */
+	RDD_IPI_HIST_3,			/* IPI count for -86 < power <= -83 (dBm) */
+	RDD_IPI_HIST_4,			/* IPI count for -83 < power <= -80 (dBm) */
+	RDD_IPI_HIST_5,			/* IPI count for -80 < power <= -75 (dBm) */
+	RDD_IPI_HIST_6,			/* IPI count for -75 < power <= -70 (dBm) */
+	RDD_IPI_HIST_7,			/* IPI count for -70 < power <= -65 (dBm) */
+	RDD_IPI_HIST_8,			/* IPI count for -65 < power <= -60 (dBm) */
+	RDD_IPI_HIST_9,			/* IPI count for -60 < power <= -55 (dBm) */
+	RDD_IPI_HIST_10,		/* IPI count for -55 < power        (dBm) */
+	RDD_IPI_FREE_RUN_CNT,		/* IPI count for counter++ per 8 us */
+	RDD_IPI_HIST_ALL_CNT,		/* Get all IPI */
+	RDD_IPI_HIST_0_TO_10_CNT,	/* Get IPI histogram 0 to 10 */
+	RDD_IPI_HIST_2_TO_10_CNT,	/* Get IPI histogram 2 to 10 */
+	RDD_TX_ASSERT_TIME,		/* Get band 1 TX assert time */
+	RDD_IPI_HIST_NUM
+};
+
+#define POWER_INDICATE_HIST_MAX		RDD_IPI_FREE_RUN_CNT
+#define IPI_HIST_TYPE_NUM		(POWER_INDICATE_HIST_MAX + 1)
+
+struct mt7996_tm_rdd_ipi_ctrl {
+	u8 ipi_hist_idx;
+	u8 band_idx;
+	u8 rsv[2];
+	__le32 ipi_hist_val[IPI_HIST_TYPE_NUM];
+	__le32 tx_assert_time;		/* unit: us */
+} __packed;
+
+#endif
diff --git a/mt7996/trace.c b/mt7996/trace.c
new file mode 100644
index 00000000..ba36f79a
--- /dev/null
+++ b/mt7996/trace.c
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: ISC */
+/*
+ * Copyright (C) 2022 MediaTek Inc.
+ */
+
+#include <linux/module.h>
+
+#ifndef __CHECKER__
+#define CREATE_TRACE_POINTS
+#include "mt7996_trace.h"
+
+#endif
diff --git a/mt7996/vendor.c b/mt7996/vendor.c
new file mode 100644
index 00000000..0a15d050
--- /dev/null
+++ b/mt7996/vendor.c
@@ -0,0 +1,1396 @@
+// SPDX-License-Identifier: ISC
+/*
+ * Copyright (C) 2020, MediaTek Inc. All rights reserved.
+ */
+
+#include <net/netlink.h>
+
+#include "mt7996.h"
+#include "mcu.h"
+#include "vendor.h"
+#include "mtk_mcu.h"
+
+#ifdef CONFIG_MTK_VENDOR
+static const struct nla_policy
+mu_ctrl_policy[NUM_MTK_VENDOR_ATTRS_MU_CTRL] = {
+	[MTK_VENDOR_ATTR_MU_CTRL_ONOFF] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_MU_CTRL_DUMP] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_MU_CTRL_STRUCT] = {.type = NLA_BINARY },
+	[MTK_VENDOR_ATTR_MU_CTRL_BAND_IDX] = {.type = NLA_U8 },
+};
+
+static const struct nla_policy
+wireless_ctrl_policy[NUM_MTK_VENDOR_ATTRS_WIRELESS_CTRL] = {
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_AMSDU] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_AMPDU] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_CERT] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_RTS_SIGTA] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_FIXED_MCS] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_OFDMA] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_PPDU_TX_TYPE] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_NUSERS_OFDMA] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_MIMO] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_BA_BUFFER_SIZE] = {.type = NLA_U16 },
+};
+
+static const struct nla_policy
+wireless_dump_policy[NUM_MTK_VENDOR_ATTRS_WIRELESS_DUMP] = {
+	[MTK_VENDOR_ATTR_WIRELESS_DUMP_AMSDU] = { .type = NLA_U8 },
+};
+
+static const struct nla_policy
+amnt_ctrl_policy[NUM_MTK_VENDOR_ATTRS_AMNT_CTRL] = {
+	[MTK_VENDOR_ATTR_AMNT_CTRL_SET] = {.type = NLA_NESTED },
+	[MTK_VENDOR_ATTR_AMNT_CTRL_DUMP] = { .type = NLA_NESTED },
+};
+
+static const struct nla_policy
+amnt_set_policy[NUM_MTK_VENDOR_ATTRS_AMNT_SET] = {
+	[MTK_VENDOR_ATTR_AMNT_SET_INDEX] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_AMNT_SET_MACADDR] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),
+};
+
+static const struct nla_policy
+amnt_dump_policy[NUM_MTK_VENDOR_ATTRS_AMNT_DUMP] = {
+	[MTK_VENDOR_ATTR_AMNT_DUMP_INDEX] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_AMNT_DUMP_LEN] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_AMNT_DUMP_RESULT] = { .type = NLA_NESTED },
+};
+
+static struct nla_policy
+bss_color_ctrl_policy[NUM_MTK_VENDOR_ATTRS_BSS_COLOR_CTRL] = {
+	[MTK_VENDOR_ATTR_AVAL_BSS_COLOR_BMP] = { .type = NLA_U64 },
+};
+
+static const struct nla_policy
+edcca_ctrl_policy[NUM_MTK_VENDOR_ATTRS_EDCCA_CTRL] = {
+	[MTK_VENDOR_ATTR_EDCCA_CTRL_MODE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_CTRL_PRI20_VAL] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC20_VAL] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC40_VAL] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC80_VAL] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_CTRL_COMPENSATE] = { .type = NLA_S8 },
+	[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC160_VAL] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_CTRL_RADIO_IDX] = { .type = NLA_U8 },
+};
+
+static const struct nla_policy
+edcca_dump_policy[NUM_MTK_VENDOR_ATTRS_EDCCA_DUMP] = {
+	[MTK_VENDOR_ATTR_EDCCA_DUMP_MODE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_DUMP_PRI20_VAL] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_DUMP_SEC40_VAL] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_DUMP_SEC80_VAL] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_DUMP_SEC160_VAL] = { .type = NLA_U8 },
+};
+
+static const struct nla_policy
+three_wire_ctrl_policy[NUM_MTK_VENDOR_ATTRS_3WIRE_CTRL] = {
+	[MTK_VENDOR_ATTR_3WIRE_CTRL_MODE] = {.type = NLA_U8 },
+};
+
+static const struct nla_policy
+ibf_ctrl_policy[NUM_MTK_VENDOR_ATTRS_IBF_CTRL] = {
+	[MTK_VENDOR_ATTR_IBF_CTRL_ENABLE] = { .type = NLA_U8 },
+};
+
+static struct nla_policy
+pp_ctrl_policy[NUM_MTK_VENDOR_ATTRS_PP_CTRL] = {
+	[MTK_VENDOR_ATTR_PP_MODE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_PP_BAND_IDX] = { .type = NLA_U8 },
+};
+
+static const struct nla_policy
+rfeature_ctrl_policy[NUM_MTK_VENDOR_ATTRS_RFEATURE_CTRL] = {
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_HE_GI] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_HE_LTF] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE_CFG] = { .type = NLA_NESTED },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE_EN] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_ACK_PLCY] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TXBF] = { .type = NLA_U8 },
+};
+
+static const struct nla_policy
+background_radar_ctrl_policy[NUM_MTK_VENDOR_ATTRS_BACKGROUND_RADAR_CTRL] = {
+	[MTK_VENDOR_ATTR_BACKGROUND_RADAR_CTRL_MODE] = {.type = NLA_U8 },
+};
+
+static const struct nla_policy
+beacon_ctrl_policy[NUM_MTK_VENDOR_ATTRS_BEACON_CTRL] = {
+	[MTK_VENDOR_ATTR_BEACON_CTRL_MODE] = { .type = NLA_U8 },
+};
+
+static const struct nla_policy
+csi_ctrl_policy[NUM_MTK_VENDOR_ATTRS_CSI_CTRL] = {
+	[MTK_VENDOR_ATTR_CSI_CTRL_BAND_IDX] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_CSI_CTRL_CFG] = {.type = NLA_NESTED },
+	[MTK_VENDOR_ATTR_CSI_CTRL_CFG_MODE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_CSI_CTRL_CFG_TYPE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_CSI_CTRL_CFG_VAL1] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_CSI_CTRL_CFG_VAL2] = { .type = NLA_U32 },
+	[MTK_VENDOR_ATTR_CSI_CTRL_MAC_ADDR] = { .type = NLA_NESTED },
+	[MTK_VENDOR_ATTR_CSI_CTRL_DUMP_NUM] = { .type = NLA_U16 },
+	[MTK_VENDOR_ATTR_CSI_CTRL_DATA] = { .type = NLA_NESTED },
+};
+
+struct mt7996_amnt_data {
+	u8 idx;
+	u8 addr[ETH_ALEN];
+	s8 rssi[4];
+	u32 last_seen;
+};
+
+static int mt7996_vendor_mu_ctrl(struct wiphy *wiphy,
+				 struct wireless_dev *wdev,
+				 const void *data,
+				 int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_MU_CTRL];
+	struct mt7996_phy *phy = &dev->phy;
+	struct mt7996_muru *muru;
+	int err;
+	u8 val8, band_idx;
+	u32 val32 = 0;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_MU_CTRL_MAX, data, data_len,
+			mu_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	if (tb[MTK_VENDOR_ATTR_MU_CTRL_ONOFF] &&
+	    tb[MTK_VENDOR_ATTR_MU_CTRL_BAND_IDX]) {
+		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_MU_CTRL_ONOFF]);
+		band_idx = nla_get_u8(tb[MTK_VENDOR_ATTR_MU_CTRL_BAND_IDX]);
+		val32 |= FIELD_PREP(RATE_CFG_MODE, RATE_PARAM_AUTO_MU) |
+			 FIELD_PREP(RATE_CFG_VAL, val8) |
+			 FIELD_PREP(RATE_CFG_BAND_IDX, band_idx);
+		ieee80211_iterate_active_interfaces_atomic(hw, IEEE80211_IFACE_ITER_RESUME_ALL,
+							   mt7996_set_wireless_vif, &val32);
+	} else if (tb[MTK_VENDOR_ATTR_MU_CTRL_STRUCT]) {
+		muru = kzalloc(sizeof(struct mt7996_muru), GFP_KERNEL);
+
+		nla_memcpy(muru, tb[MTK_VENDOR_ATTR_MU_CTRL_STRUCT],
+			   sizeof(struct mt7996_muru));
+
+		err = mt7996_mcu_set_muru_cfg(phy, muru);
+		kfree(muru);
+	}
+
+	return err;
+}
+
+static int
+mt7996_vendor_mu_ctrl_dump(struct wiphy *wiphy, struct wireless_dev *wdev,
+			   struct sk_buff *skb, const void *data, int data_len,
+			   unsigned long *storage)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy;
+	struct mt76_phy *mphy;
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_MU_CTRL];
+	int len = 0, err;
+	u8 band_idx;
+
+	if (*storage == 1)
+		return -ENOENT;
+	*storage = 1;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_MU_CTRL_MAX, data, data_len,
+			mu_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	if (!tb[MTK_VENDOR_ATTR_MU_CTRL_BAND_IDX])
+		return -EINVAL;
+
+	band_idx = nla_get_u8(tb[MTK_VENDOR_ATTR_MU_CTRL_BAND_IDX]);
+	if (!mt7996_band_valid(dev, band_idx))
+		goto error;
+
+	mphy = dev->mt76.phys[band_idx];
+	if (!mphy)
+		goto error;
+
+	phy = (struct mt7996_phy *)mphy->priv;
+
+	if (nla_put_u8(skb, MTK_VENDOR_ATTR_MU_CTRL_DUMP, phy->muru_onoff))
+		return -ENOMEM;
+	len += 1;
+
+	return len;
+
+error:
+	dev_err(dev->mt76.dev, "Invalid band idx to dump\n");
+	return -EINVAL;
+}
+
+void mt7996_set_wireless_rts_sigta(struct ieee80211_hw *hw, u8 value) {
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy = &dev->phy;
+
+	switch (value) {
+	case BW_SIGNALING_STATIC:
+	case BW_SIGNALING_DYNAMIC:
+		mt7996_mcu_set_band_confg(phy, UNI_BAND_CONFIG_RTS_SIGTA_EN, true);
+		mt7996_mcu_set_band_confg(phy, UNI_BAND_CONFIG_DIS_SECCH_CCA_DET, false);
+		break;
+	default:
+		value = BW_SIGNALING_DISABLE;
+		mt7996_mcu_set_band_confg(phy, UNI_BAND_CONFIG_RTS_SIGTA_EN, false);
+		mt7996_mcu_set_band_confg(phy, UNI_BAND_CONFIG_DIS_SECCH_CCA_DET, true);
+		break;
+      }
+
+	phy->rts_bw_sig = value;
+
+	/* Set RTS Threshold to a lower Value */
+	mt7996_mcu_set_rts_thresh(phy, 500);
+}
+
+static int
+mt7996_vendor_wireless_ctrl_dump(struct wiphy *wiphy, struct wireless_dev *wdev,
+				 struct sk_buff *skb, const void *data, int data_len,
+				 unsigned long *storage)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	int len = 0;
+
+	if (*storage == 1)
+		return -ENOENT;
+	*storage = 1;
+
+	if (nla_put_u8(skb, MTK_VENDOR_ATTR_WIRELESS_DUMP_AMSDU,
+		       ieee80211_hw_check(hw, SUPPORTS_AMSDU_IN_AMPDU)))
+	return -ENOMEM;
+	len += 1;
+
+	return len;
+ }
+
+void mt7996_vendor_amnt_fill_rx(struct mt7996_phy *phy, struct sk_buff *skb)
+{
+	struct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;
+	struct mt7996_air_monitor_ctrl *ctrl = &phy->amnt_ctrl;
+	struct ieee80211_hdr *hdr = mt76_skb_get_hdr(skb);
+	__le16 fc = hdr->frame_control;
+	u8 addr[ETH_ALEN];
+	int i;
+
+	if (!ieee80211_has_fromds(fc))
+		ether_addr_copy(addr, hdr->addr2);
+	else if (ieee80211_has_tods(fc))
+		ether_addr_copy(addr, hdr->addr4);
+	else
+		ether_addr_copy(addr, hdr->addr3);
+
+	spin_lock_bh(&phy->amnt_lock);
+	for (i = 0; i < MT7996_AIR_MONITOR_MAX_ENTRY; i++) {
+		struct mt7996_air_monitor_entry *entry;
+
+		if (ether_addr_equal(addr, ctrl->entry[i].addr)) {
+			entry = &ctrl->entry[i];
+			entry->rssi[0] = status->chain_signal[0];
+			entry->rssi[1] = status->chain_signal[1];
+			entry->rssi[2] = status->chain_signal[2];
+			entry->rssi[3] = status->chain_signal[3];
+			entry->last_seen = jiffies;
+			break;
+		}
+	}
+	spin_unlock_bh(&phy->amnt_lock);
+}
+
+static int
+mt7996_vendor_smesh_ctrl(struct mt7996_phy *phy, u8 write,
+			 u8 enable, u8 *value)
+{
+#define UNI_CMD_SMESH_PARAM  0
+	struct mt7996_dev *dev = phy->dev;
+	struct smesh_param {
+		__le16 tag;
+		__le16 length;
+
+		u8 enable;
+		bool a2;
+		bool a1;
+		bool data;
+		bool mgnt;
+		bool ctrl;
+		u8 padding[2];
+	} req = {
+		.tag = cpu_to_le16(UNI_CMD_SMESH_PARAM),
+		.length = cpu_to_le16(sizeof(req) - 4),
+
+		.enable = enable,
+		.a2 = true,
+		.a1 = true,
+		.data = true,
+		.mgnt = false,
+		.ctrl = false,
+	};
+	struct smesh_param *res;
+	struct sk_buff *skb;
+	int ret = 0;
+
+	if (!value)
+		return -EINVAL;
+
+	ret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_WM_UNI_CMD(CFG_SMESH),
+					&req, sizeof(req), !write, &skb);
+
+	if (ret || write)
+		return ret;
+
+	res = (struct smesh_param *) skb->data;
+
+	*value = res->enable;
+
+	dev_kfree_skb(skb);
+
+	return 0;
+}
+
+static int
+mt7996_vendor_amnt_muar(struct mt7996_phy *phy, u8 muar_idx, u8 *addr)
+{
+#define UNI_CMD_MUAR_ENTRY  2
+	struct mt7996_dev *dev = phy->dev;
+	struct muar_entry {
+		__le16 tag;
+		__le16 length;
+
+		bool smesh;
+		u8 hw_bss_index;
+		u8 muar_idx;
+		u8 entry_add;
+		u8 mac_addr[6];
+		u8 padding[2];
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_CMD_MUAR_ENTRY),
+		.length = cpu_to_le16(sizeof(req) - 4),
+
+		.smesh = true,
+		.hw_bss_index = phy != &dev->phy,
+		.muar_idx = muar_idx,
+		.entry_add = 1,
+	};
+
+	ether_addr_copy(req.mac_addr, addr);
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(REPT_MUAR), &req,
+				 sizeof(req), true);
+}
+
+static int
+mt7996_vendor_amnt_set_en(struct mt7996_phy *phy, u8 enable)
+{
+	u8 status;
+	int ret;
+
+	ret = mt7996_vendor_smesh_ctrl(phy, 0, enable, &status);
+	if (ret)
+		return ret;
+
+	if (status == enable)
+		return 0;
+
+	ret = mt7996_vendor_smesh_ctrl(phy, 1, enable, &status);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int
+mt7996_vendor_amnt_set_addr(struct mt7996_phy *phy, u8 index, u8 *addr)
+{
+	struct mt7996_air_monitor_ctrl *amnt_ctrl = &phy->amnt_ctrl;
+	struct mt7996_air_monitor_group *group;
+	struct mt7996_air_monitor_entry *entry;
+	int ret, i, j;
+
+	if (index >= MT7996_AIR_MONITOR_MAX_ENTRY)
+		return -1;
+
+	spin_lock_bh(&phy->amnt_lock);
+	entry = &amnt_ctrl->entry[index];
+	if (!is_zero_ether_addr(addr)) {
+		if (entry->enable == false) {
+			for (i = 0; i < MT7996_AIR_MONITOR_MAX_GROUP; i++) {
+				group = &(amnt_ctrl->group[i]);
+				if (group->used[0] == false)
+					j = 0;
+				else if (group->used[1] == false)
+					j = 1;
+				else
+					continue;
+
+				group->enable = true;
+				group->used[j] = true;
+				entry->enable = true;
+				entry->group_idx = i;
+				entry->group_used_idx = j;
+				entry->muar_idx = 32 + 4 * i + 2 * j;
+				break;
+			}
+		}
+	} else {
+		group = &(amnt_ctrl->group[entry->group_idx]);
+
+		group->used[entry->group_used_idx] = false;
+		if (group->used[0] == false && group->used[1] == false)
+			group->enable = false;
+
+		entry->enable = false;
+	}
+	ether_addr_copy(entry->addr, addr);
+	amnt_ctrl->enable &= ~(1 << entry->group_idx);
+	amnt_ctrl->enable |= entry->enable << entry->group_idx;
+	spin_unlock_bh(&phy->amnt_lock);
+
+	ret = mt7996_vendor_amnt_muar(phy, entry->muar_idx, addr);
+	if (ret)
+		return ret;
+
+	return mt7996_vendor_amnt_set_en(phy, amnt_ctrl->enable);
+}
+
+static int
+mt7966_vendor_amnt_ctrl(struct wiphy *wiphy, struct wireless_dev *wdev,
+			const void *data, int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_phy *phy = &dev->phy;
+	struct nlattr *tb1[NUM_MTK_VENDOR_ATTRS_AMNT_CTRL];
+	struct nlattr *tb2[NUM_MTK_VENDOR_ATTRS_AMNT_SET];
+	u8 index = 0;
+	u8 mac_addr[ETH_ALEN];
+	int err;
+
+	err = nla_parse(tb1, MTK_VENDOR_ATTR_AMNT_CTRL_MAX, data, data_len,
+			amnt_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	if (!tb1[MTK_VENDOR_ATTR_AMNT_CTRL_SET])
+		return -EINVAL;
+
+	err = nla_parse_nested(tb2, MTK_VENDOR_ATTR_AMNT_SET_MAX,
+		tb1[MTK_VENDOR_ATTR_AMNT_CTRL_SET], amnt_set_policy, NULL);
+
+	if (!tb2[MTK_VENDOR_ATTR_AMNT_SET_INDEX] ||
+		!tb2[MTK_VENDOR_ATTR_AMNT_SET_MACADDR])
+		return -EINVAL;
+
+	index = nla_get_u8(tb2[MTK_VENDOR_ATTR_AMNT_SET_INDEX]);
+	memcpy(mac_addr, nla_data(tb2[MTK_VENDOR_ATTR_AMNT_SET_MACADDR]), ETH_ALEN);
+
+	return mt7996_vendor_amnt_set_addr(phy, index, mac_addr);
+}
+
+int mt7996_vendor_amnt_sta_remove(struct mt7996_phy *phy,
+				  struct ieee80211_sta *sta)
+{
+	u8 zero[ETH_ALEN] = {};
+	int i;
+
+	if (!phy->amnt_ctrl.enable)
+		return 0;
+
+	for (i = 0; i < MT7996_AIR_MONITOR_MAX_ENTRY; i++)
+		if (ether_addr_equal(sta->addr, phy->amnt_ctrl.entry[i].addr))
+			return mt7996_vendor_amnt_set_addr(phy, i, zero);
+	return 0;
+}
+
+static int
+mt7996_amnt_dump(struct mt7996_phy *phy, struct sk_buff *skb,
+		 u8 amnt_idx, int *attrtype)
+{
+	struct mt7996_air_monitor_entry *entry;
+	struct mt7996_amnt_data data;
+	u32 last_seen = 0;
+
+	spin_lock_bh(&phy->amnt_lock);
+	entry = &phy->amnt_ctrl.entry[amnt_idx];
+	if (entry->enable == 0) {
+		spin_unlock_bh(&phy->amnt_lock);
+		return 0;
+	}
+
+	last_seen = jiffies_to_msecs(jiffies - entry->last_seen);
+	ether_addr_copy(data.addr, entry->addr);
+	data.rssi[0] = entry->rssi[0];
+	data.rssi[1] = entry->rssi[1];
+	data.rssi[2] = entry->rssi[2];
+	data.rssi[3] = entry->rssi[3];
+	spin_unlock_bh(&phy->amnt_lock);
+
+	data.idx = amnt_idx;
+	data.last_seen = last_seen;
+
+	nla_put(skb, (*attrtype)++, sizeof(struct mt7996_amnt_data), &data);
+
+	return 1;
+}
+
+static int
+mt7966_vendor_amnt_ctrl_dump(struct wiphy *wiphy, struct wireless_dev *wdev,
+			     struct sk_buff *skb, const void *data, int data_len,
+			     unsigned long *storage)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_phy *phy = &dev->phy;
+	struct nlattr *tb1[NUM_MTK_VENDOR_ATTRS_AMNT_CTRL];
+	struct nlattr *tb2[NUM_MTK_VENDOR_ATTRS_AMNT_DUMP];
+	void *a, *b;
+	int err = 0, attrtype = 0, i, len = 0;
+	u8 amnt_idx;
+
+	if (*storage == 1)
+		return -ENOENT;
+	*storage = 1;
+
+	err = nla_parse(tb1, MTK_VENDOR_ATTR_AMNT_CTRL_MAX, data, data_len,
+			amnt_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	if (!tb1[MTK_VENDOR_ATTR_AMNT_CTRL_DUMP])
+		return -EINVAL;
+
+	err = nla_parse_nested(tb2, MTK_VENDOR_ATTR_AMNT_DUMP_MAX,
+			       tb1[MTK_VENDOR_ATTR_AMNT_CTRL_DUMP],
+			       amnt_dump_policy, NULL);
+	if (err)
+		return err;
+
+	if (!tb2[MTK_VENDOR_ATTR_AMNT_DUMP_INDEX])
+		return -EINVAL;
+
+	amnt_idx = nla_get_u8(tb2[MTK_VENDOR_ATTR_AMNT_DUMP_INDEX]);
+
+	a = nla_nest_start(skb, MTK_VENDOR_ATTR_AMNT_CTRL_DUMP);
+	b = nla_nest_start(skb, MTK_VENDOR_ATTR_AMNT_DUMP_RESULT);
+
+	if (amnt_idx != 0xff) {
+		len += mt7996_amnt_dump(phy, skb, amnt_idx, &attrtype);
+	} else {
+		for (i = 0; i < MT7996_AIR_MONITOR_MAX_ENTRY; i++)
+			len += mt7996_amnt_dump(phy, skb, i, &attrtype);
+	}
+
+	nla_nest_end(skb, b);
+
+	nla_put_u8(skb, MTK_VENDOR_ATTR_AMNT_DUMP_LEN, len);
+
+	nla_nest_end(skb, a);
+
+	return len + 1;
+}
+
+static int
+mt7996_vendor_bss_color_ctrl_dump(struct wiphy *wiphy, struct wireless_dev *wdev,
+				  struct sk_buff *skb, const void *data, int data_len,
+				  unsigned long *storage)
+{
+	struct ieee80211_vif *vif = wdev_to_ieee80211_vif(wdev);
+	struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
+	int len = 0;
+
+	if (*storage == 1)
+		return -ENOENT;
+	*storage = 1;
+
+	if (nla_put_u64_64bit(skb, MTK_VENDOR_ATTR_AVAL_BSS_COLOR_BMP,
+			      ~bss_conf->used_color_bitmap, NL80211_ATTR_PAD))
+		return -ENOMEM;
+	len += 1;
+
+	return len;
+}
+
+static int mt7996_vendor_edcca_ctrl(struct wiphy *wiphy, struct wireless_dev *wdev,
+				    const void *data, int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy = &dev->phy;
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_EDCCA_CTRL];
+	int err;
+	u8 edcca_mode, radio_idx;
+	u8 edcca_value[EDCCA_MAX_BW_NUM];
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_EDCCA_CTRL_MAX, data, data_len,
+			edcca_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	if (!tb[MTK_VENDOR_ATTR_EDCCA_CTRL_MODE] ||
+	    !tb[MTK_VENDOR_ATTR_EDCCA_CTRL_RADIO_IDX])
+		return -EINVAL;
+
+	edcca_mode = nla_get_u8(tb[MTK_VENDOR_ATTR_EDCCA_CTRL_MODE]);
+	radio_idx = nla_get_u8(tb[MTK_VENDOR_ATTR_EDCCA_CTRL_RADIO_IDX]);
+	if (!mt7996_radio_valid(dev, radio_idx))
+		return -EINVAL;
+
+	phy = dev->radio_phy[radio_idx];
+
+	switch (edcca_mode) {
+	case EDCCA_CTRL_SET_EN:
+		if (!tb[MTK_VENDOR_ATTR_EDCCA_CTRL_PRI20_VAL])
+			return -EINVAL;
+
+		edcca_value[0] = nla_get_u8(tb[MTK_VENDOR_ATTR_EDCCA_CTRL_PRI20_VAL]);
+
+		return mt7996_mcu_edcca_enable(phy, !!edcca_value[0]);
+	case EDCCA_CTRL_SET_THRES:
+		if (!tb[MTK_VENDOR_ATTR_EDCCA_CTRL_PRI20_VAL] ||
+		    !tb[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC40_VAL] ||
+		    !tb[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC80_VAL] ||
+		    !tb[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC160_VAL])
+			return -EINVAL;
+
+		edcca_value[EDCCA_BW_20] =
+			nla_get_u8(tb[MTK_VENDOR_ATTR_EDCCA_CTRL_PRI20_VAL]);
+		edcca_value[EDCCA_BW_40] =
+			nla_get_u8(tb[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC40_VAL]);
+		edcca_value[EDCCA_BW_80] =
+			nla_get_u8(tb[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC80_VAL]);
+		edcca_value[EDCCA_BW_160] =
+			nla_get_u8(tb[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC160_VAL]);
+
+		return mt7996_mcu_edcca_threshold_ctrl(phy, edcca_value, true);
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static int
+mt7996_vendor_edcca_ctrl_dump(struct wiphy *wiphy, struct wireless_dev *wdev,
+			     struct sk_buff *skb, const void *data, int data_len,
+			     unsigned long *storage)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy = &dev->phy;
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_EDCCA_CTRL];
+	int err;
+	u8 edcca_mode, radio_idx, i;
+	u8 value[EDCCA_MAX_BW_NUM];
+
+	if (*storage == 1)
+		return -ENOENT;
+	*storage = 1;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_EDCCA_CTRL_MAX, data, data_len,
+			edcca_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	if (!tb[MTK_VENDOR_ATTR_EDCCA_CTRL_MODE] ||
+	    !tb[MTK_VENDOR_ATTR_EDCCA_CTRL_RADIO_IDX])
+		return -EINVAL;
+
+	edcca_mode = nla_get_u8(tb[MTK_VENDOR_ATTR_EDCCA_CTRL_MODE]);
+	if (edcca_mode != EDCCA_CTRL_GET_THRES)
+		return -EINVAL;
+
+	radio_idx = nla_get_u8(tb[MTK_VENDOR_ATTR_EDCCA_CTRL_RADIO_IDX]);
+	if (!mt7996_radio_valid(dev, radio_idx))
+		return -EINVAL;
+
+	phy = dev->radio_phy[radio_idx];
+	err = mt7996_mcu_edcca_threshold_ctrl(phy, value, false);
+	if (err)
+		return err;
+
+	for (i = 0; i < EDCCA_MAX_BW_NUM; i++)
+		if (nla_put_u8(skb, MTK_VENDOR_ATTR_EDCCA_DUMP_PRI20_VAL + i,
+			       value[EDCCA_BW_20 + i]))
+			return -ENOMEM;
+
+	return EDCCA_MAX_BW_NUM;
+}
+
+static int mt7996_vendor_3wire_ctrl(struct wiphy *wiphy, struct wireless_dev *wdev,
+				    const void *data, int data_len)
+{
+#define UNI_3WIRE_EXT_EN	0
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_3WIRE_CTRL];
+	struct {
+		u8 __rsv1[4];
+
+		__le16 tag;
+		__le16 len;
+		u8 three_wire_mode;
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_3WIRE_EXT_EN),
+		.len = cpu_to_le16(sizeof(req) - 4),
+	};
+	int err;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_3WIRE_CTRL_MAX, data, data_len,
+			three_wire_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	if (!tb[MTK_VENDOR_ATTR_3WIRE_CTRL_MODE])
+		return -EINVAL;
+
+	req.three_wire_mode = nla_get_u8(tb[MTK_VENDOR_ATTR_3WIRE_CTRL_MODE]);
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(PTA_3WIRE_CTRL), &req,
+				 sizeof(req), false);
+}
+
+static int mt7996_vendor_ibf_ctrl(struct wiphy *wiphy,
+				  struct wireless_dev *wdev,
+				  const void *data,
+				  int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_IBF_CTRL];
+	int err;
+	u8 val;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_IBF_CTRL_MAX, data, data_len,
+			ibf_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	if (tb[MTK_VENDOR_ATTR_IBF_CTRL_ENABLE]) {
+		val = nla_get_u8(tb[MTK_VENDOR_ATTR_IBF_CTRL_ENABLE]);
+
+		dev->ibf = !!val;
+
+		err = mt7996_mcu_set_txbf(dev, BF_HW_EN_UPDATE);
+		if (err)
+			return err;
+	}
+	return 0;
+}
+
+static int
+mt7996_vendor_ibf_ctrl_dump(struct wiphy *wiphy, struct wireless_dev *wdev,
+			    struct sk_buff *skb, const void *data, int data_len,
+			    unsigned long *storage)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+
+	if (*storage == 1)
+		return -ENOENT;
+	*storage = 1;
+
+	if (nla_put_u8(skb, MTK_VENDOR_ATTR_IBF_DUMP_ENABLE, dev->ibf))
+		return -ENOMEM;
+
+	return 1;
+}
+
+static int mt7996_vendor_pp_ctrl(struct wiphy *wiphy, struct wireless_dev *wdev,
+				 const void *data, int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_PP_CTRL];
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy;
+	struct mt76_phy *mphy;
+	struct cfg80211_chan_def *chandef;
+	int err;
+	u8 val8, band_idx = 0;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_PP_CTRL_MAX, data, data_len,
+			pp_ctrl_policy, NULL);
+
+	if (tb[MTK_VENDOR_ATTR_PP_BAND_IDX]) {
+		band_idx = nla_get_u8(tb[MTK_VENDOR_ATTR_PP_BAND_IDX]);
+	}
+
+	if (!mt7996_band_valid(dev, band_idx))
+		goto error;
+
+	mphy = dev->mt76.phys[band_idx];
+	if (!mphy)
+		goto error;
+
+	phy = (struct mt7996_phy *)mphy->priv;
+	if (!phy)
+		goto error;
+
+	chandef = &phy->mt76->chanctx->chandef;
+	if (!chandef)
+		goto error;
+
+	if (chandef->chan->band == NL80211_BAND_2GHZ)
+		return 0;
+
+	if (tb[MTK_VENDOR_ATTR_PP_MODE]) {
+		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_PP_MODE]);
+		switch (val8) {
+		case PP_DISABLE:
+		case PP_FW_MODE:
+			err = mt7996_mcu_set_pp_en(phy, val8, 0);
+			break;
+		case PP_USR_MODE:
+			/* handled by add_chanctx */
+			err = 0;
+			break;
+		default:
+			err = -EINVAL;
+		}
+	}
+
+	return err;
+error:
+	dev_err(dev->mt76.dev, "Invalid band idx: %d\n", band_idx);
+	return -EINVAL;
+}
+
+static int mt7996_vendor_rfeature_ctrl(struct wiphy *wiphy,
+				       struct wireless_dev *wdev,
+				       const void *data,
+				       int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_RFEATURE_CTRL];
+	int err;
+	u32 val;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_RFEATURE_CTRL_MAX, data, data_len,
+			rfeature_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	val = CAPI_RFEATURE_CHANGED;
+
+	if (tb[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE_CFG]) {
+		u8 enable, trig_type;
+		int rem;
+		struct nlattr *cur;
+
+		nla_for_each_nested(cur, tb[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE_CFG], rem) {
+			switch (nla_type(cur)) {
+			case MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE_EN:
+				enable = nla_get_u8(cur);
+				break;
+			case MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE:
+				trig_type = nla_get_u8(cur);
+				break;
+			default:
+				return -EINVAL;
+			};
+		}
+
+		err = mt7996_mcu_set_rfeature_trig_type(phy, enable, trig_type);
+		if (err)
+			return err;
+	} else if (tb[MTK_VENDOR_ATTR_RFEATURE_CTRL_ACK_PLCY]) {
+		u8 ack_policy;
+
+		ack_policy = nla_get_u8(tb[MTK_VENDOR_ATTR_RFEATURE_CTRL_ACK_PLCY]);
+		switch (ack_policy) {
+		case MU_DL_ACK_POLICY_TF_FOR_ACK:
+			return mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SET_MUDL_ACK_POLICY,
+						       ack_policy);
+		default:
+			return 0;
+		}
+	}
+
+	return 0;
+}
+
+static int mt7996_vendor_wireless_ctrl(struct wiphy *wiphy,
+				       struct wireless_dev *wdev,
+				       const void *data,
+				       int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_WIRELESS_CTRL];
+	int err;
+	u8 val8;
+	u16 val16;
+	u32 val32;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_WIRELESS_CTRL_MAX, data, data_len,
+			wireless_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	val32 = CAPI_WIRELESS_CHANGED;
+
+	if (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_OFDMA]) {
+		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_OFDMA]);
+		val32 |= FIELD_PREP(RATE_CFG_MODE, RATE_PARAM_FIXED_OFDMA) |
+			 FIELD_PREP(RATE_CFG_VAL, val8);
+		ieee80211_iterate_active_interfaces_atomic(hw, IEEE80211_IFACE_ITER_RESUME_ALL,
+			mt7996_set_wireless_vif, &val32);
+		if (val8 == 3) /* DL20and80 */
+			mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SET_20M_DYN_ALGO, 1);
+	} else if (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_BA_BUFFER_SIZE]) {
+		val16 = nla_get_u16(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_BA_BUFFER_SIZE]);
+		hw->max_tx_aggregation_subframes = val16;
+		hw->max_rx_aggregation_subframes = val16;
+	} else if (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_PPDU_TX_TYPE]) {
+		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_PPDU_TX_TYPE]);
+		mt7996_mcu_set_ppdu_tx_type(phy, val8);
+	} else if (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_NUSERS_OFDMA]) {
+		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_NUSERS_OFDMA]);
+		if (phy->muru_onoff & OFDMA_UL)
+			mt7996_mcu_set_nusers_ofdma(phy, MU_CTRL_UL_USER_CNT, val8);
+		else
+			mt7996_mcu_set_nusers_ofdma(phy, MU_CTRL_DL_USER_CNT, val8);
+	} else if (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_MIMO]) {
+		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_MIMO]);
+		val32 |= FIELD_PREP(RATE_CFG_MODE, RATE_PARAM_FIXED_MIMO) |
+			 FIELD_PREP(RATE_CFG_VAL, val8);
+		ieee80211_iterate_active_interfaces_atomic(hw, IEEE80211_IFACE_ITER_RESUME_ALL,
+			mt7996_set_wireless_vif, &val32);
+	} else if (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_CERT]) {
+		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_CERT]);
+		dev->cert_mode = val8;
+		mt7996_mcu_set_cert(phy, val8);
+		mt7996_mcu_set_bypass_smthint(phy, val8);
+	} else if (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_AMSDU]) {
+		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_AMSDU]);
+		mt7996_set_wireless_amsdu(hw, val8);
+	} else if (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_RTS_SIGTA]) {
+		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_RTS_SIGTA]);
+		mt7996_set_wireless_rts_sigta(hw, val8);
+	}
+
+	return 0;
+}
+
+static int mt7996_vendor_background_radar_mode_ctrl(struct wiphy *wiphy,
+						    struct wireless_dev *wdev,
+						    const void *data,
+						    int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_BACKGROUND_RADAR_CTRL];
+	int err;
+	u8 background_radar_mode;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_BACKGROUND_RADAR_CTRL_MAX, data, data_len,
+			background_radar_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	background_radar_mode = nla_get_u8(tb[MTK_VENDOR_ATTR_BACKGROUND_RADAR_CTRL_MODE]);
+
+	return mt7996_mcu_rdd_background_disable_timer(dev, !!background_radar_mode);
+}
+
+static int mt7996_vendor_beacon_ctrl(struct wiphy *wiphy,
+				     struct wireless_dev *wdev,
+				     const void *data,
+				     int data_len)
+{
+	struct ieee80211_vif *vif = wdev_to_ieee80211_vif(wdev);
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_BEACON_CTRL];
+	int err;
+	u8 val8;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_BEACON_CTRL_MAX, data, data_len,
+			beacon_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	if (tb[MTK_VENDOR_ATTR_BEACON_CTRL_MODE]) {
+		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_BEACON_CTRL_MODE]);
+		mt7996_set_beacon_vif(vif, val8);
+	}
+
+	return 0;
+}
+static int mt7996_vendor_csi_ctrl(struct wiphy *wiphy,
+				  struct wireless_dev *wdev,
+				  const void *data,
+				  int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy;
+	struct mt76_phy *mphy;
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_CSI_CTRL];
+	u8 band_idx = 0;
+	int err;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_CSI_CTRL_MAX, data, data_len,
+			csi_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	if (tb[MTK_VENDOR_ATTR_CSI_CTRL_BAND_IDX])
+		band_idx = nla_get_u8(tb[MTK_VENDOR_ATTR_CSI_CTRL_BAND_IDX]);
+
+	if (!mt7996_band_valid(dev, band_idx))
+		goto error;
+
+	mphy = dev->mt76.phys[band_idx];
+	if (!mphy)
+		goto error;
+
+	phy = (struct mt7996_phy *)mphy->priv;
+	if (!phy)
+		goto error;
+
+	if (tb[MTK_VENDOR_ATTR_CSI_CTRL_CFG]) {
+		u8 mode = 0, type = 0, v1 = 0;
+		u32 v2 = 0;
+		u8 mac_addr[ETH_ALEN] = {};
+		struct nlattr *cur;
+		int rem;
+
+		nla_for_each_nested(cur, tb[MTK_VENDOR_ATTR_CSI_CTRL_CFG], rem) {
+			switch (nla_type(cur)) {
+			case MTK_VENDOR_ATTR_CSI_CTRL_CFG_MODE:
+				mode = nla_get_u8(cur);
+				break;
+			case MTK_VENDOR_ATTR_CSI_CTRL_CFG_TYPE:
+				type = nla_get_u8(cur);
+				break;
+			case MTK_VENDOR_ATTR_CSI_CTRL_CFG_VAL1:
+				v1 = nla_get_u8(cur);
+				break;
+			case MTK_VENDOR_ATTR_CSI_CTRL_CFG_VAL2:
+				v2 = nla_get_u32(cur);
+				break;
+			default:
+				return -EINVAL;
+			};
+		}
+
+		if (tb[MTK_VENDOR_ATTR_CSI_CTRL_MAC_ADDR]) {
+			u8 idx = 0;
+
+			nla_for_each_nested(cur, tb[MTK_VENDOR_ATTR_CSI_CTRL_MAC_ADDR], rem) {
+				mac_addr[idx++] = nla_get_u8(cur);
+			}
+		}
+
+		err = mt7996_mcu_set_csi(phy, mode, type, v1, v2, mac_addr);
+		if (err < 0)
+			return err;
+
+		spin_lock_bh(&phy->csi.lock);
+
+		phy->csi.enable = !!mode;
+
+		/* clean up old csi stats */
+		if ((mode == CSI_CONTROL_MODE_STOP || mode == CSI_CONTROL_MODE_SET)
+			&& !list_empty(&phy->csi.list)) {
+			struct csi_data *c, *tmp_c;
+
+			list_for_each_entry_safe(c, tmp_c, &phy->csi.list, node) {
+				list_del(&c->node);
+				kfree(c);
+				phy->csi.count--;
+			}
+		} else if (mode == CSI_CONTROL_MODE_START) {
+			phy->csi.last_record = 0;
+		}
+
+		spin_unlock_bh(&phy->csi.lock);
+
+		if (mode == CSI_CONTROL_MODE_SET && type == CSI_CONFIG_STA_FILTER && v1 == 2)
+			phy->csi.interval = v2;
+	}
+
+	return 0;
+
+error:
+	dev_err(dev->mt76.dev, "Invalid band idx: %d\n", band_idx);
+	return -EINVAL;
+}
+
+static int
+mt7996_vendor_csi_ctrl_dump(struct wiphy *wiphy, struct wireless_dev *wdev,
+			    struct sk_buff *skb, const void *data, int data_len,
+			    unsigned long *storage)
+{
+#define RESERVED_SET	BIT(31)
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy;
+	struct mt76_phy *mphy;
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_CSI_CTRL] = {0};
+	u8 band_idx = 0;
+	int err = 0;
+
+	if (*storage & RESERVED_SET) {
+		if ((*storage & GENMASK(15, 0)) == 0)
+			return -ENOENT;
+	}
+
+	if (data) {
+		err = nla_parse(tb, MTK_VENDOR_ATTR_CSI_CTRL_MAX, data, data_len,
+				csi_ctrl_policy, NULL);
+		if (err)
+			return err;
+	}
+
+	if (tb[MTK_VENDOR_ATTR_CSI_CTRL_BAND_IDX])
+		band_idx = nla_get_u8(tb[MTK_VENDOR_ATTR_CSI_CTRL_BAND_IDX]);
+
+	if (!mt7996_band_valid(dev, band_idx))
+		return -EINVAL;
+
+	mphy = dev->mt76.phys[band_idx];
+	if (!mphy)
+		return -EINVAL;
+
+	phy = (struct mt7996_phy *)mphy->priv;
+	if (!phy)
+		return -EINVAL;
+
+	if (!(*storage & RESERVED_SET) && tb[MTK_VENDOR_ATTR_CSI_CTRL_DUMP_NUM]) {
+		*storage = nla_get_u16(tb[MTK_VENDOR_ATTR_CSI_CTRL_DUMP_NUM]);
+		*storage |= RESERVED_SET;
+	}
+
+	(*storage)--;
+
+	spin_lock_bh(&phy->csi.lock);
+
+	if (!list_empty(&phy->csi.list)) {
+		struct csi_data *csi;
+		void *a, *b;
+		int i;
+
+		csi = list_first_entry(&phy->csi.list, struct csi_data, node);
+
+		a = nla_nest_start(skb, MTK_VENDOR_ATTR_CSI_CTRL_DATA);
+		if (!a)
+			goto out;
+
+		if (nla_put_u8(skb, MTK_VENDOR_ATTR_CSI_DATA_VER, 1) ||
+		    nla_put_u8(skb, MTK_VENDOR_ATTR_CSI_DATA_RSSI, csi->rssi) ||
+		    nla_put_u8(skb, MTK_VENDOR_ATTR_CSI_DATA_SNR, csi->snr) ||
+		    nla_put_u8(skb, MTK_VENDOR_ATTR_CSI_DATA_BW, csi->data_bw) ||
+		    nla_put_u8(skb, MTK_VENDOR_ATTR_CSI_DATA_CH_IDX, csi->pri_ch_idx) ||
+		    nla_put_u8(skb, MTK_VENDOR_ATTR_CSI_DATA_MODE, csi->rx_mode))
+			goto out;
+
+		if (nla_put_u16(skb, MTK_VENDOR_ATTR_CSI_DATA_TX_ANT, csi->tx_idx) ||
+		    nla_put_u16(skb, MTK_VENDOR_ATTR_CSI_DATA_RX_ANT, csi->rx_idx))
+			goto out;
+
+		if (nla_put_u32(skb, MTK_VENDOR_ATTR_CSI_DATA_INFO, csi->ext_info) ||
+		    nla_put_u32(skb, MTK_VENDOR_ATTR_CSI_DATA_CHAIN_INFO, csi->chain_info) ||
+		    nla_put_u32(skb, MTK_VENDOR_ATTR_CSI_DATA_TS, csi->ts))
+			goto out;
+
+		b = nla_nest_start(skb, MTK_VENDOR_ATTR_CSI_DATA_TA);
+		if (!b)
+			goto out;
+
+		for (i = 0; i < ARRAY_SIZE(csi->ta); i++)
+			if (nla_put_u8(skb, i, csi->ta[i]))
+				goto out;
+		nla_nest_end(skb, b);
+
+		if (nla_put_u32(skb, MTK_VENDOR_ATTR_CSI_DATA_NUM, csi->data_num))
+			goto out;
+
+		b = nla_nest_start(skb, MTK_VENDOR_ATTR_CSI_DATA_I);
+		if (!b)
+			goto out;
+
+		for (i = 0; i < csi->data_num; i++)
+			if (nla_put_u16(skb, i, csi->data_i[i]))
+				goto out;
+		nla_nest_end(skb, b);
+
+		b = nla_nest_start(skb, MTK_VENDOR_ATTR_CSI_DATA_Q);
+		if (!b)
+			goto out;
+
+		for (i = 0; i < csi->data_num; i++)
+			if (nla_put_u16(skb, i, csi->data_q[i]))
+				goto out;
+		nla_nest_end(skb, b);
+
+		nla_nest_end(skb, a);
+
+		list_del(&csi->node);
+		kfree(csi);
+		phy->csi.count--;
+
+		spin_unlock_bh(&phy->csi.lock);
+		return skb->len;
+	} else
+		err = -ENOENT;
+
+out:
+	spin_unlock_bh(&phy->csi.lock);
+
+	return err;
+}
+
+static const struct wiphy_vendor_command mt7996_vendor_commands[] = {
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_MU_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			 WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7996_vendor_mu_ctrl,
+		.dumpit = mt7996_vendor_mu_ctrl_dump,
+		.policy = mu_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_MU_CTRL_MAX,
+	},
+	{
+		.info = {
+		        .vendor_id = MTK_NL80211_VENDOR_ID,
+		        .subcmd = MTK_NL80211_VENDOR_SUBCMD_WIRELESS_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+		        WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7996_vendor_wireless_ctrl,
+		.dumpit = mt7996_vendor_wireless_ctrl_dump,
+		.policy = wireless_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_WIRELESS_CTRL_MAX,
+	},
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_AMNT_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			 WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7966_vendor_amnt_ctrl,
+		.dumpit = mt7966_vendor_amnt_ctrl_dump,
+		.policy = amnt_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_AMNT_CTRL_MAX,
+	},
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_BSS_COLOR_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.dumpit = mt7996_vendor_bss_color_ctrl_dump,
+		.policy = bss_color_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_BSS_COLOR_CTRL_MAX,
+	},
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_EDCCA_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			 WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7996_vendor_edcca_ctrl,
+		.dumpit = mt7996_vendor_edcca_ctrl_dump,
+		.policy = edcca_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_EDCCA_CTRL_MAX,
+	},
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_3WIRE_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			 WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7996_vendor_3wire_ctrl,
+		.policy = three_wire_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_3WIRE_CTRL_MAX,
+	},
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_IBF_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7996_vendor_ibf_ctrl,
+		.dumpit = mt7996_vendor_ibf_ctrl_dump,
+		.policy = ibf_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_IBF_CTRL_MAX,
+	},
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_PP_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7996_vendor_pp_ctrl,
+		.policy = pp_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_PP_CTRL_MAX,
+	},
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_RFEATURE_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7996_vendor_rfeature_ctrl,
+		.policy = rfeature_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_RFEATURE_CTRL_MAX,
+	},
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_BACKGROUND_RADAR_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7996_vendor_background_radar_mode_ctrl,
+		.policy = background_radar_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_BACKGROUND_RADAR_CTRL_MAX,
+	},
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_BEACON_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			 WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7996_vendor_beacon_ctrl,
+		.policy = beacon_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_BEACON_CTRL_MAX,
+	},
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_CSI_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			 WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7996_vendor_csi_ctrl,
+		.dumpit = mt7996_vendor_csi_ctrl_dump,
+		.policy = csi_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_CSI_CTRL_MAX,
+	},
+};
+
+void mt7996_vendor_register(struct mt7996_phy *phy)
+{
+	phy->mt76->hw->wiphy->vendor_commands = mt7996_vendor_commands;
+	phy->mt76->hw->wiphy->n_vendor_commands = ARRAY_SIZE(mt7996_vendor_commands);
+
+	INIT_LIST_HEAD(&phy->csi.list);
+	spin_lock_init(&phy->csi.lock);
+
+	spin_lock_init(&phy->amnt_lock);
+}
+#endif
diff --git a/mt7996/vendor.h b/mt7996/vendor.h
new file mode 100644
index 00000000..7485ea22
--- /dev/null
+++ b/mt7996/vendor.h
@@ -0,0 +1,298 @@
+#ifndef __MT7996_VENDOR_H
+#define __MT7996_VENDOR_H
+
+#define MTK_NL80211_VENDOR_ID	0x0ce7
+
+#ifdef CONFIG_MTK_VENDOR
+
+enum mtk_nl80211_vendor_subcmds {
+	MTK_NL80211_VENDOR_SUBCMD_AMNT_CTRL = 0xae,
+	MTK_NL80211_VENDOR_SUBCMD_CSI_CTRL = 0xc2,
+	MTK_NL80211_VENDOR_SUBCMD_RFEATURE_CTRL = 0xc3,
+	MTK_NL80211_VENDOR_SUBCMD_WIRELESS_CTRL = 0xc4,
+	MTK_NL80211_VENDOR_SUBCMD_MU_CTRL = 0xc5,
+	MTK_NL80211_VENDOR_SUBCMD_EDCCA_CTRL = 0xc7,
+	MTK_NL80211_VENDOR_SUBCMD_3WIRE_CTRL = 0xc8,
+	MTK_NL80211_VENDOR_SUBCMD_IBF_CTRL = 0xc9,
+	MTK_NL80211_VENDOR_SUBCMD_BSS_COLOR_CTRL = 0xca,
+	MTK_NL80211_VENDOR_SUBCMD_BACKGROUND_RADAR_CTRL = 0xcb,
+	MTK_NL80211_VENDOR_SUBCMD_PP_CTRL = 0xcc,
+	MTK_NL80211_VENDOR_SUBCMD_BEACON_CTRL = 0xcd,
+};
+
+enum mtk_vendor_attr_edcca_ctrl {
+	MTK_VENDOR_ATTR_EDCCA_THRESHOLD_INVALID = 0,
+
+	MTK_VENDOR_ATTR_EDCCA_CTRL_MODE,
+	MTK_VENDOR_ATTR_EDCCA_CTRL_PRI20_VAL,
+	MTK_VENDOR_ATTR_EDCCA_CTRL_SEC20_VAL,
+	MTK_VENDOR_ATTR_EDCCA_CTRL_SEC40_VAL,
+	MTK_VENDOR_ATTR_EDCCA_CTRL_SEC80_VAL,
+	MTK_VENDOR_ATTR_EDCCA_CTRL_COMPENSATE,
+	MTK_VENDOR_ATTR_EDCCA_CTRL_SEC160_VAL,
+	MTK_VENDOR_ATTR_EDCCA_CTRL_RADIO_IDX,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_EDCCA_CTRL,
+	MTK_VENDOR_ATTR_EDCCA_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_EDCCA_CTRL - 1
+};
+
+enum mtk_vendor_attr_edcca_dump {
+	MTK_VENDOR_ATTR_EDCCA_DUMP_UNSPEC = 0,
+
+	MTK_VENDOR_ATTR_EDCCA_DUMP_MODE,
+	MTK_VENDOR_ATTR_EDCCA_DUMP_PRI20_VAL,
+	MTK_VENDOR_ATTR_EDCCA_DUMP_SEC40_VAL,
+	MTK_VENDOR_ATTR_EDCCA_DUMP_SEC80_VAL,
+	MTK_VENDOR_ATTR_EDCCA_DUMP_SEC160_VAL,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_EDCCA_DUMP,
+	MTK_VENDOR_ATTR_EDCCA_DUMP_MAX =
+		NUM_MTK_VENDOR_ATTRS_EDCCA_DUMP - 1
+};
+
+enum mtk_vendor_attr_3wire_ctrl {
+	MTK_VENDOR_ATTR_3WIRE_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_3WIRE_CTRL_MODE,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_3WIRE_CTRL,
+	MTK_VENDOR_ATTR_3WIRE_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_3WIRE_CTRL - 1
+};
+
+enum mtk_vendor_attr_mu_ctrl {
+	MTK_VENDOR_ATTR_MU_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_MU_CTRL_ONOFF,
+	MTK_VENDOR_ATTR_MU_CTRL_DUMP,
+	MTK_VENDOR_ATTR_MU_CTRL_STRUCT,
+	MTK_VENDOR_ATTR_MU_CTRL_BAND_IDX,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_MU_CTRL,
+	MTK_VENDOR_ATTR_MU_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_MU_CTRL - 1
+};
+
+enum mtk_capi_control_changed {
+	CAPI_RFEATURE_CHANGED = BIT(16),
+	CAPI_WIRELESS_CHANGED = BIT(17),
+};
+
+enum mtk_vendor_attr_rfeature_ctrl {
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_HE_GI,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_HE_LTF,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE_CFG,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE_EN,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_ACK_PLCY,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TXBF,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_RFEATURE_CTRL,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_MAX =
+	NUM_MTK_VENDOR_ATTRS_RFEATURE_CTRL - 1
+};
+
+enum mtk_vendor_attr_wireless_ctrl {
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_FIXED_MCS,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_OFDMA,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_PPDU_TX_TYPE,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_NUSERS_OFDMA,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_BA_BUFFER_SIZE,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_MIMO,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_AMSDU,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_AMPDU,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_CERT = 9,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_RTS_SIGTA,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_MU_EDCA, /* reserve */
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_WIRELESS_CTRL,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_WIRELESS_CTRL - 1
+};
+
+enum mtk_vendor_attr_wireless_dump {
+	MTK_VENDOR_ATTR_WIRELESS_DUMP_UNSPEC,
+
+	MTK_VENDOR_ATTR_WIRELESS_DUMP_AMSDU,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_WIRELESS_DUMP,
+	MTK_VENDOR_ATTR_WIRELESS_DUMP_MAX =
+		NUM_MTK_VENDOR_ATTRS_WIRELESS_DUMP - 1
+};
+
+enum mtk_vendor_attr_background_radar_ctrl {
+	MTK_VENDOR_ATTR_BACKGROUND_RADAR_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_BACKGROUND_RADAR_CTRL_MODE,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_BACKGROUND_RADAR_CTRL,
+	MTK_VENDOR_ATTR_BACKGROUND_RADAR_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_BACKGROUND_RADAR_CTRL - 1
+};
+
+enum bw_sig {
+	BW_SIGNALING_DISABLE,
+	BW_SIGNALING_STATIC,
+	BW_SIGNALING_DYNAMIC
+};
+
+enum mtk_vendor_attr_mnt_ctrl {
+	MTK_VENDOR_ATTR_AMNT_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_AMNT_CTRL_SET,
+	MTK_VENDOR_ATTR_AMNT_CTRL_DUMP,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_AMNT_CTRL,
+	MTK_VENDOR_ATTR_AMNT_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_AMNT_CTRL - 1
+};
+
+enum mtk_vendor_attr_mnt_set {
+	MTK_VENDOR_ATTR_AMNT_SET_UNSPEC,
+
+	MTK_VENDOR_ATTR_AMNT_SET_INDEX,
+	MTK_VENDOR_ATTR_AMNT_SET_MACADDR,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_AMNT_SET,
+	MTK_VENDOR_ATTR_AMNT_SET_MAX =
+		NUM_MTK_VENDOR_ATTRS_AMNT_SET - 1
+};
+
+enum mtk_vendor_attr_mnt_dump {
+	MTK_VENDOR_ATTR_AMNT_DUMP_UNSPEC,
+
+	MTK_VENDOR_ATTR_AMNT_DUMP_INDEX,
+	MTK_VENDOR_ATTR_AMNT_DUMP_LEN,
+	MTK_VENDOR_ATTR_AMNT_DUMP_RESULT,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_AMNT_DUMP,
+	MTK_VENDOR_ATTR_AMNT_DUMP_MAX =
+		NUM_MTK_VENDOR_ATTRS_AMNT_DUMP - 1
+};
+
+enum mtk_vendor_attr_bss_color_ctrl {
+	MTK_VENDOR_ATTR_BSS_COLOR_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_AVAL_BSS_COLOR_BMP,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_BSS_COLOR_CTRL,
+	MTK_VENDOR_ATTR_BSS_COLOR_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_BSS_COLOR_CTRL - 1
+};
+
+enum mtk_vendor_attr_ibf_ctrl {
+	MTK_VENDOR_ATTR_IBF_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_IBF_CTRL_ENABLE,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_IBF_CTRL,
+	MTK_VENDOR_ATTR_IBF_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_IBF_CTRL - 1
+};
+
+enum mtk_vendor_attr_ibf_dump {
+	MTK_VENDOR_ATTR_IBF_DUMP_UNSPEC,
+
+	MTK_VENDOR_ATTR_IBF_DUMP_ENABLE,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_IBF_DUMP,
+	MTK_VENDOR_ATTR_IBF_DUMP_MAX =
+		NUM_MTK_VENDOR_ATTRS_IBF_DUMP - 1
+};
+
+enum mtk_vendor_attr_pp_ctrl {
+	MTK_VENDOR_ATTR_PP_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_PP_MODE,
+	MTK_VENDOR_ATTR_PP_BAND_IDX,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_PP_CTRL,
+	MTK_VENDOR_ATTR_PP_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_PP_CTRL - 1
+};
+
+enum mtk_vendor_attr_beacon_ctrl {
+	MTK_VENDOR_ATTR_BEACON_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_BEACON_CTRL_MODE,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_BEACON_CTRL,
+	MTK_VENDOR_ATTR_BEACON_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_BEACON_CTRL - 1
+};
+
+enum mtk_vendor_attr_csi_ctrl {
+	MTK_VENDOR_ATTR_CSI_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_CSI_CTRL_CFG,
+	MTK_VENDOR_ATTR_CSI_CTRL_CFG_MODE,
+	MTK_VENDOR_ATTR_CSI_CTRL_CFG_TYPE,
+	MTK_VENDOR_ATTR_CSI_CTRL_CFG_VAL1,
+	MTK_VENDOR_ATTR_CSI_CTRL_CFG_VAL2,
+	MTK_VENDOR_ATTR_CSI_CTRL_MAC_ADDR,
+
+	MTK_VENDOR_ATTR_CSI_CTRL_DUMP_NUM,
+
+	MTK_VENDOR_ATTR_CSI_CTRL_DATA,
+
+	MTK_VENDOR_ATTR_CSI_CTRL_BAND_IDX,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_CSI_CTRL,
+	MTK_VENDOR_ATTR_CSI_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_CSI_CTRL - 1
+};
+
+enum mtk_vendor_attr_csi_data {
+	MTK_VENDOR_ATTR_CSI_DATA_UNSPEC,
+	MTK_VENDOR_ATTR_CSI_DATA_PAD,
+
+	MTK_VENDOR_ATTR_CSI_DATA_VER,
+	MTK_VENDOR_ATTR_CSI_DATA_TS,
+	MTK_VENDOR_ATTR_CSI_DATA_RSSI,
+	MTK_VENDOR_ATTR_CSI_DATA_SNR,
+	MTK_VENDOR_ATTR_CSI_DATA_BW,
+	MTK_VENDOR_ATTR_CSI_DATA_CH_IDX,
+	MTK_VENDOR_ATTR_CSI_DATA_TA,
+	MTK_VENDOR_ATTR_CSI_DATA_NUM,
+	MTK_VENDOR_ATTR_CSI_DATA_I,
+	MTK_VENDOR_ATTR_CSI_DATA_Q,
+	MTK_VENDOR_ATTR_CSI_DATA_INFO,
+	MTK_VENDOR_ATTR_CSI_DATA_RSVD1,
+	MTK_VENDOR_ATTR_CSI_DATA_RSVD2,
+	MTK_VENDOR_ATTR_CSI_DATA_RSVD3,
+	MTK_VENDOR_ATTR_CSI_DATA_RSVD4,
+	MTK_VENDOR_ATTR_CSI_DATA_TX_ANT,
+	MTK_VENDOR_ATTR_CSI_DATA_RX_ANT,
+	MTK_VENDOR_ATTR_CSI_DATA_MODE,
+	MTK_VENDOR_ATTR_CSI_DATA_CHAIN_INFO,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_CSI_DATA,
+	MTK_VENDOR_ATTR_CSI_DATA_MAX =
+		NUM_MTK_VENDOR_ATTRS_CSI_DATA - 1
+};
+#endif
+
+#endif
diff --git a/testmode.c b/testmode.c
index ca4feccf..d1344fde 100644
--- a/testmode.c
+++ b/testmode.c
@@ -2,11 +2,13 @@
 /* Copyright (C) 2020 Felix Fietkau <nbd@nbd.name> */
 
 #include <linux/random.h>
+#include "mt76_connac.h"
 #include "mt76.h"
 
 const struct nla_policy mt76_tm_policy[NUM_MT76_TM_ATTRS] = {
 	[MT76_TM_ATTR_RESET] = { .type = NLA_FLAG },
 	[MT76_TM_ATTR_STATE] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_SKU_EN] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_TX_COUNT] = { .type = NLA_U32 },
 	[MT76_TM_ATTR_TX_LENGTH] = { .type = NLA_U32 },
 	[MT76_TM_ATTR_TX_RATE_MODE] = { .type = NLA_U8 },
@@ -25,9 +27,21 @@ const struct nla_policy mt76_tm_policy[NUM_MT76_TM_ATTRS] = {
 	[MT76_TM_ATTR_TX_TIME] = { .type = NLA_U32 },
 	[MT76_TM_ATTR_FREQ_OFFSET] = { .type = NLA_U32 },
 	[MT76_TM_ATTR_DRV_DATA] = { .type = NLA_NESTED },
+	[MT76_TM_ATTR_OFF_CH_SCAN_CH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_BW] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_PATH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_IPI_THRESHOLD] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_IPI_PERIOD] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_IPI_RESET] = { .type = NLA_U8 },
 };
 EXPORT_SYMBOL_GPL(mt76_tm_policy);
 
+static inline bool mt76_testmode_offload(struct mt76_dev *dev)
+{
+	return is_mt7996(dev) || is_mt7992(dev);
+}
+
 void mt76_testmode_tx_pending(struct mt76_phy *phy)
 {
 	struct mt76_testmode_data *td = &phy->test;
@@ -82,6 +96,11 @@ mt76_testmode_max_mpdu_len(struct mt76_phy *phy, u8 tx_rate_mode)
 		    IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991)
 			return IEEE80211_MAX_MPDU_LEN_VHT_7991;
 		return IEEE80211_MAX_MPDU_LEN_VHT_11454;
+	case MT76_TM_TX_MODE_EHT_SU:
+	case MT76_TM_TX_MODE_EHT_TRIG:
+	case MT76_TM_TX_MODE_EHT_MU:
+		/* TODO: check the limit */
+		return UINT_MAX;
 	case MT76_TM_TX_MODE_CCK:
 	case MT76_TM_TX_MODE_OFDM:
 	default:
@@ -174,6 +193,114 @@ int mt76_testmode_alloc_skb(struct mt76_phy *phy, u32 len)
 }
 EXPORT_SYMBOL(mt76_testmode_alloc_skb);
 
+static int
+mt76_testmode_tx_config_check(struct mt76_phy *phy)
+{
+	struct mt76_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->test;
+	struct cfg80211_chan_def *chandef = &phy->chandef;
+	u8 max_nss = hweight8(phy->antenna_mask);
+	enum invalid_type {
+		INVALID_TYPE_TX_LEN,
+		INVALID_TYPE_RATE_MODE,
+		INVALID_TYPE_RATE_IDX,
+		INVALID_TYPE_RATE_NSS,
+		INVALID_TYPE_LDPC,
+	} type;
+	static const char * const invalid_msg[] = {
+		[INVALID_TYPE_TX_LEN] = "tx length",
+		[INVALID_TYPE_RATE_MODE] = "tx rate mode",
+		[INVALID_TYPE_RATE_IDX] = "tx rate idx",
+		[INVALID_TYPE_RATE_NSS] = "tx rate nss",
+		[INVALID_TYPE_LDPC] = "tx rate ldpc",
+	};
+	u32 max_tx_len;
+
+	max_tx_len = mt76_testmode_max_mpdu_len(phy, td->tx_rate_mode);
+	if (max_tx_len < td->tx_mpdu_len ||
+	    sizeof(struct ieee80211_hdr) > td->tx_mpdu_len) {
+		type = INVALID_TYPE_TX_LEN;
+		goto fail;
+	}
+
+	if (td->tx_antenna_mask)
+		max_nss = min_t(u8, max_nss, hweight8(td->tx_antenna_mask));
+
+	switch (td->tx_rate_mode) {
+	case MT76_TM_TX_MODE_CCK:
+		if (chandef->chan->band != NL80211_BAND_2GHZ) {
+			type = INVALID_TYPE_RATE_MODE;
+			goto fail;
+		}
+		if (td->tx_rate_idx > 3) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		break;
+	case MT76_TM_TX_MODE_OFDM:
+		if (td->tx_rate_idx > 7) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		break;
+	case MT76_TM_TX_MODE_HT:
+		if (td->tx_rate_idx > 8 * max_nss - 1) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		break;
+	case MT76_TM_TX_MODE_VHT:
+		if (td->tx_rate_nss > max_nss) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		if (td->tx_rate_idx > 9) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		break;
+	case MT76_TM_TX_MODE_HE_SU:
+	case MT76_TM_TX_MODE_HE_EXT_SU:
+	case MT76_TM_TX_MODE_HE_TB:
+	case MT76_TM_TX_MODE_HE_MU:
+		if (td->tx_rate_nss > max_nss) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		if (td->tx_rate_idx > 11) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		if (chandef->width > NL80211_CHAN_WIDTH_20 &&
+		    !td->tx_rate_ldpc) {
+			type = INVALID_TYPE_LDPC;
+			goto fail;
+		}
+		break;
+	case MT76_TM_TX_MODE_EHT_SU:
+	case MT76_TM_TX_MODE_EHT_TRIG:
+	case MT76_TM_TX_MODE_EHT_MU:
+		if (td->tx_rate_idx > 15) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		if (chandef->width > NL80211_CHAN_WIDTH_20 &&
+		    !td->tx_rate_ldpc) {
+			type = INVALID_TYPE_LDPC;
+			goto fail;
+		}
+		break;
+	default:
+		type = INVALID_TYPE_RATE_MODE;
+		goto fail;
+	}
+
+	return 0;
+fail:
+	dev_err(dev->dev, "Invalid %s\n", invalid_msg[type]);
+	return -EINVAL;
+}
+
 static int
 mt76_testmode_tx_init(struct mt76_phy *phy)
 {
@@ -183,6 +310,13 @@ mt76_testmode_tx_init(struct mt76_phy *phy)
 	u8 max_nss = hweight8(phy->antenna_mask);
 	int ret;
 
+	ret = mt76_testmode_tx_config_check(phy);
+	if (ret)
+		return ret;
+
+	if (mt76_testmode_offload(phy->dev))
+		return 0;
+
 	ret = mt76_testmode_alloc_skb(phy, td->tx_mpdu_len);
 	if (ret)
 		return ret;
@@ -200,36 +334,17 @@ mt76_testmode_tx_init(struct mt76_phy *phy)
 
 	switch (td->tx_rate_mode) {
 	case MT76_TM_TX_MODE_CCK:
-		if (phy->chandef.chan->band != NL80211_BAND_2GHZ)
-			return -EINVAL;
-
-		if (rate->idx > 4)
-			return -EINVAL;
 		break;
 	case MT76_TM_TX_MODE_OFDM:
 		if (phy->chandef.chan->band != NL80211_BAND_2GHZ)
 			break;
 
-		if (rate->idx > 8)
-			return -EINVAL;
-
 		rate->idx += 4;
 		break;
 	case MT76_TM_TX_MODE_HT:
-		if (rate->idx > 8 * max_nss &&
-			!(rate->idx == 32 &&
-			  phy->chandef.width >= NL80211_CHAN_WIDTH_40))
-			return -EINVAL;
-
 		rate->flags |= IEEE80211_TX_RC_MCS;
 		break;
 	case MT76_TM_TX_MODE_VHT:
-		if (rate->idx > 9)
-			return -EINVAL;
-
-		if (td->tx_rate_nss > max_nss)
-			return -EINVAL;
-
 		ieee80211_rate_set_vht(rate, td->tx_rate_idx, td->tx_rate_nss);
 		rate->flags |= IEEE80211_TX_RC_VHT_MCS;
 		break;
@@ -275,7 +390,9 @@ mt76_testmode_tx_start(struct mt76_phy *phy)
 	td->tx_queued = 0;
 	td->tx_done = 0;
 	td->tx_pending = td->tx_count;
-	mt76_worker_schedule(&dev->tx_worker);
+
+	if (!mt76_testmode_offload(dev))
+		mt76_worker_schedule(&dev->tx_worker);
 }
 
 static void
@@ -284,6 +401,11 @@ mt76_testmode_tx_stop(struct mt76_phy *phy)
 	struct mt76_testmode_data *td = &phy->test;
 	struct mt76_dev *dev = phy->dev;
 
+	if (mt76_testmode_offload(dev) && dev->test_ops->tx_stop) {
+		dev->test_ops->tx_stop(phy);
+		return;
+	}
+
 	mt76_worker_disable(&dev->tx_worker);
 
 	td->tx_pending = 0;
@@ -296,22 +418,11 @@ mt76_testmode_tx_stop(struct mt76_phy *phy)
 	mt76_testmode_free_skb(phy);
 }
 
-static inline void
-mt76_testmode_param_set(struct mt76_testmode_data *td, u16 idx)
-{
-	td->param_set[idx / 32] |= BIT(idx % 32);
-}
-
-static inline bool
-mt76_testmode_param_present(struct mt76_testmode_data *td, u16 idx)
-{
-	return td->param_set[idx / 32] & BIT(idx % 32);
-}
-
 static void
 mt76_testmode_init_defaults(struct mt76_phy *phy)
 {
 	struct mt76_testmode_data *td = &phy->test;
+	u8 addr[ETH_ALEN] = {phy->band_idx, 0x11, 0x22, 0xaa, 0xbb, 0xcc};
 
 	if (td->tx_mpdu_len > 0)
 		return;
@@ -319,11 +430,18 @@ mt76_testmode_init_defaults(struct mt76_phy *phy)
 	td->tx_mpdu_len = 1024;
 	td->tx_count = 1;
 	td->tx_rate_mode = MT76_TM_TX_MODE_OFDM;
+	td->tx_rate_idx = 7;
 	td->tx_rate_nss = 1;
+	/* 0xffff for OFDMA no puncture */
+	td->tx_preamble_puncture = ~(td->tx_preamble_puncture & 0);
+	td->tx_ipg = 50;
+
+	/* rx stat user config */
+	td->aid = 1;
 
-	memcpy(td->addr[0], phy->macaddr, ETH_ALEN);
-	memcpy(td->addr[1], phy->macaddr, ETH_ALEN);
-	memcpy(td->addr[2], phy->macaddr, ETH_ALEN);
+	memcpy(td->addr[0], addr, ETH_ALEN);
+	memcpy(td->addr[1], addr, ETH_ALEN);
+	memcpy(td->addr[2], addr, ETH_ALEN);
 }
 
 static int
@@ -353,7 +471,7 @@ __mt76_testmode_set_state(struct mt76_phy *phy, enum mt76_testmode_state state)
 	if (state == MT76_TM_STATE_TX_FRAMES)
 		mt76_testmode_tx_start(phy);
 	else if (state == MT76_TM_STATE_RX_FRAMES) {
-		memset(&phy->test.rx_stats, 0, sizeof(phy->test.rx_stats));
+		dev->test_ops->reset_rx_stats(phy);
 	}
 
 	phy->test.state = state;
@@ -371,7 +489,8 @@ int mt76_testmode_set_state(struct mt76_phy *phy, enum mt76_testmode_state state
 
 	if (state > MT76_TM_STATE_OFF &&
 	    (!test_bit(MT76_STATE_RUNNING, &phy->state) ||
-	     !(hw->conf.flags & IEEE80211_CONF_MONITOR)))
+	     (!(hw->conf.flags & IEEE80211_CONF_MONITOR) &&
+	      !phy->monitor_vif)))
 		return -ENOTCONN;
 
 	if (state != MT76_TM_STATE_IDLE &&
@@ -404,6 +523,82 @@ mt76_tm_get_u8(struct nlattr *attr, u8 *dest, u8 min, u8 max)
 	return 0;
 }
 
+static int
+mt76_testmode_set_eeprom(struct mt76_phy *phy, struct nlattr **tb)
+{
+	struct mt76_dev *dev = phy->dev;
+	u8 action, val[MT76_TM_EEPROM_BLOCK_SIZE];
+	u32 offset = 0;
+	int err = -EINVAL;
+
+	if (!dev->test_ops->set_eeprom)
+		return -EOPNOTSUPP;
+
+	if (mt76_tm_get_u8(tb[MT76_TM_ATTR_EEPROM_ACTION], &action,
+			   0, MT76_TM_EEPROM_ACTION_MAX))
+		goto out;
+
+	if (tb[MT76_TM_ATTR_EEPROM_OFFSET]) {
+		struct nlattr *cur;
+		int rem, idx = 0;
+
+		offset = nla_get_u32(tb[MT76_TM_ATTR_EEPROM_OFFSET]);
+		if (!!(offset % MT76_TM_EEPROM_BLOCK_SIZE) ||
+		    !tb[MT76_TM_ATTR_EEPROM_VAL])
+			goto out;
+
+		nla_for_each_nested(cur, tb[MT76_TM_ATTR_EEPROM_VAL], rem) {
+			if (nla_len(cur) != 1 || idx >= ARRAY_SIZE(val))
+				goto out;
+
+			val[idx++] = nla_get_u8(cur);
+		}
+	}
+
+	err = dev->test_ops->set_eeprom(phy, offset, val, action);
+
+out:
+	return err;
+}
+
+static int
+mt76_testmode_txbf_profile_update_all_cmd(struct mt76_phy *phy, struct nlattr **tb, u32 state)
+{
+#define PARAM_UNIT	5
+#define PARAM_UNIT_5X5	6
+	static u8 pfmu_idx;
+	struct mt76_testmode_data *td = &phy->test;
+	struct mt76_dev *dev = phy->dev;
+	struct nlattr *cur;
+	u16 tmp_val[PARAM_UNIT_5X5], *val = td->txbf_param;
+	int idx, rem, ret, i = 0;
+	int param_len = hweight16(phy->chainmask) == 5 ? PARAM_UNIT_5X5 : PARAM_UNIT;
+
+	memset(td->txbf_param, 0, sizeof(td->txbf_param));
+	nla_for_each_nested(cur, tb[MT76_TM_ATTR_TXBF_PARAM], rem) {
+		if (nla_len(cur) != 2)
+			return -EINVAL;
+		idx = i % param_len;
+		tmp_val[idx] = nla_get_u16(cur);
+		if (idx == 1 && (tmp_val[idx] == 0xf0 || tmp_val[idx] == 0xff)) {
+			pfmu_idx = tmp_val[0];
+			return 0;
+		}
+		if (idx == param_len - 1) {
+			val[0] = pfmu_idx;
+			memcpy(val + 1, tmp_val, param_len * sizeof(u16));
+			if (dev->test_ops->set_params) {
+				ret = dev->test_ops->set_params(phy, tb, state);
+				if (ret)
+					return ret;
+			}
+		}
+		i++;
+	}
+
+	return 0;
+}
+
 int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		      void *data, int len)
 {
@@ -427,6 +622,11 @@ int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 
 	mutex_lock(&dev->mutex);
 
+	if (tb[MT76_TM_ATTR_EEPROM_ACTION]) {
+		err = mt76_testmode_set_eeprom(phy, tb);
+		goto out;
+	}
+
 	if (tb[MT76_TM_ATTR_RESET]) {
 		mt76_testmode_set_state(phy, MT76_TM_STATE_OFF);
 		memset(td, 0, sizeof(*td));
@@ -434,12 +634,18 @@ int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 
 	mt76_testmode_init_defaults(phy);
 
+	if (tb[MT76_TM_ATTR_SKU_EN])
+		td->sku_en = nla_get_u8(tb[MT76_TM_ATTR_SKU_EN]);
+
 	if (tb[MT76_TM_ATTR_TX_COUNT])
 		td->tx_count = nla_get_u32(tb[MT76_TM_ATTR_TX_COUNT]);
 
 	if (tb[MT76_TM_ATTR_TX_RATE_IDX])
 		td->tx_rate_idx = nla_get_u8(tb[MT76_TM_ATTR_TX_RATE_IDX]);
 
+	if (tb[MT76_TM_ATTR_IPI_PERIOD])
+		td->ipi_period = nla_get_u32(tb[MT76_TM_ATTR_IPI_PERIOD]);
+
 	if (mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_MODE], &td->tx_rate_mode,
 			   0, MT76_TM_TX_MODE_MAX) ||
 	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_NSS], &td->tx_rate_nss,
@@ -454,7 +660,15 @@ int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_DUTY_CYCLE],
 			   &td->tx_duty_cycle, 0, 99) ||
 	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_POWER_CONTROL],
-			   &td->tx_power_control, 0, 1))
+			   &td->tx_power_control, 0, 1) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_AID], &td->aid, 0, 16) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_OFF_CH_SCAN_CH], &td->offchan_ch, 36, 196) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH], &td->offchan_center_ch,
+			   36, 196) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_OFF_CH_SCAN_BW],
+			   &td->offchan_bw, NL80211_CHAN_WIDTH_20_NOHT, NL80211_CHAN_WIDTH_160) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_IPI_THRESHOLD], &td->ipi_threshold, 0, 10) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_IPI_RESET], &td->ipi_reset, 0, 1))
 		goto out;
 
 	if (tb[MT76_TM_ATTR_TX_LENGTH]) {
@@ -494,7 +708,9 @@ int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			    idx >= ARRAY_SIZE(td->tx_power))
 				goto out;
 
-			td->tx_power[idx++] = nla_get_u8(cur);
+			err = mt76_tm_get_u8(cur, &td->tx_power[idx++], 0, 63);
+			if (err)
+				return err;
 		}
 	}
 
@@ -512,6 +728,46 @@ int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		}
 	}
 
+	if (tb[MT76_TM_ATTR_CFG]) {
+		struct nlattr *cur;
+		int rem, idx = 0;
+
+		nla_for_each_nested(cur, tb[MT76_TM_ATTR_CFG], rem) {
+			if (nla_len(cur) != 1 || idx >= 2)
+				goto out;
+
+			if (idx == 0)
+				td->cfg.type = nla_get_u8(cur);
+			else
+				td->cfg.enable = nla_get_u8(cur);
+			idx++;
+		}
+	}
+
+	if (tb[MT76_TM_ATTR_TXBF_ACT]) {
+		struct nlattr *cur;
+		int rem, idx = 0;
+
+		if (!tb[MT76_TM_ATTR_TXBF_PARAM] ||
+		    mt76_tm_get_u8(tb[MT76_TM_ATTR_TXBF_ACT], &td->txbf_act,
+				   0, MT76_TM_TXBF_ACT_MAX))
+			goto out;
+
+		if (td->txbf_act == MT76_TM_TXBF_ACT_PROF_UPDATE_ALL_CMD) {
+			err = mt76_testmode_txbf_profile_update_all_cmd(phy, tb, state);
+			goto out;
+		}
+
+		memset(td->txbf_param, 0, sizeof(td->txbf_param));
+		nla_for_each_nested(cur, tb[MT76_TM_ATTR_TXBF_PARAM], rem) {
+			if (nla_len(cur) != 2 ||
+			    idx >= ARRAY_SIZE(td->txbf_param))
+				goto out;
+
+			td->txbf_param[idx++] = nla_get_u16(cur);
+		}
+	}
+
 	if (dev->test_ops->set_params) {
 		err = dev->test_ops->set_params(phy, tb, state);
 		if (err)
@@ -561,6 +817,9 @@ mt76_testmode_dump_stats(struct mt76_phy *phy, struct sk_buff *msg)
 	    nla_put_u64_64bit(msg, MT76_TM_STATS_ATTR_RX_PACKETS, rx_packets,
 			      MT76_TM_STATS_ATTR_PAD) ||
 	    nla_put_u64_64bit(msg, MT76_TM_STATS_ATTR_RX_FCS_ERROR, rx_fcs_error,
+			      MT76_TM_STATS_ATTR_PAD) ||
+	    nla_put_u64_64bit(msg, MT76_TM_STATS_ATTR_RX_LEN_MISMATCH,
+			      td->rx_stats.len_mismatch,
 			      MT76_TM_STATS_ATTR_PAD))
 		return -EMSGSIZE;
 
@@ -593,6 +852,18 @@ int mt76_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *msg,
 
 	mutex_lock(&dev->mutex);
 
+	if (tb[MT76_TM_ATTR_PRECAL] || tb[MT76_TM_ATTR_PRECAL_INFO]) {
+		int flag, type;
+
+		err = -EINVAL;
+		flag = tb[MT76_TM_ATTR_PRECAL] ? 1 : 0;
+		type = flag ? nla_get_u8(tb[MT76_TM_ATTR_PRECAL_INFO]) : 0;
+		if (dev->test_ops->dump_precal)
+			err = dev->test_ops->dump_precal(phy, msg, flag, type);
+
+		goto out;
+	}
+
 	if (tb[MT76_TM_ATTR_STATS]) {
 		err = -EINVAL;
 
@@ -611,6 +882,9 @@ int mt76_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *msg,
 	if (nla_put_u32(msg, MT76_TM_ATTR_STATE, td->state))
 		goto out;
 
+	if (nla_put_u8(msg, MT76_TM_ATTR_BAND_IDX, phy->band_idx))
+		goto out;
+
 	if (dev->test_mtd.name &&
 	    (nla_put_string(msg, MT76_TM_ATTR_MTD_PART, dev->test_mtd.name) ||
 	     nla_put_u32(msg, MT76_TM_ATTR_MTD_OFFSET, dev->test_mtd.offset)))
@@ -624,6 +898,11 @@ int mt76_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *msg,
 	    nla_put_u8(msg, MT76_TM_ATTR_TX_RATE_SGI, td->tx_rate_sgi) ||
 	    nla_put_u8(msg, MT76_TM_ATTR_TX_RATE_LDPC, td->tx_rate_ldpc) ||
 	    nla_put_u8(msg, MT76_TM_ATTR_TX_RATE_STBC, td->tx_rate_stbc) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_SKU_EN, td->sku_en) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_AID, td->aid) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_OFF_CH_SCAN_CH, td->offchan_ch) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH, td->offchan_center_ch) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_OFF_CH_SCAN_BW, td->offchan_bw) ||
 	    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_LTF) &&
 	     nla_put_u8(msg, MT76_TM_ATTR_TX_LTF, td->tx_ltf)) ||
 	    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_ANTENNA) &&
@@ -639,7 +918,7 @@ int mt76_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *msg,
 	    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_POWER_CONTROL) &&
 	     nla_put_u8(msg, MT76_TM_ATTR_TX_POWER_CONTROL, td->tx_power_control)) ||
 	    (mt76_testmode_param_present(td, MT76_TM_ATTR_FREQ_OFFSET) &&
-	     nla_put_u8(msg, MT76_TM_ATTR_FREQ_OFFSET, td->freq_offset)))
+	     nla_put_u32(msg, MT76_TM_ATTR_FREQ_OFFSET, td->freq_offset)))
 		goto out;
 
 	if (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_POWER)) {
diff --git a/testmode.h b/testmode.h
index 1b0bcae8..794a74f9 100644
--- a/testmode.h
+++ b/testmode.h
@@ -5,7 +5,8 @@
 #ifndef __MT76_TESTMODE_H
 #define __MT76_TESTMODE_H
 
-#define MT76_TM_TIMEOUT	10
+#define MT76_TM_TIMEOUT			10
+#define MT76_TM_EEPROM_BLOCK_SIZE	16
 
 /**
  * enum mt76_testmode_attr - testmode attributes inside NL80211_ATTR_TESTDATA
@@ -15,9 +16,11 @@
  * @MT76_TM_ATTR_RESET: reset parameters to default (flag)
  * @MT76_TM_ATTR_STATE: test state (u32), see &enum mt76_testmode_state
  *
- * @MT76_TM_ATTR_MTD_PART: mtd partition used for eeprom data (string)
+ * @MT76_TM_ATTR_MTD_PART: mtd partition or binfile used for eeprom data (string)
  * @MT76_TM_ATTR_MTD_OFFSET: offset of eeprom data within the partition (u32)
+ * @MT76_TM_ATTR_BAND_IDX: band idx of the chip (u8)
  *
+ * @MT76_TM_ATTR_SKU_EN: config txpower sku is enabled or disabled in testmode (u8)
  * @MT76_TM_ATTR_TX_COUNT: configured number of frames to send when setting
  *	state to MT76_TM_STATE_TX_FRAMES (u32)
  * @MT76_TM_ATTR_TX_PENDING: pending frames during MT76_TM_STATE_TX_FRAMES (u32)
@@ -38,6 +41,11 @@
  *
  * @MT76_TM_ATTR_STATS: statistics (nested, see &enum mt76_testmode_stats_attr)
  *
+ * @MT76_TM_ATTR_PRECAL: Pre-cal data (u8)
+ * @MT76_TM_ATTR_PRECAL_INFO: group size, dpd size, dpd_info, transmit size,
+ *                            eeprom cal indicator (u32),
+ *                            dpd_info = [dpd_per_chan_size, chan_num_2g,
+ *                                        chan_num_5g, chan_num_6g]
  * @MT76_TM_ATTR_TX_SPE_IDX: tx spatial extension index (u8)
  *
  * @MT76_TM_ATTR_TX_DUTY_CYCLE: packet tx duty cycle (u8)
@@ -47,6 +55,29 @@
  * @MT76_TM_ATTR_DRV_DATA: driver specific netlink attrs (nested)
  *
  * @MT76_TM_ATTR_MAC_ADDRS: array of nested MAC addresses (nested)
+ *
+ * @MT76_TM_ATTR_EEPROM_ACTION: eeprom setting actions
+ *	(u8, see &enum mt76_testmode_eeprom_action)
+ * @MT76_TM_ATTR_EEPROM_OFFSET: offset of eeprom data block for writing (u32)
+ * @MT76_TM_ATTR_EEPROM_VAL: values for writing into a 16-byte data block
+ *	(nested, u8 attrs)
+ *
+ * @MT76_TM_ATTR_CFG: config testmode rf feature (nested, see &mt76_testmode_cfg)
+ * @MT76_TM_ATTR_TXBF_ACT: txbf setting actions (u8)
+ * @MT76_TM_ATTR_TXBF_PARAM: txbf parameters (nested)
+ *
+ * @MT76_TM_ATTR_OFF_CH_SCAN_CH: config the channel of background chain (ZWDFS) (u8)
+ * @MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH: config the center channel of background chain (ZWDFS) (u8)
+ * @MT76_TM_ATTR_OFF_CH_SCAN_BW: config the bandwidth of background chain (ZWDFS) (u8)
+ * @MT76_TM_ATTR_OFF_CH_SCAN_PATH: config the tx path of background chain (ZWDFS) (u8)
+ *
+ * @MT76_TM_ATTR_IPI_THRESHOLD: config the IPI index you want to read (u8)
+ * @MT76_TM_ATTR_IPI_PERIOD: config the time period for reading
+ *			     the histogram of specific IPI index (u8)
+ * @MT76_TM_ATTR_IPI_ANTENNA_INDEX: config the antenna index for reading
+ *				    the histogram of specific IPI index (u8)
+ * @MT76_TM_ATTR_IPI_RESET: Reset the IPI counter
+ *
  */
 enum mt76_testmode_attr {
 	MT76_TM_ATTR_UNSPEC,
@@ -56,7 +87,9 @@ enum mt76_testmode_attr {
 
 	MT76_TM_ATTR_MTD_PART,
 	MT76_TM_ATTR_MTD_OFFSET,
+	MT76_TM_ATTR_BAND_IDX,
 
+	MT76_TM_ATTR_SKU_EN,
 	MT76_TM_ATTR_TX_COUNT,
 	MT76_TM_ATTR_TX_LENGTH,
 	MT76_TM_ATTR_TX_RATE_MODE,
@@ -74,6 +107,8 @@ enum mt76_testmode_attr {
 	MT76_TM_ATTR_FREQ_OFFSET,
 
 	MT76_TM_ATTR_STATS,
+	MT76_TM_ATTR_PRECAL,
+	MT76_TM_ATTR_PRECAL_INFO,
 
 	MT76_TM_ATTR_TX_SPE_IDX,
 
@@ -84,6 +119,27 @@ enum mt76_testmode_attr {
 	MT76_TM_ATTR_DRV_DATA,
 
 	MT76_TM_ATTR_MAC_ADDRS,
+	MT76_TM_ATTR_AID,
+	MT76_TM_ATTR_RU_ALLOC,
+	MT76_TM_ATTR_RU_IDX,
+
+	MT76_TM_ATTR_EEPROM_ACTION,
+	MT76_TM_ATTR_EEPROM_OFFSET,
+	MT76_TM_ATTR_EEPROM_VAL,
+
+	MT76_TM_ATTR_CFG,
+	MT76_TM_ATTR_TXBF_ACT,
+	MT76_TM_ATTR_TXBF_PARAM,
+
+	MT76_TM_ATTR_OFF_CH_SCAN_CH,
+	MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH,
+	MT76_TM_ATTR_OFF_CH_SCAN_BW,
+	MT76_TM_ATTR_OFF_CH_SCAN_PATH,
+
+	MT76_TM_ATTR_IPI_THRESHOLD,
+	MT76_TM_ATTR_IPI_PERIOD,
+	MT76_TM_ATTR_IPI_ANTENNA_INDEX,
+	MT76_TM_ATTR_IPI_RESET,
 
 	/* keep last */
 	NUM_MT76_TM_ATTRS,
@@ -101,6 +157,8 @@ enum mt76_testmode_attr {
  * @MT76_TM_STATS_ATTR_RX_FCS_ERROR: number of rx packets with FCS error (u64)
  * @MT76_TM_STATS_ATTR_LAST_RX: information about the last received packet
  *	see &enum mt76_testmode_rx_attr
+ * @MT76_TM_STATS_ATTR_RX_LEN_MISMATCH: number of rx packets with length
+ *	mismatch error (u64)
  */
 enum mt76_testmode_stats_attr {
 	MT76_TM_STATS_ATTR_UNSPEC,
@@ -113,6 +171,7 @@ enum mt76_testmode_stats_attr {
 	MT76_TM_STATS_ATTR_RX_PACKETS,
 	MT76_TM_STATS_ATTR_RX_FCS_ERROR,
 	MT76_TM_STATS_ATTR_LAST_RX,
+	MT76_TM_STATS_ATTR_RX_LEN_MISMATCH,
 
 	/* keep last */
 	NUM_MT76_TM_STATS_ATTRS,
@@ -125,6 +184,7 @@ enum mt76_testmode_stats_attr {
  *
  * @MT76_TM_RX_ATTR_FREQ_OFFSET: frequency offset (s32)
  * @MT76_TM_RX_ATTR_RCPI: received channel power indicator (array, u8)
+ * @MT76_TM_RX_ATTR_RSSI: received signal strength indicator (array, s8)
  * @MT76_TM_RX_ATTR_IB_RSSI: internal inband RSSI (array, s8)
  * @MT76_TM_RX_ATTR_WB_RSSI: internal wideband RSSI (array, s8)
  * @MT76_TM_RX_ATTR_SNR: signal-to-noise ratio (u8)
@@ -134,6 +194,7 @@ enum mt76_testmode_rx_attr {
 
 	MT76_TM_RX_ATTR_FREQ_OFFSET,
 	MT76_TM_RX_ATTR_RCPI,
+	MT76_TM_RX_ATTR_RSSI,
 	MT76_TM_RX_ATTR_IB_RSSI,
 	MT76_TM_RX_ATTR_WB_RSSI,
 	MT76_TM_RX_ATTR_SNR,
@@ -159,6 +220,14 @@ enum mt76_testmode_state {
 	MT76_TM_STATE_TX_FRAMES,
 	MT76_TM_STATE_RX_FRAMES,
 	MT76_TM_STATE_TX_CONT,
+	MT76_TM_STATE_GROUP_PREK,
+	MT76_TM_STATE_GROUP_PREK_DUMP,
+	MT76_TM_STATE_GROUP_PREK_CLEAN,
+	MT76_TM_STATE_DPD_2G,
+	MT76_TM_STATE_DPD_5G,
+	MT76_TM_STATE_DPD_6G,
+	MT76_TM_STATE_DPD_DUMP,
+	MT76_TM_STATE_DPD_CLEAN,
 	MT76_TM_STATE_ON,
 
 	/* keep last */
@@ -177,6 +246,9 @@ enum mt76_testmode_state {
  * @MT76_TM_TX_MODE_HE_EXT_SU: 802.11ax extended-range SU
  * @MT76_TM_TX_MODE_HE_TB: 802.11ax trigger-based
  * @MT76_TM_TX_MODE_HE_MU: 802.11ax multi-user MIMO
+ * @MT76_TM_TX_MODE_EHT_SU: 802.11be single-user MIMO
+ * @MT76_TM_TX_MODE_EHT_TRIG: 802.11be trigger-based
+ * @MT76_TM_TX_MODE_EHT_MU: 802.11be multi-user MIMO
  */
 enum mt76_testmode_tx_mode {
 	MT76_TM_TX_MODE_CCK,
@@ -187,10 +259,84 @@ enum mt76_testmode_tx_mode {
 	MT76_TM_TX_MODE_HE_EXT_SU,
 	MT76_TM_TX_MODE_HE_TB,
 	MT76_TM_TX_MODE_HE_MU,
+	MT76_TM_TX_MODE_EHT_SU,
+	MT76_TM_TX_MODE_EHT_TRIG,
+	MT76_TM_TX_MODE_EHT_MU,
 
 	/* keep last */
 	NUM_MT76_TM_TX_MODES,
 	MT76_TM_TX_MODE_MAX = NUM_MT76_TM_TX_MODES - 1,
 };
 
+/**
+ * enum mt76_testmode_eeprom_action - eeprom setting actions
+ *
+ * @MT76_TM_EEPROM_ACTION_UPDATE_DATA: update rf values to specific
+ *	eeprom data block
+ * @MT76_TM_EEPROM_ACTION_UPDATE_BUFFER_MODE: send updated eeprom data to fw
+ * @MT76_TM_EEPROM_ACTION_WRITE_TO_EFUSE: write eeprom data back to efuse
+ */
+enum mt76_testmode_eeprom_action {
+	MT76_TM_EEPROM_ACTION_UPDATE_DATA,
+	MT76_TM_EEPROM_ACTION_UPDATE_BUFFER_MODE,
+	MT76_TM_EEPROM_ACTION_WRITE_TO_EFUSE,
+
+	/* keep last */
+	NUM_MT76_TM_EEPROM_ACTION,
+	MT76_TM_EEPROM_ACTION_MAX = NUM_MT76_TM_EEPROM_ACTION - 1,
+};
+
+/**
+ * enum mt76_testmode_txbf_act - txbf action
+ *
+ * @MT76_TM_TXBF_ACT_GOLDEN_INIT: init ibf setting for golden device
+ * @MT76_TM_TXBF_ACT_INIT: init ibf setting for DUT
+ * @MT76_TM_TX_EBF_ACT_GOLDEN_INIT: init ebf setting for golden device
+ * @MT76_TM_TX_EBF_ACT_INIT: init ebf setting for DUT
+ * @MT76_TM_TXBF_ACT_UPDATE_CH: update channel info
+ * @MT76_TM_TXBF_ACT_PHASE_COMP: txbf phase compensation
+ * @MT76_TM_TXBF_ACT_TX_PREP: TX preparation for txbf
+ * @MT76_TM_TXBF_ACT_IBF_PROF_UPDATE: update ibf profile (pfmu tag, bf sta record)
+ * @MT76_TM_TXBF_ACT_EBF_PROF_UPDATE: update ebf profile
+ * @MT76_TM_TXBF_ACT_APPLY_TX: apply TX setting for txbf
+ * @MT76_TM_TXBF_ACT_PHASE_CAL: perform txbf phase calibration
+ * @MT76_TM_TXBF_ACT_PROF_UPDATE_ALL: update bf profile via instrument
+ * @MT76_TM_TXBF_ACT_PROF_UPDATE_ALL_CMD: update bf profile via instrument
+ * @MT76_TM_TXBF_ACT_E2P_UPDATE: write back txbf calibration result to eeprom
+ * @MT76_TM_TXBF_ACT_TRIGGER_SOUNDING: trigger beamformer to send sounding packet
+ * @MT76_TM_TXBF_ACT_STOP_SOUNDING: stop sending sounding packet
+ * @MT76_TM_TXBF_ACT_PROFILE_TAG_READ: read pfmu tag
+ * @MT76_TM_TXBF_ACT_PROFILE_TAG_WRITE: update pfmu tag
+ * @MT76_TM_TXBF_ACT_PROFILE_TAG_INVALID: invalidate pfmu tag
+ * @MT76_TM_TXBF_ACT_STA_REC_READ: read bf sta record
+ * @MT76_TM_TXBF_ACT_TXCMD: configure txcmd bf bit manually
+ */
+enum mt76_testmode_txbf_act {
+	MT76_TM_TXBF_ACT_GOLDEN_INIT,
+	MT76_TM_TXBF_ACT_INIT,
+	MT76_TM_TX_EBF_ACT_GOLDEN_INIT,
+	MT76_TM_TX_EBF_ACT_INIT,
+	MT76_TM_TXBF_ACT_UPDATE_CH,
+	MT76_TM_TXBF_ACT_PHASE_COMP,
+	MT76_TM_TXBF_ACT_TX_PREP,
+	MT76_TM_TXBF_ACT_IBF_PROF_UPDATE,
+	MT76_TM_TXBF_ACT_EBF_PROF_UPDATE,
+	MT76_TM_TXBF_ACT_APPLY_TX,
+	MT76_TM_TXBF_ACT_PHASE_CAL,
+	MT76_TM_TXBF_ACT_PROF_UPDATE_ALL,
+	MT76_TM_TXBF_ACT_PROF_UPDATE_ALL_CMD,
+	MT76_TM_TXBF_ACT_E2P_UPDATE,
+	MT76_TM_TXBF_ACT_TRIGGER_SOUNDING,
+	MT76_TM_TXBF_ACT_STOP_SOUNDING,
+	MT76_TM_TXBF_ACT_PROFILE_TAG_READ,
+	MT76_TM_TXBF_ACT_PROFILE_TAG_WRITE,
+	MT76_TM_TXBF_ACT_PROFILE_TAG_INVALID,
+	MT76_TM_TXBF_ACT_STA_REC_READ,
+	MT76_TM_TXBF_ACT_TXCMD,
+
+	/* keep last */
+	NUM_MT76_TM_TXBF_ACT,
+	MT76_TM_TXBF_ACT_MAX = NUM_MT76_TM_TXBF_ACT - 1,
+};
+
 #endif
diff --git a/tools/CMakeLists.txt b/tools/CMakeLists.txt
index 3a83e34d..6599c444 100644
--- a/tools/CMakeLists.txt
+++ b/tools/CMakeLists.txt
@@ -3,6 +3,13 @@ cmake_minimum_required(VERSION 2.8)
 PROJECT(mt76-test C)
 ADD_DEFINITIONS(-Os -Wall -Werror --std=gnu99 -g3)
 
+UNSET(backports_dir CACHE)
+FIND_PATH(
+	backports_dir
+	NAMES "mac80211/uapi/linux"
+)
+INCLUDE_DIRECTORIES("${backports_dir}/mac80211/uapi")
+
 ADD_EXECUTABLE(mt76-test main.c fields.c eeprom.c fwlog.c)
 TARGET_LINK_LIBRARIES(mt76-test nl-tiny)
 
diff --git a/tools/eeprom.c b/tools/eeprom.c
index d8fceaa5..cbb44d82 100644
--- a/tools/eeprom.c
+++ b/tools/eeprom.c
@@ -132,6 +132,7 @@ mt76_eeprom_init_file(void)
 int mt76_eeprom_init(int phy)
 {
 	struct nl_msg *msg;
+	int len;
 
 	msg = unl_genl_msg(&unl, NL80211_CMD_TESTMODE, true);
 	nla_put_u32(msg, NL80211_ATTR_WIPHY, phy);
@@ -142,8 +143,9 @@ int mt76_eeprom_init(int phy)
 		return -1;
 	}
 
-	eeprom_file = malloc(sizeof(EEPROM_FILE_PATH_FMT) + strlen(mtd_part));
-	sprintf(eeprom_file, EEPROM_FILE_PATH_FMT, mtd_part);
+	len = sizeof(EEPROM_FILE_PATH_FMT) + strlen(mtd_part);
+	eeprom_file = malloc(len);
+	snprintf(eeprom_file, len, EEPROM_FILE_PATH_FMT, mtd_part);
 
 	eeprom_fd = mt76_eeprom_init_file();
 	if (eeprom_fd < 0)
diff --git a/tools/fields.c b/tools/fields.c
index e3f69089..f793d1a5 100644
--- a/tools/fields.c
+++ b/tools/fields.c
@@ -10,6 +10,15 @@ static const char * const testmode_state[] = {
 	[MT76_TM_STATE_IDLE] = "idle",
 	[MT76_TM_STATE_TX_FRAMES] = "tx_frames",
 	[MT76_TM_STATE_RX_FRAMES] = "rx_frames",
+	[MT76_TM_STATE_TX_CONT] = "tx_cont",
+	[MT76_TM_STATE_GROUP_PREK] = "group_prek",
+	[MT76_TM_STATE_GROUP_PREK_DUMP] = "group_prek_dump",
+	[MT76_TM_STATE_GROUP_PREK_CLEAN] = "group_prek_clean",
+	[MT76_TM_STATE_DPD_2G] = "dpd_2g",
+	[MT76_TM_STATE_DPD_5G] = "dpd_5g",
+	[MT76_TM_STATE_DPD_6G] = "dpd_6g",
+	[MT76_TM_STATE_DPD_DUMP] = "dpd_dump",
+	[MT76_TM_STATE_DPD_CLEAN] = "dpd_clean",
 };
 
 static const char * const testmode_tx_mode[] = {
@@ -21,6 +30,42 @@ static const char * const testmode_tx_mode[] = {
 	[MT76_TM_TX_MODE_HE_EXT_SU] = "he_ext_su",
 	[MT76_TM_TX_MODE_HE_TB] = "he_tb",
 	[MT76_TM_TX_MODE_HE_MU] = "he_mu",
+	[MT76_TM_TX_MODE_EHT_SU] = "eht_su",
+	[MT76_TM_TX_MODE_EHT_TRIG] = "eht_tb",
+	[MT76_TM_TX_MODE_EHT_MU] = "eht_mu",
+};
+
+static const char * const testmode_offchan_bw[] = {
+	[NL80211_CHAN_WIDTH_20_NOHT] = "NOHT",
+	[NL80211_CHAN_WIDTH_20] = "20",
+	[NL80211_CHAN_WIDTH_40] = "40",
+	[NL80211_CHAN_WIDTH_80] = "80",
+	[NL80211_CHAN_WIDTH_80P80] = "80p80",
+	[NL80211_CHAN_WIDTH_160] = "160",
+};
+
+static const char * const testmode_txbf_act[] = {
+	[MT76_TM_TXBF_ACT_GOLDEN_INIT] = "golden_init",
+	[MT76_TM_TXBF_ACT_INIT] = "init",
+	[MT76_TM_TX_EBF_ACT_GOLDEN_INIT] = "ebf_golden_init",
+	[MT76_TM_TX_EBF_ACT_INIT] = "ebf_init",
+	[MT76_TM_TXBF_ACT_UPDATE_CH] = "update_ch",
+	[MT76_TM_TXBF_ACT_PHASE_COMP] = "phase_comp",
+	[MT76_TM_TXBF_ACT_TX_PREP] = "tx_prep",
+	[MT76_TM_TXBF_ACT_IBF_PROF_UPDATE] = "ibf_prof_update",
+	[MT76_TM_TXBF_ACT_EBF_PROF_UPDATE] = "ebf_prof_update",
+	[MT76_TM_TXBF_ACT_APPLY_TX] = "apply_tx",
+	[MT76_TM_TXBF_ACT_PHASE_CAL] = "phase_cal",
+	[MT76_TM_TXBF_ACT_PROF_UPDATE_ALL] = "prof_update",
+	[MT76_TM_TXBF_ACT_PROF_UPDATE_ALL_CMD] = "prof_update_all",
+	[MT76_TM_TXBF_ACT_E2P_UPDATE] = "e2p_update",
+	[MT76_TM_TXBF_ACT_TRIGGER_SOUNDING] = "trigger_sounding",
+	[MT76_TM_TXBF_ACT_STOP_SOUNDING] = "stop_sounding",
+	[MT76_TM_TXBF_ACT_PROFILE_TAG_READ] = "pfmu_tag_read",
+	[MT76_TM_TXBF_ACT_PROFILE_TAG_WRITE] = "pfmu_tag_write",
+	[MT76_TM_TXBF_ACT_PROFILE_TAG_INVALID] = "set_invalid_prof",
+	[MT76_TM_TXBF_ACT_STA_REC_READ] = "sta_rec_read",
+	[MT76_TM_TXBF_ACT_TXCMD] = "txcmd",
 };
 
 static void print_enum(const struct tm_field *field, struct nlattr *attr)
@@ -65,7 +110,7 @@ static bool parse_u8(const struct tm_field *field, int idx,
 
 static void print_u8(const struct tm_field *field, struct nlattr *attr)
 {
-	printf("%d", nla_get_u8(attr));
+	printf("%u", nla_get_u8(attr));
 }
 
 static void print_s8(const struct tm_field *field, struct nlattr *attr)
@@ -73,6 +118,17 @@ static void print_s8(const struct tm_field *field, struct nlattr *attr)
 	printf("%d", (int8_t)nla_get_u8(attr));
 }
 
+static bool parse_u16_hex(const struct tm_field *field, int idx,
+			  struct nl_msg *msg, const char *val)
+{
+	return !nla_put_u16(msg, idx, strtoul(val, NULL, 16));
+}
+
+static void print_u16_hex(const struct tm_field *field, struct nlattr *attr)
+{
+	printf("%d", nla_get_u16(attr));
+}
+
 static bool parse_u32(const struct tm_field *field, int idx,
 		      struct nl_msg *msg, const char *val)
 {
@@ -86,12 +142,12 @@ static void print_s32(const struct tm_field *field, struct nlattr *attr)
 
 static void print_u32(const struct tm_field *field, struct nlattr *attr)
 {
-	printf("%d", nla_get_u32(attr));
+	printf("%u", nla_get_u32(attr));
 }
 
 static void print_u64(const struct tm_field *field, struct nlattr *attr)
 {
-	printf("%lld", (unsigned long long)nla_get_u64(attr));
+	printf("%llu", (unsigned long long)nla_get_u64(attr));
 }
 
 static bool parse_flag(const struct tm_field *field, int idx,
@@ -201,6 +257,62 @@ static void print_extra_stats(const struct tm_field *field, struct nlattr **tb)
 	printf("%srx_per=%.02f%%\n", prefix, 100 * failed / total);
 }
 
+static bool parse_mac(const struct tm_field *field, int idx,
+		      struct nl_msg *msg, const char *val)
+{
+#define ETH_ALEN	6
+	bool ret = true;
+	char *str, *cur, *ap;
+	void *a;
+
+	str = strdup(val);
+	ap = str;
+
+	a = nla_nest_start(msg, idx);
+
+	idx = 0;
+	while ((cur = strsep(&ap, ",")) != NULL) {
+		unsigned char addr[ETH_ALEN];
+		char *val, *tmp = cur;
+		int i = 0;
+
+		while ((val = strsep(&tmp, ":")) != NULL) {
+			if (i >= ETH_ALEN)
+				break;
+
+			addr[i++] = strtoul(val, NULL, 16);
+		}
+
+		nla_put(msg, idx, ETH_ALEN, addr);
+
+		idx++;
+	}
+
+	nla_nest_end(msg, a);
+
+	free(str);
+
+	return ret;
+}
+
+static void print_mac(const struct tm_field *field, struct nlattr *attr)
+{
+#define MAC2STR(a) (a)[0], (a)[1], (a)[2], (a)[3], (a)[4], (a)[5]
+#define MACSTR "%02x:%02x:%02x:%02x:%02x:%02x"
+	unsigned char addr[3][6];
+	struct nlattr *cur;
+	int idx = 0;
+	int rem;
+
+	nla_for_each_nested(cur, attr, rem) {
+		if (nla_len(cur) != 6)
+			continue;
+		memcpy(addr[idx++], nla_data(cur), 6);
+	}
+
+	printf("" MACSTR "," MACSTR "," MACSTR "",
+	       MAC2STR(addr[0]), MAC2STR(addr[1]), MAC2STR(addr[2]));
+}
 
 #define FIELD_GENERIC(_field, _name, ...)	\
 	[FIELD_NAME(_field)] = {			\
@@ -250,10 +362,18 @@ static void print_extra_stats(const struct tm_field *field, struct nlattr **tb)
 		 ##__VA_ARGS__				\
 	)
 
+#define FIELD_MAC(_field, _name)			\
+	[FIELD_NAME(_field)] = {			\
+		.name = _name,				\
+		.parse = parse_mac,			\
+		.print = print_mac			\
+	}
+
 #define FIELD_NAME(_field) MT76_TM_RX_ATTR_##_field
 static const struct tm_field rx_fields[NUM_MT76_TM_RX_ATTRS] = {
 	FIELD_RO(s32, FREQ_OFFSET, "freq_offset"),
 	FIELD_ARRAY_RO(u8, RCPI, "rcpi"),
+	FIELD_ARRAY_RO(s8, RSSI, "rssi"),
 	FIELD_ARRAY_RO(s8, IB_RSSI, "ib_rssi"),
 	FIELD_ARRAY_RO(s8, WB_RSSI, "wb_rssi"),
 	FIELD_RO(s8, SNR, "snr"),
@@ -261,6 +381,7 @@ static const struct tm_field rx_fields[NUM_MT76_TM_RX_ATTRS] = {
 static struct nla_policy rx_policy[NUM_MT76_TM_RX_ATTRS] = {
 	[MT76_TM_RX_ATTR_FREQ_OFFSET] = { .type = NLA_U32 },
 	[MT76_TM_RX_ATTR_RCPI] = { .type = NLA_NESTED },
+	[MT76_TM_RX_ATTR_RSSI] = { .type = NLA_NESTED },
 	[MT76_TM_RX_ATTR_IB_RSSI] = { .type = NLA_NESTED },
 	[MT76_TM_RX_ATTR_WB_RSSI] = { .type = NLA_NESTED },
 	[MT76_TM_RX_ATTR_SNR] = { .type = NLA_U8 },
@@ -274,6 +395,7 @@ static const struct tm_field stats_fields[NUM_MT76_TM_STATS_ATTRS] = {
 	FIELD_RO(u32, TX_DONE, "tx_done"),
 	FIELD_RO(u64, RX_PACKETS, "rx_packets"),
 	FIELD_RO(u64, RX_FCS_ERROR, "rx_fcs_error"),
+	FIELD_RO(u64, RX_LEN_MISMATCH, "rx_len_mismatch"),
 	FIELD_NESTED_RO(LAST_RX, rx, "last_"),
 };
 static struct nla_policy stats_policy[NUM_MT76_TM_STATS_ATTRS] = {
@@ -282,6 +404,7 @@ static struct nla_policy stats_policy[NUM_MT76_TM_STATS_ATTRS] = {
 	[MT76_TM_STATS_ATTR_TX_DONE] = { .type = NLA_U32 },
 	[MT76_TM_STATS_ATTR_RX_PACKETS] = { .type = NLA_U64 },
 	[MT76_TM_STATS_ATTR_RX_FCS_ERROR] = { .type = NLA_U64 },
+	[MT76_TM_STATS_ATTR_RX_LEN_MISMATCH] = { .type = NLA_U64 },
 };
 #undef FIELD_NAME
 
@@ -291,6 +414,7 @@ static const struct tm_field testdata_fields[NUM_MT76_TM_ATTRS] = {
 	FIELD_ENUM(STATE, "state", testmode_state),
 	FIELD_RO(string, MTD_PART, "mtd_part"),
 	FIELD_RO(u32, MTD_OFFSET, "mtd_offset"),
+	FIELD(u8, SKU_EN, "sku_en"),
 	FIELD(u32, TX_COUNT, "tx_count"),
 	FIELD(u32, TX_LENGTH, "tx_length"),
 	FIELD_ENUM(TX_RATE_MODE, "tx_rate_mode", testmode_tx_mode),
@@ -300,12 +424,28 @@ static const struct tm_field testdata_fields[NUM_MT76_TM_ATTRS] = {
 	FIELD(u8, TX_RATE_LDPC, "tx_rate_ldpc"),
 	FIELD(u8, TX_RATE_STBC, "tx_rate_stbc"),
 	FIELD(u8, TX_LTF, "tx_ltf"),
+	FIELD(u8, TX_DUTY_CYCLE, "tx_duty_cycle"),
+	FIELD(u32, TX_IPG, "tx_ipg"),
+	FIELD(u32, TX_TIME, "tx_time"),
 	FIELD(u8, TX_POWER_CONTROL, "tx_power_control"),
 	FIELD_ARRAY(u8, TX_POWER, "tx_power"),
 	FIELD(u8, TX_ANTENNA, "tx_antenna"),
 	FIELD(u32, FREQ_OFFSET, "freq_offset"),
+	FIELD(u8, AID, "aid"),
+	FIELD(u8, RU_ALLOC, "ru_alloc"),
+	FIELD(u8, RU_IDX, "ru_idx"),
+	FIELD_ENUM(TXBF_ACT, "txbf_act", testmode_txbf_act),
+	FIELD_ARRAY(u16_hex, TXBF_PARAM, "txbf_param"),
+	FIELD(u8, OFF_CH_SCAN_CH, "offchan_ch"),
+	FIELD(u8, OFF_CH_SCAN_CENTER_CH, "offchan_center_ch"),
+	FIELD_ENUM(OFF_CH_SCAN_BW, "offchan_bw", testmode_offchan_bw),
+	FIELD(u8, IPI_THRESHOLD, "ipi_threshold"),
+	FIELD(u32, IPI_PERIOD, "ipi_period"),
+	FIELD(u8, IPI_RESET, "ipi_reset"),
+	FIELD_MAC(MAC_ADDRS, "mac_addrs"),
 	FIELD_NESTED_RO(STATS, stats, "",
 			.print_extra = print_extra_stats),
+
 };
 #undef FIELD_NAME
 
@@ -313,6 +453,7 @@ static struct nla_policy testdata_policy[NUM_MT76_TM_ATTRS] = {
 	[MT76_TM_ATTR_STATE] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_MTD_PART] = { .type = NLA_STRING },
 	[MT76_TM_ATTR_MTD_OFFSET] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_SKU_EN] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_TX_COUNT] = { .type = NLA_U32 },
 	[MT76_TM_ATTR_TX_LENGTH] = { .type = NLA_U32 },
 	[MT76_TM_ATTR_TX_RATE_MODE] = { .type = NLA_U8 },
@@ -322,10 +463,25 @@ static struct nla_policy testdata_policy[NUM_MT76_TM_ATTRS] = {
 	[MT76_TM_ATTR_TX_RATE_LDPC] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_TX_RATE_STBC] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_TX_LTF] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_TX_DUTY_CYCLE] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_TX_IPG] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_TX_TIME] = { .type = NLA_U32 },
 	[MT76_TM_ATTR_TX_POWER_CONTROL] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_TX_ANTENNA] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_TX_SPE_IDX] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_FREQ_OFFSET] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_AID] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_RU_ALLOC] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_RU_IDX] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_STATS] = { .type = NLA_NESTED },
+	[MT76_TM_ATTR_TXBF_ACT] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_CH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_BW] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_IPI_THRESHOLD] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_IPI_PERIOD] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_IPI_ANTENNA_INDEX] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_IPI_RESET] = { .type = NLA_U8 },
 };
 
 const struct tm_field msg_field = {
diff --git a/tools/fwlog.c b/tools/fwlog.c
index e5d4a105..c894d31a 100644
--- a/tools/fwlog.c
+++ b/tools/fwlog.c
@@ -26,16 +26,36 @@ static const char *debugfs_path(const char *phyname, const char *file)
 	return path;
 }
 
-static int mt76_set_fwlog_en(const char *phyname, bool en)
+static int mt76_set_fwlog_en(const char *phyname, bool en, char *val)
 {
 	FILE *f = fopen(debugfs_path(phyname, "fw_debug_bin"), "w");
+	if (!f) {
+		perror("fopen");
+		return -1;
+	}
+
+	if (en && val)
+		fprintf(f, "%s", val);
+	else if (en)
+		fprintf(f, "7");
+	else
+		fprintf(f, "0");
+
+	fclose(f);
+
+	return 0;
+}
 
+static int mt76_set_idxlog_enable(const char *phyname, bool enable)
+{
+	FILE *f = fopen(debugfs_path(phyname, "idxlog_enable"), "w");
 	if (!f) {
-		fprintf(stderr, "Could not open fw_debug_bin file\n");
-		return 1;
+		perror("fopen");
+		return -1;
 	}
 
-	fprintf(f, "7");
+	fprintf(f, "%hhu", enable);
+
 	fclose(f);
 
 	return 0;
@@ -74,104 +94,215 @@ static void handle_signal(int sig)
 	done = true;
 }
 
-int mt76_fwlog(const char *phyname, int argc, char **argv)
+static int mt76_log_socket(struct sockaddr_in *remote, char *ip, unsigned short port)
 {
 	struct sockaddr_in local = {
 		.sin_family = AF_INET,
 		.sin_addr.s_addr = INADDR_ANY,
 	};
-	struct sockaddr_in remote = {
-		.sin_family = AF_INET,
-		.sin_port = htons(55688),
-	};
-	char buf[1504];
-	int ret = 0;
-	int yes = 1;
-	int s, fd;
-
-	if (argc < 1) {
-		fprintf(stderr, "need destination address\n");
-		return 1;
-	}
+	int s, ret;
 
-	if (!inet_aton(argv[0], &remote.sin_addr)) {
-		fprintf(stderr, "invalid destination address\n");
-		return 1;
+	remote->sin_family = AF_INET;
+	remote->sin_port = htons(port);
+	if (!inet_aton(ip, &remote->sin_addr)) {
+		fprintf(stderr, "Invalid destination IP address: %s\n", ip);
+		return -EINVAL;
 	}
 
 	s = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
 	if (s < 0) {
 		perror("socket");
-		return 1;
+		return s;
 	}
 
-	setsockopt(s, SOL_SOCKET, SO_BROADCAST, &yes, sizeof(yes));
-	if (bind(s, (struct sockaddr *)&local, sizeof(local)) < 0) {
+	ret = bind(s, (struct sockaddr *)&local, sizeof(local));
+	if (ret) {
 		perror("bind");
-		return 1;
+		close(s);
+		return ret;
 	}
 
-	if (mt76_set_fwlog_en(phyname, true))
-		return 1;
+	return s;
+}
+
+static int mt76_log_relay(int in_fd, int out_fd, struct sockaddr_in *remote)
+{
+	char *buf = malloc(FWLOG_BUF_SIZE);
+	int ret = 0;
 
-	fd = open(debugfs_path(phyname, "fwlog_data"), O_RDONLY);
-	if (fd < 0) {
-		fprintf(stderr, "Could not open fwlog_data file: %s\n", strerror(errno));
-		ret = 1;
-		goto out;
+	if (!buf) {
+		perror("malloc");
+		return -ENOMEM;
 	}
 
 	signal(SIGTERM, handle_signal);
 	signal(SIGINT, handle_signal);
 	signal(SIGQUIT, handle_signal);
 
-	while (1) {
+	while (!done) {
 		struct pollfd pfd = {
-			.fd = fd,
-			.events = POLLIN | POLLHUP | POLLERR,
+			.fd = in_fd,
+			.events = POLLIN,
 		};
 		uint32_t len;
-		int r;
-
-		if (done)
-			break;
+		int rc;
 
 		poll(&pfd, 1, -1);
 
-		r = read_retry(fd, &len, sizeof(len));
-		if (r < 0)
+		rc = read_retry(in_fd, &len, sizeof(len));
+		if (rc < 0) {
+			if (!done) {
+				fprintf(stderr, "Failed to read relay file.\n");
+				ret = -1;
+			}
 			break;
-
-		if (!r)
+		}
+		if (!rc)
 			continue;
 
-		if (len > sizeof(buf)) {
-			fprintf(stderr, "Length error: %d > %d\n", len, (int)sizeof(buf));
-			ret = 1;
+		if (len > FWLOG_BUF_SIZE) {
+			fprintf(stderr, "Log size was too large: %u bytes\n", len);
+			ret = -ENOMEM;
 			break;
 		}
 
-		if (done)
+		rc = read_retry(in_fd, buf, len);
+		if (rc < 0) {
+			if (!done) {
+				fprintf(stderr, "Failed to read relay file.\n");
+				ret = -1;
+			}
 			break;
-
-		r = read_retry(fd, buf, len);
-		if (done)
+		}
+		if (rc != len) {
+			fprintf(stderr, "Expected log size: %u bytes\n", len);
+			fprintf(stderr, "Read log size: %u bytes\n", rc);
+			ret = -EIO;
 			break;
+		}
 
-		if (r != len) {
-			fprintf(stderr, "Short read: %d < %d\n", r, len);
-			ret = 1;
+		if (remote)
+			rc = sendto(out_fd, buf, len, 0, (struct sockaddr *)remote, sizeof(*remote));
+		else
+			rc = write(out_fd, buf, len);
+		if (rc < 0) {
+			perror("sendto/write");
+			ret = -1;
 			break;
 		}
+	}
+
+	free(buf);
+
+	return ret;
+}
 
-		/* send buf */
-		sendto(s, buf, len, 0, (struct sockaddr *)&remote, sizeof(remote));
+int mt76_fwlog(const char *phyname, int argc, char **argv)
+{
+	struct sockaddr_in remote;
+	int in_fd, out_fd, ret;
+	char dev_ip[16] = {};
+	unsigned short port;
+
+	if (argc < 2) {
+		fprintf(stderr, "need destination address and fw_debug_bin\n");
+		return -EINVAL;
 	}
 
-	close(fd);
 
-out:
-	mt76_set_fwlog_en(phyname, false);
+	if (argc == 2) {
+		/* support ip:port format */
+		if (strchr(argv[0], ':')) {
+			sscanf(argv[0], "%[^:]:%hu", dev_ip, &port);
+		} else {
+			strncpy(dev_ip, argv[0], sizeof(dev_ip) - 1);
+			port = 55688;
+		}
+
+		out_fd = mt76_log_socket(&remote, dev_ip, port);
+		if (out_fd < 0)
+			return out_fd;
+	} else if (argc == 3) {
+		out_fd = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR);
+		if (out_fd < 0) {
+			perror("open");
+			return out_fd;
+		}
+	} else {
+		fprintf(stderr, "Too many arguments.\n");
+		return -EINVAL;
+	}
+
+	ret = mt76_set_fwlog_en(phyname, true, argv[1]);
+	if (ret)
+		goto close;
+
+	in_fd = open(debugfs_path(phyname, "fwlog_data"), O_RDONLY);
+	if (in_fd < 0) {
+		perror("open");
+		goto disable;
+	}
+
+	if (mt76_log_relay(in_fd, out_fd, argc == 3 ? NULL : &remote))
+		fprintf(stderr, "Failed to relay FW log.\n");
+
+	close(in_fd);
+disable:
+	ret = mt76_set_fwlog_en(phyname, false, NULL);
+close:
+	close(out_fd);
+
+	return ret;
+}
+
+int mt76_idxlog(const char *phyname, int argc, char **argv)
+{
+#define IDXLOG_FILE_PATH	"/tmp/log/WIFI_FW.clog"
+	struct sockaddr_in remote;
+	int in_fd, out_fd, ret;
+
+	if (argc) {
+		out_fd = mt76_log_socket(&remote, argv[0], 55688);
+		if (out_fd < 0)
+			return out_fd;
+	} else {
+		out_fd = open(IDXLOG_FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR);
+		if (out_fd < 0) {
+			perror("open");
+			return -1;
+		}
+	}
+
+	ret = mt76_set_idxlog_enable(phyname, true);
+	if (ret)
+		goto close;
+
+	in_fd = open(debugfs_path(phyname, "idxlog_data"), O_RDONLY);
+	if (in_fd < 0) {
+		perror("open");
+		goto disable;
+	}
+
+	if (mt76_log_relay(in_fd, out_fd, argc ? &remote : NULL))
+		fprintf(stderr, "Failed to relay index log.\n");
+
+	close(in_fd);
+disable:
+	ret = mt76_set_idxlog_enable(phyname, false);
+close:
+	close(out_fd);
+
+	if (argc)
+		system("timestamp=$(date +\"%y%m%d_%H%M%S\");"
+		       "clog_dir=/tmp/log/clog_${timestamp};"
+		       "mkdir ${clog_dir};"
+		       "dmesg > ${clog_dir}/WIFI_KERNEL_${timestamp}.clog");
+	else
+		system("timestamp=$(date +\"%y%m%d_%H%M%S\");"
+		       "clog_dir=/tmp/log/clog_${timestamp};"
+		       "mkdir ${clog_dir};"
+		       "mv /tmp/log/WIFI_FW.clog ${clog_dir}/WIFI_FW_${timestamp}.clog;"
+		       "dmesg > ${clog_dir}/WIFI_KERNEL_${timestamp}.clog");
 
 	return ret;
 }
diff --git a/tools/main.c b/tools/main.c
index 699a9eea..9e8f0bcf 100644
--- a/tools/main.c
+++ b/tools/main.c
@@ -13,6 +13,7 @@
 #include <poll.h>
 #include <fcntl.h>
 #include <signal.h>
+#include <net/if.h>
 #include "mt76-test.h"
 
 struct unl unl;
@@ -25,6 +26,7 @@ static int phy_lookup_idx(const char *name)
 	FILE *f;
 	int len;
 
+	/* TODO: Handle single wiphy radio index */
 	snprintf(buf, sizeof(buf), "/sys/class/ieee80211/%s/index", name);
 	f = fopen(buf, "r");
 	if (!f)
@@ -43,12 +45,15 @@ static int phy_lookup_idx(const char *name)
 void usage(void)
 {
 	static const char *const commands[] = {
+		"add <interface>",
+		"del <interface>",
 		"set <var>=<val> [...]",
 		"dump [stats]",
 		"eeprom file",
 		"eeprom set <addr>=<val> [...]",
 		"eeprom changes",
 		"eeprom reset",
+		"fwlog <ip> <fw_debug_bin input> <fwlog name>",
 	};
 	int i;
 
@@ -164,6 +169,122 @@ static int mt76_set(int phy, int argc, char **argv)
 	return ret;
 }
 
+static int mt76_set_state(int phy, char *state)
+{
+	const struct tm_field *fields = msg_field.fields;
+	struct nl_msg *msg;
+	void *data;
+	int ret, i;
+
+	msg = unl_genl_msg(&unl, NL80211_CMD_TESTMODE, false);
+	nla_put_u32(msg, NL80211_ATTR_WIPHY, phy);
+
+	data = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
+	for (i = 0; i < msg_field.len; i++) {
+		if (!fields[i].parse)
+			continue;
+
+		if (!strcmp(fields[i].name, "state"))
+			break;
+	}
+
+	if (!fields[i].parse(&fields[i], i, msg, state))
+		return 1;
+
+	tm_set_changed(i);
+	nla_nest_end(msg, data);
+
+	ret = unl_genl_request(&unl, msg, NULL, NULL);
+	if (ret)
+		fprintf(stderr, "Failed to set state %s: %s\n", state, strerror(-ret));
+
+	return ret;
+}
+
+static void mt76_set_tm_reg(void)
+{
+	struct nl_msg *msg;
+	char reg[3] = "VV\0";
+	int ret;
+
+	msg = unl_genl_msg(&unl, NL80211_CMD_REQ_SET_REG, false);
+	nla_put_string(msg, NL80211_ATTR_REG_ALPHA2, reg);
+
+	ret = unl_genl_request(&unl, msg, NULL, NULL);
+	if (ret)
+		fprintf(stderr, "Failed to set reg %s: %s\n", reg, strerror(-ret));
+}
+
+static int mt76_add_iface(int phy, int argc, char **argv)
+{
+	struct nl_msg *msg;
+	char *name, cmd[64];
+	int ret;
+
+	mt76_set_tm_reg();
+
+	if (argc < 1)
+		return 1;
+
+	name = argv[0];
+	msg = unl_genl_msg(&unl, NL80211_CMD_NEW_INTERFACE, false);
+	/* TODO: Handle single wiphy radio index */
+	nla_put_u32(msg, NL80211_ATTR_WIPHY, phy);
+	nla_put_u32(msg, NL80211_ATTR_IFTYPE, NL80211_IFTYPE_MONITOR);
+	nla_put_string(msg, NL80211_ATTR_IFNAME, name);
+
+	ret = unl_genl_request(&unl, msg, NULL, NULL);
+	if (ret) {
+		fprintf(stderr, "nl80211 call failed: %s\n", strerror(-ret));
+		return ret;
+	}
+
+	snprintf(cmd, sizeof(cmd), "ifconfig %s up", name);
+	system(cmd);
+
+	/* turn on testmode */
+	ret = mt76_set_state(phy, "idle");
+	return ret;
+}
+
+static int mt76_delete_iface(int phy, int argc, char **argv)
+{
+	unsigned int devidx;
+	struct nl_msg *msg;
+	char *name, cmd[64];
+	int ret;
+
+	if (argc < 1)
+		return 1;
+
+	name = argv[0];
+	devidx = if_nametoindex(name);
+	if (!devidx) {
+		fprintf(stderr, "Failed to find ifindex for %s: %s\n",
+			name, strerror(errno));
+		return 2;
+	}
+
+	/* turn off testmode before deleting interface */
+	ret = mt76_set_state(phy, "off");
+	if (ret)
+		return ret;
+
+	snprintf(cmd, sizeof(cmd), "ifconfig %s down", name);
+	system(cmd);
+
+	/* delete interface */
+	msg = unl_genl_msg(&unl, NL80211_CMD_DEL_INTERFACE, false);
+	nla_put_u32(msg, NL80211_ATTR_WIPHY, phy);
+	nla_put_u32(msg, NL80211_ATTR_IFINDEX, devidx);
+
+	ret = unl_genl_request(&unl, msg, NULL, NULL);
+	if (ret)
+		fprintf(stderr, "nl80211 call failed: %s\n", strerror(-ret));
+
+	return ret;
+}
+
 int main(int argc, char **argv)
 {
 	const char *cmd, *phyname;
@@ -194,10 +315,16 @@ int main(int argc, char **argv)
 		ret = mt76_dump(phy, argc, argv);
 	else if (!strcmp(cmd, "set"))
 		ret = mt76_set(phy, argc, argv);
+	else if (!strcmp(cmd, "add"))
+		ret = mt76_add_iface(phy, argc, argv);
+	else if (!strcmp(cmd, "del"))
+		ret = mt76_delete_iface(phy, argc, argv);
 	else if (!strcmp(cmd, "eeprom"))
 		ret = mt76_eeprom(phy, argc, argv);
 	else if (!strcmp(cmd, "fwlog"))
 		ret = mt76_fwlog(phyname, argc, argv);
+	else if (!strcmp(cmd, "idxlog"))
+		ret = mt76_idxlog(phyname, argc, argv);
 	else
 		usage();
 
diff --git a/tools/mt76-test.h b/tools/mt76-test.h
index d2fafa86..b9d508c5 100644
--- a/tools/mt76-test.h
+++ b/tools/mt76-test.h
@@ -22,6 +22,8 @@
 #define EEPROM_FILE_PATH_FMT	"/tmp/mt76-test-%s"
 #define EEPROM_PART_SIZE	20480
 
+#define FWLOG_BUF_SIZE	1504
+
 struct nl_msg;
 struct nlattr;
 
@@ -61,5 +63,6 @@ extern unsigned char *eeprom_data;
 void usage(void);
 int mt76_eeprom(int phy, int argc, char **argv);
 int mt76_fwlog(const char *phyname, int argc, char **argv);
+int mt76_idxlog(const char *phyname, int argc, char **argv);
 
 #endif
diff --git a/trace.h b/trace.h
index 109a07f9..1ff3283e 100644
--- a/trace.h
+++ b/trace.h
@@ -101,6 +101,64 @@ DEFINE_EVENT(dev_txid_evt, mac_txdone,
 	TP_ARGS(dev, wcid, pktid)
 );
 
+TRACE_EVENT(mt76_rx_complete,
+	TP_PROTO(struct mt76_dev *dev, struct mt76_rx_status *status, bool sub),
+	TP_ARGS(dev, status, sub),
+
+	TP_STRUCT__entry(
+		DEV_ENTRY
+		__field(u16, seqno)
+		__field(u16, wcid)
+		__field(u8, first_amsdu)
+		__field(bool, sub)
+	),
+
+	TP_fast_assign(
+		strlcpy(__entry->wiphy_name,
+			wiphy_name(mt76_dev_phy(dev, status->phy_idx)->hw->wiphy),
+			MAXNAME);
+		__entry->seqno = status->seqno;
+		__entry->wcid = status->wcid ? status->wcid->idx : 0;
+		__entry->first_amsdu = status->first_amsdu;
+		__entry->sub = sub;
+	),
+
+	TP_printk(
+		DEV_PR_FMT " seqno: %u, wcid: %u, first_amsdu: %x, sub: %d",
+		DEV_PR_ARG, __entry->seqno, __entry->wcid, __entry->first_amsdu,
+		__entry->sub
+	)
+);
+
+TRACE_EVENT(mt76_rx_aggr_reorder,
+	TP_PROTO(struct mt76_dev *dev, struct mt76_wcid *wcid, u16 _head, u16 seqno, bool sn_less),
+	TP_ARGS(dev, wcid, _head, seqno, sn_less),
+
+	TP_STRUCT__entry(
+		DEV_ENTRY
+		__field(u16, wcid)
+		__field(u16, _head)
+		__field(u16, seqno)
+		__field(bool, sn_less)
+	),
+
+	TP_fast_assign(
+		strlcpy(__entry->wiphy_name,
+			wiphy_name(dev->phys[wcid->phy_idx]->hw->wiphy),
+			MAXNAME);
+		__entry->wcid = wcid->idx;
+		__entry->_head = _head;
+		__entry->seqno = seqno;
+		__entry->sn_less = sn_less;
+	),
+
+	TP_printk(
+		DEV_PR_FMT " wcid: %u, head: %u, seqno: %u, sn_less: %d",
+		DEV_PR_ARG, __entry->wcid, __entry->_head, __entry->seqno,
+		__entry->sn_less
+	)
+);
+
 #endif
 
 #undef TRACE_INCLUDE_PATH
diff --git a/tx.c b/tx.c
index 8ab5840f..f35bfd10 100644
--- a/tx.c
+++ b/tx.c
@@ -335,8 +335,14 @@ mt76_tx(struct mt76_phy *phy, struct ieee80211_sta *sta,
 	struct ieee80211_hdr *hdr = (void *)skb->data;
 	struct sk_buff_head *head;
 
+	spin_lock_bh(&phy->tx_dbg_stats.lock);
+	phy->tx_dbg_stats.tx_from_mac80211++;
+	spin_unlock_bh(&phy->tx_dbg_stats.lock);
 	if (mt76_testmode_enabled(phy)) {
 		ieee80211_free_txskb(phy->hw, skb);
+		spin_lock_bh(&phy->tx_dbg_stats.lock);
+		phy->tx_dbg_stats.tx_drop[MT_TX_DROP_IN_TESTMODE]++;
+		spin_unlock_bh(&phy->tx_dbg_stats.lock);
 		return;
 	}
 
@@ -353,8 +359,19 @@ mt76_tx(struct mt76_phy *phy, struct ieee80211_sta *sta,
 	    ((info->control.flags & IEEE80211_TX_CTRL_DONT_USE_RATE_MASK) &&
 	     ieee80211_is_probe_req(hdr->frame_control)))
 		head = &wcid->tx_offchannel;
-	else
+	else {
+		if (!wcid->tx_pending.prev || !wcid->tx_pending.next) {
+			dev_warn(phy->dev->dev, "Un-initialized STA %pM wcid %d in mt76_tx\n",
+				 sta->addr, wcid->idx);
+
+			spin_lock_bh(&phy->tx_dbg_stats.lock);
+			phy->tx_dbg_stats.tx_drop[MT_TX_DROP_WCID_NOT_INIT]++;
+			spin_unlock_bh(&phy->tx_dbg_stats.lock);
+			ieee80211_free_txskb(phy->hw, skb);
+			return;
+		}
 		head = &wcid->tx_pending;
+	}
 
 	spin_lock_bh(&head->lock);
 	__skb_queue_tail(head, skb);
@@ -383,6 +400,8 @@ mt76_txq_dequeue(struct mt76_phy *phy, struct mt76_txq *mtxq)
 	info = IEEE80211_SKB_CB(skb);
 	info->hw_queue |= FIELD_PREP(MT_TX_HW_QUEUE_PHY, phy->band_idx);
 
+	phy->dev->tx_dbg_stats.tx_from_mac80211++;
+
 	return skb;
 }
 
@@ -490,7 +509,7 @@ mt76_txq_send_burst(struct mt76_phy *phy, struct mt76_queue *q,
 
 	do {
 		if (test_bit(MT76_RESET, &phy->state) || phy->offchannel)
-			break;
+			return -EBUSY;
 
 		if (stop || mt76_txq_stopped(q))
 			break;
@@ -523,16 +542,24 @@ mt76_txq_send_burst(struct mt76_phy *phy, struct mt76_queue *q,
 static int
 mt76_txq_schedule_list(struct mt76_phy *phy, enum mt76_txq_id qid)
 {
+	struct mt76_queue *q = phy->q_tx[qid];
 	struct mt76_dev *dev = phy->dev;
 	struct ieee80211_txq *txq;
 	struct mt76_txq *mtxq;
 	struct mt76_wcid *wcid;
-	struct mt76_queue *q;
 	int ret = 0;
 
 	while (1) {
 		int n_frames = 0;
 
+		if (test_bit(MT76_RESET, &phy->state) || phy->offchannel)
+			return -EBUSY;
+
+		if (dev->queue_ops->tx_cleanup &&
+		    q->queued + 2 * MT_TXQ_FREE_THR >= q->ndesc) {
+			dev->queue_ops->tx_cleanup(dev, q, false);
+		}
+
 		txq = ieee80211_next_txq(phy->hw, qid);
 		if (!txq)
 			break;
@@ -542,16 +569,6 @@ mt76_txq_schedule_list(struct mt76_phy *phy, enum mt76_txq_id qid)
 		if (!wcid || test_bit(MT_WCID_FLAG_PS, &wcid->flags))
 			continue;
 
-		phy = mt76_dev_phy(dev, wcid->phy_idx);
-		if (test_bit(MT76_RESET, &phy->state) || phy->offchannel)
-			continue;
-
-		q = phy->q_tx[qid];
-		if (dev->queue_ops->tx_cleanup &&
-		    q->queued + 2 * MT_TXQ_FREE_THR >= q->ndesc) {
-			dev->queue_ops->tx_cleanup(dev, q, false);
-		}
-
 		if (mtxq->send_bar && mtxq->aggr) {
 			struct ieee80211_txq *txq = mtxq_to_txq(mtxq);
 			struct ieee80211_sta *sta = txq->sta;
@@ -581,7 +598,7 @@ void mt76_txq_schedule(struct mt76_phy *phy, enum mt76_txq_id qid)
 {
 	int len;
 
-	if (qid >= 4)
+	if (qid >= 4 || phy->offchannel)
 		return;
 
 	local_bh_disable();
@@ -624,6 +641,7 @@ mt76_txq_schedule_pending_wcid(struct mt76_phy *phy, struct mt76_wcid *wcid,
 		q = phy->q_tx[qid];
 		if (mt76_txq_stopped(q) || test_bit(MT76_RESET, &phy->state)) {
 			ret = -1;
+			phy->tx_dbg_stats.tx_drop[MT_TX_DROP_STOPPED_QUEUE]++;
 			break;
 		}
 
@@ -682,14 +700,9 @@ static void mt76_txq_schedule_pending(struct mt76_phy *phy)
 
 void mt76_txq_schedule_all(struct mt76_phy *phy)
 {
-	struct mt76_phy *main_phy = &phy->dev->phy;
 	int i;
 
 	mt76_txq_schedule_pending(phy);
-
-	if (phy != main_phy && phy->hw == main_phy->hw)
-		return;
-
 	for (i = 0; i <= MT_TXQ_BK; i++)
 		mt76_txq_schedule(phy, i);
 }
@@ -700,7 +713,6 @@ void mt76_tx_worker_run(struct mt76_dev *dev)
 	struct mt76_phy *phy;
 	int i;
 
-	mt76_txq_schedule_all(&dev->phy);
 	for (i = 0; i < ARRAY_SIZE(dev->phys); i++) {
 		phy = dev->phys[i];
 		if (!phy)
@@ -756,6 +768,9 @@ void mt76_wake_tx_queue(struct ieee80211_hw *hw, struct ieee80211_txq *txq)
 	struct mt76_phy *phy = hw->priv;
 	struct mt76_dev *dev = phy->dev;
 
+	if (!test_bit(MT76_STATE_RUNNING, &phy->state))
+		return;
+
 	mt76_worker_schedule(&dev->tx_worker);
 }
 EXPORT_SYMBOL_GPL(mt76_wake_tx_queue);
@@ -842,12 +857,16 @@ EXPORT_SYMBOL_GPL(__mt76_set_tx_blocked);
 
 int mt76_token_consume(struct mt76_dev *dev, struct mt76_txwi_cache **ptxwi)
 {
-	int token;
+	int token, start = 0;
+
+	if (mtk_wed_device_active(&dev->mmio.wed))
+		start = dev->mmio.wed.wlan.nbuf;
 
 	spin_lock_bh(&dev->token_lock);
 
-	token = idr_alloc(&dev->token, *ptxwi, 0, dev->token_size, GFP_ATOMIC);
-	if (token >= 0)
+	token = idr_alloc(&dev->token, *ptxwi, start, start + dev->token_size,
+			  GFP_ATOMIC);
+	if (token >= start)
 		dev->token_count++;
 
 #ifdef CONFIG_NET_MEDIATEK_SOC_WED
diff --git a/wed.c b/wed.c
index 63f69e15..d7746996 100644
--- a/wed.c
+++ b/wed.c
@@ -9,6 +9,7 @@
 void mt76_wed_release_rx_buf(struct mtk_wed_device *wed)
 {
 	struct mt76_dev *dev = container_of(wed, struct mt76_dev, mmio.wed);
+	struct page *page;
 	int i;
 
 	for (i = 0; i < dev->rx_token_size; i++) {
@@ -25,6 +26,26 @@ void mt76_wed_release_rx_buf(struct mtk_wed_device *wed)
 	}
 
 	mt76_free_pending_rxwi(dev);
+
+	mt76_for_each_q_rx(dev, i) {
+		struct mt76_queue *q = &dev->q_rx[i];
+
+		if (mt76_queue_is_wed_rx(q)) {
+			if (!q->rx_page.va)
+				continue;
+
+			page = virt_to_page(q->rx_page.va);
+			__page_frag_cache_drain(page, q->rx_page.pagecnt_bias);
+			memset(&q->rx_page, 0, sizeof(q->rx_page));
+		}
+	}
+
+	if (!wed->rx_buf_ring.rx_page.va)
+		return;
+
+	page = virt_to_page(wed->rx_buf_ring.rx_page.va);
+	__page_frag_cache_drain(page, wed->rx_buf_ring.rx_page.pagecnt_bias);
+	memset(&wed->rx_buf_ring.rx_page, 0, sizeof(wed->rx_buf_ring.rx_page));
 }
 EXPORT_SYMBOL_GPL(mt76_wed_release_rx_buf);
 
@@ -83,7 +104,7 @@ int mt76_wed_offload_enable(struct mtk_wed_device *wed)
 	struct mt76_dev *dev = container_of(wed, struct mt76_dev, mmio.wed);
 
 	spin_lock_bh(&dev->token_lock);
-	dev->token_size = wed->wlan.token_start;
+	dev->token_size = MT76_WED_SW_TOKEN_SIZE;
 	spin_unlock_bh(&dev->token_lock);
 
 	return !wait_event_timeout(dev->tx_wait, !dev->wed_token_count, HZ);
@@ -118,8 +139,8 @@ int mt76_wed_dma_setup(struct mt76_dev *dev, struct mt76_queue *q, bool reset)
 	case MT76_WED_Q_TXFREE:
 		/* WED txfree queue needs ring to be initialized before setup */
 		q->flags = 0;
-		mt76_dma_queue_reset(dev, q);
-		mt76_dma_rx_fill(dev, q, false);
+		mt76_dma_queue_reset(dev, q, true);
+		mt76_dma_rx_fill_buf(dev, q, false);
 
 		ret = mtk_wed_device_txfree_ring_setup(q->wed, q->regs);
 		if (!ret)
@@ -147,8 +168,8 @@ int mt76_wed_dma_setup(struct mt76_dev *dev, struct mt76_queue *q, bool reset)
 		break;
 	case MT76_WED_RRO_Q_IND:
 		q->flags &= ~MT_QFLAG_WED;
-		mt76_dma_queue_reset(dev, q);
-		mt76_dma_rx_fill(dev, q, false);
+		mt76_dma_queue_reset(dev, q, true);
+		mt76_dma_rx_fill_buf(dev, q, false);
 		mtk_wed_device_ind_rx_ring_setup(q->wed, q->regs);
 		break;
 	default:
@@ -167,7 +188,7 @@ void mt76_wed_offload_disable(struct mtk_wed_device *wed)
 	struct mt76_dev *dev = container_of(wed, struct mt76_dev, mmio.wed);
 
 	spin_lock_bh(&dev->token_lock);
-	dev->token_size = dev->drv->token_size;
+	dev->token_size = MT76_WED_SW_TOKEN_SIZE;
 	spin_unlock_bh(&dev->token_lock);
 }
 EXPORT_SYMBOL_GPL(mt76_wed_offload_disable);
-- 
2.45.2

