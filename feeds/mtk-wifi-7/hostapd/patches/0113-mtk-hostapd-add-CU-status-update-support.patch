From 7e79bbf8466f2e6daf96ce5d3b058bd5a7441bae Mon Sep 17 00:00:00 2001
From: StanleyYP Wang <StanleyYP.Wang@mediatek.com>
Date: Mon, 29 Jul 2024 10:09:42 +0800
Subject: [PATCH 113/236] mtk: hostapd: add CU status update support

Update the CUF status when a CU event notification is sent by kernel
Also, refactor the CU flag mechanism to support different dtim period
in different bss.
For example, if Link 0 has a DTIM period of 100, while Links 1 & 2 have
a DTIM period of 2, the CU flag of link 0 should only be cleared after
the DTIM count of its beacon reaches 0, which may occur much later than
when links 1 and 2 clear their CU flags.
Therefore, the BSS should only consider its own CU flag rather than the
partner links' CU flag when filling its own capabilities.

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>
---
 hostapd/ctrl_iface.c               |  7 ----
 src/ap/beacon.c                    | 35 ++++++++++++--------
 src/ap/dfs.c                       |  7 ----
 src/ap/drv_callbacks.c             | 52 ++++++++++++++++++++++++++----
 src/ap/hostapd.c                   |  8 +----
 src/ap/ieee802_11.c                | 10 ++----
 src/drivers/driver.h               | 18 +++++++++++
 src/drivers/driver_nl80211_event.c | 49 ++++++++++++++++++++++++++++
 8 files changed, 137 insertions(+), 49 deletions(-)

diff --git a/hostapd/ctrl_iface.c b/hostapd/ctrl_iface.c
index 536def442..e7dc3cee9 100644
--- a/hostapd/ctrl_iface.c
+++ b/hostapd/ctrl_iface.c
@@ -2968,13 +2968,6 @@ static int hostapd_ctrl_iface_chan_switch(struct hostapd_iface *iface,
 #ifdef CONFIG_IEEE80211BE
 		if (!err && iface->bss[i]->conf->mld_ap)
 			hostapd_update_aff_link_beacon(iface->bss[i], settings.cs_count);
-
-		/*
-		 * Currently, no FW notification event for clearing CU flag after DTIM period.
-		 * Also, another CU or set beacon is not allowed during CSA period.
-		 * Therefore, just clear it manually here for workaround.
-		 */
-		iface->bss[i]->eht_mld_bss_critical_update = 0;
 #endif /* CONFIG_IEEE80211BE */
 	}
 
diff --git a/src/ap/beacon.c b/src/ap/beacon.c
index a6c84425d..be4be1b3c 100644
--- a/src/ap/beacon.c
+++ b/src/ap/beacon.c
@@ -3355,7 +3355,6 @@ fail:
 int ieee802_11_set_beacon(struct hostapd_data *hapd)
 {
 	struct hostapd_iface *iface = hapd->iface;
-	struct hostapd_data *h;
 	int ret, link_id;
 	size_t i, j;
 	bool is_6g, hapd_mld = false;
@@ -3411,16 +3410,9 @@ int ieee802_11_set_beacon(struct hostapd_data *hapd)
 	for_each_mld_link(link_bss, hapd) {
 		hostapd_gen_per_sta_profiles(link_bss);
 
-		/* clear critical update flag for UPDATE_SINGLE type & link adding,
-		 * for other types, we should get some notified events from driver
-		 */
-		if (h->eht_mld_bss_critical_update == BSS_CRIT_UPDATE_SINGLE)
-			h->eht_mld_bss_critical_update = 0;
-		if (h->eht_mld_bss_critical_update == BSS_CRIT_UPDATE_FLAG &&
-		    (h->mld->link_reconf_in_progress & BIT(h->mld_link_id))) {
-			h->mld->link_reconf_in_progress &= ~BIT(h->mld_link_id);
-			h->eht_mld_bss_critical_update = 0;
-		}
+		if (link_bss->eht_mld_bss_critical_update == BSS_CRIT_UPDATE_FLAG &&
+		    (link_bss->mld->link_reconf_in_progress & BIT(link_bss->mld_link_id)))
+			link_bss->mld->link_reconf_in_progress &= ~BIT(link_bss->mld_link_id);
 	}
 #endif /* CONFIG_IEEE80211BE */
 
@@ -3462,6 +3454,8 @@ int ieee802_11_update_beacons(struct hostapd_iface *iface)
 int ieee802_11_set_bss_critical_update(struct hostapd_data *hapd,
 				       enum bss_crit_update_event event)
 {
+	struct hostapd_data *h;
+
 	if (!hapd->conf->mld_ap)
 		return 0;
 
@@ -3480,7 +3474,7 @@ int ieee802_11_set_bss_critical_update(struct hostapd_data *hapd,
 	case BSS_CRIT_UPDATE_EVENT_TPE:
 		hapd->eht_mld_bss_param_change += 1;
 		hapd->eht_mld_bss_critical_update = BSS_CRIT_UPDATE_ALL;
-		return 0;
+		break;
 	case BSS_CRIT_UPDATE_EVENT_EDCA:
 	case BSS_CRIT_UPDATE_EVENT_DSSS:
 	case BSS_CRIT_UPDATE_EVENT_HT_OPERATION:
@@ -3492,16 +3486,29 @@ int ieee802_11_set_bss_critical_update(struct hostapd_data *hapd,
 	case BSS_CRIT_UPDATE_EVENT_EHT_OPERATION:
 		hapd->eht_mld_bss_param_change += 1;
 		hapd->eht_mld_bss_critical_update = BSS_CRIT_UPDATE_SINGLE;
-		return 0;
+		break;
 	case BSS_CRIT_UPDATE_EVENT_RECONFIG:
-	case BSS_CRIT_UPDATE_EVENT_ADD_LINK:
 	case BSS_CRIT_UPDATE_EVENT_ATTLM:
+		hapd->eht_mld_bss_critical_update = BSS_CRIT_UPDATE_FLAG;
+		break;
+	case BSS_CRIT_UPDATE_EVENT_ADD_LINK:
+		/* only set the CU flag for the links in link_reconf_in_progress */
 		hapd->eht_mld_bss_critical_update = BSS_CRIT_UPDATE_FLAG;
 		return 0;
 	default:
 		hapd->eht_mld_bss_critical_update = BSS_CRIT_UPDATE_NONE;
 		return -1;
 	}
+
+	/* only set the CU flag for the non-CU links */
+	for_each_mld_link(h, hapd) {
+		if (h == hapd)
+			continue;
+
+		h->eht_mld_bss_critical_update = BSS_CRIT_UPDATE_FLAG;
+	}
+
+	return 0;
 }
 
 #endif /* CONFIG_NATIVE_WINDOWS */
diff --git a/src/ap/dfs.c b/src/ap/dfs.c
index 4fe6cb276..c69e04f28 100644
--- a/src/ap/dfs.c
+++ b/src/ap/dfs.c
@@ -1149,13 +1149,6 @@ static int hostapd_dfs_request_channel_switch(struct hostapd_iface *iface,
 #ifdef CONFIG_IEEE80211BE
 		if (!err && iface->bss[i]->conf->mld_ap)
 			hostapd_update_aff_link_beacon(iface->bss[i], csa_settings.cs_count);
-
-		/*
-		 * Currently, no FW notification event for clearing CU flag after DTIM period.
-		 * Also, another CU or set beacon is not allowed during CSA period.
-		 * Therefore, just clear it manually here for workaround.
-		 */
-		iface->bss[i]->eht_mld_bss_critical_update = 0;
 #endif /* CONFIG_IEEE80211BE */
 	}
 
diff --git a/src/ap/drv_callbacks.c b/src/ap/drv_callbacks.c
index c2141ede0..2a6b91430 100644
--- a/src/ap/drv_callbacks.c
+++ b/src/ap/drv_callbacks.c
@@ -1522,7 +1522,44 @@ void hostapd_event_attlm(struct hostapd_data *hapd, struct attlm_event *attlm_ev
 #endif /* CONFIG_TESTING_OPTIONS */
 
 	ieee802_11_set_beacon(hapd);
-	hapd->eht_mld_bss_critical_update = 0;
+}
+
+
+static void hostapd_event_update_crit_update_flag(struct hostapd_data *hapd, u8 flag)
+{
+	const char *type;
+
+	if (!hapd->conf->mld_ap || !hapd->mld)
+		return;
+
+	switch (flag) {
+	case CRIT_UPDATE_NONE:
+		hapd->eht_mld_bss_critical_update = 0;
+		type = "UPDATE_NONE";
+		break;
+	case CRIT_UPDATE_SINGLE:
+		hapd->eht_mld_bss_critical_update = BSS_CRIT_UPDATE_SINGLE;
+		hapd->eht_mld_bss_param_change += 1;
+		type = "UPDATE_SINGLE";
+		break;
+	case CRIT_UPDATE_ALL:
+		hapd->eht_mld_bss_critical_update = BSS_CRIT_UPDATE_ALL;
+		hapd->eht_mld_bss_param_change += 1;
+		type = "UPDATE_ALL";
+		break;
+	case CRIT_UPDATE_FLAG:
+		hapd->eht_mld_bss_critical_update = BSS_CRIT_UPDATE_FLAG;
+		type = "UPDATE_FLAG";
+		break;
+	default:
+		wpa_printf(MSG_DEBUG, "Unknown critical update type");
+		return;
+	}
+
+	wpa_printf(MSG_DEBUG,
+		   "MLD: set critical update flag to %s (bpcc=%d) for %s link %d",
+		   type, hapd->eht_mld_bss_param_change, hapd->mld->name,
+		   hapd->mld_link_id);
 }
 #endif /* CONFIG_IEEE80211BE */
 
@@ -2722,11 +2759,6 @@ static void hostapd_event_pp_bitmap_update(struct hostapd_data *hapd,
 		if (iface->bss[i]->conf->mld_ap)
 			hostapd_update_aff_link_beacon(iface->bss[i],
 						       csa_settings.cs_count);
-
-		/* FIXME:
-		 * CU flag should be cleared when receiving DTIM event from FW
-		 */
-		iface->bss[i]->eht_mld_bss_critical_update = 0;
 #endif /* CONFIG_IEEE80211BE */
 	}
 }
@@ -3118,6 +3150,14 @@ void hostapd_wpa_event(void *ctx, enum wpa_event_type event,
 	case EVENT_LINK_RECONFIG:
 		hostapd_link_remove_cb(hapd, data->reconfig_info.removed_links);
 		break;
+	case EVENT_CRIT_UPDATE:
+		if (!data)
+			break;
+		hapd = switch_link_hapd(hapd, data->crit_update_info.link_id);
+#ifdef CONFIG_IEEE80211BE
+		hostapd_event_update_crit_update_flag(hapd, data->crit_update_info.flag);
+#endif /* CONFIG_IEEE80211BE */
+		break;
 #endif /* CONFIG_IEEE80211AX */
 #ifdef CONFIG_IEEE80211BE
 	case EVENT_MLD_INTERFACE_FREED:
diff --git a/src/ap/hostapd.c b/src/ap/hostapd.c
index 19bd3525d..ef1a427ff 100644
--- a/src/ap/hostapd.c
+++ b/src/ap/hostapd.c
@@ -483,7 +483,6 @@ void hostapd_link_remove_cb(struct hostapd_data *hapd, u16 removed_links)
 		if (!(BIT(link->mld_link_id) & removed_links))
 			continue;
 
-		link->eht_mld_bss_critical_update = 0;
 		eloop_register_timeout(0, 0,
 				       hostapd_link_remove_timeout_handler,
 				       link, NULL);
@@ -4805,9 +4804,6 @@ static int hostapd_fill_csa_settings(struct hostapd_data *hapd,
 		return ret;
 	}
 
-	/* Change back to the final BPCC and CU flag */
-	ieee802_11_set_bss_critical_update(hapd, BSS_CRIT_UPDATE_EVENT_EHT_OPERATION);
-
 	settings->counter_offset_beacon[0] = hapd->cs_c_off_beacon;
 	settings->counter_offset_presp[0] = hapd->cs_c_off_proberesp;
 	settings->counter_offset_beacon[1] = hapd->cs_c_off_ecsa_beacon;
@@ -4941,6 +4937,7 @@ int hostapd_update_aff_link_beacon(struct hostapd_data *hapd, u8 cs_count)
 					mode ? &mode->eht_capab[IEEE80211_MODE_AP] : NULL,
 					hostapd_get_punct_bitmap(h));
 		hapd->cs_freq_params.channel = 0;
+		ieee802_11_set_bss_critical_update(hapd, BSS_CRIT_UPDATE_EVENT_EHT_OPERATION);
 		ret = hostapd_build_beacon_data(h, &settings.beacon_after);
 		hostapd_change_config_freq(hapd, hapd->iconf,
 					   &old_freq, NULL);
@@ -4957,9 +4954,6 @@ int hostapd_update_aff_link_beacon(struct hostapd_data *hapd, u8 cs_count)
 			return ret;
 		}
 
-		/* Change back to the final BPCC and CU flag */
-		ieee802_11_set_bss_critical_update(hapd, BSS_CRIT_UPDATE_EVENT_EHT_OPERATION);
-
 		settings.counter_offset_sta_prof[cs_link_id][0] =
 						h->cs_c_off_sta_prof[cs_link_id];
 		settings.counter_offset_sta_prof[cs_link_id][1] =
diff --git a/src/ap/ieee802_11.c b/src/ap/ieee802_11.c
index 4c05bd448..257254756 100644
--- a/src/ap/ieee802_11.c
+++ b/src/ap/ieee802_11.c
@@ -283,14 +283,8 @@ u16 hostapd_own_capab_info(struct hostapd_data *hapd)
 	}
 
 #ifdef CONFIG_IEEE80211BE
-	if (hapd->conf->mld_ap) {
-		for_each_mld_link(h, hapd) {
-			if (h->eht_mld_bss_critical_update) {
-				capab |= WLAN_CAPABILITY_PBCC;
-				break;
-			}
-		}
-	}
+	if (hapd->conf->mld_ap && hapd->eht_mld_bss_critical_update)
+		capab |= WLAN_CAPABILITY_PBCC;
 #endif /* CONFIG_IEEE80211BE */
 
 
diff --git a/src/drivers/driver.h b/src/drivers/driver.h
index e66aa3314..7787cf2f0 100644
--- a/src/drivers/driver.h
+++ b/src/drivers/driver.h
@@ -6437,6 +6437,11 @@ enum wpa_event_type {
 	 * has been applied and a channel switch should be triggered.
 	 */
 	EVENT_PP_BITMAP_UPDATE,
+
+	/**
+	 * EVENT_CRIT_UPDATE - Notification of the status of a critical update event
+	 */
+	EVENT_CRIT_UPDATE,
 };
 
 
@@ -7455,6 +7460,19 @@ union wpa_event_data {
 		size_t resp_ie_len;
 		u16 removed_links;
 	} reconfig_info;
+
+	/**
+	 * struct crit_update_info - Data for EVENT_CRIT_UPDATE
+	 */
+	struct crit_update_info {
+		int link_id;
+		enum {
+			CRIT_UPDATE_NONE,
+			CRIT_UPDATE_SINGLE,
+			CRIT_UPDATE_ALL,
+			CRIT_UPDATE_FLAG,
+		} flag;
+	} crit_update_info;
 };
 
 /**
diff --git a/src/drivers/driver_nl80211_event.c b/src/drivers/driver_nl80211_event.c
index 900f5f3cc..f096c53a3 100644
--- a/src/drivers/driver_nl80211_event.c
+++ b/src/drivers/driver_nl80211_event.c
@@ -192,6 +192,7 @@ static const char * nl80211_command_to_string(enum nl80211_commands cmd)
 	C2S(NL80211_CMD_EPCS_CFG)
 	C2S(NL80211_CMD_ATTLM_EVENT)
 	C2S(NL80211_CMD_SET_ATTLM)
+	C2S(NL80211_CMD_NOTIFY_CRIT_UPDATE)
 	C2S(__NL80211_CMD_AFTER_LAST)
 	}
 #undef C2S
@@ -4233,6 +4234,51 @@ static void nl80211_links_removed(struct wpa_driver_nl80211_data *drv,
 }
 
 
+static void nl80211_notify_crit_update(struct wpa_driver_nl80211_data *drv,
+				       struct nlattr **tb)
+{
+	struct i802_bss *bss;
+	union wpa_event_data data;
+	enum nl80211_crit_update_event event_type;
+	int ifidx;
+
+	if (!tb[NL80211_ATTR_IFINDEX] || !tb[NL80211_ATTR_MLO_LINK_ID] ||
+	    !tb[NL80211_ATTR_CRTI_UPDATE_EVENT])
+		return;
+
+	ifidx = nla_get_u32(tb[NL80211_ATTR_IFINDEX]);
+	bss = get_bss_ifindex(drv, ifidx);
+	if (!bss) {
+		wpa_printf(MSG_ERROR,
+			   "nl80211: Unknown ifindex (%d) for critical update event, ignoring",
+			   ifidx);
+		return;
+	}
+
+	data.crit_update_info.link_id = nla_get_u8(tb[NL80211_ATTR_MLO_LINK_ID]);
+	event_type = nla_get_u8(tb[NL80211_ATTR_CRTI_UPDATE_EVENT]);
+	switch (event_type) {
+	case NL80211_CRIT_UPDATE_NONE:
+		data.crit_update_info.flag = CRIT_UPDATE_NONE;
+		break;
+	case NL80211_CRIT_UPDATE_SINGLE:
+		data.crit_update_info.flag = CRIT_UPDATE_SINGLE;
+		break;
+	case NL80211_CRIT_UPDATE_ALL:
+		data.crit_update_info.flag = CRIT_UPDATE_ALL;
+		break;
+	case NL80211_CRIT_UPDATE_FLAG:
+		data.crit_update_info.flag = CRIT_UPDATE_FLAG;
+		break;
+	default:
+		wpa_printf(MSG_DEBUG,
+			   "nl80211: Unknown critical update event");
+		return;
+	}
+	wpa_supplicant_event(bss->ctx, EVENT_CRIT_UPDATE, &data);
+}
+
+
 static void do_process_drv_event(struct i802_bss *bss, int cmd,
 				 struct nlattr **tb)
 {
@@ -4508,6 +4554,9 @@ static void do_process_drv_event(struct i802_bss *bss, int cmd,
 	case NL80211_CMD_ASSOC_MLO_RECONF:
 		mlme_event_link_addition(drv, nla_data(frame), nla_len(frame));
 		break;
+	case NL80211_CMD_NOTIFY_CRIT_UPDATE:
+		nl80211_notify_crit_update(drv, tb);
+		break;
 	default:
 		wpa_dbg(drv->ctx, MSG_DEBUG, "nl80211: Ignored unknown event "
 			"(cmd=%d)", cmd);
-- 
2.45.2

