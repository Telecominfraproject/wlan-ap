diff -upr a/src/ap/ubus.c b/src/ap/ubus.c
--- a/src/ap/ubus.c	2025-10-30 18:05:10.769232337 +0800
+++ b/src/ap/ubus.c	2025-11-03 01:03:31.261969064 +0800
@@ -24,6 +24,7 @@
 #include "taxonomy.h"
 #include "airtime_policy.h"
 #include "hw_features.h"
+#include "ieee802_11_auth.h"
 
 static struct ubus_context *ctx;
 static struct blob_buf b;
@@ -153,7 +154,7 @@ hostapd_bss_ban_client(struct hostapd_da
 		}
 	}
 
-	eloop_register_timeout(0, time * 1000, hostapd_bss_del_ban, ban, hapd);
+	eloop_register_timeout(time, 0, hostapd_bss_del_ban, ban, hapd);
 }
 
 static int
@@ -319,7 +320,42 @@ hostapd_bss_get_clients(struct ubus_cont
 			blobmsg_add_u32(&b, "rx", sta_driver_data.current_rx_rate * 100);
 			blobmsg_add_u32(&b, "tx", sta_driver_data.current_tx_rate * 100);
 			blobmsg_close_table(&b, r);
+			blobmsg_add_u32(&b, "retries", sta_driver_data.tx_retry_count);
+			blobmsg_add_u32(&b, "failed", sta_driver_data.tx_retry_failed);
 			blobmsg_add_u32(&b, "signal", sta_driver_data.signal);
+
+			r = blobmsg_open_table(&b, "mcs");
+			if (sta_driver_data.rx_hemcs) {
+				blobmsg_add_u32(&b, "he", 1);
+				blobmsg_add_u32(&b, "rx", sta_driver_data.rx_hemcs);
+				blobmsg_add_u32(&b, "tx", sta_driver_data.tx_hemcs);
+			} else if (sta_driver_data.rx_vhtmcs) {
+				blobmsg_add_u32(&b, "vht", 1);
+				blobmsg_add_u32(&b, "rx", sta_driver_data.rx_vhtmcs);
+				blobmsg_add_u32(&b, "tx", sta_driver_data.tx_vhtmcs);
+			} else {
+				blobmsg_add_u32(&b, "rx", sta_driver_data.rx_mcs);
+				blobmsg_add_u32(&b, "tx", sta_driver_data.tx_mcs);
+			}
+			blobmsg_close_table(&b, r);
+
+			r = blobmsg_open_table(&b, "nss");
+			if (sta_driver_data.rx_he_nss) {
+				blobmsg_add_u32(&b, "he", 1);
+				blobmsg_add_u32(&b, "rx", sta_driver_data.rx_he_nss);
+				blobmsg_add_u32(&b, "tx", sta_driver_data.tx_he_nss);
+			} else if (sta_driver_data.rx_vht_nss) {
+				blobmsg_add_u32(&b, "vht", 1);
+				blobmsg_add_u32(&b, "rx", sta_driver_data.rx_vht_nss);
+				blobmsg_add_u32(&b, "tx", sta_driver_data.tx_vht_nss);
+			} else {
+				blobmsg_add_u32(&b, "rx", sta_driver_data.rx_mcs);
+				blobmsg_add_u32(&b, "tx", sta_driver_data.tx_mcs);
+			}
+			blobmsg_close_table(&b, r);
+
+			if (sta->signal_mgmt)
+				blobmsg_add_u32(&b, "signal_mgmt", sta->signal_mgmt);
 		}
 
 		hostapd_parse_capab_blobmsg(sta);
@@ -369,6 +405,7 @@ hostapd_bss_get_status(struct ubus_conte
 				      &op_class, &channel);
 
 	blob_buf_init(&b, 0);
+	blobmsg_add_string(&b, "driver", hapd->driver->name);
 	blobmsg_add_string(&b, "status", hostapd_state_text(hapd->iface->state));
 	blobmsg_printf(&b, "bssid", MACSTR, MAC2STR(hapd->conf->bssid));
 
@@ -418,6 +455,9 @@ hostapd_bss_get_status(struct ubus_conte
 			hapd->iface->cac_started ? hapd->iface->dfs_cac_ms / 1000 - now.sec : 0);
 	blobmsg_close_table(&b, dfs_table);
 
+	if (hapd->signal_mgmt)
+		blobmsg_add_u32(&b, "signal_mgmt", hapd->signal_mgmt);
+
 	ubus_send_reply(ctx, req, b.head);
 
 	return 0;
@@ -459,6 +499,7 @@ enum {
 	DEL_CLIENT_REASON,
 	DEL_CLIENT_DEAUTH,
 	DEL_CLIENT_BAN_TIME,
+	DEL_CLIENT_GLOBAL_BAN,
 	__DEL_CLIENT_MAX
 };
 
@@ -467,9 +508,27 @@ static const struct blobmsg_policy del_p
 	[DEL_CLIENT_REASON] = { "reason", BLOBMSG_TYPE_INT32 },
 	[DEL_CLIENT_DEAUTH] = { "deauth", BLOBMSG_TYPE_INT8 },
 	[DEL_CLIENT_BAN_TIME] = { "ban_time", BLOBMSG_TYPE_INT32 },
+	[DEL_CLIENT_GLOBAL_BAN] = { "global_ban", BLOBMSG_TYPE_INT8 },
 };
 
 static int
+hostapd_bss_del_client_cb(struct hostapd_iface *iface, void *ctx)
+{
+	struct blob_attr **tb = ctx;
+	u8 addr[ETH_ALEN];
+	int i;
+
+	hwaddr_aton(blobmsg_data(tb[DEL_CLIENT_ADDR]), addr);
+
+	for (i = 0; i < iface->num_bss; i++) {
+		struct hostapd_data *bss = iface->bss[i];
+
+		hostapd_bss_ban_client(bss, addr, blobmsg_get_u32(tb[DEL_CLIENT_BAN_TIME]));
+	}
+	return 0;
+}
+
+static int
 hostapd_bss_del_client(struct ubus_context *ctx, struct ubus_object *obj,
 			struct ubus_request_data *req, const char *method,
 			struct blob_attr *msg)
@@ -477,8 +536,8 @@ hostapd_bss_del_client(struct ubus_conte
 	struct blob_attr *tb[__DEL_CLIENT_MAX];
 	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
 	struct sta_info *sta;
-	bool deauth = false;
-	int reason;
+	bool deauth = false, global = false;
+	int reason, ban_time = 0;
 	u8 addr[ETH_ALEN];
 
 	blobmsg_parse(del_policy, __DEL_CLIENT_MAX, tb, blob_data(msg), blob_len(msg));
@@ -495,6 +554,12 @@ hostapd_bss_del_client(struct ubus_conte
 	if (tb[DEL_CLIENT_DEAUTH])
 		deauth = blobmsg_get_bool(tb[DEL_CLIENT_DEAUTH]);
 
+	if (tb[DEL_CLIENT_GLOBAL_BAN])
+		global = blobmsg_get_bool(tb[DEL_CLIENT_GLOBAL_BAN]);
+
+	if (tb[DEL_CLIENT_GLOBAL_BAN])
+		global = blobmsg_get_bool(tb[DEL_CLIENT_GLOBAL_BAN]);
+
 	sta = ap_get_sta(hapd, addr);
 	if (sta) {
 		if (deauth) {
@@ -506,8 +571,13 @@ hostapd_bss_del_client(struct ubus_conte
 		}
 	}
 
-	if (tb[DEL_CLIENT_BAN_TIME])
-		hostapd_bss_ban_client(hapd, addr, blobmsg_get_u32(tb[DEL_CLIENT_BAN_TIME]));
+	if (tb[DEL_CLIENT_BAN_TIME]) {
+		ban_time = blobmsg_get_u32(tb[DEL_CLIENT_BAN_TIME]);
+		if (global)
+			hapd->iface->interfaces->for_each_interface(hapd->iface->interfaces, hostapd_bss_del_client_cb, tb);
+		else
+			hostapd_bss_ban_client(hapd, addr, ban_time);
+	}
 
 	return 0;
 }
@@ -1658,6 +1728,121 @@ static int avl_compare_macaddr(const voi
 	return memcmp(k1, k2, ETH_ALEN);
 }
 
+static int
+hostapd_wired_get_clients(struct ubus_context *ctx, struct ubus_object *obj,
+			  struct ubus_request_data *req, const char *method,
+			  struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+	struct hostap_sta_driver_data sta_driver_data;
+	struct sta_info *sta;
+	void *list, *c;
+	char mac_buf[20];
+	static const struct {
+		const char *name;
+		uint32_t flag;
+	} sta_flags[] = {
+		{ "authorized", WLAN_STA_AUTHORIZED },
+	};
+
+	blob_buf_init(&b, 0);
+	list = blobmsg_open_table(&b, "clients");
+	for (sta = hapd->sta_list; sta; sta = sta->next) {
+		void *r;
+		int i;
+
+		sprintf(mac_buf, MACSTR, MAC2STR(sta->addr));
+		c = blobmsg_open_table(&b, mac_buf);
+		for (i = 0; i < ARRAY_SIZE(sta_flags); i++)
+			blobmsg_add_u8(&b, sta_flags[i].name,
+				       !!(sta->flags & sta_flags[i].flag));
+
+			blobmsg_close_table(&b, c);
+	}
+	blobmsg_close_array(&b, list);
+	ubus_send_reply(ctx, req, b.head);
+
+	return 0;
+}
+
+static int
+hostapd_wired_get_status(struct ubus_context *ctx, struct ubus_object *obj,
+			 struct ubus_request_data *req, const char *method,
+			 struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+	char iface_name[17];
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_string(&b, "driver", hapd->driver->name);
+	blobmsg_add_string(&b, "status", hostapd_state_text(hapd->iface->state));
+
+	snprintf(iface_name, 17, "%s", hapd->iface->phy);
+	blobmsg_add_string(&b, "iface", iface_name);
+
+	ubus_send_reply(ctx, req, b.head);
+
+	return 0;
+}
+
+static int
+hostapd_wired_del_clients(struct ubus_context *ctx, struct ubus_object *obj,
+			  struct ubus_request_data *req, const char *method,
+			  struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+
+	hostapd_free_stas(hapd);
+
+	return 0;
+}
+
+enum {
+	MAC_AUTH_ADDR,
+	__MAC_AUTH_MAX
+};
+
+static const struct blobmsg_policy mac_auth_policy[__MAC_AUTH_MAX] = {
+	[MAC_AUTH_ADDR] = { "addr", BLOBMSG_TYPE_STRING },
+};
+
+static int
+hostapd_wired_mac_auth(struct ubus_context *ctx, struct ubus_object *obj,
+		       struct ubus_request_data *req, const char *method,
+		       struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+	struct blob_attr *tb[__MAC_AUTH_MAX];
+	struct radius_sta rad_info;
+	struct sta_info *sta;
+	u8 addr[ETH_ALEN];
+	int acl_res;
+
+	blobmsg_parse(mac_auth_policy, __MAC_AUTH_MAX, tb, blob_data(msg), blob_len(msg));
+
+	if (hwaddr_aton(blobmsg_data(tb[MAC_AUTH_ADDR]), addr))
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	acl_res = hostapd_allowed_address(hapd, addr, NULL, 0, &rad_info, 0);
+	if (acl_res == HOSTAPD_ACL_REJECT) {
+		wpa_printf(MSG_ERROR, "Ignore new peer notification\n");
+		return UBUS_STATUS_INVALID_ARGUMENT;
+	}
+
+	return 0;
+}
+
+static const struct ubus_method wired_methods[] = {
+	UBUS_METHOD_NOARG("reload", hostapd_bss_reload),
+	UBUS_METHOD_NOARG("get_clients", hostapd_wired_get_clients),
+	UBUS_METHOD_NOARG("del_clients", hostapd_wired_del_clients),
+	UBUS_METHOD_NOARG("get_status", hostapd_wired_get_status),
+	UBUS_METHOD("mac_auth", hostapd_wired_mac_auth, mac_auth_policy),
+};
+
+static struct ubus_object_type wired_object_type =
+	UBUS_OBJECT_TYPE("hostapd_wired", wired_methods);
+
 void hostapd_ubus_add_bss(struct hostapd_data *hapd)
 {
 	struct ubus_object *obj = &hapd->ubus.obj;
@@ -1677,9 +1862,15 @@ void hostapd_ubus_add_bss(struct hostapd
 
 	avl_init(&hapd->ubus.banned, avl_compare_macaddr, false, NULL);
 	obj->name = name;
-	obj->type = &bss_object_type;
-	obj->methods = bss_object_type.methods;
-	obj->n_methods = bss_object_type.n_methods;
+	if (!strcmp(hapd->driver->name, "wired")) {
+		obj->type = &wired_object_type;
+		obj->methods = wired_object_type.methods;
+		obj->n_methods = wired_object_type.n_methods;
+	} else {
+		obj->type = &bss_object_type;
+		obj->methods = bss_object_type.methods;
+		obj->n_methods = bss_object_type.n_methods;
+	}
 	ret = ubus_add_object(ctx, obj);
 	hostapd_ubus_ref_inc();
 }
@@ -1762,6 +1953,7 @@ int hostapd_ubus_handle_event(struct hos
 		[HOSTAPD_UBUS_PROBE_REQ] = "probe",
 		[HOSTAPD_UBUS_AUTH_REQ] = "auth",
 		[HOSTAPD_UBUS_ASSOC_REQ] = "assoc",
+		[HOSTAPD_UBUS_COA] = "coa",
 	};
 	const char *type = "mgmt";
 	struct ubus_event_req ureq = {};
@@ -1832,7 +2024,7 @@ int hostapd_ubus_handle_event(struct hos
 		}
 	}
 
-	if (!hapd->ubus.notify_response) {
+	if (!hapd->ubus.notify_response && req->type != HOSTAPD_UBUS_COA) {
 		ubus_notify(ctx, &hapd->ubus.obj, type, b.head, -1);
 		return WLAN_STATUS_SUCCESS;
 	}
@@ -1877,6 +2069,13 @@ void hostapd_ubus_notify_authorized(stru
 	blobmsg_add_string(&b, "ifname", hapd->conf->iface);
 	if (auth_alg)
 		blobmsg_add_string(&b, "auth-alg", auth_alg);
+	if (sta->bandwidth[0] || sta->bandwidth[1]) {
+		void *r = blobmsg_open_array(&b, "rate-limit");
+ 
+		blobmsg_add_u32(&b, "", sta->bandwidth[0]);
+		blobmsg_add_u32(&b, "", sta->bandwidth[1]);
+		blobmsg_close_array(&b, r);
+	}
 
 	ubus_notify(ctx, &hapd->ubus.obj, "sta-authorized", b.head, -1);
 }
@@ -2026,6 +2225,21 @@ void hostapd_ubus_notify_apup_newpeer(
 }
 #endif // def CONFIG_APUP
 
+void hostapd_ubus_notify_rssi(struct hostapd_data *hapd, const char *type, const u8 *addr, int rssi)
+{
+	if (!hapd->ubus.obj.has_subscribers)
+		return;
+
+	if (!addr)
+		return;
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_macaddr(&b, "address", addr);
+	blobmsg_add_u32(&b, "rssi", rssi);
+
+	ubus_notify(ctx, &hapd->ubus.obj, type, b.head, -1);
+}
+
 void hostapd_ubus_notify_csa(struct hostapd_data *hapd, int freq)
 {
 	if (!hapd->ubus.obj.has_subscribers)
diff -upr a/src/ap/ubus.h b/src/ap/ubus.h
--- a/src/ap/ubus.h	2025-10-30 18:05:09.781218929 +0800
+++ b/src/ap/ubus.h	2025-11-03 01:03:31.261969064 +0800
@@ -12,6 +12,7 @@ enum hostapd_ubus_event_type {
 	HOSTAPD_UBUS_PROBE_REQ,
 	HOSTAPD_UBUS_AUTH_REQ,
 	HOSTAPD_UBUS_ASSOC_REQ,
+	HOSTAPD_UBUS_COA,
 	HOSTAPD_UBUS_TYPE_MAX
 };
 
@@ -56,6 +57,7 @@ void hostapd_ubus_notify_beacon_report(s
 				       size_t len);
 void hostapd_ubus_notify_radar_detected(struct hostapd_iface *iface, int frequency,
 					int chan_width, int cf1, int cf2);
+void hostapd_ubus_notify_rssi(struct hostapd_data *hapd, const char *type, const u8 *addr, int rssi);
 
 void hostapd_ubus_notify_bss_transition_response(
 	struct hostapd_data *hapd, const u8 *addr, u8 dialog_token, u8 status_code,
diff -upr a/src/ap/ucode.c b/src/ap/ucode.c
--- a/src/ap/ucode.c	2025-10-30 18:05:11.093236733 +0800
+++ b/src/ap/ucode.c	2025-11-03 01:04:58.074331719 +0800
@@ -11,6 +11,7 @@
 #include "acs.h"
 #include "ieee802_11_auth.h"
 #include "ieee802_11.h"
+#include "neighbor_db.h"
 #include <libubox/uloop.h>
 
 static uc_resource_type_t *global_type, *bss_type, *iface_type;
@@ -24,7 +25,7 @@ hostapd_ucode_bss_get_uval(struct hostap
 	uc_value_t *val;
 
 	if (hapd->ucode.idx)
-		return wpa_ucode_registry_get(bss_registry, hapd->ucode.idx);
+		return ucv_get(wpa_ucode_registry_get(bss_registry, hapd->ucode.idx));
 
 	val = uc_resource_new(bss_type, hapd);
 	hapd->ucode.idx = wpa_ucode_registry_add(bss_registry, val);
@@ -38,7 +39,7 @@ hostapd_ucode_iface_get_uval(struct host
 	uc_value_t *val;
 
 	if (hapd->ucode.idx)
-		return wpa_ucode_registry_get(iface_registry, hapd->ucode.idx);
+		return ucv_get(wpa_ucode_registry_get(iface_registry, hapd->ucode.idx));
 
 	val = uc_resource_new(iface_type, hapd);
 	hapd->ucode.idx = wpa_ucode_registry_add(iface_registry, val);
@@ -55,12 +56,11 @@ hostapd_ucode_update_bss_list(struct hos
 	list = ucv_array_new(vm);
 	for (i = 0; iface->bss && i < iface->num_bss; i++) {
 		struct hostapd_data *hapd = iface->bss[i];
-		uc_value_t *val = hostapd_ucode_bss_get_uval(hapd);
 
-		ucv_array_set(list, i, ucv_get(ucv_string_new(hapd->conf->iface)));
-		ucv_object_add(bss, hapd->conf->iface, ucv_get(val));
+		ucv_array_set(list, i, ucv_string_new(hapd->conf->iface));
+		ucv_object_add(bss, hapd->conf->iface, hostapd_ucode_bss_get_uval(hapd));
 	}
-	ucv_object_add(if_bss, iface->phy, ucv_get(list));
+	ucv_object_add(if_bss, iface->phy, list);
 }
 
 static void
@@ -74,13 +74,14 @@ hostapd_ucode_update_interfaces(void)
 	for (i = 0; i < interfaces->count; i++) {
 		struct hostapd_iface *iface = interfaces->iface[i];
 
-		ucv_object_add(ifs, iface->phy, ucv_get(hostapd_ucode_iface_get_uval(iface)));
+		ucv_object_add(ifs, iface->phy, hostapd_ucode_iface_get_uval(iface));
 		hostapd_ucode_update_bss_list(iface, if_bss, bss);
 	}
 
-	ucv_object_add(ucv_prototype_get(global), "interfaces", ucv_get(ifs));
-	ucv_object_add(ucv_prototype_get(global), "interface_bss", ucv_get(if_bss));
-	ucv_object_add(ucv_prototype_get(global), "bss", ucv_get(bss));
+	ucv_object_add(ucv_prototype_get(global), "interfaces", ifs);
+	ucv_object_add(ucv_prototype_get(global), "interface_bss", if_bss);
+	ucv_object_add(ucv_prototype_get(global), "bss", bss);
+
 	ucv_gc(vm);
 }
 
@@ -259,7 +260,11 @@ uc_hostapd_bss_set_config(uc_vm_t *vm, s
 	hapd->conf = conf->bss[idx];
 	conf->bss[idx] = old_bss;
 
+	if (hapd == iface->bss[0])
+		memcpy(hapd->own_addr, hapd->conf->bssid, ETH_ALEN);
+
 	hostapd_setup_bss(hapd, hapd == iface->bss[0], true);
+	hostapd_neighbor_set_own_report(hapd);
 	hostapd_ucode_update_interfaces();
 	hostapd_owe_update_trans(iface);
 
@@ -363,6 +368,10 @@ uc_hostapd_iface_add_bss(uc_vm_t *vm, si
 
 	hapd->driver = iface->bss[0]->driver;
 	hapd->drv_priv = iface->bss[0]->drv_priv;
+#ifdef CONFIG_IEEE80211BE
+	os_strlcpy(hapd->ctrl_sock_iface, hapd->conf->iface,
+		   sizeof(hapd->ctrl_sock_iface));
+#endif
 	if (interfaces->ctrl_iface_init &&
 	    interfaces->ctrl_iface_init(hapd) < 0)
 		goto free_hapd;
@@ -381,6 +390,7 @@ uc_hostapd_iface_add_bss(uc_vm_t *vm, si
 	iface->conf->bss[iface->conf->num_bss] = bss;
 	conf->bss[idx] = NULL;
 	ret = hostapd_ucode_bss_get_uval(hapd);
+	hostapd_neighbor_set_own_report(hapd);
 	hostapd_ucode_update_interfaces();
 	hostapd_owe_update_trans(iface);
 	goto out;
@@ -810,11 +820,10 @@ int hostapd_ucode_sta_auth(struct hostap
 	if (wpa_ucode_call_prepare("sta_auth"))
 		return 0;
 
-	uc_value_push(ucv_get(ucv_string_new(hapd->conf->iface)));
+	uc_value_push(ucv_string_new(hapd->conf->iface));
 
 	snprintf(addr, sizeof(addr), MACSTR, MAC2STR(sta->addr));
-	val = ucv_string_new(addr);
-	uc_value_push(ucv_get(val));
+	uc_value_push(ucv_string_new(addr));
 
 	val = wpa_ucode_call(2);
 
@@ -876,16 +885,15 @@ void hostapd_ucode_sta_connected(struct
 	if (wpa_ucode_call_prepare("sta_connected"))
 		return;
 
-	uc_value_push(ucv_get(ucv_string_new(hapd->conf->iface)));
+	uc_value_push(ucv_string_new(hapd->conf->iface));
 
 	snprintf(addr, sizeof(addr), MACSTR, MAC2STR(sta->addr));
-	val = ucv_string_new(addr);
-	uc_value_push(ucv_get(val));
+	uc_value_push(ucv_string_new(addr));
 
 	val = ucv_object_new(vm);
 	if (sta->psk_idx)
 		ucv_object_add(val, "psk_idx", ucv_int64_new(sta->psk_idx - 1));
-	uc_value_push(ucv_get(val));
+	uc_value_push(val);
 
 	val = wpa_ucode_call(3);
 	if (ucv_type(val) != UC_OBJECT)
@@ -969,7 +977,7 @@ void hostapd_ucode_free(void)
 
 void hostapd_ucode_free_iface(struct hostapd_iface *iface)
 {
-	wpa_ucode_registry_remove(iface_registry, iface->ucode.idx);
+	ucv_put(wpa_ucode_registry_remove(iface_registry, iface->ucode.idx));
 }
 
 void hostapd_ucode_bss_cb(struct hostapd_data *hapd, const char *type)
@@ -980,10 +988,11 @@ void hostapd_ucode_bss_cb(struct hostapd
 		return;
 
 	val = hostapd_ucode_bss_get_uval(hapd);
-	uc_value_push(ucv_get(ucv_string_new(hapd->iface->phy)));
-	uc_value_push(ucv_get(ucv_string_new(hapd->conf->iface)));
+	uc_value_push(ucv_string_new(hapd->iface->phy));
+	uc_value_push(ucv_string_new(hapd->conf->iface));
 	uc_value_push(ucv_get(val));
 	ucv_put(wpa_ucode_call(3));
+	ucv_put(val);
 	ucv_gc(vm);
 }
 
@@ -1002,6 +1011,8 @@ void hostapd_ucode_free_bss(struct hosta
 	uc_value_push(ucv_string_new(hapd->conf->iface));
 	uc_value_push(ucv_get(val));
 	ucv_put(wpa_ucode_call(2));
+
+	ucv_put(val);
 	ucv_gc(vm);
 }
 
@@ -1014,10 +1025,11 @@ void hostapd_ucode_apup_newpeer(struct h
 		return;
 
 	val = hostapd_ucode_bss_get_uval(hapd);
-	uc_value_push(ucv_get(ucv_string_new(hapd->conf->iface))); // BSS ifname
+	uc_value_push(ucv_string_new(hapd->conf->iface)); // BSS ifname
 	uc_value_push(ucv_get(val));
-	uc_value_push(ucv_get(ucv_string_new(ifname))); // APuP peer ifname
+	uc_value_push(ucv_string_new(ifname)); // APuP peer ifname
 	ucv_put(wpa_ucode_call(2));
+	ucv_put(val);
 	ucv_gc(vm);
 }
 #endif // def CONFIG_APUP
diff -upr a/src/utils/ucode.c b/src/utils/ucode.c
--- a/src/utils/ucode.c	2025-10-30 18:05:10.637230546 +0800
+++ b/src/utils/ucode.c	2025-11-03 01:03:31.261969064 +0800
@@ -181,7 +181,7 @@ uc_value_t *uc_wpa_freq_info(uc_vm_t *vm
 	ucv_object_add(ret, "op_class", ucv_int64_new(op_class));
 	ucv_object_add(ret, "channel", ucv_int64_new(channel));
 	ucv_object_add(ret, "hw_mode", ucv_int64_new(hw_mode));
-	ucv_object_add(ret, "hw_mode_str", ucv_get(ucv_string_new(modestr)));
+	ucv_object_add(ret, "hw_mode_str", ucv_string_new(modestr));
 	ucv_object_add(ret, "sec_channel", ucv_int64_new(sec_channel));
 	ucv_object_add(ret, "frequency", ucv_int64_new(freq_val));
 	ucv_object_add(ret, "oper_chwidth", ucv_int64_new(chanwidth));
@@ -440,7 +440,7 @@ uc_value_t *wpa_ucode_global_init(const
 
 	uc_vm_registry_set(&vm, "hostap.global", global);
 	proto = ucv_prototype_get(global);
-	ucv_object_add(proto, "data", ucv_get(ucv_object_new(&vm)));
+	ucv_object_add(proto, "data", ucv_object_new(&vm));
 
 #define ADD_CONST(x) ucv_object_add(proto, #x, ucv_int64_new(x))
 	ADD_CONST(MSG_EXCESSIVE);
@@ -485,6 +485,7 @@ uc_value_t *wpa_ucode_registry_remove(uc
 	if (!val)
 		return NULL;
 
+	ucv_get(val);
 	ucv_array_set(reg, idx - 1, NULL);
 	dataptr = ucv_resource_dataptr(val, NULL);
 	if (dataptr)
diff -upr a/wpa_supplicant/ucode.c b/wpa_supplicant/ucode.c
--- a/wpa_supplicant/ucode.c	2025-10-30 18:05:10.977235160 +0800
+++ b/wpa_supplicant/ucode.c	2025-11-03 01:07:15.143003137 +0800
@@ -43,7 +43,7 @@ wpas_ucode_iface_get_uval(struct wpa_sup
 	uc_value_t *val;
 
 	if (wpa_s->ucode.idx)
-		return wpa_ucode_registry_get(iface_registry, wpa_s->ucode.idx);
+		return ucv_get(wpa_ucode_registry_get(iface_registry, wpa_s->ucode.idx));
 
 	val = uc_resource_new(iface_type, wpa_s);
 	wpa_s->ucode.idx = wpa_ucode_registry_add(iface_registry, val);
@@ -59,9 +59,9 @@ wpas_ucode_update_interfaces(void)
 	int i;
 
 	for (wpa_s = wpa_global->ifaces; wpa_s; wpa_s = wpa_s->next)
-		ucv_object_add(ifs, wpa_s->ifname, ucv_get(wpas_ucode_iface_get_uval(wpa_s)));
+		ucv_object_add(ifs, wpa_s->ifname, wpas_ucode_iface_get_uval(wpa_s));
 
-	ucv_object_add(ucv_prototype_get(global), "interfaces", ucv_get(ifs));
+	ucv_object_add(ucv_prototype_get(global), "interfaces", ifs);
 	ucv_gc(vm);
 }
 
@@ -72,8 +72,8 @@ void wpas_ucode_add_bss(struct wpa_suppl
 	if (wpa_ucode_call_prepare("iface_add"))
 		return;
 
-	uc_value_push(ucv_get(ucv_string_new(wpa_s->ifname)));
-	uc_value_push(ucv_get(wpas_ucode_iface_get_uval(wpa_s)));
+	uc_value_push(ucv_string_new(wpa_s->ifname));
+	uc_value_push(wpas_ucode_iface_get_uval(wpa_s));
 	ucv_put(wpa_ucode_call(2));
 	ucv_gc(vm);
 }
@@ -90,9 +90,10 @@ void wpas_ucode_free_bss(struct wpa_supp
 	if (wpa_ucode_call_prepare("iface_remove"))
 		return;
 
-	uc_value_push(ucv_get(ucv_string_new(wpa_s->ifname)));
+	uc_value_push(ucv_string_new(wpa_s->ifname));
 	uc_value_push(ucv_get(val));
 	ucv_put(wpa_ucode_call(2));
+	ucv_put(val);
 	ucv_gc(vm);
 }
 
@@ -109,9 +110,9 @@ void wpas_ucode_update_state(struct wpa_
 		return;
 
 	state = wpa_supplicant_state_txt(wpa_s->wpa_state);
-	uc_value_push(ucv_get(ucv_string_new(wpa_s->ifname)));
+	uc_value_push(ucv_string_new(wpa_s->ifname));
 	uc_value_push(ucv_get(val));
-	uc_value_push(ucv_get(ucv_string_new(state)));
+	uc_value_push(ucv_string_new(state));
 	ucv_put(wpa_ucode_call(3));
 	ucv_gc(vm);
 }
@@ -134,9 +135,9 @@ void wpas_ucode_event(struct wpa_supplic
 	if (wpa_ucode_call_prepare("event"))
 		return;
 
-	uc_value_push(ucv_get(ucv_string_new(wpa_s->ifname)));
+	uc_value_push(ucv_string_new(wpa_s->ifname));
 	uc_value_push(ucv_get(val));
-	uc_value_push(ucv_get(ucv_string_new(event_to_string(event))));
+	uc_value_push(ucv_string_new(event_to_string(event)));
 	val = ucv_object_new(vm);
 	uc_value_push(ucv_get(val));
 
@@ -283,7 +284,7 @@ uc_wpas_iface_status(uc_vm_t *vm, size_t
 {
 	struct wpa_supplicant *wpa_s = uc_fn_thisval("wpas.iface");
 	struct wpa_bss *bss = NULL;
-	uc_value_t *ret, *val, *radio_idx_obj = uc_fn_arg(0);
+	uc_value_t *ret, *radio_idx_obj = uc_fn_arg(0);
 	struct wpa_channel_info ci;
 	u8 op_class, channel;
 	enum chan_width chwidth;
@@ -299,8 +300,7 @@ uc_wpas_iface_status(uc_vm_t *vm, size_t
 
 	ret = ucv_object_new(vm);
 
-	val = ucv_string_new(wpa_supplicant_state_txt(wpa_s->wpa_state));
-	ucv_object_add(ret, "state", ucv_get(val));
+	ucv_object_add(ret, "state", ucv_string_new(wpa_supplicant_state_txt(wpa_s->wpa_state)));
 
 	if (wpa_s->valid_links) {
 		/* The connection is ML */
