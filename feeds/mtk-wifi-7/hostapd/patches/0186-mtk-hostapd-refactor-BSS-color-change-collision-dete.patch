From 615fff1b057c75972429dcf7d3cdb46aa4307646 Mon Sep 17 00:00:00 2001
From: Michael-CY Lee <michael-cy.lee@mediatek.com>
Date: Mon, 14 Apr 2025 14:00:54 +0800
Subject: [PATCH 186/236] mtk: hostapd: refactor BSS color change & collision
 detection

1. Provide link ID for color bitmap dump request
2. if driver reports error on collor change of one BSS, the entire color
   change should be regarded as failure and reported to upper layer.
3. In hostapd_fill_cca_settings, old color should be restored before the
   check on the return value of hostapd_build_beacon_data.

Signed-off-by: Michael-CY Lee <michael-cy.lee@mediatek.com>
---
 hostapd/ctrl_iface.c         | 18 +++++++++++++++---
 src/ap/ap_drv_ops.c          |  6 ++++--
 src/ap/ap_drv_ops.h          |  2 +-
 src/ap/hostapd.c             |  3 +--
 src/common/mtk_vendor.h      |  1 +
 src/drivers/driver.h         |  2 +-
 src/drivers/driver_nl80211.c |  7 +++++--
 7 files changed, 28 insertions(+), 11 deletions(-)

diff --git a/hostapd/ctrl_iface.c b/hostapd/ctrl_iface.c
index c723a4d36..7d1f6aca4 100644
--- a/hostapd/ctrl_iface.c
+++ b/hostapd/ctrl_iface.c
@@ -3127,14 +3127,16 @@ static int hostapd_ctrl_iface_color_change(struct hostapd_iface *iface,
 
 		wpa_printf(MSG_DEBUG, "Setting user selected color: %d", color);
 		ret = hostapd_drv_switch_color(bss, &settings);
-		if (ret)
+		if (ret) {
 			hostapd_cleanup_cca_params(bss);
+			break;
+		}
 
 		free_beacon_data(&settings.beacon_cca);
 		free_beacon_data(&settings.beacon_after);
 	}
 
-	return 0;
+	return ret;
 #else /* NEED_AP_MLME */
 	return -1;
 #endif /* NEED_AP_MLME */
@@ -5173,8 +5175,18 @@ hostapd_ctrl_iface_get_aval_color_bmp(struct hostapd_data *hapd, char *buf,
 	char *pos, *end;
 	int i;
 	u64 aval_color_bmp = 0;
+	u8 link_id = 0;
+
+#ifdef CONFIG_IEEE80211BE
+	if (hostapd_is_mld_ap(hapd))
+		link_id = hapd->mld_link_id;
+#endif /* CONFIG_IEEE80211BE */
+
+	ret = hostapd_drv_get_aval_bss_color_bmp(hapd, &aval_color_bmp, link_id);
+
+	if (ret)
+		return ret;
 
-	hostapd_drv_get_aval_bss_color_bmp(hapd, &aval_color_bmp);
 	hapd->color_collision_bitmap = ~aval_color_bmp;
 
 	pos = buf;
diff --git a/src/ap/ap_drv_ops.c b/src/ap/ap_drv_ops.c
index 5b21a95ea..620f04491 100644
--- a/src/ap/ap_drv_ops.c
+++ b/src/ap/ap_drv_ops.c
@@ -1576,12 +1576,14 @@ int hostapd_drv_amsdu_dump(struct hostapd_data *hapd, u8 *amsdu)
 	return hapd->driver->amsdu_dump(hapd->drv_priv, amsdu);
 }
 
-int hostapd_drv_get_aval_bss_color_bmp(struct hostapd_data *hapd, u64 *aval_color_bmp)
+int hostapd_drv_get_aval_bss_color_bmp(struct hostapd_data *hapd,
+				       u64 *aval_color_bmp, u8 link_id)
 {
 	if (!hapd->driver || !hapd->driver->get_aval_color_bmp ||
 	    hapd->iface->conf->he_op.he_bss_color_disabled)
 		return 0;
-	return hapd->driver->get_aval_color_bmp(hapd->drv_priv, aval_color_bmp);
+	return hapd->driver->get_aval_color_bmp(hapd->drv_priv, aval_color_bmp,
+						link_id);
 }
 
 int hostapd_drv_txpower_ctrl(struct hostapd_data *hapd)
diff --git a/src/ap/ap_drv_ops.h b/src/ap/ap_drv_ops.h
index c3e113ce2..d6cd07de7 100644
--- a/src/ap/ap_drv_ops.h
+++ b/src/ap/ap_drv_ops.h
@@ -174,7 +174,7 @@ int hostapd_drv_ibf_dump(struct hostapd_data *hapd, u8 *ibf_enable);
 int hostapd_drv_amsdu_ctrl(struct hostapd_data *hapd);
 int hostapd_drv_amsdu_dump(struct hostapd_data *hapd, u8 *amsdu);
 int hostapd_drv_get_aval_bss_color_bmp(struct hostapd_data *hapd,
-				       u64 *aval_color_bmp);
+				       u64 *aval_color_bmp, u8 link_id);
 int hostapd_drv_txpower_ctrl(struct hostapd_data *hapd);
 int hostapd_drv_ap_wireless(struct hostapd_data *hapd, u8 sub_vendor_id, int value);
 int hostapd_drv_ap_rfeatures(struct hostapd_data *hapd, u8 sub_vendor_id, int value);
diff --git a/src/ap/hostapd.c b/src/ap/hostapd.c
index 319e9eea2..5cba10899 100644
--- a/src/ap/hostapd.c
+++ b/src/ap/hostapd.c
@@ -5447,11 +5447,10 @@ int hostapd_fill_cca_settings(struct hostapd_data *hapd,
 	old_color = iface->conf->he_op.he_bss_color;
 	iface->conf->he_op.he_bss_color = hapd->cca_color;
 	ret = hostapd_build_beacon_data(hapd, &settings->beacon_after);
+	iface->conf->he_op.he_bss_color = old_color;
 	if (ret)
 		return ret;
 
-	iface->conf->he_op.he_bss_color = old_color;
-
 	settings->cca_count = hapd->cca_count;
 	settings->cca_color = hapd->cca_color,
 	hapd->cca_in_progress = true;
diff --git a/src/common/mtk_vendor.h b/src/common/mtk_vendor.h
index cc74f7a01..f35d9976e 100644
--- a/src/common/mtk_vendor.h
+++ b/src/common/mtk_vendor.h
@@ -257,6 +257,7 @@ enum mtk_vendor_attr_bss_color_ctrl {
 	MTK_VENDOR_ATTR_BSS_COLOR_CTRL_UNSPEC,
 
 	MTK_VENDOR_ATTR_AVAL_BSS_COLOR_BMP,
+	MTK_VENDOR_ATTR_AVAL_BSS_COLOR_LINK_ID,
 
 	/* keep last */
 	NUM_MTK_VENDOR_ATTRS_BSS_COLOR_CTRL,
diff --git a/src/drivers/driver.h b/src/drivers/driver.h
index 8a515d2f6..ff73ba15a 100644
--- a/src/drivers/driver.h
+++ b/src/drivers/driver.h
@@ -5691,7 +5691,7 @@ struct wpa_driver_ops {
 	 * @aval_color_bmp: available bss color bitmap
 	 *
 	 */
-	int (*get_aval_color_bmp)(void *priv, u64 *aval_color_bmp);
+	int (*get_aval_color_bmp)(void *priv, u64 *aval_color_bmp, u8 link_id);
 
 	/**
 	* ap_wireless - set wireless command
diff --git a/src/drivers/driver_nl80211.c b/src/drivers/driver_nl80211.c
index bb51f0c33..43076e8e4 100644
--- a/src/drivers/driver_nl80211.c
+++ b/src/drivers/driver_nl80211.c
@@ -15994,7 +15994,7 @@ static int nl80211_get_aval_color_bmp_handler(struct nl_msg *msg, void *arg)
 	return 0;
 }
 
-static int nl80211_get_aval_color_bmp(void *priv, u64 *aval_color_bmp)
+static int nl80211_get_aval_color_bmp(void *priv, u64 *aval_color_bmp, u8 link_id)
 {
 	struct i802_bss *bss = priv;
 	struct wpa_driver_nl80211_data *drv = bss->drv;
@@ -16008,7 +16008,7 @@ static int nl80211_get_aval_color_bmp(void *priv, u64 *aval_color_bmp)
 		return 0;
 	}
 
-	if (!(msg = nl80211_drv_msg(drv, NLM_F_DUMP, NL80211_CMD_VENDOR)) ||
+	if (!(msg = nl80211_bss_msg(bss, NLM_F_DUMP, NL80211_CMD_VENDOR)) ||
 	    nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
 	    nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD,
 			MTK_NL80211_VENDOR_SUBCMD_BSS_COLOR_CTRL))
@@ -16020,6 +16020,9 @@ static int nl80211_get_aval_color_bmp(void *priv, u64 *aval_color_bmp)
 		return -1;
 	}
 
+	if (nla_put_u8(msg, MTK_VENDOR_ATTR_AVAL_BSS_COLOR_LINK_ID, link_id))
+		return -ENOBUFS;
+
 	nla_nest_end(msg, attr);
 
 	ret = send_and_recv_resp(drv, msg, nl80211_get_aval_color_bmp_handler, aval_color_bmp);
-- 
2.45.2

