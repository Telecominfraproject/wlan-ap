From e918d9d86082ede7aee455ca98ebd147f06c416e Mon Sep 17 00:00:00 2001
From: Michael-CY Lee <michael-cy.lee@mediatek.com>
Date: Mon, 13 Jan 2025 15:22:15 +0800
Subject: [PATCH 086/115] mtk: mac80211: set single STA's TTLM on AP MLD

Add support to set a STA's TTLM on AP MLD, including receiving NL80211
command and fowarding the TTLM request to driver.

Note that if the bitmaps attributes are not provided, it should become
the default TTLM.

Signed-off-by: Michael-CY Lee <michael-cy.lee@mediatek.com>
---
 include/net/cfg80211.h       |  3 +++
 include/net/mac80211.h       |  4 ++++
 include/uapi/linux/nl80211.h |  1 +
 net/mac80211/cfg.c           | 25 ++++++++++++++++++++++
 net/mac80211/driver-ops.h    | 16 ++++++++++++++
 net/mac80211/trace.h         | 29 +++++++++++++++++++++++++
 net/wireless/nl80211.c       | 41 ++++++++++++++++++++++++++++++++++++
 net/wireless/rdev-ops.h      | 15 +++++++++++++
 net/wireless/trace.h         | 22 +++++++++++++++++++
 9 files changed, 156 insertions(+)

diff --git a/include/net/cfg80211.h b/include/net/cfg80211.h
index ad0b8392..2c358d16 100644
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -4744,6 +4744,7 @@ struct mgmt_frame_regs {
  * @del_link_station: Remove a link of a station.
  *
  * @set_hw_timestamp: Enable/disable HW timestamping of TM/FTM frames.
+ * @set_sta_ttlm: For AP MLD to set a specific non-AP MLD's TID to link mapping
  * @set_attlm: For AP MLD to to set advertised TID to link mapping
  * @set_ttlm: set the TID to link mapping.
  * @set_epcs: Enable/Disable EPCS for station mode.
@@ -5127,6 +5128,8 @@ struct cfg80211_ops {
 				    struct link_station_del_parameters *params);
 	int	(*set_hw_timestamp)(struct wiphy *wiphy, struct net_device *dev,
 				    struct cfg80211_set_hw_timestamp *hwts);
+	int	(*set_sta_ttlm)(struct wiphy *wiphy, struct net_device *dev,
+				u8 *mac, struct cfg80211_ttlm_params *params);
 	int	(*set_attlm)(struct wiphy *wiphy, struct net_device *dev,
 			     u16 disabled_links, u16 switch_time, u32 duration);
 	int	(*set_ttlm)(struct wiphy *wiphy, struct net_device *dev,
diff --git a/include/net/mac80211.h b/include/net/mac80211.h
index 152afc24..6de2b552 100644
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -4543,6 +4543,7 @@ struct ieee80211_prep_tx_info {
  *	flow offloading for flows originating from the vif.
  *	Note that the driver must not assume that the vif driver_data is valid
  *	at this point, since the callback can be called during netdev teardown.
+ * @set_sta_ttlm: For AP MLD, set a specific non-AP MLD's TID-To-Link mapping.
  * @set_attlm: For AP MLD to request a advertised TID-To-Link mapping.
  * @can_neg_ttlm: for managed interface, requests the driver to determine
  *	if the requested TID-To-Link mapping can be accepted or not.
@@ -4949,6 +4950,9 @@ struct ieee80211_ops {
 			    struct net_device *dev,
 			    enum tc_setup_type type,
 			    void *type_data);
+	int (*set_sta_ttlm)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			    struct ieee80211_sta *sta,
+			    struct ieee80211_neg_ttlm *neg_ttlm);
 	int (*set_attlm)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			 u16 disabled_links, u16 switch_time, u32 druation);
 	enum ieee80211_neg_ttlm_res
diff --git a/include/uapi/linux/nl80211.h b/include/uapi/linux/nl80211.h
index 4be2eb90..5fdc24a3 100644
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@ -1612,6 +1612,7 @@ enum nl80211_commands {
 	/* MTK internal */
 	NL80211_CMD_ATTLM_EVENT,
 	NL80211_CMD_SET_ATTLM,
+	NL80211_CMD_SET_STA_TTLM,
 	NL80211_CMD_NOTIFY_CRIT_UPDATE,
 	NL80211_CMD_TSF_OFFSET_EVENT,
 
diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c
index 3eb2a924..408feaa1 100644
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -5470,6 +5470,30 @@ static int ieee80211_set_hw_timestamp(struct wiphy *wiphy,
 
 	return local->ops->set_hw_timestamp(&local->hw, &sdata->vif, hwts);
 }
+static int ieee80211_set_sta_ttlm(struct wiphy *wiphy, struct net_device *dev,
+				  u8 *mac, struct cfg80211_ttlm_params *params)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_neg_ttlm neg_ttlm;
+	struct sta_info *sta;
+
+	lockdep_assert_wiphy(sdata->local->hw.wiphy);
+
+	sta = sta_info_get_bss(sdata, mac);
+	if (!sta)
+		return -ENOENT;
+
+	if (!params->is_teardown) {
+		memcpy(neg_ttlm.downlink, params->dlink, sizeof(neg_ttlm.downlink));
+		memcpy(neg_ttlm.uplink, params->ulink, sizeof(neg_ttlm.uplink));
+	} else {
+		memset(neg_ttlm.downlink, 0xff, sizeof(neg_ttlm.downlink));
+		memset(neg_ttlm.uplink, 0xff, sizeof(neg_ttlm.uplink));
+	}
+
+	return drv_set_sta_ttlm(local, sdata, &sta->sta, &neg_ttlm);
+}
 
 static int
 ieee80211_set_attlm(struct wiphy *wiphy, struct net_device *dev,
@@ -5695,6 +5719,7 @@ const struct cfg80211_ops mac80211_config_ops = {
 	.mod_link_station = ieee80211_mod_link_station,
 	.del_link_station = ieee80211_del_link_station,
 	.set_hw_timestamp = ieee80211_set_hw_timestamp,
+	.set_sta_ttlm = ieee80211_set_sta_ttlm,
 	.set_attlm = ieee80211_set_attlm,
 	.set_ttlm = ieee80211_set_ttlm,
 	.get_radio_mask = ieee80211_get_radio_mask,
diff --git a/net/mac80211/driver-ops.h b/net/mac80211/driver-ops.h
index 9ba2fc13..45b72534 100644
--- a/net/mac80211/driver-ops.h
+++ b/net/mac80211/driver-ops.h
@@ -1807,4 +1807,20 @@ static inline int drv_set_qos_map(struct ieee80211_local *local,
 	return ret;
 }
 
+static inline int drv_set_sta_ttlm(struct ieee80211_local *local,
+				   struct ieee80211_sub_if_data *sdata,
+				   struct ieee80211_sta *sta,
+				   struct ieee80211_neg_ttlm *neg_ttlm)
+{
+	int ret = -EOPNOTSUPP;
+
+	trace_drv_set_sta_ttlm(local, sdata, sta, neg_ttlm);
+	if (local->ops->set_sta_ttlm)
+		ret = local->ops->set_sta_ttlm(&local->hw, &sdata->vif,
+					       sta, neg_ttlm);
+	trace_drv_return_int(local, ret);
+
+	return ret;
+}
+
 #endif /* __MAC80211_DRIVER_OPS */
diff --git a/net/mac80211/trace.h b/net/mac80211/trace.h
index 789beecf..230e80b1 100644
--- a/net/mac80211/trace.h
+++ b/net/mac80211/trace.h
@@ -3383,6 +3383,35 @@ DEFINE_EVENT(local_sdata_evt, drv_set_qos_map,
 		 struct ieee80211_sub_if_data *sdata),
 	TP_ARGS(local, sdata)
 );
+
+TRACE_EVENT(drv_set_sta_ttlm,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata,
+		 struct ieee80211_sta *sta,
+		 struct ieee80211_neg_ttlm *neg_ttlm),
+
+	TP_ARGS(local, sdata, sta, neg_ttlm),
+
+	TP_STRUCT__entry(LOCAL_ENTRY
+			 VIF_ENTRY
+			 STA_ENTRY
+			 __array(u16, downlink, sizeof(u16) * 8)
+			 __array(u16, uplink, sizeof(u16) * 8)
+	),
+
+	TP_fast_assign(LOCAL_ASSIGN;
+		       VIF_ASSIGN;
+		       STA_ASSIGN;
+		       memcpy(__entry->downlink, neg_ttlm->downlink,
+			      sizeof(neg_ttlm->downlink));
+		       memcpy(__entry->uplink, neg_ttlm->uplink,
+			      sizeof(neg_ttlm->uplink));
+	),
+
+	TP_printk(LOCAL_PR_FMT  VIF_PR_FMT STA_PR_FMT,
+		  LOCAL_PR_ARG, VIF_PR_ARG, STA_PR_ARG
+	)
+);
 #endif /* !__MAC80211_DRIVER_TRACE || TRACE_HEADER_MULTI_READ */
 
 #undef TRACE_INCLUDE_PATH
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index 449ffc78..7d40c9a4 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -17224,6 +17224,41 @@ static int nl80211_set_hw_timestamp(struct sk_buff *skb,
 	return rdev_set_hw_timestamp(rdev, dev, &hwts);
 }
 
+static int
+nl80211_set_sta_ttlm(struct sk_buff *skb, struct genl_info *info)
+{
+	struct cfg80211_ttlm_params params = {};
+	struct cfg80211_registered_device *rdev = info->user_ptr[0];
+	struct net_device *dev = info->user_ptr[1];
+	struct wireless_dev *wdev = dev->ieee80211_ptr;
+	u8 *mac_addr = NULL;
+
+	if (wdev->iftype != NL80211_IFTYPE_AP)
+		return -EOPNOTSUPP;
+
+	if (!info->attrs[NL80211_ATTR_MAC])
+		return -EINVAL;
+
+	mac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);
+
+	if (info->attrs[NL80211_ATTR_MLO_TTLM_DLINK] &&
+	    info->attrs[NL80211_ATTR_MLO_TTLM_ULINK]) {
+		nla_memcpy(params.dlink,
+			   info->attrs[NL80211_ATTR_MLO_TTLM_DLINK],
+			   sizeof(params.dlink));
+		nla_memcpy(params.ulink,
+			   info->attrs[NL80211_ATTR_MLO_TTLM_ULINK],
+			   sizeof(params.ulink));
+	} else if (!info->attrs[NL80211_ATTR_MLO_TTLM_DLINK] &&
+		   !info->attrs[NL80211_ATTR_MLO_TTLM_ULINK]) {
+		params.is_teardown = true;
+	} else {
+		return -EINVAL;
+	}
+
+	return rdev_set_sta_ttlm(rdev, dev, mac_addr, &params);
+}
+
 static int
 nl80211_set_attlm(struct sk_buff *skb, struct genl_info *info)
 {
@@ -18563,6 +18598,12 @@ static const struct genl_small_ops nl80211_small_ops[] = {
 		.flags = GENL_UNS_ADMIN_PERM,
 		.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),
 	},
+	{
+		.cmd = NL80211_CMD_SET_STA_TTLM,
+		.doit = nl80211_set_sta_ttlm,
+		.flags = GENL_UNS_ADMIN_PERM,
+		.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),
+	},
 	{
 		.cmd = NL80211_CMD_SET_ATTLM,
 		.doit = nl80211_set_attlm,
diff --git a/net/wireless/rdev-ops.h b/net/wireless/rdev-ops.h
index 09d7eead..36891bf8 100644
--- a/net/wireless/rdev-ops.h
+++ b/net/wireless/rdev-ops.h
@@ -1543,6 +1543,21 @@ rdev_set_hw_timestamp(struct cfg80211_registered_device *rdev,
 	return ret;
 }
 
+static inline int
+rdev_set_sta_ttlm(struct cfg80211_registered_device *rdev, struct net_device *dev,
+		  u8 *mac, struct cfg80211_ttlm_params *params)
+{
+	struct wiphy *wiphy = &rdev->wiphy;
+	int ret = -EOPNOTSUPP;
+
+	trace_rdev_set_sta_ttlm(wiphy, dev, mac, params);
+	if (rdev->ops->set_sta_ttlm)
+		ret = rdev->ops->set_sta_ttlm(wiphy, dev, mac, params);
+	trace_rdev_return_int(wiphy, ret);
+
+	return ret;
+}
+
 static inline int
 rdev_set_attlm(struct cfg80211_registered_device *rdev, struct net_device *dev,
 	       u16 disabled_links, u16 switch_time, u32 duration)
diff --git a/net/wireless/trace.h b/net/wireless/trace.h
index 13706669..a9f3d214 100644
--- a/net/wireless/trace.h
+++ b/net/wireless/trace.h
@@ -3064,6 +3064,28 @@ TRACE_EVENT(rdev_set_hw_timestamp,
 		  __entry->enable)
 );
 
+TRACE_EVENT(rdev_set_sta_ttlm,
+	TP_PROTO(struct wiphy *wiphy, struct net_device *netdev, u8 *mac,
+		 struct cfg80211_ttlm_params *params),
+	TP_ARGS(wiphy, netdev, mac, params),
+	TP_STRUCT__entry(
+		WIPHY_ENTRY
+		NETDEV_ENTRY
+		MAC_ENTRY(mac)
+		__array(u8, dlink, sizeof(u16) * 8)
+		__array(u8, ulink, sizeof(u16) * 8)
+	),
+	TP_fast_assign(
+		WIPHY_ASSIGN;
+		NETDEV_ASSIGN;
+		MAC_ASSIGN(mac, mac);
+		memcpy(__entry->dlink, params->dlink, sizeof(params->dlink));
+		memcpy(__entry->ulink, params->ulink, sizeof(params->ulink));
+	),
+	TP_printk(WIPHY_PR_FMT ", " NETDEV_PR_FMT ", sta: %pM",
+		  WIPHY_PR_ARG, NETDEV_PR_ARG, __entry->mac)
+);
+
 TRACE_EVENT(rdev_set_attlm,
 	TP_PROTO(struct wiphy *wiphy, struct net_device *netdev,
 		 u16 disabled_links, u16 switch_time, u32 duration),
-- 
2.45.2

