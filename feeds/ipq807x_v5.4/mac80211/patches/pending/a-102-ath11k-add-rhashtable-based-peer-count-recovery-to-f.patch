From 91a24101efb33ade1d4b39fb391d5e6dbf1f1b9b Mon Sep 17 00:00:00 2001
From: Venkat Chimata <venkat@nearhop.com>
Date: Sun, 23 Nov 2025 23:34:02 +0530
Subject: [PATCH] ath11k: add rhashtable-based peer count recovery to fix peer
 resource desynchronization

Description:

This change introduces a helper function ath11k_get_peer_count() that walks the
 peer rhashtable and returns the total number of peer entries currently tracked
  by the driver. The function uses rhashtable_walk_*() APIs and handles -EAGAIN
to correctly iterate even when the hash table is resized during traversal.

During roaming and frequent peer create/delete sequences, the driver’s internal
peer counter (ar->num_peers) can become desynchronized from the actual number
of peer entries stored in the rhashtable. This mismatch may occur when peer
delete operations timeout or when the firmware and driver get out of sync,
resulting in the driver incorrectly reporting peer exhaustion:

failed to create peer due to insufficient peer entry resource in firmware

When ar->num_peers becomes negative or exceeds ar->max_num_peers - 1, the
driver now logs a warning and recomputes the peer count directly from the
rhashtable. If the recalculated rhashtable count is within limits,
ar->num_peers is corrected. If the recalculated count still exceeds the
firmware peer limit, peer creation is aborted with -ENOBUFS.

This recovery mechanism prevents permanent peer allocation failures caused
 by stale or leaked peer entries and helps keep the driver’s peer accounting
 consistent with the actual peer table state. It is especially useful in
 environments with rapid roaming or random-MAC clients where peer churn is high.

This change also changes the way num_peers is decremented. Per this change,
num_peers is decremented only during the peer is deleted from the list ie
list_del

Signed-off-by: Venkat Chimata <venkat@nearhop.com>
---
 drivers/net/wireless/ath/ath11k/mac.c  |  2 -
 drivers/net/wireless/ath/ath11k/peer.c | 59 +++++++++++++++++++++++---
 2 files changed, 54 insertions(+), 7 deletions(-)

diff --git a/drivers/net/wireless/ath/ath11k/mac.c b/drivers/net/wireless/ath/ath11k/mac.c
index 10925f2..037bc69 100644
--- a/drivers/net/wireless/ath/ath11k/mac.c
+++ b/drivers/net/wireless/ath/ath11k/mac.c
@@ -7845,8 +7845,6 @@ err_peer_del:
 							 vif->addr);
 		if (fbret)
 			goto err_keyid;
-
-		ar->num_peers--;
 	}
 
 err_vdev_del:
diff --git a/drivers/net/wireless/ath/ath11k/peer.c b/drivers/net/wireless/ath/ath11k/peer.c
index aefc6ba..b040093 100644
--- a/drivers/net/wireless/ath/ath11k/peer.c
+++ b/drivers/net/wireless/ath/ath11k/peer.c
@@ -447,6 +447,7 @@ void ath11k_peer_ast_cleanup(struct ath11k *ar, struct ath11k_peer *peer,
 void ath11k_peer_unmap_event(struct ath11k_base *ab, u16 peer_id)
 {
 	struct ath11k_peer *peer;
+	struct ath11k *ar;
 
 	spin_lock_bh(&ab->base_lock);
 
@@ -463,6 +464,13 @@ void ath11k_peer_unmap_event(struct ath11k_base *ab, u16 peer_id)
 
 	list_del(&peer->list);
 	kfree(peer);
+	ar = ath11k_mac_get_ar_by_vdev_id(ab, peer->vdev_id);
+	if (!ar) {
+		ath11k_warn(ab, "peer-unmap-event: unknown peer vdev id %d\n",
+			    peer->vdev_id);
+	} else {
+		ar->num_peers--;
+	}
 	wake_up(&ab->peer_mapping_wq);
 
 exit:
@@ -516,6 +524,7 @@ free_peer:
 	rcu_read_unlock();
 	list_del(&peer->list);
 	kfree(peer);
+	ar->num_peers--;
 	wake_up(&ab->peer_mapping_wq);
 
 exit:
@@ -866,8 +875,6 @@ int ath11k_peer_delete(struct ath11k *ar, u32 vdev_id, u8 *addr)
 	ATH11K_MEMORY_STATS_DEC(ar->ab, per_peer_object,
 				sizeof(struct ath11k_peer));
 
-	ar->num_peers--;
-
 	return 0;
 }
 
@@ -876,6 +883,31 @@ static int ath11k_wait_for_peer_created(struct ath11k *ar, int vdev_id, const u8
 	return ath11k_wait_for_peer_common(ar->ab, vdev_id, addr, true);
 }
 
+static int ath11k_get_peer_count(struct rhashtable *ht)
+{
+	struct rhashtable_iter iter;
+	struct rhash_head *pos;
+	int count = 0;
+
+	rhashtable_walk_enter(ht, &iter);
+	rhashtable_walk_start(&iter);
+
+	while ((pos = rhashtable_walk_next(&iter))) {
+		if (IS_ERR(pos)) {
+			if (PTR_ERR(pos) == -EAGAIN)
+				continue;   // retry due to resize
+			break;          // some other error
+		}
+		count++;
+	}
+
+	rhashtable_walk_stop(&iter);
+	rhashtable_walk_exit(&iter);
+
+	return count;
+}
+
+
 int ath11k_peer_create(struct ath11k *ar, struct ath11k_vif *arvif,
 		       struct ieee80211_sta *sta, struct peer_create_params *param)
 {
@@ -884,13 +916,30 @@ int ath11k_peer_create(struct ath11k *ar, struct ath11k_vif *arvif,
 	struct ath11k_sta *arsta;
 	int ret, fbret;
 	u8 vdev_id = 0;
+	int rhash_count;
 
 	lockdep_assert_held(&ar->conf_mutex);
 
-	if (ar->num_peers > (ar->max_num_peers - 1)) {
+	// Check for peer count desynchronization
+	// If num_peers is negative or exceeds max_num_peers -1, recalculate from rhashtable
+	if ((ar->num_peers < 0) || (ar->num_peers > (ar->max_num_peers - 1))) {
+        // This can happen if rhash table and num_peers get out of sync
+        // e.g. during peer delete for some unknown reason
+        // Recalculate num_peers from rhash table
 		ath11k_warn(ar->ab,
-			    "failed to create peer due to insufficient peer entry resource in firmware\n");
-		return -ENOBUFS;
+			    "failed to create peer due to insufficient peer entry resource in firmware ar->num_peers = %d "
+                "ar->max_num_peers = %d ar->num_stations = %d\n", ar->num_peers, ar->max_num_peers, ar->num_stations);
+		mutex_lock(&ar->ab->tbl_mtx_lock);
+		spin_lock_bh(&ar->ab->base_lock);
+		rhash_count = ath11k_get_peer_count(ar->ab->rhead_peer_addr);
+		spin_unlock_bh(&ar->ab->base_lock);
+		mutex_unlock(&ar->ab->tbl_mtx_lock);
+		if (rhash_count > ar->max_num_peers -1 ) {
+			ath11k_warn(ar->ab,
+				"rhash_count %d exceeds max_num_peers %d\n", rhash_count, ar->max_num_peers);
+			return -ENOBUFS;
+		}
+		ar->num_peers = rhash_count;
 	}
 
 	mutex_lock(&ar->ab->tbl_mtx_lock);
-- 
2.34.1

