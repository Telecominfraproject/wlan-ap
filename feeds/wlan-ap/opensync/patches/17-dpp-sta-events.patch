Index: opensync-2.0.5.0/src/lib/datapipeline/inc/dpp_events.h
===================================================================
--- /dev/null
+++ opensync-2.0.5.0/src/lib/datapipeline/inc/dpp_events.h
@@ -0,0 +1,364 @@
+#ifndef DPP_EVENTS_H_INCLUDED
+#define DPP_EVENTS_H_INCLUDED
+
+#include "ds.h"
+#include "ds_dlist.h"
+
+#include "dpp_types.h"
+
+// string limits
+#define DPP_REASON_STR_LEN  129
+#define DPP_CLT_ID_LEN      129
+
+// proto: EventType
+typedef enum
+{
+    ET_CLIENT_ASSOC = 0,
+    ET_CLIENT_AUTH,
+    ET_CLIENT_DISCONNECT,
+    ET_CLIENT_FAILURE,
+    ET_CLIENT_FIRST_DATA,
+    ET_CLIENT_ID,
+    ET_CLIENT_IP,
+    ET_CLIENT_TIMEOUT
+} event_type_t;
+
+// proto: AssocType
+typedef enum
+{
+    AT_ASSOC = 0,
+    AT_REASSOC
+} assoc_type_t;
+
+// proto: DeviceType
+typedef enum
+{
+    DT_AP = 0,
+    DT_STA
+} device_type_t;
+
+// proto: FrameType
+typedef enum
+{
+    FT_DEAUTH = 0,
+    FT_DISASSOC
+} frame_type_t;
+
+// proto: CTReasonType
+typedef enum
+{
+    CTR_IDLE_TOO_LONG = 0,
+    CTR_PROBE_FAIL
+} ct_reason_t;
+
+// proto: ClientAssocEvent
+typedef struct
+{
+    mac_address_t    sta_mac;
+    uint64_t         session_id;
+    radio_essid_t    ssid;
+    radio_type_t     band;
+    assoc_type_t     assoc_type;
+    uint32_t         status;
+    int32_t          rssi;
+    uint32_t         internal_sc;
+    bool             using11k;
+    bool             using11r;
+    bool             using11v;
+} dpp_event_record_assoc_t;
+
+// proto: ClientAuthEvent
+typedef struct
+{
+    mac_address_t    sta_mac;
+    uint64_t         session_id;
+    radio_essid_t    ssid;
+    radio_type_t     band;
+    uint32_t         auth_status;
+} dpp_event_record_auth_t;
+
+// proto: ClientDisconnectEvent
+typedef struct
+{
+    mac_address_t    sta_mac;
+    uint64_t         session_id;
+    uint32_t         reason;
+    device_type_t    dev_type;
+    frame_type_t     fr_type;
+    uint64_t         last_sent_up_ts_in_us;
+    uint64_t         last_recv_up_ts_in_us;
+    uint32_t         internal_rc;
+    int32_t          rssi;
+    radio_essid_t    ssid;
+    radio_type_t     band;
+} dpp_event_record_disconnect_t;
+
+// proto: ClientFailureEvent
+typedef struct
+{
+    mac_address_t    sta_mac;
+    uint64_t         session_id;
+    radio_essid_t    ssid;
+    int32_t          reason;
+    char             reason_str[DPP_REASON_STR_LEN];
+} dpp_event_record_failure_t;
+
+// proto: ClientFirstDataEvent
+typedef struct
+{
+    mac_address_t    sta_mac;
+    uint64_t         session_id;
+    uint64_t         first_data_tx_up_ts_in_us;
+    uint64_t         first_data_rx_up_ts_in_us;
+} dpp_event_record_first_data_t;
+
+// proto: ClientIdEvent
+typedef struct
+{
+    mac_address_t    clt_mac;
+    uint64_t         session_id;
+    char             clt_id[DPP_CLT_ID_LEN];
+} dpp_event_record_id_t;
+
+// proto: ClientIpEvent
+typedef struct
+{
+    mac_address_t    sta_mac;
+    uint64_t         session_id;
+    char             ip_addr[16];
+} dpp_event_record_ip_t;
+
+// proto: ClientTimeoutEvent
+typedef struct
+{
+    mac_address_t    sta_mac;
+    uint64_t         session_id;
+    ct_reason_t      r_code;
+    uint64_t         last_sent_up_ts_in_us;
+    uint64_t         last_recv_up_ts_in_us;
+
+} dpp_event_record_timeout_t;
+
+// event record
+typedef struct
+{
+    event_type_t                    event_type;
+    dpp_event_record_assoc_t        client_assoc_event;
+    dpp_event_record_auth_t         client_auth_event;
+    dpp_event_record_disconnect_t   client_disconnect_event;
+    dpp_event_record_failure_t      client_failure_event;
+    dpp_event_record_first_data_t   client_first_data_event;
+    dpp_event_record_id_t           client_id_event;
+    dpp_event_record_ip_t           client_ip_event;
+    dpp_event_record_timeout_t      client_timeout_event;
+    ds_dlist_node_t                 node;
+} dpp_event_record_t;
+
+/*******************************/
+/* ClientAssocEvent alloc/free */
+/*******************************/
+// alloc
+static inline dpp_event_record_assoc_t * dpp_event_client_assoc_record_alloc()
+{
+    dpp_event_record_assoc_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_assoc_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_assoc_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_assoc_record_free(dpp_event_record_assoc_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+/******************************/
+/* ClientAuthEvent alloc/free */
+/******************************/
+// alloc
+static inline dpp_event_record_auth_t * dpp_event_client_auth_record_alloc()
+{
+    dpp_event_record_auth_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_auth_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_auth_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_auth_record_free(dpp_event_record_auth_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+/************************************/
+/* ClientDisconnectEvent alloc/free */
+/************************************/
+// alloc
+static inline dpp_event_record_disconnect_t * dpp_event_client_disconnect_record_alloc()
+{
+    dpp_event_record_disconnect_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_disconnect_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_disconnect_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_disconnect_record_free(dpp_event_record_disconnect_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+/*********************************/
+/* ClientFailureEvent alloc/free */
+/*********************************/
+// alloc
+static inline dpp_event_record_failure_t * dpp_event_client_failure_record_alloc()
+{
+    dpp_event_record_failure_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_failure_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_failure_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_failure_record_free(dpp_event_record_failure_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+/***********************************/
+/* ClientFirstDataEvent alloc/free */
+/***********************************/
+// alloc
+static inline dpp_event_record_first_data_t * dpp_event_client_first_data_record_alloc()
+{
+    dpp_event_record_first_data_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_first_data_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_first_data_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_first_data_record_free(dpp_event_record_first_data_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+/****************************/
+/* ClientIdEvent alloc/free */
+/****************************/
+// alloc
+static inline dpp_event_record_id_t * dpp_event_client_id_record_alloc()
+{
+    dpp_event_record_id_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_id_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_id_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_id_record_free(dpp_event_record_id_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+/****************************/
+/* ClientIpEvent alloc/free */
+/****************************/
+// alloc
+static inline dpp_event_record_ip_t * dpp_event_client_ip_record_alloc()
+{
+    dpp_event_record_ip_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_ip_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_ip_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_ip_record_free(dpp_event_record_ip_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+/*********************************/
+/* ClientTimeoutEvent alloc/free */
+/*********************************/
+// alloc
+static inline dpp_event_record_timeout_t * dpp_event_client_timeout_record_alloc()
+{
+    dpp_event_record_timeout_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_timeout_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_timeout_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_timeout_record_free(dpp_event_record_timeout_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+// Events report type
+typedef struct
+{
+    uint64_t        timestamp_ms;
+    ds_dlist_t      list; // dpp_event_record_t
+} dpp_event_report_data_t;
+
+#endif /* DPP_EVENTS_H_INCLUDED */
Index: opensync-2.0.5.0/src/lib/datapipeline/src/dppline.c
===================================================================
--- opensync-2.0.5.0.orig/src/lib/datapipeline/src/dppline.c
+++ opensync-2.0.5.0/src/lib/datapipeline/src/dppline.c
@@ -43,6 +43,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #include "dpp_device.h"
 #include "dpp_capacity.h"
 #include "dpp_bs_client.h"
+#include "dpp_events.h"
 
 #ifndef TARGET_NATIVE
 #include "os_types.h"
@@ -64,6 +65,7 @@ typedef enum
     DPP_T_BS_CLIENT = 6,
     DPP_T_RSSI      = 7,
     DPP_T_NETWORK_PROBE =8,
+    DPP_T_EVENTS    = 9
 } DPP_STS_TYPE;
 
 uint32_t queue_depth;
@@ -96,6 +98,13 @@ typedef struct dpp_network_probe_stats
     uint64_t                        timestamp_ms;
 } dppline_network_probe_stats_t;
 
+typedef struct dpp_events_stats
+{
+    dpp_event_record_t             *list;
+    uint32_t                        qty;
+    uint64_t                        timestamp_ms;
+} dppline_events_stats_t;
+
 typedef struct
 {
     radio_type_t                    radio_type;
@@ -159,6 +168,8 @@ typedef struct dpp_rssi_stats
     uint64_t                        timestamp_ms;
 } dppline_rssi_stats_t;
 
+
+
 /* DPP stats type, used as element in internal double ds */
 typedef struct dpp_stats
 {
@@ -175,6 +186,7 @@ typedef struct dpp_stats
         dppline_bs_client_stats_t   bs_client;
         dppline_rssi_stats_t        rssi;
         dppline_network_probe_stats_t        network_probe;
+        dppline_events_stats_t       events;
     } u;
 } dppline_stats_t;
 
@@ -230,7 +242,13 @@ static void dppline_free_stat(dppline_st
                 break;
             case DPP_T_NETWORK_PROBE:
                 break;
-            default:;
+
+            case DPP_T_EVENTS:
+                free(s->u.events.list);
+                break;
+
+            default:
+                break;
         }
 
         free(s);
@@ -623,6 +641,40 @@ static bool dppline_copysts(dppline_stat
                 dst->u.network_probe.timestamp_ms = report_data->timestamp_ms;
            }
            break;
+
+        case DPP_T_EVENTS:
+           {
+                dpp_event_report_data_t *report_data = sts;
+                dpp_event_record_t      *result_entry = NULL;
+                ds_dlist_iter_t          result_iter;
+
+                /* Loop through linked list of results and copy them to dppline buffer */
+                dst->u.events.qty = 0;
+                dst->u.events.timestamp_ms = report_data->timestamp_ms;
+                for (   result_entry = ds_dlist_ifirst(&result_iter, &report_data->list);
+                        result_entry != NULL;
+                        result_entry = ds_dlist_inext(&result_iter))
+                {
+                    size = (dst->u.events.qty + 1) * sizeof(dpp_event_record_t);
+                    if (!dst->u.events.qty) {
+                        dst->u.events.list = calloc(1, size);
+                    }
+                    else {
+                        dst->u.events.list = realloc(dst->u.events.list, size);
+                        memset(&dst->u.events.list[dst->u.events.qty],
+                               0,
+                               sizeof(dpp_event_record_t));
+                    }
+                    memcpy(&dst->u.events.list[dst->u.events.qty],
+                            result_entry,
+                            sizeof(dpp_event_record_t));
+
+                    dst->u.events.qty++;
+
+                }
+           }
+           break;
+
         default:
             LOG(ERR, "Failed to copy %d stats", dst->type);
             /* do nothing */
@@ -653,6 +705,103 @@ static char * getNodeid()
     return buff;
 }
 
+Sts__AssocType dppline_to_proto_assoc_type(assoc_type_t assoc_type)
+{
+    switch (assoc_type)
+    {
+        case AT_ASSOC:
+            return STS__ASSOC_TYPE__ASSOC;
+
+        case AT_REASSOC:
+            return STS__ASSOC_TYPE__REASSOC;
+
+        default:
+            assert(0);
+    }
+    return 0;
+}
+
+Sts__DeviceType dppline_to_proto_device_type(device_type_t device_type)
+{
+    switch (device_type)
+    {
+        case DT_AP:
+            return STS__DEVICE_TYPE__DEV_AP;
+
+        case DT_STA:
+            return STS__DEVICE_TYPE__DEV_STA;
+
+        default:
+            assert(0);
+    }
+    return 0;
+}
+
+Sts__FrameType dppline_to_proto_frame_type(frame_type_t frame_type)
+{
+    switch (frame_type)
+    {
+        case FT_DEAUTH:
+            return STS__FRAME_TYPE__FT_DEAUTH;
+
+        case FT_DISASSOC:
+            return STS__FRAME_TYPE__FT_DISASSOC;
+
+        default:
+            assert(0);
+    }
+    return 0;
+}
+
+Sts__CTReasonType dppline_to_proto_ct_reason_type(ct_reason_t reason_type)
+{
+    switch (reason_type)
+    {
+        case CTR_IDLE_TOO_LONG:
+            return STS__CTREASON_TYPE__CTR_IDLE_TOO_LONG;
+
+        case CTR_PROBE_FAIL:
+            return STS__CTREASON_TYPE__CTR_PROBE_FAIL;
+
+        default:
+            assert(0);
+    }
+    return 0;
+}
+
+Sts__EventType dppline_to_proto_event_type(event_type_t event_type)
+{
+    switch (event_type)
+    {
+        case ET_CLIENT_ASSOC:
+            return STS__EVENT_TYPE__CLIENT_ASSOC;
+
+        case ET_CLIENT_AUTH:
+            return STS__EVENT_TYPE__CLIENT_AUTH;
+
+        case ET_CLIENT_DISCONNECT:
+            return STS__EVENT_TYPE__CLIENT_DISCONNECT;
+
+        case ET_CLIENT_FAILURE:
+            return STS__EVENT_TYPE__CLIENT_FAILURE;
+
+        case ET_CLIENT_FIRST_DATA:
+            return STS__EVENT_TYPE__CLIENT_FIRST_DATA;
+
+        case ET_CLIENT_ID:
+            return STS__EVENT_TYPE__CLIENT_ID;
+
+        case ET_CLIENT_IP:
+            return STS__EVENT_TYPE__CLIENT_IP;
+
+        case ET_CLIENT_TIMEOUT:
+            return STS__EVENT_TYPE__CLIENT_TIMEOUT;
+
+        default:
+            assert(0);
+    }
+    return 0;
+}
 
 Sts__RadioBandType dppline_to_proto_radio(radio_type_t radio_type)
 {
@@ -1238,6 +1387,60 @@ static void dppline_add_stat_client(Sts_
             sizeof(*s->u.device), s->size, size);*/
 }
 
+static void dppline_add_stat_events(Sts__Report *r, dppline_stats_t *s)
+{
+    Sts__EventReport *sr = NULL;
+    Sts__EventReport__ClientAssocEvent *dr_assoc = NULL;
+    /*
+    Sts__EventReport__ClientAuthEvent *dr_auth;
+    Sts__EventReport__ClientDisconnectEvent *dr_dscn;
+    Sts__EventReport__ClientFailureEvent *dr_fail;
+    Sts__EventReport__ClientFirstDataEvent *dr_fdata;
+    Sts__EventReport__ClientIdEvent *dr_id;
+    Sts__EventReport__ClientIpEvent *dr_ip;
+    Sts__EventReport__ClientTimeoutEvent *dr_tmt;
+    */
+    uint32_t i = 0;
+    //int j;
+    int size = 0;
+    dppline_events_stats_t *events = &s->u.events;
+
+    // increase the number of event_report
+    r->n_event_report++;
+
+    // allocate or extend the size of event_report
+    r->event_report = realloc(r->event_report,
+            r->n_event_report * sizeof(Sts__EventReport*));
+
+    // allocate new buffer
+    sr = malloc(sizeof(Sts__EventReport));
+    size += sizeof(Sts__EventReport);
+    assert(sr);
+    r->event_report[r->n_event_report - 1] = sr;
+    sts__event_report__init(sr);
+    //sr->timestamp_ms = events->timestamp_ms;
+
+    for (i = 0; i < events->qty; i++)
+    {
+        // dpp event pointer
+        dpp_event_record_t *rec = &events->list[i];
+
+        // ClientAssocEvent
+        if(rec->event_type == ET_CLIENT_ASSOC){
+            // init
+            sts__event_report__client_assoc_event__init(dr_assoc);
+            // STA mac
+            dr_assoc->sta_mac = malloc(MACADDR_STR_LEN);
+            dpp_mac_to_str(rec->client_assoc_event.sta_mac, dr_assoc->sta_mac);
+            // SSID
+            if(rec->client_assoc_event.ssid)
+                dr_assoc->ssid = strcpy(dr_assoc->ssid, rec->client_assoc_event.ssid);
+
+            // Band
+        }
+    }
+}
+
 static void dppline_add_stat_device(Sts__Report *r, dppline_stats_t *s)
 {
     Sts__Device *sr = NULL;
@@ -1942,6 +2145,10 @@ static void dppline_add_stat(Sts__Report
             dppline_add_stat_network_probe(r, s);
             break;
 
+        case DPP_T_EVENTS:
+            dppline_add_stat_events(r, s);
+            break;
+
         default:
             LOG(ERR, "Failed to add %d to stats report", s->type);
             /* do nothing       */
@@ -2106,6 +2313,14 @@ bool dpp_put_network_probe(dpp_network_p
 }
 
 /*
+ * Put event report to internal queue
+ */
+bool dpp_put_events(dpp_event_report_data_t *rpt)
+{
+    return dppline_put(DPP_T_EVENTS, rpt);
+}
+
+/*
  * Create the protobuf buff and copy it to given buffer
  */
 #ifndef DPP_FAST_PACK
Index: opensync-2.0.5.0/platform/openwrt/src/lib/target/inc/target_OPENWRT.h
===================================================================
--- opensync-2.0.5.0.orig/platform/openwrt/src/lib/target/inc/target_OPENWRT.h
+++ opensync-2.0.5.0/platform/openwrt/src/lib/target/inc/target_OPENWRT.h
@@ -25,10 +25,11 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 */
 
 #ifndef TARGET_OPENWRT_H_INCLUDED
-#define TARGET_OPEMWRT_H_INCLUDED
+#define TARGET_OPENWRT_H_INCLUDED
 
 #include "dpp_client.h"
 #include "dpp_survey.h"
+#include "dpp_events.h"
 
 #define TARGET_CERT_PATH            "/var/run/openvswitch/certs"
 #define TARGET_MANAGERS_PID_PATH    "/tmp/dmpid"
@@ -54,6 +55,12 @@ typedef struct
 	uint32_t duration_ms;
 } target_survey_record_t;
 
+typedef struct
+{
+        dpp_event_record_t record;
+
+} target_event_record_t;
+
 typedef void target_capacity_data_t;
 
 /******************************************************************************
Index: opensync-2.0.5.0/platform/openwrt/src/lib/target/src/stats.c
===================================================================
--- opensync-2.0.5.0.orig/platform/openwrt/src/lib/target/src/stats.c
+++ opensync-2.0.5.0/platform/openwrt/src/lib/target/src/stats.c
@@ -66,6 +66,43 @@ bool target_radio_fast_scan_enable(radio
 	return true;
 }
 
+/******************************************************************************
+ *  EVENT definitions
+ *****************************************************************************/
+target_event_record_t* target_event_record_alloc()
+{
+	target_event_record_t *record = NULL;
+
+	record = malloc(sizeof(target_event_record_t));
+	if (record == NULL)
+		return NULL;
+
+	memset(record, 0, sizeof(target_event_record_t));
+
+	return record;
+}
+
+void target_event_record_free(target_event_record_t *record)
+{
+	if (record != NULL)
+		free(record);
+}
+
+bool target_stats_events_get(radio_entry_t *radio_cfg,
+                             ds_dlist_t *record_list)
+{
+	struct nl_call_param nl_call_param = {
+		.ifname = radio_cfg->if_name,
+		.type = radio_cfg->type,
+                .list = record_list
+	};
+	bool ret = true;
+	if (nl80211_get_sta_assoc(&nl_call_param) < 0)
+		ret = false;
+
+        return ret;
+}
+
 
 /******************************************************************************
  *  CLIENT definitions
Index: opensync-2.0.5.0/platform/openwrt/src/lib/target/src/stats_nl80211.c
===================================================================
--- opensync-2.0.5.0.orig/platform/openwrt/src/lib/target/src/stats_nl80211.c
+++ opensync-2.0.5.0/platform/openwrt/src/lib/target/src/stats_nl80211.c
@@ -67,6 +67,44 @@ static int nl80211_chainmask_recv(struct
 	return NL_OK;
 }
 
+static int nl80211_cmd_assoc_recv(struct nl_msg *msg, void *arg)
+{
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nl_call_param *nl_call_param = (struct nl_call_param *)arg;
+	struct nlattr *cinfo[NL80211_CMD_MAX + 1];
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+        target_event_record_t *event_entry;
+
+	memset(tb, 0, sizeof(tb));
+	memset(cinfo, 0, sizeof(cinfo));
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (!tb[NL80211_ATTR_MAC] || !tb[NL80211_ATTR_SSID]){
+	        LOG(ERROR, "%s: invalid assoc entry", nl_call_param->ifname);
+		return NL_OK;
+        }
+
+        event_entry = target_event_record_alloc();
+        event_entry->record.event_type = ET_CLIENT_ASSOC;
+        // client_assoc_event pointer
+        dpp_event_record_assoc_t *cap = &event_entry->record.client_assoc_event;
+        memset(cap, 0, sizeof(dpp_event_record_assoc_t));
+        // set data
+        memcpy(cap->sta_mac, nla_data(tb[NL80211_ATTR_MAC]), ETH_ALEN);
+	memcpy(cap->ssid,
+               nla_data(tb[NL80211_ATTR_SSID]),
+               nla_len(tb[NL80211_ATTR_SSID]));
+        cap->assoc_type = AT_ASSOC;
+
+	ds_dlist_insert_tail(nl_call_param->list, event_entry);
+
+        LOG(INFO, "nl80211_cmd_assoc_recv STA_ASSOC!!");
+        return NL_OK;
+
+}
+
 static int nl80211_assoclist_recv(struct nl_msg *msg, void *arg)
 {
 	static struct nla_policy stats_policy[NL80211_STA_INFO_MAX + 1] = {
@@ -436,6 +474,9 @@ static struct nl_msg *nl80211_call_vif(s
 
 	if (!nl80211_scan_started) {
 		unl_genl_subscribe(&unl, "scan");
+		unl_genl_subscribe(&unl, "mlme");
+		unl_genl_subscribe(&unl, "vendor");
+		unl_genl_subscribe(&unl, "config");
 
 		ev_io_init(&unl_io, nl80211_ev, unl.sock->s_fd, EV_READ);
 		ev_io_start(wifihal_evloop, &unl_io);
@@ -529,6 +570,16 @@ int nl80211_scan_dump(struct nl_call_par
 	return unl_genl_request(&unl, msg, nl80211_scan_dump_recv, nl_call_param);
 }
 
+int nl80211_get_sta_assoc(struct nl_call_param *nl_call_param)
+{
+	struct nl_msg *msg = nl80211_call_vif(nl_call_param, NL80211_CMD_ASSOCIATE, true);
+
+	if (!msg)
+		return -1;
+
+	return unl_genl_request(&unl, msg, nl80211_cmd_assoc_recv, nl_call_param);
+}
+
 int stats_nl80211_init(void)
 {
 	if (unl_genl_init(&unl, "nl80211") < 0) {
Index: opensync-2.0.5.0/src/lib/datapipeline/inc/dppline.h
===================================================================
--- opensync-2.0.5.0.orig/src/lib/datapipeline/inc/dppline.h
+++ opensync-2.0.5.0/src/lib/datapipeline/inc/dppline.h
@@ -46,6 +46,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #include "dpp_bs_client.h"
 #include "dpp_rssi.h"
 #include "dpp_network_probe.h"
+#include "dpp_events.h"
 
 #ifdef CONFIG_MANAGER_QM
 // QM does queue-ing of reports when offline on it's own, so dpp needs
@@ -107,6 +108,11 @@ bool dpp_put_bs_client(dpp_bs_client_rep
 bool dpp_put_rssi(dpp_rssi_report_data_t *rpt);
 
 /*
+ * Put event report to internal queue
+ */
+bool dpp_put_events(dpp_event_report_data_t *rpt);
+
+/*
  * Get the protobuf packed buffer
  *
  * This buffer is ready to be send using MQTT
Index: opensync-2.0.5.0/src/sm/src/sm_ovsdb.c
===================================================================
--- opensync-2.0.5.0.orig/src/sm/src/sm_ovsdb.c
+++ opensync-2.0.5.0/src/sm/src/sm_ovsdb.c
@@ -62,6 +62,7 @@ char *sm_report_type_str[STS_REPORT_MAX]
     "device",
     "rssi",
     "network_probe",
+    "event",
 };
 
 #ifndef CONFIG_MANAGER_QM
@@ -359,8 +360,11 @@ bool sm_update_stats_config(sm_stats_con
             sm_rssi_report_request(&radio->config, &req);
             break;
 	case STS_REPORT_NETWORK_PROBE:
-	sm_network_probe_report_request(&req);
-	break;
+	    sm_network_probe_report_request(&req);
+	    break;
+        case STS_REPORT_EVENT:
+            sm_events_report_request(&radio->config, &req);
+            break;
         default:
             return false;
     }
Index: opensync-2.0.5.0/src/lib/target/inc/target_native.h
===================================================================
--- opensync-2.0.5.0.orig/src/lib/target/inc/target_native.h
+++ opensync-2.0.5.0/src/lib/target/inc/target_native.h
@@ -39,6 +39,8 @@ typedef void target_survey_record_t;
 
 typedef void target_capacity_data_t;
 
+typedef void target_event_record_t;
+
 #include "target_common.h"
 
 #endif  /* TARGET_NATIVE_H_INCLUDED */
Index: opensync-2.0.5.0/vendor/tip/src/lib/target/inc/target_tip.h
===================================================================
--- opensync-2.0.5.0.orig/vendor/tip/src/lib/target/inc/target_tip.h
+++ opensync-2.0.5.0/vendor/tip/src/lib/target/inc/target_tip.h
@@ -29,6 +29,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 
 #include "dpp_client.h"
 #include "dpp_survey.h"
+#include "dpp_events.h"
 
 #define TARGET_CERT_PATH            "/var/run/openvswitch/certs"
 #define TARGET_MANAGERS_PID_PATH    "/tmp/dmpid"
@@ -54,6 +55,12 @@ typedef struct
 	uint32_t duration_ms;
 } target_survey_record_t;
 
+typedef struct
+{
+        dpp_event_record_t record;
+
+} target_event_record_t;
+
 typedef void target_capacity_data_t;
 
 /******************************************************************************
Index: opensync-2.0.5.0/src/lib/target/inc/target_common.h
===================================================================
--- opensync-2.0.5.0.orig/src/lib/target/inc/target_common.h
+++ opensync-2.0.5.0/src/lib/target/inc/target_common.h
@@ -389,6 +389,13 @@ typedef bool target_stats_clients_cb_t (
         void                       *ctx,
         int                         status);
 
+/******************************************************************************
+ *  EVENT definitions
+ *****************************************************************************/
+target_event_record_t *target_event_record_alloc();
+bool target_stats_events_get(radio_entry_t *radio_cfg,
+                             ds_dlist_t *record_list);
+
 /**
  * @brief Get clients stats
  *
Index: opensync-2.0.5.0/src/sm/src/sm.h
===================================================================
--- opensync-2.0.5.0.orig/src/sm/src/sm.h
+++ opensync-2.0.5.0/src/sm/src/sm.h
@@ -161,6 +161,13 @@ bool sm_network_probe_report_request(
         sm_stats_request_t         *request);
 
 /******************************************************************************
+ *  EVENTS REPORT definitions
+ *****************************************************************************/
+bool sm_events_report_request(
+        radio_entry_t              *radio_cfg,
+        sm_stats_request_t         *request);
+
+/******************************************************************************
  *  SURVEY_REPORT definitions
  *****************************************************************************/
 bool sm_survey_report_request(
@@ -271,6 +278,7 @@ typedef enum
     STS_REPORT_DEVICE,
     STS_REPORT_RSSI,
     STS_REPORT_NETWORK_PROBE,
+    STS_REPORT_EVENT,
     STS_REPORT_MAX,
     STS_REPORT_ERROR = STS_REPORT_MAX
 } sm_report_type_t;
Index: opensync-2.0.5.0/src/sm/src/sm_events_report.c
===================================================================
--- /dev/null
+++ opensync-2.0.5.0/src/sm/src/sm_events_report.c
@@ -0,0 +1,453 @@
+/*
+Copyright (c) 2015, Plume Design Inc. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+   3. Neither the name of the Plume Design Inc. nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL Plume Design Inc. BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#define _GNU_SOURCE
+#include <sys/socket.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <net/if.h>
+
+#include <sys/types.h>
+
+#include <linux/sockios.h>
+#include <linux/nl80211.h>
+
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+#include <netlink/socket.h>
+#include <netlink/genl/ctrl.h>
+#include <netlink/genl/genl.h>
+
+#include <ev.h>
+
+#include <syslog.h>
+#include <libubox/avl-cmp.h>
+
+#include <libubox/avl.h>
+#include <libubox/vlist.h>
+#include <unl.h>
+
+#include "sm.h"
+#include "target.h"
+#include "nl80211.h"
+#include "utils.h"
+#include "radio.h"
+
+
+#define MODULE_ID LOG_MODULE_ID_MAIN
+
+/* new part */
+typedef struct
+{
+    bool                            initialized;
+
+    /* Internal structure used to lower layer radio selection */
+    radio_entry_t                  *radio_cfg;
+
+    /* Internal structure used to lower layer radio selection */
+    ev_timer                        report_timer;
+
+    /* Structure containing cloud request timer params */
+    sm_stats_request_t              request;
+
+    /* Structure pointing to upper layer events storage */
+    dpp_event_report_data_t         report;
+
+    /* event list (only one for now) */
+    ds_dlist_t                      record_list;
+
+    /* Reporting start timestamp used for reporting timestamp calculation */
+    uint64_t                        report_ts;
+} sm_events_ctx_t;
+
+/* Common place holder for all events stat report contexts */
+static sm_events_ctx_t              g_sm_events_ctx;
+
+/* netlink related */
+static struct ev_loop *sm_ev_loop;
+static struct unl unl;
+static ev_io unl_io;
+
+
+/******************************************************************************
+ *  PROTECTED definitions
+ *****************************************************************************/
+static
+bool dpp_events_report_timer_set(ev_timer *timer, bool enable)
+{
+    if (enable) {
+        ev_timer_again(EV_DEFAULT, timer);
+    }
+    else {
+        ev_timer_stop(EV_DEFAULT, timer);
+    }
+
+    return true;
+}
+
+static
+bool dpp_events_report_timer_restart(ev_timer *timer)
+{
+    sm_events_ctx_t  *events_ctx = (sm_events_ctx_t *)timer->data;
+    sm_stats_request_t *request_ctx = &events_ctx->request;
+
+    if (request_ctx->reporting_count) {
+        request_ctx->reporting_count--;
+
+        LOG(DEBUG,
+            "Updated events reporting count=%d",
+            request_ctx->reporting_count);
+
+        /* If reporting_count becomes zero, then stop reporting */
+        if (0 == request_ctx->reporting_count) {
+            dpp_events_report_timer_set(timer, false);
+
+            LOG(DEBUG,
+                "Stopped events reporting (count expired)");
+            return true;
+        }
+    }
+
+    return true;
+}
+
+static
+void sm_events_report (EV_P_ ev_timer *w, int revents)
+{
+    //bool rc;
+
+    sm_events_ctx_t         *events_ctx = (sm_events_ctx_t *)w->data;
+    dpp_event_report_data_t *report_ctx = &events_ctx->report;
+    sm_stats_request_t      *request_ctx = &events_ctx->request;
+    ev_timer                *report_timer = &events_ctx->report_timer;
+    dpp_event_record_t      *dpp_record = NULL;
+    target_event_record_t   *target_record = NULL;
+    ds_dlist_iter_t         record_iter;
+
+    dpp_events_report_timer_restart(report_timer);
+
+    /* Get events stats */
+    //rc = target_stats_events_get(events_ctx->radio_cfg,
+    //                             &events_ctx->record_list);
+    //if (true != rc) {
+    //    return;
+    //}
+
+    /* get cached eventes */
+    for (target_record = ds_dlist_ifirst(&record_iter, &g_sm_events_ctx.record_list);
+         target_record != NULL;
+         target_record = ds_dlist_inext(&record_iter))
+    {
+        dpp_record = malloc(sizeof(dpp_event_record_t));
+        // copy
+        memcpy(dpp_record, &target_record->record, sizeof(dpp_event_record_t));
+	ds_dlist_insert_tail(&report_ctx->list, dpp_record);
+
+        // clear
+        ds_dlist_iremove(&record_iter);
+        free(target_record);
+    }
+
+    /* Report_timestamp is base-timestamp + relative start time offset */
+    report_ctx->timestamp_ms = request_ctx->reporting_timestamp -
+                               events_ctx->report_ts + get_timestamp();
+
+    LOG(INFO, "Sending events report...");
+    if(!ds_dlist_is_empty(&report_ctx->list)){
+        dpp_put_events(report_ctx);
+    }
+
+}
+
+static int ev_assoc_add(struct nl_msg *msg)
+{
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *cinfo[NL80211_CMD_MAX + 1];
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+        target_event_record_t *event_entry;
+
+	memset(tb, 0, sizeof(tb));
+	memset(cinfo, 0, sizeof(cinfo));
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (!tb[NL80211_ATTR_MAC] || !tb[NL80211_ATTR_SSID]) return NL_OK;
+
+        event_entry = target_event_record_alloc();
+        event_entry->record.event_type = ET_CLIENT_ASSOC;
+        // client_assoc_event pointer
+        dpp_event_record_assoc_t *cap = &event_entry->record.client_assoc_event;
+        memset(cap, 0, sizeof(dpp_event_record_assoc_t));
+        // set data
+        memcpy(cap->sta_mac, nla_data(tb[NL80211_ATTR_MAC]), ETH_ALEN);
+	memcpy(cap->ssid,
+               nla_data(tb[NL80211_ATTR_SSID]),
+               nla_len(tb[NL80211_ATTR_SSID]));
+        cap->assoc_type = AT_ASSOC;
+        // add to cached list
+	ds_dlist_insert_tail(&g_sm_events_ctx.record_list, event_entry);
+
+        return NL_OK;
+
+}
+
+static int ev_disconnect_add(struct nl_msg *msg)
+{
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *cinfo[NL80211_CMD_MAX + 1];
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+        target_event_record_t *event_entry;
+
+	memset(tb, 0, sizeof(tb));
+	memset(cinfo, 0, sizeof(cinfo));
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (!tb[NL80211_ATTR_MAC] || !tb[NL80211_ATTR_SSID]) return NL_OK;
+
+        event_entry = target_event_record_alloc();
+        event_entry->record.event_type = ET_CLIENT_DISCONNECT;
+        // client_disconnect_event pointer
+        dpp_event_record_disconnect_t *cap = &event_entry->record.client_disconnect_event;
+        memset(cap, 0, sizeof(dpp_event_record_disconnect_t));
+        // set data
+        memcpy(cap->sta_mac, nla_data(tb[NL80211_ATTR_MAC]), ETH_ALEN);
+	memcpy(cap->ssid,
+               nla_data(tb[NL80211_ATTR_SSID]),
+               nla_len(tb[NL80211_ATTR_SSID]));
+        // add to cached list
+	ds_dlist_insert_tail(&g_sm_events_ctx.record_list, event_entry);
+
+        return NL_OK;
+
+}
+
+static int ev_auth_add(struct nl_msg *msg)
+{
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *cinfo[NL80211_CMD_MAX + 1];
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+        target_event_record_t *event_entry;
+
+	memset(tb, 0, sizeof(tb));
+	memset(cinfo, 0, sizeof(cinfo));
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (!tb[NL80211_ATTR_MAC] || !tb[NL80211_ATTR_SSID]) return NL_OK;
+
+        event_entry = target_event_record_alloc();
+        event_entry->record.event_type = ET_CLIENT_AUTH;
+        // client_auth event pointer
+        dpp_event_record_auth_t *cap = &event_entry->record.client_auth_event;
+        memset(cap, 0, sizeof(dpp_event_record_auth_t));
+        // set data
+        memcpy(cap->sta_mac, nla_data(tb[NL80211_ATTR_MAC]), ETH_ALEN);
+	memcpy(cap->ssid,
+               nla_data(tb[NL80211_ATTR_SSID]),
+               nla_len(tb[NL80211_ATTR_SSID]));
+        // add to cached list
+	ds_dlist_insert_tail(&g_sm_events_ctx.record_list, event_entry);
+
+        return NL_OK;
+
+}
+
+
+
+static int nl80211_recv(struct nl_msg *msg, void *arg)
+{
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	memset(tb, 0, sizeof(tb));
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	switch (gnlh->cmd) {
+        // ASSOCIATE
+        case NL80211_CMD_ASSOCIATE:
+        case NL80211_CMD_CONNECT:
+        case NL80211_CMD_ROAM:
+                LOG(INFO, "Event: NL80211_CMD_ASSOCIATE");
+                ev_assoc_add(msg);
+		break;
+
+        // DISCONNECT
+	case NL80211_CMD_DISCONNECT:
+                LOG(INFO, "Event: NL80211_CMD_DISCONNECT");
+                ev_disconnect_add(msg);
+		break;
+
+        // AUTHENTICATE
+        case NL80211_CMD_AUTHENTICATE:
+                LOG(INFO, "Event: NL80211_CMD_AUTHENTICATE");
+                ev_auth_add(msg);
+                break;
+
+	default:
+		break;
+	}
+
+	return NL_OK;
+}
+
+static int finish_handler(struct nl_msg *msg, void *arg)
+{
+	return NL_SKIP;
+}
+
+static int error_handler(struct sockaddr_nl *nla, struct nlmsgerr *err, void *arg)
+{
+	return NL_SKIP;
+}
+
+static int no_seq_check(struct nl_msg *msg, void *arg)
+{
+	return NL_OK;
+}
+
+static void nl80211_ev(struct ev_loop *ev, struct ev_io *io, int event)
+{
+	struct nl_cb *cb;
+
+	cb = nl_cb_alloc(NL_CB_CUSTOM);
+	nl_cb_err(cb, NL_CB_CUSTOM, error_handler, NULL);
+	nl_cb_set(cb, NL_CB_FINISH, NL_CB_CUSTOM, finish_handler, NULL);
+	nl_cb_set(cb, NL_CB_SEQ_CHECK, NL_CB_CUSTOM, no_seq_check, NULL);
+	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, nl80211_recv, NULL);
+	nl_recvmsgs(unl.sock, cb);
+	nl_cb_put(cb);
+}
+
+
+static int sm_events_nl80211_init(void)
+{
+        sm_ev_loop = EV_DEFAULT;
+	struct nl_msg *msg;
+
+	if (unl_genl_init(&unl, "nl80211") < 0) {
+		syslog(0, "sm_events nl80211: failed to connect\n");
+		return -1;
+	}
+
+	msg = unl_genl_msg(&unl, NL80211_CMD_GET_WIPHY, true);
+	unl_genl_request(&unl, msg, nl80211_recv, NULL);
+	msg = unl_genl_msg(&unl, NL80211_CMD_GET_INTERFACE, true);
+	unl_genl_request(&unl, msg, nl80211_recv, NULL);
+
+	unl_genl_subscribe(&unl, "config");
+	unl_genl_subscribe(&unl, "mlme");
+	unl_genl_subscribe(&unl, "vendor");
+
+	ev_io_init(&unl_io, nl80211_ev, unl.sock->s_fd, EV_READ);
+        ev_io_start(sm_ev_loop, &unl_io);
+
+	return 0;
+}
+
+/******************************************************************************
+ *  PUBLIC API definitions
+ *****************************************************************************/
+bool sm_events_report_request(radio_entry_t *radio_cfg,
+                              sm_stats_request_t *request) {
+
+    sm_events_ctx_t *events_ctx = &g_sm_events_ctx;
+    sm_stats_request_t *request_ctx = &events_ctx->request;
+    dpp_event_report_data_t *report_ctx = &events_ctx->report;
+    ev_timer *report_timer = &events_ctx->report_timer;
+
+    // save radio cfg
+    events_ctx->radio_cfg = radio_cfg;
+
+    if (NULL == request) {
+        LOG(ERR,
+            "Initializing events reporting "
+            "(Invalid request config)");
+        return false;
+    }
+
+    /* Initialize global stats only once */
+    if (!events_ctx->initialized) {
+        memset(request_ctx, 0, sizeof(*request_ctx));
+        memset(report_ctx, 0, sizeof(*report_ctx));
+
+        LOG(INFO, "Initializing events reporting");
+
+        sm_events_nl80211_init();
+
+        /* Initialize report list */
+        ds_dlist_init(
+                &report_ctx->list,
+                dpp_event_record_t,
+                node);
+
+        /* Initialize event list */
+        ds_dlist_init(
+                &events_ctx->record_list,
+                dpp_event_record_t,
+                node);
+
+
+        /* Initialize event lib timers and pass the global
+           internal cache
+         */
+        ev_init(report_timer, sm_events_report);
+        report_timer->data = events_ctx;
+
+        events_ctx->initialized = true;
+    }
+
+    /* Store and compare every request parameter ...
+       memcpy would be easier but we want some debug info
+     */
+    REQUEST_VAL_UPDATE("event", reporting_count, "%d");
+    REQUEST_VAL_UPDATE("event", reporting_interval, "%d");
+    REQUEST_VAL_UPDATE("event", reporting_timestamp, "%" PRIu64 "");
+
+    /* Restart timers with new parameters */
+    dpp_events_report_timer_set(report_timer, false);
+
+    if (request_ctx->reporting_interval) {
+        events_ctx->report_ts = get_timestamp();
+        report_timer->repeat = request_ctx->reporting_interval;
+        dpp_events_report_timer_set(report_timer, true);
+
+        LOG(INFO, "Started events reporting");
+    } else {
+        LOG(INFO, "Stopped events reporting");
+        memset(request_ctx, 0, sizeof(*request_ctx));
+    }
+
+    return true;
+}
Index: opensync-2.0.5.0/src/sm/unit.mk
===================================================================
--- opensync-2.0.5.0.orig/src/sm/unit.mk
+++ opensync-2.0.5.0/src/sm/unit.mk
@@ -44,6 +44,7 @@ UNIT_SRC     += src/sm_radio_config.c
 UNIT_SRC     += src/sm_scan_schedule.c
 UNIT_SRC     += src/sm_rssi_report.c
 UNIT_SRC     += src/sm_network_probe_report.c
+UNIT_SRC     += src/sm_events_report.c
 UNIT_SRC     += src/sm_common.c
 
 ifeq ($(CONFIG_SM_CAPACITY_QUEUE_STATS),y)
Index: opensync-2.0.5.0/platform/openwrt/src/lib/target/inc/nl80211.h
===================================================================
--- opensync-2.0.5.0.orig/platform/openwrt/src/lib/target/inc/nl80211.h
+++ opensync-2.0.5.0/platform/openwrt/src/lib/target/inc/nl80211.h
@@ -69,6 +69,7 @@ struct nl_call_param {
 extern int stats_nl80211_init(void);
 extern int nl80211_get_tx_chainmask(char *name, unsigned int *mask);
 extern int nl80211_get_assoclist(struct nl_call_param *nl_call_param);
+extern int nl80211_get_sta_assoc(struct nl_call_param *nl_call_param);
 extern int nl80211_get_survey(struct nl_call_param *nl_call_param);
 extern int nl80211_scan_trigger(struct nl_call_param *nl_call_param, uint32_t *chan_list, uint32_t chan_num,
 				int dwell_time, radio_scan_type_t scan_type,
