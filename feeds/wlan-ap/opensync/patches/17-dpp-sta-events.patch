Index: opensync-2.0.5.0/src/lib/datapipeline/inc/dpp_events.h
===================================================================
--- /dev/null
+++ opensync-2.0.5.0/src/lib/datapipeline/inc/dpp_events.h
@@ -0,0 +1,363 @@
+#ifndef DPP_EVENTS_H_INCLUDED
+#define DPP_EVENTS_H_INCLUDED
+
+#include "ds.h"
+#include "ds_dlist.h"
+
+#include "dpp_types.h"
+
+// string limits
+#define DPP_REASON_STR_LEN  129
+#define DPP_CLT_ID_LEN      129
+
+// proto: EventType
+typedef enum
+{
+    ET_CLIENT_ASSOC = 0,
+    ET_CLIENT_AUTH,
+    ET_CLIENT_DISCONNECT,
+    ET_CLIENT_FAILURE,
+    ET_CLIENT_FIRST_DATA,
+    ET_CLIENT_ID,
+    ET_CLIENT_IP,
+    ET_CLIENT_TIMEOUT
+} event_type_t;
+
+// proto: AssocType
+typedef enum
+{
+    AT_ASSOC = 0,
+    AT_REASSOC
+} assoc_type_t;
+
+// proto: DeviceType
+typedef enum
+{
+    DT_AP = 0,
+    DT_STA
+} device_type_t;
+
+// proto: FrameType
+typedef enum
+{
+    FT_DEAUTH = 0,
+    FT_DISASSOC
+} frame_type_t;
+
+// proto: CTReasonType
+typedef enum
+{
+    CTR_IDLE_TOO_LONG = 0,
+    CTR_PROBE_FAIL
+} ct_reason_t;
+
+// proto: ClientAssocEvent
+typedef struct
+{
+    mac_address_t    sta_mac;
+    uint64_t         session_id;
+    radio_essid_t    ssid;
+    radio_type_t     band;
+    assoc_type_t     assoc_type;
+    uint32_t         status;
+    int32_t          rssi;
+    uint32_t         internal_sc;
+    bool             using11k;
+    bool             using11r;
+    bool             using11v;
+} dpp_event_record_assoc_t;
+
+// proto: ClientAuthEvent
+typedef struct
+{
+    mac_address_t    sta_mac;
+    uint64_t         session_id;
+    radio_essid_t    ssid;
+    radio_type_t     band;
+    uint32_t         auth_status;
+} dpp_event_record_auth_t;
+
+// proto: ClientDisconnectEvent
+typedef struct
+{
+    mac_address_t    sta_mac;
+    uint64_t         session_id;
+    uint32_t         reason;
+    device_type_t    dev_type;
+    frame_type_t     fr_type;
+    uint64_t         last_sent_up_ts_in_us;
+    uint64_t         last_recv_up_ts_in_us;
+    uint32_t         internal_rc;
+    int32_t          rssi;
+    radio_essid_t    ssid;
+    radio_type_t     band;
+} dpp_event_record_disconnect_t;
+
+// proto: ClientFailureEvent
+typedef struct
+{
+    mac_address_t    sta_mac;
+    uint64_t         session_id;
+    radio_essid_t    ssid;
+    int32_t          reason;
+    char             reason_str[DPP_REASON_STR_LEN];
+} dpp_event_record_failure_t;
+
+// proto: ClientFirstDataEvent
+typedef struct
+{
+    mac_address_t    sta_mac;
+    uint64_t         session_id;
+    uint64_t         first_data_tx_up_ts_in_us;
+    uint64_t         first_data_rx_up_ts_in_us;
+} dpp_event_record_first_data_t;
+
+// proto: ClientIdEvent
+typedef struct
+{
+    mac_address_t    clt_mac;
+    uint64_t         session_id;
+    char             clt_id[DPP_CLT_ID_LEN];
+} dpp_event_record_id_t;
+
+// proto: ClientIpEvent
+typedef struct
+{
+    mac_address_t    sta_mac;
+    uint64_t         session_id;
+    char             ip_addr[16];
+} dpp_event_record_ip_t;
+
+// proto: ClientTimeoutEvent
+typedef struct
+{
+    mac_address_t    sta_mac;
+    uint64_t         session_id;
+    ct_reason_t      r_code;
+    uint64_t         last_sent_up_ts_in_us;
+    uint64_t         last_recv_up_ts_in_us;
+
+} dpp_event_record_timeout_t;
+
+// event record
+typedef struct
+{
+    event_type_t                    event_type;
+    dpp_event_record_assoc_t        client_assoc_event;
+    dpp_event_record_auth_t         client_auth_event;
+    dpp_event_record_disconnect_t   client_disconnect_event;
+    dpp_event_record_failure_t      client_failure_event;
+    dpp_event_record_first_data_t   client_first_data_event;
+    dpp_event_record_id_t           client_id_event;
+    dpp_event_record_ip_t           client_ip_event;
+    dpp_event_record_timeout_t      client_timeout_event;
+} dpp_event_record_t;
+
+/*******************************/
+/* ClientAssocEvent alloc/free */
+/*******************************/
+// alloc
+static inline dpp_event_record_assoc_t * dpp_event_client_assoc_record_alloc()
+{
+    dpp_event_record_assoc_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_assoc_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_assoc_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_assoc_record_free(dpp_event_record_assoc_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+/******************************/
+/* ClientAuthEvent alloc/free */
+/******************************/
+// alloc
+static inline dpp_event_record_auth_t * dpp_event_client_auth_record_alloc()
+{
+    dpp_event_record_auth_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_auth_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_auth_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_auth_record_free(dpp_event_record_auth_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+/************************************/
+/* ClientDisconnectEvent alloc/free */
+/************************************/
+// alloc
+static inline dpp_event_record_disconnect_t * dpp_event_client_disconnect_record_alloc()
+{
+    dpp_event_record_disconnect_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_disconnect_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_disconnect_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_disconnect_record_free(dpp_event_record_disconnect_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+/*********************************/
+/* ClientFailureEvent alloc/free */
+/*********************************/
+// alloc
+static inline dpp_event_record_failure_t * dpp_event_client_failure_record_alloc()
+{
+    dpp_event_record_failure_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_failure_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_failure_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_failure_record_free(dpp_event_record_failure_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+/***********************************/
+/* ClientFirstDataEvent alloc/free */
+/***********************************/
+// alloc
+static inline dpp_event_record_first_data_t * dpp_event_client_first_data_record_alloc()
+{
+    dpp_event_record_first_data_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_first_data_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_first_data_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_first_data_record_free(dpp_event_record_first_data_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+/****************************/
+/* ClientIdEvent alloc/free */
+/****************************/
+// alloc
+static inline dpp_event_record_id_t * dpp_event_client_id_record_alloc()
+{
+    dpp_event_record_id_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_id_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_id_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_id_record_free(dpp_event_record_id_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+/****************************/
+/* ClientIpEvent alloc/free */
+/****************************/
+// alloc
+static inline dpp_event_record_ip_t * dpp_event_client_ip_record_alloc()
+{
+    dpp_event_record_ip_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_ip_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_ip_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_ip_record_free(dpp_event_record_ip_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+/*********************************/
+/* ClientTimeoutEvent alloc/free */
+/*********************************/
+// alloc
+static inline dpp_event_record_timeout_t * dpp_event_client_timeout_record_alloc()
+{
+    dpp_event_record_timeout_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_timeout_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_timeout_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_timeout_record_free(dpp_event_record_timeout_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+// Events report type
+typedef struct
+{
+    uint64_t        timestamp_ms;
+    ds_dlist_t      list; // dpp_event_record_t
+} dpp_event_report_data_t;
+
+#endif /* DPP_EVENTS_H_INCLUDED */
Index: opensync-2.0.5.0/src/lib/datapipeline/src/dppline.c
===================================================================
--- opensync-2.0.5.0.orig/src/lib/datapipeline/src/dppline.c
+++ opensync-2.0.5.0/src/lib/datapipeline/src/dppline.c
@@ -43,6 +43,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #include "dpp_device.h"
 #include "dpp_capacity.h"
 #include "dpp_bs_client.h"
+#include "dpp_events.h"
 
 #ifndef TARGET_NATIVE
 #include "os_types.h"
@@ -64,6 +65,7 @@ typedef enum
     DPP_T_BS_CLIENT = 6,
     DPP_T_RSSI      = 7,
     DPP_T_NETWORK_PROBE =8,
+    DPP_T_EVENTS    = 9
 } DPP_STS_TYPE;
 
 uint32_t queue_depth;
@@ -96,6 +98,13 @@ typedef struct dpp_network_probe_stats
     uint64_t                        timestamp_ms;
 } dppline_network_probe_stats_t;
 
+typedef struct dpp_events_stats
+{
+    dpp_event_record_t             *list;
+    uint32_t                        qty;
+    uint64_t                        timestamp_ms;
+} dppline_events_stats_t;
+
 typedef struct
 {
     radio_type_t                    radio_type;
@@ -159,6 +168,8 @@ typedef struct dpp_rssi_stats
     uint64_t                        timestamp_ms;
 } dppline_rssi_stats_t;
 
+
+
 /* DPP stats type, used as element in internal double ds */
 typedef struct dpp_stats
 {
@@ -175,6 +186,7 @@ typedef struct dpp_stats
         dppline_bs_client_stats_t   bs_client;
         dppline_rssi_stats_t        rssi;
         dppline_network_probe_stats_t        network_probe;
+        dppline_events_stats_t       events;
     } u;
 } dppline_stats_t;
 
@@ -653,6 +665,103 @@ static char * getNodeid()
     return buff;
 }
 
+Sts__AssocType dppline_to_proto_assoc_type(assoc_type_t assoc_type)
+{
+    switch (assoc_type)
+    {
+        case AT_ASSOC:
+            return STS__ASSOC_TYPE__ASSOC;
+
+        case AT_REASSOC:
+            return STS__ASSOC_TYPE__REASSOC;
+
+        default:
+            assert(0);
+    }
+    return 0;
+}
+
+Sts__DeviceType dppline_to_proto_device_type(device_type_t device_type)
+{
+    switch (device_type)
+    {
+        case DT_AP:
+            return STS__DEVICE_TYPE__DEV_AP;
+
+        case DT_STA:
+            return STS__DEVICE_TYPE__DEV_STA;
+
+        default:
+            assert(0);
+    }
+    return 0;
+}
+
+Sts__FrameType dppline_to_proto_frame_type(frame_type_t frame_type)
+{
+    switch (frame_type)
+    {
+        case FT_DEAUTH:
+            return STS__FRAME_TYPE__FT_DEAUTH;
+
+        case FT_DISASSOC:
+            return STS__FRAME_TYPE__FT_DISASSOC;
+
+        default:
+            assert(0);
+    }
+    return 0;
+}
+
+Sts__CTReasonType dppline_to_proto_ct_reason_type(ct_reason_t reason_type)
+{
+    switch (reason_type)
+    {
+        case CTR_IDLE_TOO_LONG:
+            return STS__CTREASON_TYPE__CTR_IDLE_TOO_LONG;
+
+        case CTR_PROBE_FAIL:
+            return STS__CTREASON_TYPE__CTR_PROBE_FAIL;
+
+        default:
+            assert(0);
+    }
+    return 0;
+}
+
+Sts__EventType dppline_to_proto_event_type(event_type_t event_type)
+{
+    switch (event_type)
+    {
+        case ET_CLIENT_ASSOC:
+            return STS__EVENT_TYPE__CLIENT_ASSOC;
+
+        case ET_CLIENT_AUTH:
+            return STS__EVENT_TYPE__CLIENT_AUTH;
+
+        case ET_CLIENT_DISCONNECT:
+            return STS__EVENT_TYPE__CLIENT_DISCONNECT;
+
+        case ET_CLIENT_FAILURE:
+            return STS__EVENT_TYPE__CLIENT_FAILURE;
+
+        case ET_CLIENT_FIRST_DATA:
+            return STS__EVENT_TYPE__CLIENT_FIRST_DATA;
+
+        case ET_CLIENT_ID:
+            return STS__EVENT_TYPE__CLIENT_ID;
+
+        case ET_CLIENT_IP:
+            return STS__EVENT_TYPE__CLIENT_IP;
+
+        case ET_CLIENT_TIMEOUT:
+            return STS__EVENT_TYPE__CLIENT_TIMEOUT;
+
+        default:
+            assert(0);
+    }
+    return 0;
+}
 
 Sts__RadioBandType dppline_to_proto_radio(radio_type_t radio_type)
 {
@@ -1238,6 +1347,13 @@ static void dppline_add_stat_client(Sts_
             sizeof(*s->u.device), s->size, size);*/
 }
 
+/*
+static void dppline_add_stat_events(Sts__Report *r, dppline_stats_t *s)
+{
+    // stub
+}
+*/
+
 static void dppline_add_stat_device(Sts__Report *r, dppline_stats_t *s)
 {
     Sts__Device *sr = NULL;
