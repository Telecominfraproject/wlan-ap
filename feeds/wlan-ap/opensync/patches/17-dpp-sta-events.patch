Index: opensync-2.0.5.0/src/lib/datapipeline/inc/dpp_events.h
===================================================================
--- /dev/null
+++ opensync-2.0.5.0/src/lib/datapipeline/inc/dpp_events.h
@@ -0,0 +1,364 @@
+#ifndef DPP_EVENTS_H_INCLUDED
+#define DPP_EVENTS_H_INCLUDED
+
+#include "ds.h"
+#include "ds_dlist.h"
+
+#include "dpp_types.h"
+
+// string limits
+#define DPP_REASON_STR_LEN  129
+#define DPP_CLT_ID_LEN      129
+
+// proto: EventType
+typedef enum
+{
+    ET_CLIENT_ASSOC = 0,
+    ET_CLIENT_AUTH,
+    ET_CLIENT_DISCONNECT,
+    ET_CLIENT_FAILURE,
+    ET_CLIENT_FIRST_DATA,
+    ET_CLIENT_ID,
+    ET_CLIENT_IP,
+    ET_CLIENT_TIMEOUT
+} event_type_t;
+
+// proto: AssocType
+typedef enum
+{
+    AT_ASSOC = 0,
+    AT_REASSOC
+} assoc_type_t;
+
+// proto: DeviceType
+typedef enum
+{
+    DT_AP = 0,
+    DT_STA
+} device_type_t;
+
+// proto: FrameType
+typedef enum
+{
+    FT_DEAUTH = 0,
+    FT_DISASSOC
+} frame_type_t;
+
+// proto: CTReasonType
+typedef enum
+{
+    CTR_IDLE_TOO_LONG = 0,
+    CTR_PROBE_FAIL
+} ct_reason_t;
+
+// proto: ClientAssocEvent
+typedef struct
+{
+    mac_address_t    sta_mac;
+    uint64_t         session_id;
+    radio_essid_t    ssid;
+    radio_type_t     band;
+    assoc_type_t     assoc_type;
+    uint32_t         status;
+    int32_t          rssi;
+    uint32_t         internal_sc;
+    bool             using11k;
+    bool             using11r;
+    bool             using11v;
+} dpp_event_record_assoc_t;
+
+// proto: ClientAuthEvent
+typedef struct
+{
+    mac_address_t    sta_mac;
+    uint64_t         session_id;
+    radio_essid_t    ssid;
+    radio_type_t     band;
+    uint32_t         auth_status;
+} dpp_event_record_auth_t;
+
+// proto: ClientDisconnectEvent
+typedef struct
+{
+    mac_address_t    sta_mac;
+    uint64_t         session_id;
+    uint32_t         reason;
+    device_type_t    dev_type;
+    frame_type_t     fr_type;
+    uint64_t         last_sent_up_ts_in_us;
+    uint64_t         last_recv_up_ts_in_us;
+    uint32_t         internal_rc;
+    int32_t          rssi;
+    radio_essid_t    ssid;
+    radio_type_t     band;
+} dpp_event_record_disconnect_t;
+
+// proto: ClientFailureEvent
+typedef struct
+{
+    mac_address_t    sta_mac;
+    uint64_t         session_id;
+    radio_essid_t    ssid;
+    int32_t          reason;
+    char             reason_str[DPP_REASON_STR_LEN];
+} dpp_event_record_failure_t;
+
+// proto: ClientFirstDataEvent
+typedef struct
+{
+    mac_address_t    sta_mac;
+    uint64_t         session_id;
+    uint64_t         first_data_tx_up_ts_in_us;
+    uint64_t         first_data_rx_up_ts_in_us;
+} dpp_event_record_first_data_t;
+
+// proto: ClientIdEvent
+typedef struct
+{
+    mac_address_t    clt_mac;
+    uint64_t         session_id;
+    char             clt_id[DPP_CLT_ID_LEN];
+} dpp_event_record_id_t;
+
+// proto: ClientIpEvent
+typedef struct
+{
+    mac_address_t    sta_mac;
+    uint64_t         session_id;
+    char             ip_addr[16];
+} dpp_event_record_ip_t;
+
+// proto: ClientTimeoutEvent
+typedef struct
+{
+    mac_address_t    sta_mac;
+    uint64_t         session_id;
+    ct_reason_t      r_code;
+    uint64_t         last_sent_up_ts_in_us;
+    uint64_t         last_recv_up_ts_in_us;
+
+} dpp_event_record_timeout_t;
+
+// event record
+typedef struct
+{
+    event_type_t                    event_type;
+    dpp_event_record_assoc_t        client_assoc_event;
+    dpp_event_record_auth_t         client_auth_event;
+    dpp_event_record_disconnect_t   client_disconnect_event;
+    dpp_event_record_failure_t      client_failure_event;
+    dpp_event_record_first_data_t   client_first_data_event;
+    dpp_event_record_id_t           client_id_event;
+    dpp_event_record_ip_t           client_ip_event;
+    dpp_event_record_timeout_t      client_timeout_event;
+    ds_dlist_node_t                 node;
+} dpp_event_record_t;
+
+/*******************************/
+/* ClientAssocEvent alloc/free */
+/*******************************/
+// alloc
+static inline dpp_event_record_assoc_t * dpp_event_client_assoc_record_alloc()
+{
+    dpp_event_record_assoc_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_assoc_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_assoc_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_assoc_record_free(dpp_event_record_assoc_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+/******************************/
+/* ClientAuthEvent alloc/free */
+/******************************/
+// alloc
+static inline dpp_event_record_auth_t * dpp_event_client_auth_record_alloc()
+{
+    dpp_event_record_auth_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_auth_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_auth_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_auth_record_free(dpp_event_record_auth_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+/************************************/
+/* ClientDisconnectEvent alloc/free */
+/************************************/
+// alloc
+static inline dpp_event_record_disconnect_t * dpp_event_client_disconnect_record_alloc()
+{
+    dpp_event_record_disconnect_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_disconnect_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_disconnect_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_disconnect_record_free(dpp_event_record_disconnect_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+/*********************************/
+/* ClientFailureEvent alloc/free */
+/*********************************/
+// alloc
+static inline dpp_event_record_failure_t * dpp_event_client_failure_record_alloc()
+{
+    dpp_event_record_failure_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_failure_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_failure_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_failure_record_free(dpp_event_record_failure_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+/***********************************/
+/* ClientFirstDataEvent alloc/free */
+/***********************************/
+// alloc
+static inline dpp_event_record_first_data_t * dpp_event_client_first_data_record_alloc()
+{
+    dpp_event_record_first_data_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_first_data_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_first_data_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_first_data_record_free(dpp_event_record_first_data_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+/****************************/
+/* ClientIdEvent alloc/free */
+/****************************/
+// alloc
+static inline dpp_event_record_id_t * dpp_event_client_id_record_alloc()
+{
+    dpp_event_record_id_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_id_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_id_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_id_record_free(dpp_event_record_id_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+/****************************/
+/* ClientIpEvent alloc/free */
+/****************************/
+// alloc
+static inline dpp_event_record_ip_t * dpp_event_client_ip_record_alloc()
+{
+    dpp_event_record_ip_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_ip_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_ip_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_ip_record_free(dpp_event_record_ip_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+/*********************************/
+/* ClientTimeoutEvent alloc/free */
+/*********************************/
+// alloc
+static inline dpp_event_record_timeout_t * dpp_event_client_timeout_record_alloc()
+{
+    dpp_event_record_timeout_t *record = NULL;
+
+    record = malloc(sizeof(dpp_event_record_timeout_t));
+    if (record)
+    {
+        memset(record, 0, sizeof(dpp_event_record_timeout_t));
+    }
+    return record;
+}
+
+// free
+static inline void dpp_event_client_timeout_record_free(dpp_event_record_timeout_t *record)
+{
+    if (NULL != record)
+    {
+        free(record);
+    }
+}
+
+// Events report type
+typedef struct
+{
+    uint64_t        timestamp_ms;
+    ds_dlist_t      list; // dpp_event_record_t
+} dpp_event_report_data_t;
+
+#endif /* DPP_EVENTS_H_INCLUDED */
Index: opensync-2.0.5.0/src/lib/datapipeline/src/dppline.c
===================================================================
--- opensync-2.0.5.0.orig/src/lib/datapipeline/src/dppline.c
+++ opensync-2.0.5.0/src/lib/datapipeline/src/dppline.c
@@ -43,6 +43,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #include "dpp_device.h"
 #include "dpp_capacity.h"
 #include "dpp_bs_client.h"
+#include "dpp_events.h"
 
 #ifndef TARGET_NATIVE
 #include "os_types.h"
@@ -64,6 +65,7 @@ typedef enum
     DPP_T_BS_CLIENT = 6,
     DPP_T_RSSI      = 7,
     DPP_T_NETWORK_PROBE =8,
+    DPP_T_EVENTS    = 9
 } DPP_STS_TYPE;
 
 uint32_t queue_depth;
@@ -96,6 +98,13 @@ typedef struct dpp_network_probe_stats
     uint64_t                        timestamp_ms;
 } dppline_network_probe_stats_t;
 
+typedef struct dpp_events_stats
+{
+    dpp_event_record_t             *list;
+    uint32_t                        qty;
+    uint64_t                        timestamp_ms;
+} dppline_events_stats_t;
+
 typedef struct
 {
     radio_type_t                    radio_type;
@@ -159,6 +168,8 @@ typedef struct dpp_rssi_stats
     uint64_t                        timestamp_ms;
 } dppline_rssi_stats_t;
 
+
+
 /* DPP stats type, used as element in internal double ds */
 typedef struct dpp_stats
 {
@@ -175,6 +186,7 @@ typedef struct dpp_stats
         dppline_bs_client_stats_t   bs_client;
         dppline_rssi_stats_t        rssi;
         dppline_network_probe_stats_t        network_probe;
+        dppline_events_stats_t       events;
     } u;
 } dppline_stats_t;
 
@@ -230,7 +242,13 @@ static void dppline_free_stat(dppline_st
                 break;
             case DPP_T_NETWORK_PROBE:
                 break;
-            default:;
+
+            case DPP_T_EVENTS:
+                free(s->u.events.list);
+                break;
+
+            default:
+                break;
         }
 
         free(s);
@@ -623,6 +641,40 @@ static bool dppline_copysts(dppline_stat
                 dst->u.network_probe.timestamp_ms = report_data->timestamp_ms;
            }
            break;
+
+        case DPP_T_EVENTS:
+           {
+                dpp_event_report_data_t *report_data = sts;
+                dpp_event_record_t      *result_entry = NULL;
+                ds_dlist_iter_t          result_iter;
+
+                /* Loop through linked list of results and copy them to dppline buffer */
+                dst->u.events.qty = 0;
+                dst->u.events.timestamp_ms = report_data->timestamp_ms;
+                for (   result_entry = ds_dlist_ifirst(&result_iter, &report_data->list);
+                        result_entry != NULL;
+                        result_entry = ds_dlist_inext(&result_iter))
+                {
+                    size = (dst->u.events.qty + 1) * sizeof(dpp_event_record_t);
+                    if (!dst->u.events.qty) {
+                        dst->u.events.list = calloc(1, size);
+                    }
+                    else {
+                        dst->u.events.list = realloc(dst->u.events.list, size);
+                        memset(&dst->u.events.list[dst->u.events.qty],
+                               0,
+                               sizeof(dpp_event_record_t));
+                    }
+                    memcpy(&dst->u.events.list[dst->u.events.qty],
+                            result_entry,
+                            sizeof(dpp_event_record_t));
+
+                    dst->u.events.qty++;
+
+                }
+           }
+           break;
+
         default:
             LOG(ERR, "Failed to copy %d stats", dst->type);
             /* do nothing */
@@ -653,6 +705,103 @@ static char * getNodeid()
     return buff;
 }
 
+Sts__AssocType dppline_to_proto_assoc_type(assoc_type_t assoc_type)
+{
+    switch (assoc_type)
+    {
+        case AT_ASSOC:
+            return STS__ASSOC_TYPE__ASSOC;
+
+        case AT_REASSOC:
+            return STS__ASSOC_TYPE__REASSOC;
+
+        default:
+            assert(0);
+    }
+    return 0;
+}
+
+Sts__DeviceType dppline_to_proto_device_type(device_type_t device_type)
+{
+    switch (device_type)
+    {
+        case DT_AP:
+            return STS__DEVICE_TYPE__DEV_AP;
+
+        case DT_STA:
+            return STS__DEVICE_TYPE__DEV_STA;
+
+        default:
+            assert(0);
+    }
+    return 0;
+}
+
+Sts__FrameType dppline_to_proto_frame_type(frame_type_t frame_type)
+{
+    switch (frame_type)
+    {
+        case FT_DEAUTH:
+            return STS__FRAME_TYPE__FT_DEAUTH;
+
+        case FT_DISASSOC:
+            return STS__FRAME_TYPE__FT_DISASSOC;
+
+        default:
+            assert(0);
+    }
+    return 0;
+}
+
+Sts__CTReasonType dppline_to_proto_ct_reason_type(ct_reason_t reason_type)
+{
+    switch (reason_type)
+    {
+        case CTR_IDLE_TOO_LONG:
+            return STS__CTREASON_TYPE__CTR_IDLE_TOO_LONG;
+
+        case CTR_PROBE_FAIL:
+            return STS__CTREASON_TYPE__CTR_PROBE_FAIL;
+
+        default:
+            assert(0);
+    }
+    return 0;
+}
+
+Sts__EventType dppline_to_proto_event_type(event_type_t event_type)
+{
+    switch (event_type)
+    {
+        case ET_CLIENT_ASSOC:
+            return STS__EVENT_TYPE__CLIENT_ASSOC;
+
+        case ET_CLIENT_AUTH:
+            return STS__EVENT_TYPE__CLIENT_AUTH;
+
+        case ET_CLIENT_DISCONNECT:
+            return STS__EVENT_TYPE__CLIENT_DISCONNECT;
+
+        case ET_CLIENT_FAILURE:
+            return STS__EVENT_TYPE__CLIENT_FAILURE;
+
+        case ET_CLIENT_FIRST_DATA:
+            return STS__EVENT_TYPE__CLIENT_FIRST_DATA;
+
+        case ET_CLIENT_ID:
+            return STS__EVENT_TYPE__CLIENT_ID;
+
+        case ET_CLIENT_IP:
+            return STS__EVENT_TYPE__CLIENT_IP;
+
+        case ET_CLIENT_TIMEOUT:
+            return STS__EVENT_TYPE__CLIENT_TIMEOUT;
+
+        default:
+            assert(0);
+    }
+    return 0;
+}
 
 Sts__RadioBandType dppline_to_proto_radio(radio_type_t radio_type)
 {
@@ -1238,6 +1387,81 @@ static void dppline_add_stat_client(Sts_
             sizeof(*s->u.device), s->size, size);*/
 }
 
+static void dppline_add_stat_events(Sts__Report *r, dppline_stats_t *s)
+{
+    Sts__EventReport *sr = NULL;
+    Sts__EventReport__ClientAssocEvent *dr_assoc = NULL;
+    Sts__EventReport__ClientAuthEvent *dr_auth = NULL;
+    Sts__EventReport__ClientDisconnectEvent *dr_dscn = NULL;
+    /*
+    Sts__EventReport__ClientFailureEvent *dr_fail;
+    Sts__EventReport__ClientFirstDataEvent *dr_fdata;
+    Sts__EventReport__ClientIdEvent *dr_id;
+    Sts__EventReport__ClientIpEvent *dr_ip;
+    Sts__EventReport__ClientTimeoutEvent *dr_tmt;
+    */
+    uint32_t i = 0;
+    //int j;
+    int size = 0;
+    dppline_events_stats_t *events = &s->u.events;
+
+    // increase the number of event_report
+    r->n_event_report++;
+
+    // allocate or extend the size of event_report
+    r->event_report = realloc(r->event_report,
+            r->n_event_report * sizeof(Sts__EventReport*));
+
+    // allocate new buffer
+    sr = malloc(sizeof(Sts__EventReport));
+    size += sizeof(Sts__EventReport);
+    assert(sr);
+    r->event_report[r->n_event_report - 1] = sr;
+    sts__event_report__init(sr);
+    //sr->timestamp_ms = events->timestamp_ms;
+
+    for (i = 0; i < events->qty; i++)
+    {
+        // dpp event pointer
+        dpp_event_record_t *rec = &events->list[i];
+
+        // ClientAssocEvent
+        if(rec->event_type == ET_CLIENT_ASSOC){
+            // init
+            sts__event_report__client_assoc_event__init(dr_assoc);
+            // STA mac
+            dr_assoc->sta_mac = malloc(MACADDR_STR_LEN);
+            dpp_mac_to_str(rec->client_assoc_event.sta_mac, dr_assoc->sta_mac);
+            // SSID
+            if(rec->client_assoc_event.ssid)
+                dr_assoc->ssid = strcpy(dr_assoc->ssid, rec->client_assoc_event.ssid);
+
+        // ClientAuthEvent
+        }else if (rec->event_type == ET_CLIENT_AUTH){
+            // init
+            sts__event_report__client_auth_event__init(dr_auth);
+            // STA mac
+            dr_auth->sta_mac = malloc(MACADDR_STR_LEN);
+            dpp_mac_to_str(rec->client_auth_event.sta_mac, dr_auth->sta_mac);
+            // SSID
+            if(rec->client_auth_event.ssid)
+                dr_auth->ssid = strcpy(dr_auth->ssid, rec->client_auth_event.ssid);
+
+        // ClientDisconnectEvent
+        }else if (rec->event_type == ET_CLIENT_DISCONNECT){
+            // init
+            sts__event_report__client_disconnect_event__init(dr_dscn);
+            // STA mac
+            dr_dscn->sta_mac = malloc(MACADDR_STR_LEN);
+            dpp_mac_to_str(rec->client_disconnect_event.sta_mac, dr_dscn->sta_mac);
+            // SSID
+            if(rec->client_disconnect_event.ssid)
+                dr_dscn->ssid = strcpy(dr_dscn->ssid, rec->client_disconnect_event.ssid);
+
+        }
+    }
+}
+
 static void dppline_add_stat_device(Sts__Report *r, dppline_stats_t *s)
 {
     Sts__Device *sr = NULL;
@@ -1942,6 +2166,10 @@ static void dppline_add_stat(Sts__Report
             dppline_add_stat_network_probe(r, s);
             break;
 
+        case DPP_T_EVENTS:
+            dppline_add_stat_events(r, s);
+            break;
+
         default:
             LOG(ERR, "Failed to add %d to stats report", s->type);
             /* do nothing       */
@@ -2106,6 +2334,14 @@ bool dpp_put_network_probe(dpp_network_p
 }
 
 /*
+ * Put event report to internal queue
+ */
+bool dpp_put_events(dpp_event_report_data_t *rpt)
+{
+    return dppline_put(DPP_T_EVENTS, rpt);
+}
+
+/*
  * Create the protobuf buff and copy it to given buffer
  */
 #ifndef DPP_FAST_PACK
Index: opensync-2.0.5.0/platform/openwrt/src/lib/target/inc/target_OPENWRT.h
===================================================================
--- opensync-2.0.5.0.orig/platform/openwrt/src/lib/target/inc/target_OPENWRT.h
+++ opensync-2.0.5.0/platform/openwrt/src/lib/target/inc/target_OPENWRT.h
@@ -25,10 +25,11 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 */
 
 #ifndef TARGET_OPENWRT_H_INCLUDED
-#define TARGET_OPEMWRT_H_INCLUDED
+#define TARGET_OPENWRT_H_INCLUDED
 
 #include "dpp_client.h"
 #include "dpp_survey.h"
+#include "dpp_events.h"
 
 #define TARGET_CERT_PATH            "/var/run/openvswitch/certs"
 #define TARGET_MANAGERS_PID_PATH    "/tmp/dmpid"
@@ -54,6 +55,12 @@ typedef struct
 	uint32_t duration_ms;
 } target_survey_record_t;
 
+typedef struct
+{
+        dpp_event_record_t record;
+
+} target_event_record_t;
+
 typedef void target_capacity_data_t;
 
 /******************************************************************************
Index: opensync-2.0.5.0/platform/openwrt/src/lib/target/src/stats.c
===================================================================
--- opensync-2.0.5.0.orig/platform/openwrt/src/lib/target/src/stats.c
+++ opensync-2.0.5.0/platform/openwrt/src/lib/target/src/stats.c
@@ -66,6 +66,43 @@ bool target_radio_fast_scan_enable(radio
 	return true;
 }
 
+/******************************************************************************
+ *  EVENT definitions
+ *****************************************************************************/
+target_event_record_t* target_event_record_alloc()
+{
+	target_event_record_t *record = NULL;
+
+	record = malloc(sizeof(target_event_record_t));
+	if (record == NULL)
+		return NULL;
+
+	memset(record, 0, sizeof(target_event_record_t));
+
+	return record;
+}
+
+void target_event_record_free(target_event_record_t *record)
+{
+	if (record != NULL)
+		free(record);
+}
+
+bool target_stats_events_get(radio_entry_t *radio_cfg,
+                             ds_dlist_t *record_list)
+{
+	struct nl_call_param nl_call_param = {
+		.ifname = radio_cfg->if_name,
+		.type = radio_cfg->type,
+                .list = record_list
+	};
+	bool ret = true;
+	if (nl80211_rt_events_handler(&nl_call_param) < 0)
+		ret = false;
+
+        return ret;
+}
+
 
 /******************************************************************************
  *  CLIENT definitions
Index: opensync-2.0.5.0/platform/openwrt/src/lib/target/src/stats_nl80211.c
===================================================================
--- opensync-2.0.5.0.orig/platform/openwrt/src/lib/target/src/stats_nl80211.c
+++ opensync-2.0.5.0/platform/openwrt/src/lib/target/src/stats_nl80211.c
@@ -48,6 +48,7 @@ struct nl80211_scan {
 	struct avl_node avl;
 	ev_async async;
 };
+extern struct rt_events g_rt_events;
 
 static struct avl_tree nl80211_scan_tree = AVL_TREE_INIT(nl80211_scan_tree, avl_strcmp, false, NULL);
 
@@ -67,6 +68,46 @@ static int nl80211_chainmask_recv(struct
 	return NL_OK;
 }
 
+/*
+static int nl80211_cmd_assoc_recv(struct nl_msg *msg, void *arg)
+{
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nl_call_param *nl_call_param = (struct nl_call_param *)arg;
+	struct nlattr *cinfo[NL80211_CMD_MAX + 1];
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+        target_event_record_t *event_entry;
+
+	memset(tb, 0, sizeof(tb));
+	memset(cinfo, 0, sizeof(cinfo));
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (!tb[NL80211_ATTR_MAC] || !tb[NL80211_ATTR_SSID]){
+	        LOG(ERROR, "%s: invalid assoc entry", nl_call_param->ifname);
+		return NL_OK;
+        }
+
+        event_entry = target_event_record_alloc();
+        event_entry->record.event_type = ET_CLIENT_ASSOC;
+        // client_assoc_event pointer
+        dpp_event_record_assoc_t *cap = &event_entry->record.client_assoc_event;
+        memset(cap, 0, sizeof(dpp_event_record_assoc_t));
+        // set data
+        memcpy(cap->sta_mac, nla_data(tb[NL80211_ATTR_MAC]), ETH_ALEN);
+	memcpy(cap->ssid,
+               nla_data(tb[NL80211_ATTR_SSID]),
+               nla_len(tb[NL80211_ATTR_SSID]));
+        cap->assoc_type = AT_ASSOC;
+
+	ds_dlist_insert_tail(nl_call_param->list, event_entry);
+
+        LOG(INFO, "nl80211_cmd_assoc_recv STA_ASSOC!!");
+        return NL_OK;
+
+}
+*/
+
 static int nl80211_assoclist_recv(struct nl_msg *msg, void *arg)
 {
 	static struct nla_policy stats_policy[NL80211_STA_INFO_MAX + 1] = {
@@ -436,6 +477,9 @@ static struct nl_msg *nl80211_call_vif(s
 
 	if (!nl80211_scan_started) {
 		unl_genl_subscribe(&unl, "scan");
+		unl_genl_subscribe(&unl, "mlme");
+		unl_genl_subscribe(&unl, "vendor");
+		unl_genl_subscribe(&unl, "config");
 
 		ev_io_init(&unl_io, nl80211_ev, unl.sock->s_fd, EV_READ);
 		ev_io_start(wifihal_evloop, &unl_io);
@@ -529,6 +573,27 @@ int nl80211_scan_dump(struct nl_call_par
 	return unl_genl_request(&unl, msg, nl80211_scan_dump_recv, nl_call_param);
 }
 
+int nl80211_rt_events_handler(struct nl_call_param *nl_call_param)
+{
+        if(ds_dlist_is_empty(&g_rt_events.event_list)) return -1;
+
+        //ds_dlist_insert_tail(&g_rt_events.event_list, event_entry);
+        target_event_record_t  *target_record = NULL;
+        ds_dlist_iter_t         record_iter;
+        /* get cached eventes */
+        for (target_record = ds_dlist_ifirst(&record_iter, &g_rt_events.event_list);
+             target_record != NULL;
+             target_record = ds_dlist_inext(&record_iter))
+        {
+            // copy (shallow)
+	    ds_dlist_insert_tail(nl_call_param->list, target_record);
+            // remove
+            ds_dlist_iremove(&record_iter);
+        }
+        // no error
+        return 0;
+}
+
 int stats_nl80211_init(void)
 {
 	if (unl_genl_init(&unl, "nl80211") < 0) {
Index: opensync-2.0.5.0/src/lib/datapipeline/inc/dppline.h
===================================================================
--- opensync-2.0.5.0.orig/src/lib/datapipeline/inc/dppline.h
+++ opensync-2.0.5.0/src/lib/datapipeline/inc/dppline.h
@@ -46,6 +46,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #include "dpp_bs_client.h"
 #include "dpp_rssi.h"
 #include "dpp_network_probe.h"
+#include "dpp_events.h"
 
 #ifdef CONFIG_MANAGER_QM
 // QM does queue-ing of reports when offline on it's own, so dpp needs
@@ -107,6 +108,11 @@ bool dpp_put_bs_client(dpp_bs_client_rep
 bool dpp_put_rssi(dpp_rssi_report_data_t *rpt);
 
 /*
+ * Put event report to internal queue
+ */
+bool dpp_put_events(dpp_event_report_data_t *rpt);
+
+/*
  * Get the protobuf packed buffer
  *
  * This buffer is ready to be send using MQTT
Index: opensync-2.0.5.0/src/sm/src/sm_ovsdb.c
===================================================================
--- opensync-2.0.5.0.orig/src/sm/src/sm_ovsdb.c
+++ opensync-2.0.5.0/src/sm/src/sm_ovsdb.c
@@ -62,6 +62,7 @@ char *sm_report_type_str[STS_REPORT_MAX]
     "device",
     "rssi",
     "network_probe",
+    "event",
 };
 
 #ifndef CONFIG_MANAGER_QM
@@ -359,8 +360,11 @@ bool sm_update_stats_config(sm_stats_con
             sm_rssi_report_request(&radio->config, &req);
             break;
 	case STS_REPORT_NETWORK_PROBE:
-	sm_network_probe_report_request(&req);
-	break;
+	    sm_network_probe_report_request(&req);
+	    break;
+        case STS_REPORT_EVENT:
+            sm_events_report_request(&radio->config, &req);
+            break;
         default:
             return false;
     }
Index: opensync-2.0.5.0/src/lib/target/inc/target_native.h
===================================================================
--- opensync-2.0.5.0.orig/src/lib/target/inc/target_native.h
+++ opensync-2.0.5.0/src/lib/target/inc/target_native.h
@@ -39,6 +39,8 @@ typedef void target_survey_record_t;
 
 typedef void target_capacity_data_t;
 
+typedef void target_event_record_t;
+
 #include "target_common.h"
 
 #endif  /* TARGET_NATIVE_H_INCLUDED */
Index: opensync-2.0.5.0/vendor/tip/src/lib/target/inc/target_tip.h
===================================================================
--- opensync-2.0.5.0.orig/vendor/tip/src/lib/target/inc/target_tip.h
+++ opensync-2.0.5.0/vendor/tip/src/lib/target/inc/target_tip.h
@@ -29,6 +29,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 
 #include "dpp_client.h"
 #include "dpp_survey.h"
+#include "dpp_events.h"
 
 #define TARGET_CERT_PATH            "/var/run/openvswitch/certs"
 #define TARGET_MANAGERS_PID_PATH    "/tmp/dmpid"
@@ -54,6 +55,12 @@ typedef struct
 	uint32_t duration_ms;
 } target_survey_record_t;
 
+typedef struct
+{
+        dpp_event_record_t record;
+
+} target_event_record_t;
+
 typedef void target_capacity_data_t;
 
 /******************************************************************************
Index: opensync-2.0.5.0/src/lib/target/inc/target_common.h
===================================================================
--- opensync-2.0.5.0.orig/src/lib/target/inc/target_common.h
+++ opensync-2.0.5.0/src/lib/target/inc/target_common.h
@@ -389,6 +389,13 @@ typedef bool target_stats_clients_cb_t (
         void                       *ctx,
         int                         status);
 
+/******************************************************************************
+ *  EVENT definitions
+ *****************************************************************************/
+target_event_record_t *target_event_record_alloc();
+bool target_stats_events_get(radio_entry_t *radio_cfg,
+                             ds_dlist_t *record_list);
+
 /**
  * @brief Get clients stats
  *
Index: opensync-2.0.5.0/src/sm/src/sm.h
===================================================================
--- opensync-2.0.5.0.orig/src/sm/src/sm.h
+++ opensync-2.0.5.0/src/sm/src/sm.h
@@ -161,6 +161,13 @@ bool sm_network_probe_report_request(
         sm_stats_request_t         *request);
 
 /******************************************************************************
+ *  EVENTS REPORT definitions
+ *****************************************************************************/
+bool sm_events_report_request(
+        radio_entry_t              *radio_cfg,
+        sm_stats_request_t         *request);
+
+/******************************************************************************
  *  SURVEY_REPORT definitions
  *****************************************************************************/
 bool sm_survey_report_request(
@@ -271,6 +278,7 @@ typedef enum
     STS_REPORT_DEVICE,
     STS_REPORT_RSSI,
     STS_REPORT_NETWORK_PROBE,
+    STS_REPORT_EVENT,
     STS_REPORT_MAX,
     STS_REPORT_ERROR = STS_REPORT_MAX
 } sm_report_type_t;
Index: opensync-2.0.5.0/src/sm/src/sm_events_report.c
===================================================================
--- /dev/null
+++ opensync-2.0.5.0/src/sm/src/sm_events_report.c
@@ -0,0 +1,238 @@
+/*
+Copyright (c) 2015, Plume Design Inc. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+   3. Neither the name of the Plume Design Inc. nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL Plume Design Inc. BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#define _GNU_SOURCE
+#include <sys/socket.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <net/if.h>
+
+#include <sys/types.h>
+
+
+#include <ev.h>
+
+#include <syslog.h>
+#include <unl.h>
+
+#include "sm.h"
+
+#define MODULE_ID LOG_MODULE_ID_MAIN
+
+/* new part */
+typedef struct
+{
+    bool                            initialized;
+
+    /* Internal structure used to lower layer radio selection */
+    radio_entry_t                  *radio_cfg;
+
+    /* Internal structure used to lower layer radio selection */
+    ev_timer                        report_timer;
+
+    /* Structure containing cloud request timer params */
+    sm_stats_request_t              request;
+
+    /* Structure pointing to upper layer events storage */
+    dpp_event_report_data_t         report;
+
+    /* event list (only one for now) */
+    ds_dlist_t                      record_list;
+
+    /* Reporting start timestamp used for reporting timestamp calculation */
+    uint64_t                        report_ts;
+} sm_events_ctx_t;
+
+/* Common place holder for all events stat report contexts */
+sm_events_ctx_t                     g_sm_events_ctx;
+
+/******************************************************************************
+ *  PROTECTED definitions
+ *****************************************************************************/
+static
+bool dpp_events_report_timer_set(ev_timer *timer, bool enable)
+{
+    if (enable) {
+        ev_timer_again(EV_DEFAULT, timer);
+    }
+    else {
+        ev_timer_stop(EV_DEFAULT, timer);
+    }
+
+    return true;
+}
+
+static
+bool dpp_events_report_timer_restart(ev_timer *timer)
+{
+    sm_events_ctx_t  *events_ctx = (sm_events_ctx_t *)timer->data;
+    sm_stats_request_t *request_ctx = &events_ctx->request;
+
+    if (request_ctx->reporting_count) {
+        request_ctx->reporting_count--;
+
+        LOG(DEBUG,
+            "Updated events reporting count=%d",
+            request_ctx->reporting_count);
+
+        /* If reporting_count becomes zero, then stop reporting */
+        if (0 == request_ctx->reporting_count) {
+            dpp_events_report_timer_set(timer, false);
+
+            LOG(DEBUG,
+                "Stopped events reporting (count expired)");
+            return true;
+        }
+    }
+
+    return true;
+}
+
+static
+void sm_events_report (EV_P_ ev_timer *w, int revents)
+{
+    bool rc;
+
+    sm_events_ctx_t         *events_ctx = (sm_events_ctx_t *)w->data;
+    dpp_event_report_data_t *report_ctx = &events_ctx->report;
+    sm_stats_request_t      *request_ctx = &events_ctx->request;
+    ev_timer                *report_timer = &events_ctx->report_timer;
+    dpp_event_record_t      *dpp_record = NULL;
+    target_event_record_t   *target_record = NULL;
+    ds_dlist_iter_t         record_iter;
+
+    dpp_events_report_timer_restart(report_timer);
+
+    /* Get events stats */
+    rc = target_stats_events_get(events_ctx->radio_cfg,
+                                 &events_ctx->record_list);
+    if (true != rc) {
+        return;
+    }
+
+    /* get cached eventes */
+    for (target_record = ds_dlist_ifirst(&record_iter, &g_sm_events_ctx.record_list);
+         target_record != NULL;
+         target_record = ds_dlist_inext(&record_iter))
+    {
+        dpp_record = malloc(sizeof(dpp_event_record_t));
+        // copy
+        memcpy(dpp_record, &target_record->record, sizeof(dpp_event_record_t));
+	ds_dlist_insert_tail(&report_ctx->list, dpp_record);
+
+        // remove
+        ds_dlist_iremove(&record_iter);
+        free(target_record);
+    }
+
+    /* Report_timestamp is base-timestamp + relative start time offset */
+    report_ctx->timestamp_ms = request_ctx->reporting_timestamp -
+                               events_ctx->report_ts + get_timestamp();
+
+    LOG(INFO, "Sending events report...");
+    if(!ds_dlist_is_empty(&report_ctx->list)){
+        dpp_put_events(report_ctx);
+    }
+
+}
+
+/******************************************************************************
+ *  PUBLIC API definitions
+ *****************************************************************************/
+bool sm_events_report_request(radio_entry_t *radio_cfg,
+                              sm_stats_request_t *request) {
+
+    sm_events_ctx_t *events_ctx = &g_sm_events_ctx;
+    sm_stats_request_t *request_ctx = &events_ctx->request;
+    dpp_event_report_data_t *report_ctx = &events_ctx->report;
+    ev_timer *report_timer = &events_ctx->report_timer;
+
+    // save radio cfg
+    events_ctx->radio_cfg = radio_cfg;
+
+    if (NULL == request) {
+        LOG(ERR,
+            "Initializing events reporting "
+            "(Invalid request config)");
+        return false;
+    }
+
+    /* Initialize global stats only once */
+    if (!events_ctx->initialized) {
+        memset(request_ctx, 0, sizeof(*request_ctx));
+        memset(report_ctx, 0, sizeof(*report_ctx));
+
+        LOG(INFO, "Initializing events reporting");
+
+        /* Initialize report list */
+        ds_dlist_init(
+                &report_ctx->list,
+                dpp_event_record_t,
+                node);
+
+        /* Initialize event list */
+        ds_dlist_init(
+                &events_ctx->record_list,
+                dpp_event_record_t,
+                node);
+
+
+        /* Initialize event lib timers and pass the global
+           internal cache
+         */
+        ev_init(report_timer, sm_events_report);
+        report_timer->data = events_ctx;
+
+        events_ctx->initialized = true;
+    }
+
+    /* Store and compare every request parameter ...
+       memcpy would be easier but we want some debug info
+     */
+    REQUEST_VAL_UPDATE("event", reporting_count, "%d");
+    REQUEST_VAL_UPDATE("event", reporting_interval, "%d");
+    REQUEST_VAL_UPDATE("event", reporting_timestamp, "%" PRIu64 "");
+
+    /* Restart timers with new parameters */
+    dpp_events_report_timer_set(report_timer, false);
+
+    if (request_ctx->reporting_interval) {
+        events_ctx->report_ts = get_timestamp();
+        report_timer->repeat = request_ctx->reporting_interval;
+        dpp_events_report_timer_set(report_timer, true);
+
+        LOG(INFO, "Started events reporting");
+    } else {
+        LOG(INFO, "Stopped events reporting");
+        memset(request_ctx, 0, sizeof(*request_ctx));
+    }
+
+    return true;
+}
Index: opensync-2.0.5.0/src/sm/unit.mk
===================================================================
--- opensync-2.0.5.0.orig/src/sm/unit.mk
+++ opensync-2.0.5.0/src/sm/unit.mk
@@ -44,6 +44,7 @@ UNIT_SRC     += src/sm_radio_config.c
 UNIT_SRC     += src/sm_scan_schedule.c
 UNIT_SRC     += src/sm_rssi_report.c
 UNIT_SRC     += src/sm_network_probe_report.c
+UNIT_SRC     += src/sm_events_report.c
 UNIT_SRC     += src/sm_common.c
 
 ifeq ($(CONFIG_SM_CAPACITY_QUEUE_STATS),y)
Index: opensync-2.0.5.0/platform/openwrt/src/lib/target/inc/nl80211.h
===================================================================
--- opensync-2.0.5.0.orig/platform/openwrt/src/lib/target/inc/nl80211.h
+++ opensync-2.0.5.0/platform/openwrt/src/lib/target/inc/nl80211.h
@@ -5,6 +5,8 @@
 
 #include <net/if.h>
 
+#include <sys/types.h>
+
 #include <linux/limits.h>
 
 #include <libubox/avl.h>
@@ -53,6 +55,8 @@ struct wifi_station {
 	uint32_t rx_bytes;
 	uint32_t tx_bytes;
 };
+struct nl_msg;
+struct nlattr;
 
 extern int radio_nl80211_init(void);
 
@@ -66,14 +70,22 @@ struct nl_call_param {
 	ds_dlist_t *list;
 };
 
+struct rt_events {
+    ds_dlist_t event_list;
+};
+
 extern int stats_nl80211_init(void);
 extern int nl80211_get_tx_chainmask(char *name, unsigned int *mask);
 extern int nl80211_get_assoclist(struct nl_call_param *nl_call_param);
+extern int nl80211_get_sta_assoc(struct nl_call_param *nl_call_param);
 extern int nl80211_get_survey(struct nl_call_param *nl_call_param);
 extern int nl80211_scan_trigger(struct nl_call_param *nl_call_param, uint32_t *chan_list, uint32_t chan_num,
 				int dwell_time, radio_scan_type_t scan_type,
 				target_scan_cb_t *scan_cb, void *scan_ctx);
 extern int nl80211_scan_abort(struct nl_call_param *nl_call_param);
 extern int nl80211_scan_dump(struct nl_call_param *nl_call_param);
+// real time events handler used by sm_events_report
+extern int nl80211_rt_events_handler(struct nl_call_param *nl_call_param);
+
 
 #endif
Index: opensync-2.0.5.0/platform/openwrt/src/lib/target/src/radio_nl80211.c
===================================================================
--- opensync-2.0.5.0.orig/platform/openwrt/src/lib/target/src/radio_nl80211.c
+++ opensync-2.0.5.0/platform/openwrt/src/lib/target/src/radio_nl80211.c
@@ -12,6 +12,7 @@
 #include <net/if.h>
 
 #include <sys/types.h>
+#include <linux/types.h>
 
 #include <linux/sockios.h>
 #include <linux/nl80211.h>
@@ -30,6 +31,7 @@
 #include <libubox/avl.h>
 #include <libubox/vlist.h>
 #include <unl.h>
+//#include <bm_ieee80211.h>
 
 #include "target.h"
 #include "nl80211.h"
@@ -40,6 +42,7 @@
 extern struct ev_loop *wifihal_evloop;
 static struct unl unl;
 static ev_io unl_io;
+struct rt_events g_rt_events;
 
 static int avl_addrcmp(const void *k1, const void *k2, void *ptr)
 {
@@ -384,6 +387,107 @@ static void nl80211_del_phy(struct nlatt
 	free(phy);
 }
 
+
+static void mlme_ev_auth(struct nl_msg *msg, struct nlattr **tb)
+{
+    // check ssid and mac
+    struct nlattr *ssid = tb[NL80211_ATTR_SSID];
+    struct nlattr *mac = tb[NL80211_ATTR_MAC];
+    if(!(ssid && mac)) return;
+
+    // add to list
+    target_event_record_t *event_entry = target_event_record_alloc();
+    event_entry->record.event_type = ET_CLIENT_AUTH;
+    // client_auth event pointer
+    dpp_event_record_auth_t *cap = &event_entry->record.client_auth_event;
+    memset(cap, 0, sizeof(dpp_event_record_auth_t));
+    // set data
+    memcpy(cap->sta_mac, nla_data(mac), ETH_ALEN);
+    memcpy(cap->ssid, nla_data(ssid), nla_len(ssid));
+    cap->session_id = get_timestamp();
+    // add to global list
+    ds_dlist_insert_tail(&g_rt_events.event_list, event_entry);
+}
+
+static void mlme_ev_assoc(struct nl_msg *msg, struct nlattr **tb)
+{
+    // check ssid and mac
+    struct nlattr *ssid = tb[NL80211_ATTR_SSID];
+    struct nlattr *mac = tb[NL80211_ATTR_MAC];
+    if(!(ssid && mac)) return;
+
+    // add to list
+    target_event_record_t *event_entry = target_event_record_alloc();
+    event_entry->record.event_type = ET_CLIENT_ASSOC;
+    // client_auth event pointer
+    dpp_event_record_assoc_t *cap = &event_entry->record.client_assoc_event;
+    memset(cap, 0, sizeof(dpp_event_record_assoc_t));
+    // set data
+    memcpy(cap->sta_mac, nla_data(mac), ETH_ALEN);
+    memcpy(cap->ssid, nla_data(ssid), nla_len(ssid));
+    cap->session_id = get_timestamp();
+    // add to global list
+    ds_dlist_insert_tail(&g_rt_events.event_list, event_entry);
+}
+
+static void mlme_ev_disconnect(struct nl_msg *msg, struct nlattr **tb)
+{
+    // check ssid and mac
+    struct nlattr *ssid = tb[NL80211_ATTR_SSID];
+    struct nlattr *mac = tb[NL80211_ATTR_MAC];
+    if(!(ssid && mac)) return;
+
+    // add to list
+    target_event_record_t *event_entry = target_event_record_alloc();
+    event_entry->record.event_type = ET_CLIENT_DISCONNECT;
+    // client_auth event pointer
+    dpp_event_record_disconnect_t *cap = &event_entry->record.client_disconnect_event;
+    memset(cap, 0, sizeof(dpp_event_record_disconnect_t));
+    // set data
+    memcpy(cap->sta_mac, nla_data(mac), ETH_ALEN);
+    memcpy(cap->ssid, nla_data(ssid), nla_len(ssid));
+    cap->session_id = get_timestamp();
+    // add to global list
+    ds_dlist_insert_tail(&g_rt_events.event_list, event_entry);
+}
+
+
+
+static void mlme_ev_recv(struct nl_msg *msg, struct nlattr **tb)
+{
+    //const uint8_t *data;
+    size_t len;
+    struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+    struct nlattr *frame = tb[NL80211_ATTR_FRAME];
+    struct nlattr *addr = tb[NL80211_ATTR_MAC];
+
+    // frame should be present
+    if(!(frame && addr)) return;
+
+    //data = nla_data(frame);
+    len = nla_len(frame);
+
+    // length check
+    if (len < 4 + 2 * ETH_ALEN) return;
+
+    switch(gnlh->cmd){
+    case NL80211_CMD_AUTHENTICATE:
+            mlme_ev_auth(msg, tb);
+            break;
+    case NL80211_CMD_ASSOCIATE:
+            mlme_ev_assoc(msg, tb);
+            break;
+    case NL80211_CMD_DEAUTHENTICATE:
+    case NL80211_CMD_DISASSOCIATE:
+    case NL80211_CMD_UNPROT_DEAUTHENTICATE:
+    case NL80211_CMD_UNPROT_DISASSOCIATE:
+            mlme_ev_disconnect(msg, tb);
+            break;
+
+    }
+
+}
+
 static int nl80211_recv(struct nl_msg *msg, void *arg)
 {
 	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
@@ -433,6 +537,23 @@ static int nl80211_recv(struct nl_msg *m
 	case NL80211_CMD_GET_WIPHY:
 		nl80211_add_phy(tb, phyname);
 		break;
+
+        // connect
+        case NL80211_CMD_ASSOCIATE:
+        case NL80211_CMD_AUTHENTICATE:
+        case NL80211_CMD_DEAUTHENTICATE:
+        case NL80211_CMD_DISASSOCIATE:
+        case NL80211_CMD_CONNECT:
+                mlme_ev_recv(msg, tb);
+                break;
+
+        // disconnect
+        case NL80211_CMD_DISCONNECT:
+        case NL80211_CMD_UNPROT_DEAUTHENTICATE:
+        case NL80211_CMD_UNPROT_DISASSOCIATE:
+                mlme_ev_disconnect(msg, tb);
+                break;
+
 	default:
 		syslog(0, "%s:%s[%d]%d\n", __FILE__, __func__, __LINE__, gnlh->cmd);
 		break;
@@ -492,6 +613,13 @@ int radio_nl80211_init(void)
 		return -1;
 	}
 
+        // init global real time event list
+        ds_dlist_init(
+                &g_rt_events.event_list,
+                dpp_event_record_t,
+                node);
+
+
 	msg = unl_genl_msg(&unl, NL80211_CMD_GET_WIPHY, true);
 	unl_genl_request(&unl, msg, nl80211_recv, NULL);
 	msg = unl_genl_msg(&unl, NL80211_CMD_GET_INTERFACE, true);
Index: opensync-2.0.5.0/platform/openwrt/src/lib/target/src/radio.c
===================================================================
--- opensync-2.0.5.0.orig/platform/openwrt/src/lib/target/src/radio.c
+++ opensync-2.0.5.0/platform/openwrt/src/lib/target/src/radio.c
@@ -14,7 +14,6 @@
 #include "ovsdb_table.h"
 #include "ovsdb_cache.h"
 
-#include "nl80211.h"
 #include "radio.h"
 #include "vif.h"
 #include "phy.h"
@@ -22,6 +21,7 @@
 #include "evsched.h"
 #include "uci.h"
 #include "utils.h"
+#include "nl80211.h"
 
 static struct uci_package *wireless;
 struct uci_context *uci;
