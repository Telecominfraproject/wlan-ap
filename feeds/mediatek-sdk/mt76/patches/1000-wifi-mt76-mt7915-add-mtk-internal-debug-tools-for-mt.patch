From fc8eaff0aa3ff1f6a7ac8808922aafba48ed3efc Mon Sep 17 00:00:00 2001
From: Shayne Chen <shayne.chen@mediatek.com>
Date: Wed, 22 Jun 2022 10:39:47 +0800
Subject: [PATCH] wifi: mt76: mt7915: add mtk internal debug tools for mt76

---
 mt76_connac_mcu.h     |    6 +
 mt7915/Makefile       |    2 +-
 mt7915/debugfs.c      |   89 +-
 mt7915/mac.c          |   14 +
 mt7915/main.c         |    5 +
 mt7915/mcu.c          |   48 +-
 mt7915/mcu.h          |    4 +
 mt7915/mt7915.h       |   56 +
 mt7915/mt7915_debug.h | 1442 ++++++++++++++++
 mt7915/mtk_debugfs.c  | 3750 +++++++++++++++++++++++++++++++++++++++++
 mt7915/mtk_mcu.c      |   51 +
 mt7915/soc.c          |    7 +
 tools/fwlog.c         |   44 +-
 13 files changed, 5499 insertions(+), 19 deletions(-)
 create mode 100644 mt7915/mt7915_debug.h
 create mode 100644 mt7915/mtk_debugfs.c
 create mode 100644 mt7915/mtk_mcu.c

diff --git a/mt76_connac_mcu.h b/mt76_connac_mcu.h
index abc57f18..01d6598a 100644
--- a/mt76_connac_mcu.h
+++ b/mt76_connac_mcu.h
@@ -1197,6 +1197,7 @@ enum {
 	MCU_EXT_CMD_SET_TX_POWER_CTRL = 0x11,
 	MCU_EXT_CMD_FW_LOG_2_HOST = 0x13,
 	MCU_EXT_CMD_TXBF_ACTION = 0x1e,
+	MCU_EXT_CMD_MEC_CTRL = 0x1f,
 	MCU_EXT_CMD_EFUSE_BUFFER_MODE = 0x21,
 	MCU_EXT_CMD_THERMAL_PROT = 0x23,
 	MCU_EXT_CMD_STA_REC_UPDATE = 0x25,
@@ -1220,6 +1221,11 @@ enum {
 	MCU_EXT_CMD_TX_POWER_FEATURE_CTRL = 0x58,
 	MCU_EXT_CMD_RXDCOC_CAL = 0x59,
 	MCU_EXT_CMD_GET_MIB_INFO = 0x5a,
+#ifdef MTK_DEBUG
+	MCU_EXT_CMD_RED_SHOW_STA = 0x69,
+	MCU_EXT_CMD_RED_TARGET_DELAY = 0x6A,
+	MCU_EXT_CMD_RED_TX_RPT = 0x6B,
+#endif
 	MCU_EXT_CMD_TXDPD_CAL = 0x60,
 	MCU_EXT_CMD_CAL_CACHE = 0x67,
 	MCU_EXT_CMD_RED_ENABLE = 0x68,
diff --git a/mt7915/Makefile b/mt7915/Makefile
index c4dca9c1..fd711416 100644
--- a/mt7915/Makefile
+++ b/mt7915/Makefile
@@ -4,7 +4,7 @@ EXTRA_CFLAGS += -DCONFIG_MT76_LEDS
 obj-$(CONFIG_MT7915E) += mt7915e.o
 
 mt7915e-y := pci.o init.o dma.o eeprom.o main.o mcu.o mac.o \
-	     debugfs.o mmio.o
+	     debugfs.o mmio.o mtk_debugfs.o mtk_mcu.o
 
 mt7915e-$(CONFIG_NL80211_TESTMODE) += testmode.o
 mt7915e-$(CONFIG_MT798X_WMAC) += soc.o
diff --git a/mt7915/debugfs.c b/mt7915/debugfs.c
index 894e2cd7..26613869 100644
--- a/mt7915/debugfs.c
+++ b/mt7915/debugfs.c
@@ -8,6 +8,9 @@
 #include "mac.h"
 
 #define FW_BIN_LOG_MAGIC	0x44e98caf
+#ifdef MTK_DEBUG
+#define FW_BIN_LOG_MAGIC_V2	0x44d9c99a
+#endif
 
 /** global debugfs **/
 
@@ -496,6 +499,9 @@ mt7915_fw_debug_wm_set(void *data, u64 val)
 	int ret;
 
 	dev->fw.debug_wm = val ? MCU_FW_LOG_TO_HOST : 0;
+#ifdef MTK_DEBUG
+	dev->fw.debug_wm = val;
+#endif
 
 	if (dev->fw.debug_bin)
 		val = 16;
@@ -520,6 +526,9 @@ mt7915_fw_debug_wm_set(void *data, u64 val)
 		if (ret)
 			goto out;
 	}
+#ifdef MTK_DEBUG
+	mt7915_mcu_fw_dbg_ctrl(dev, 68, !!val);
+#endif
 
 	/* WM CPU info record control */
 	mt76_clear(dev, MT_CPU_UTIL_CTRL, BIT(0));
@@ -528,6 +537,12 @@ mt7915_fw_debug_wm_set(void *data, u64 val)
 	mt76_wr(dev, MT_MCU_WM_CIRQ_IRQ_MASK_CLR_ADDR, BIT(5));
 	mt76_wr(dev, MT_MCU_WM_CIRQ_IRQ_SOFT_ADDR, BIT(5));
 
+#ifdef MTK_DEBUG
+	if (dev->fw.debug_bin & BIT(3))
+		/* use bit 7 to indicate v2 magic number */
+		dev->fw.debug_wm |= BIT(7);
+#endif
+
 out:
 	if (ret)
 		dev->fw.debug_wm = 0;
@@ -540,7 +555,11 @@ mt7915_fw_debug_wm_get(void *data, u64 *val)
 {
 	struct mt7915_dev *dev = data;
 
-	*val = dev->fw.debug_wm;
+#ifdef MTK_DEBUG
+	*val = dev->fw.debug_wm & ~BIT(7);
+#else
+	val = dev->fw.debug_wm;
+#endif
 
 	return 0;
 }
@@ -615,16 +634,30 @@ mt7915_fw_debug_bin_set(void *data, u64 val)
 	};
 	struct mt7915_dev *dev = data;
 
-	if (!dev->relay_fwlog)
+	if (!dev->relay_fwlog && val) {
 		dev->relay_fwlog = relay_open("fwlog_data", dev->debugfs_dir,
 					    1500, 512, &relay_cb, NULL);
-	if (!dev->relay_fwlog)
-		return -ENOMEM;
+		if (!dev->relay_fwlog)
+			return -ENOMEM;
+	}
 
 	dev->fw.debug_bin = val;
 
 	relay_reset(dev->relay_fwlog);
 
+#ifdef MTK_DEBUG
+	dev->dbg.dump_mcu_pkt = val & BIT(4) ? true : false;
+	dev->dbg.dump_txd = val & BIT(5) ? true : false;
+	dev->dbg.dump_tx_pkt = val & BIT(6) ? true : false;
+	dev->dbg.dump_rx_pkt = val & BIT(7) ? true : false;
+	dev->dbg.dump_rx_raw = val & BIT(8) ? true : false;
+#endif
+
+	if (dev->relay_fwlog && !val) {
+		relay_close(dev->relay_fwlog);
+		dev->relay_fwlog = NULL;
+	}
+
 	return mt7915_fw_debug_wm_set(dev, dev->fw.debug_wm);
 }
 
@@ -1254,6 +1287,11 @@ int mt7915_init_debugfs(struct mt7915_phy *phy)
 	if (!ext_phy)
 		dev->debugfs_dir = dir;
 
+#ifdef MTK_DEBUG
+	debugfs_create_u16("wlan_idx", 0600, dir, &dev->wlan_idx);
+	mt7915_mtk_init_debugfs(phy, dir);
+#endif
+
 	return 0;
 }
 
@@ -1266,6 +1304,12 @@ mt7915_debugfs_write_fwlog(struct mt7915_dev *dev, const void *hdr, int hdrlen,
 	void *dest;
 
 	spin_lock_irqsave(&lock, flags);
+
+	if (!dev->relay_fwlog) {
+		spin_unlock_irqrestore(&lock, flags);
+		return;
+	}
+
 	dest = relay_reserve(dev->relay_fwlog, hdrlen + len + 4);
 	if (dest) {
 		*(u32 *)dest = hdrlen + len;
@@ -1294,17 +1338,50 @@ void mt7915_debugfs_rx_fw_monitor(struct mt7915_dev *dev, const void *data, int
 		.msg_type = cpu_to_le16(PKT_TYPE_RX_FW_MONITOR),
 	};
 
-	if (!dev->relay_fwlog)
-		return;
+#ifdef MTK_DEBUG
+	struct {
+		__le32 magic;
+		u8 version;
+		u8 _rsv;
+		__le16 serial_id;
+		__le32 timestamp;
+		__le16 msg_type;
+		__le16 len;
+	} hdr2 = {
+		.version = 0x1,
+		.magic = cpu_to_le32(FW_BIN_LOG_MAGIC_V2),
+		.msg_type = PKT_TYPE_RX_FW_MONITOR,
+	};
+#endif
 
+#ifdef MTK_DEBUG
+	/* old magic num */
+	if (!(dev->fw.debug_wm & BIT(7))) {
+		hdr.timestamp = mt76_rr(dev, MT_LPON_FRCR(0));
+		hdr.len = *(__le16 *)data;
+		mt7915_debugfs_write_fwlog(dev, &hdr, sizeof(hdr), data, len);
+	} else {
+		hdr2.serial_id = dev->dbg.fwlog_seq++;
+		hdr2.timestamp = mt76_rr(dev, MT_LPON_FRCR(0));
+		hdr2.len = *(__le16 *)data;
+		mt7915_debugfs_write_fwlog(dev, &hdr2, sizeof(hdr2), data, len);
+	}
+#else
 	hdr.timestamp = cpu_to_le32(mt76_rr(dev, MT_LPON_FRCR(0)));
 	hdr.len = *(__le16 *)data;
 	mt7915_debugfs_write_fwlog(dev, &hdr, sizeof(hdr), data, len);
+#endif
 }
 
 bool mt7915_debugfs_rx_log(struct mt7915_dev *dev, const void *data, int len)
 {
+#ifdef MTK_DEBUG
+	if (get_unaligned_le32(data) != FW_BIN_LOG_MAGIC &&
+	    get_unaligned_le32(data) != FW_BIN_LOG_MAGIC_V2 &&
+	    get_unaligned_le32(data) != PKT_BIN_DEBUG_MAGIC)
+#else
 	if (get_unaligned_le32(data) != FW_BIN_LOG_MAGIC)
+#endif
 		return false;
 
 	if (dev->relay_fwlog)
diff --git a/mt7915/mac.c b/mt7915/mac.c
index 9c56f105..d1f58eb4 100644
--- a/mt7915/mac.c
+++ b/mt7915/mac.c
@@ -282,6 +282,10 @@ mt7915_mac_fill_rx(struct mt7915_dev *dev, struct sk_buff *skb,
 	__le16 fc = 0;
 	int idx;
 
+#ifdef MTK_DEBUG
+	if (dev->dbg.dump_rx_raw)
+		mt7915_packet_log_to_host(dev, skb->data, skb->len, PKT_BIN_DEBUG_RX_RAW, 0);
+#endif
 	memset(status, 0, sizeof(*status));
 
 	if ((rxd1 & MT_RXD1_NORMAL_BAND_IDX) && !phy->mt76->band_idx) {
@@ -466,6 +470,10 @@ mt7915_mac_fill_rx(struct mt7915_dev *dev, struct sk_buff *skb,
 	}
 
 	hdr_gap = (u8 *)rxd - skb->data + 2 * remove_pad;
+#ifdef MTK_DEBUG
+	if (dev->dbg.dump_rx_pkt)
+		mt7915_packet_log_to_host(dev, skb->data, skb->len, PKT_BIN_DEBUG_RX, hdr_gap);
+#endif
 	if (hdr_trans && ieee80211_has_morefrags(fc)) {
 		struct ieee80211_vif *vif;
 		int err;
@@ -804,6 +812,12 @@ int mt7915_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
 	tx_info->buf[1].skip_unmap = true;
 	tx_info->nbuf = MT_CT_DMA_BUF_NUM;
 
+#ifdef MTK_DEBUG
+	if (dev->dbg.dump_txd)
+		mt7915_packet_log_to_host(dev, txwi, MT_TXD_SIZE, PKT_BIN_DEBUG_TXD, 0);
+	if (dev->dbg.dump_tx_pkt)
+		mt7915_packet_log_to_host(dev, t->skb->data, t->skb->len, PKT_BIN_DEBUG_TX, 0);
+#endif
 	return 0;
 }
 
diff --git a/mt7915/main.c b/mt7915/main.c
index 2b161611..90cd834c 100644
--- a/mt7915/main.c
+++ b/mt7915/main.c
@@ -73,7 +73,11 @@ int mt7915_run(struct ieee80211_hw *hw)
 	if (ret)
 		goto out;
 
+#ifdef MTK_DEBUG
+	ret = mt7915_mcu_set_sku_en(phy, !dev->dbg.sku_disable);
+#else
 	ret = mt7915_mcu_set_sku_en(phy, true);
+#endif
 	if (ret)
 		goto out;
 
@@ -254,6 +258,7 @@ static int mt7915_add_interface(struct ieee80211_hw *hw,
 	mvif->sta.wcid.hw_key_idx = -1;
 	mvif->sta.wcid.tx_info |= MT_WCID_TX_INFO_SET;
 	mt76_wcid_init(&mvif->sta.wcid);
+	mvif->sta.vif = mvif;
 
 	/* init Default QoS map, defined in section 2.3 of RFC8325.
 	 * Three most significant bits of DSCP are used as UP.
diff --git a/mt7915/mcu.c b/mt7915/mcu.c
index 34323577..ff7f81b0 100644
--- a/mt7915/mcu.c
+++ b/mt7915/mcu.c
@@ -205,6 +205,11 @@ mt7915_mcu_send_message(struct mt76_dev *mdev, struct sk_buff *skb,
 	else
 		qid = MT_MCUQ_WM;
 
+#ifdef MTK_DEBUG
+	if (dev->dbg.dump_mcu_pkt)
+		mt7915_packet_log_to_host(dev, skb->data, skb->len, PKT_BIN_DEBUG_MCU, 0);
+#endif
+
 	return mt76_tx_queue_skb_raw(dev, mdev->q_mcu[qid], skb, 0);
 }
 
@@ -2385,7 +2390,10 @@ static int mt7915_red_set_watermark(struct mt7915_dev *dev)
 				 sizeof(req), false);
 }
 
-static int mt7915_mcu_set_red(struct mt7915_dev *dev, bool enabled)
+#ifndef MTK_DEBUG
+static
+#endif
+int mt7915_mcu_set_red(struct mt7915_dev *dev, bool enabled)
 {
 #define RED_DISABLE		0
 #define RED_BY_WA_ENABLE	2
@@ -3519,6 +3527,8 @@ int mt7915_mcu_set_sku_en(struct mt7915_phy *phy, bool enable)
 		.sku_enable = enable,
 	};
 
+	pr_info("%s: enable = %d\n", __func__, enable);
+
 	return mt76_mcu_send_msg(&dev->mt76,
 				 MCU_EXT_CMD(TX_POWER_FEATURE_CTRL), &req,
 				 sizeof(req), true);
@@ -4185,6 +4195,23 @@ out:
 	return ret;
 }
 
+#ifdef MTK_DEBUG
+int mt7915_dbg_mcu_wa_cmd(struct mt7915_dev *dev, int cmd, u32 a1, u32 a2, u32 a3, bool wait_resp)
+{
+	struct {
+		__le32 args[3];
+	} req = {
+		.args = {
+			cpu_to_le32(a1),
+			cpu_to_le32(a2),
+			cpu_to_le32(a3),
+		},
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, cmd, &req, sizeof(req), wait_resp);
+}
+#endif
+
 int mt7915_mcu_rf_regval(struct mt7915_dev *dev, u32 regidx, u32 *val, bool set)
 {
 	struct {
@@ -4213,3 +4240,22 @@ int mt7915_mcu_rf_regval(struct mt7915_dev *dev, u32 regidx, u32 *val, bool set)
 
 	return 0;
 }
+
+#ifdef MTK_DEBUG
+int mt7915_mcu_set_amsdu_algo(struct mt7915_dev *dev, u16 wcid, u8 enable)
+{
+	struct {
+		u16 action;
+		u8 _rsv1[2];
+		u16 wcid;
+		u8 enable;
+		u8 _rsv2[5];
+	} __packed req = {
+		.action = cpu_to_le16(1),
+		.wcid = cpu_to_le16(wcid),
+		.enable = enable,
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(MEC_CTRL), &req, sizeof(req), true);
+}
+#endif
diff --git a/mt7915/mcu.h b/mt7915/mcu.h
index fa0847d5..9ae0f07a 100644
--- a/mt7915/mcu.h
+++ b/mt7915/mcu.h
@@ -347,6 +347,10 @@ enum {
 	MCU_WA_PARAM_PDMA_RX = 0x04,
 	MCU_WA_PARAM_CPU_UTIL = 0x0b,
 	MCU_WA_PARAM_RED = 0x0e,
+#ifdef MTK_DEBUG
+	MCU_WA_PARAM_RED_SHOW_STA = 0xf,
+	MCU_WA_PARAM_RED_TARGET_DELAY = 0x10,
+#endif
 	MCU_WA_PARAM_BSS_ACQ_PKT_CNT = 0x12,
 	MCU_WA_PARAM_RED_SETTING = 0x40,
 };
diff --git a/mt7915/mt7915.h b/mt7915/mt7915.h
index bfac8516..72158419 100644
--- a/mt7915/mt7915.h
+++ b/mt7915/mt7915.h
@@ -9,6 +9,7 @@
 #include "../mt76_connac.h"
 #include "regs.h"
 
+#define MTK_DEBUG 1
 #define MT7915_MAX_INTERFACES		19
 #define MT7915_WTBL_SIZE		288
 #define MT7916_WTBL_SIZE		544
@@ -248,6 +249,14 @@ struct mt7915_phy {
 #endif
 };
 
+#ifdef MTK_DEBUG
+enum {
+	ADIE0,
+	ADIE1,
+	ADIE_MAX_CNT,
+};
+#endif
+
 struct mt7915_dev {
 	union { /* must be first */
 		struct mt76_dev mt76;
@@ -331,6 +340,33 @@ struct mt7915_dev {
 	void __iomem *dcm;
 	void __iomem *sku;
 
+#ifdef MTK_DEBUG
+	u16 wlan_idx;
+	struct {
+		u32 fixed_rate;
+		u32 l1debugfs_reg;
+		u32 l2debugfs_reg;
+		u32 mac_reg;
+		u32 fw_dbg_module;
+		u8 fw_dbg_lv;
+		u32 bcn_total_cnt[2];
+		u16 fwlog_seq;
+		bool dump_mcu_pkt;
+		bool dump_txd;
+		bool dump_tx_pkt;
+		bool dump_rx_pkt;
+		bool dump_rx_raw;
+		u32 token_idx;
+		u8 sku_disable;
+	} dbg;
+	const struct mt7915_dbg_reg_desc *dbg_reg;
+
+	struct {
+		u16 id;
+		u16 version;
+	} adie[ADIE_MAX_CNT];
+#endif
+
 	bool wmm_pbc_enable;
 	struct work_struct wmm_pbc_work;
 	u32 adie_type;
@@ -614,4 +650,24 @@ void mt7915_sta_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 int mt7915_mmio_wed_init(struct mt7915_dev *dev, void *pdev_ptr,
 			 bool pci, int *irq);
 
+#ifdef MTK_DEBUG
+int mt7915_mtk_init_debugfs(struct mt7915_phy *phy, struct dentry *dir);
+int mt7915_dbg_mcu_wa_cmd(struct mt7915_dev *dev, int cmd, u32 a1, u32 a2, u32 a3, bool wait_resp);
+int mt7915_mcu_set_red(struct mt7915_dev *dev, bool enabled);
+void mt7915_dump_tmac_info(u8 *tmac_info);
+int mt7915_mcu_set_txpower_level(struct mt7915_phy *phy, u8 drop_level);
+void mt7915_packet_log_to_host(struct mt7915_dev *dev, const void *data, int len, int type, int des_len);
+int mt7915_mcu_set_amsdu_algo(struct mt7915_dev *dev, u16 wcid, u8 enable);
+
+#define PKT_BIN_DEBUG_MAGIC	0xc8763123
+enum {
+	PKT_BIN_DEBUG_MCU,
+	PKT_BIN_DEBUG_TXD,
+	PKT_BIN_DEBUG_TX,
+	PKT_BIN_DEBUG_RX,
+	PKT_BIN_DEBUG_RX_RAW,
+};
+
+#endif
+
 #endif
diff --git a/mt7915/mt7915_debug.h b/mt7915/mt7915_debug.h
new file mode 100644
index 00000000..2f9f3da7
--- /dev/null
+++ b/mt7915/mt7915_debug.h
@@ -0,0 +1,1442 @@
+#ifndef __MT7915_DEBUG_H
+#define __MT7915_DEBUG_H
+
+#ifdef MTK_DEBUG
+
+#define DBG_INVALID_BASE		0xffffffff
+#define DBG_INVALID_OFFSET		0x0
+
+struct __dbg_map {
+	u32 phys;
+	u32 maps;
+	u32 size;
+};
+
+struct __dbg_reg {
+	u32 base;
+	u32 offs;
+};
+
+struct __dbg_mask {
+	u32 end;
+	u32 start;
+};
+
+enum dbg_base_rev {
+	MT_DBG_WFDMA0_BASE,
+	MT_DBG_WFDMA1_BASE,
+	MT_DBG_WFDMA0_PCIE1_BASE,
+	MT_DBG_WFDMA1_PCIE1_BASE,
+	MT_DBG_WFDMA_EXT_CSR_BASE,
+	MT_DBG_SWDEF_BASE,
+	__MT_DBG_BASE_REV_MAX,
+};
+
+enum dbg_reg_rev {
+	DBG_INT_SOURCE_CSR,
+	DBG_INT_MASK_CSR,
+	DBG_INT1_SOURCE_CSR,
+	DBG_INT1_MASK_CSR,
+	DBG_TX_RING_BASE,
+	DBG_RX_EVENT_RING_BASE,
+	DBG_RX_STS_RING_BASE,
+	DBG_RX_DATA_RING_BASE,
+	DBG_DMA_ICSC_FR0,
+	DBG_DMA_ICSC_FR1,
+	DBG_TMAC_ICSCR0,
+	DBG_RMAC_RXICSRPT,
+	DBG_MIB_M0SDR0,
+	DBG_MIB_M0SDR3,
+	DBG_MIB_M0SDR4,
+	DBG_MIB_M0SDR5,
+	DBG_MIB_M0SDR7,
+	DBG_MIB_M0SDR8,
+	DBG_MIB_M0SDR9,
+	DBG_MIB_M0SDR10,
+	DBG_MIB_M0SDR11,
+	DBG_MIB_M0SDR12,
+	DBG_MIB_M0SDR14,
+	DBG_MIB_M0SDR15,
+	DBG_MIB_M0SDR16,
+	DBG_MIB_M0SDR17,
+	DBG_MIB_M0SDR18,
+	DBG_MIB_M0SDR19,
+	DBG_MIB_M0SDR20,
+	DBG_MIB_M0SDR21,
+	DBG_MIB_M0SDR22,
+	DBG_MIB_M0SDR23,
+	DBG_MIB_M0DR0,
+	DBG_MIB_M0DR1,
+	DBG_MIB_MUBF,
+	DBG_MIB_M0DR6,
+	DBG_MIB_M0DR7,
+	DBG_MIB_M0DR8,
+	DBG_MIB_M0DR9,
+	DBG_MIB_M0DR10,
+	DBG_MIB_M0DR11,
+	DBG_MIB_M0DR12,
+	DBG_WTBLON_WDUCR,
+	DBG_UWTBL_WDUCR,
+	DBG_PLE_DRR_TABLE_CTRL,
+	DBG_PLE_DRR_TABLE_RDATA,
+	DBG_PLE_PBUF_CTRL,
+	DBG_PLE_QUEUE_EMPTY,
+	DBG_PLE_FREEPG_CNT,
+	DBG_PLE_FREEPG_HEAD_TAIL,
+	DBG_PLE_PG_HIF_GROUP,
+	DBG_PLE_HIF_PG_INFO,
+	DBG_PLE_PG_HIF_TXCMD_GROUP,
+	DBG_PLE_HIF_TXCMD_PG_INFO,
+	DBG_PLE_PG_CPU_GROUP,
+	DBG_PLE_CPU_PG_INFO,
+	DBG_PLE_FL_QUE_CTRL,
+	DBG_PLE_NATIVE_TXCMD_Q_EMPTY,
+	DBG_PLE_TXCMD_Q_EMPTY,
+	DBG_PLE_AC_QEMPTY,
+	DBG_PLE_AC_OFFSET,
+	DBG_PLE_STATION_PAUSE,
+	DBG_PLE_DIS_STA_MAP,
+	DBG_PSE_PBUF_CTRL,
+	DBG_PSE_FREEPG_CNT,
+	DBG_PSE_FREEPG_HEAD_TAIL,
+	DBG_PSE_HIF0_PG_INFO,
+	DBG_PSE_PG_HIF1_GROUP,
+	DBG_PSE_HIF1_PG_INFO,
+	DBG_PSE_PG_CPU_GROUP,
+	DBG_PSE_CPU_PG_INFO,
+	DBG_PSE_PG_PLE_GROUP,
+	DBG_PSE_PLE_PG_INFO,
+	DBG_PSE_PG_LMAC0_GROUP,
+	DBG_PSE_LMAC0_PG_INFO,
+	DBG_PSE_PG_LMAC1_GROUP,
+	DBG_PSE_LMAC1_PG_INFO,
+	DBG_PSE_PG_LMAC2_GROUP,
+	DBG_PSE_LMAC2_PG_INFO,
+	DBG_PSE_PG_LMAC3_GROUP,
+	DBG_PSE_LMAC3_PG_INFO,
+	DBG_PSE_PG_MDP_GROUP,
+	DBG_PSE_MDP_PG_INFO,
+	DBG_PSE_PG_PLE1_GROUP,
+	DBG_PSE_PLE1_PG_INFO,
+	DBG_AGG_AALCR0,
+	DBG_AGG_AALCR1,
+	DBG_AGG_AALCR2,
+	DBG_AGG_AALCR3,
+	DBG_AGG_AALCR4,
+	DBG_AGG_B0BRR0,
+	DBG_AGG_B1BRR0,
+	DBG_AGG_B2BRR0,
+	DBG_AGG_B3BRR0,
+	DBG_AGG_AWSCR0,
+	DBG_AGG_PCR0,
+	DBG_AGG_TTCR0,
+	DBG_MIB_M0ARNG0,
+	DBG_MIB_M0DR2,
+	DBG_MIB_M0DR13,
+	DBG_WFDMA_WED_TX_CTRL,
+	DBG_WFDMA_WED_RX_CTRL,
+	__MT_DBG_REG_REV_MAX,
+};
+
+enum dbg_mask_rev {
+	DBG_MIB_M0SDR10_RX_MDRDY_COUNT,
+	DBG_MIB_M0SDR14_AMPDU,
+	DBG_MIB_M0SDR15_AMPDU_ACKED,
+	DBG_MIB_RX_FCS_ERROR_COUNT,
+	__MT_DBG_MASK_REV_MAX,
+};
+
+enum dbg_bit_rev {
+	__MT_DBG_BIT_REV_MAX,
+};
+
+static const u32 mt7915_dbg_base[] = {
+	[MT_DBG_WFDMA0_BASE]		= 0xd4000,
+	[MT_DBG_WFDMA1_BASE]		= 0xd5000,
+	[MT_DBG_WFDMA0_PCIE1_BASE]	= 0xd8000,
+	[MT_DBG_WFDMA1_PCIE1_BASE]	= 0xd9000,
+	[MT_DBG_WFDMA_EXT_CSR_BASE]	= 0xd7000,
+	[MT_DBG_SWDEF_BASE]		= 0x41f200,
+};
+
+static const u32 mt7916_dbg_base[] = {
+	[MT_DBG_WFDMA0_BASE]		= 0xd4000,
+	[MT_DBG_WFDMA1_BASE]		= 0xd5000,
+	[MT_DBG_WFDMA0_PCIE1_BASE]	= 0xd8000,
+	[MT_DBG_WFDMA1_PCIE1_BASE]	= 0xd9000,
+	[MT_DBG_WFDMA_EXT_CSR_BASE]	= 0xd7000,
+	[MT_DBG_SWDEF_BASE]		= 0x411400,
+};
+
+static const u32 mt7981_dbg_base[] = {
+	[MT_DBG_WFDMA0_BASE]		= 0x24000,
+	[MT_DBG_WFDMA1_BASE]		= 0x25000,
+	[MT_DBG_WFDMA0_PCIE1_BASE]	= 0x28000,
+	[MT_DBG_WFDMA1_PCIE1_BASE]	= 0x29000,
+	[MT_DBG_WFDMA_EXT_CSR_BASE]	= 0x27000,
+	[MT_DBG_SWDEF_BASE]		= 0x411400,
+};
+
+static const u32 mt7986_dbg_base[] = {
+	[MT_DBG_WFDMA0_BASE]		= 0x24000,
+	[MT_DBG_WFDMA1_BASE]		= 0x25000,
+	[MT_DBG_WFDMA0_PCIE1_BASE]	= 0x28000,
+	[MT_DBG_WFDMA1_PCIE1_BASE]	= 0x29000,
+	[MT_DBG_WFDMA_EXT_CSR_BASE]	= 0x27000,
+	[MT_DBG_SWDEF_BASE]		= 0x411400,
+};
+
+/* mt7915 regs with different base and offset */
+static const struct __dbg_reg mt7915_dbg_reg[] = {
+	[DBG_WFDMA_WED_TX_CTRL]		= { MT_DBG_WFDMA_EXT_CSR_BASE, 0x300 },
+	[DBG_WFDMA_WED_RX_CTRL]		= { MT_DBG_WFDMA_EXT_CSR_BASE, 0x400 },
+	[DBG_INT_SOURCE_CSR]		= { MT_DBG_WFDMA_EXT_CSR_BASE, 0x10 },
+	[DBG_INT_MASK_CSR]		= { MT_DBG_WFDMA_EXT_CSR_BASE, 0x14 },
+	[DBG_INT1_SOURCE_CSR]		= { MT_DBG_WFDMA_EXT_CSR_BASE, 0x88 },
+	[DBG_INT1_MASK_CSR]		= { MT_DBG_WFDMA_EXT_CSR_BASE, 0x8c },
+	[DBG_TX_RING_BASE]		= { MT_DBG_WFDMA1_BASE, 0x400 },
+	[DBG_RX_EVENT_RING_BASE]	= { MT_DBG_WFDMA1_BASE, 0x500 },
+	[DBG_RX_STS_RING_BASE]		= { MT_DBG_WFDMA1_BASE, 0x510 },
+	[DBG_RX_DATA_RING_BASE]		= { MT_DBG_WFDMA0_BASE, 0x500 },
+	[DBG_DMA_ICSC_FR0]		= { DBG_INVALID_BASE, 0x0f0 },
+	[DBG_DMA_ICSC_FR1]		= { DBG_INVALID_BASE, 0x0f4 },
+	[DBG_TMAC_ICSCR0]		= { DBG_INVALID_BASE, 0x200 },
+	[DBG_RMAC_RXICSRPT]		= { DBG_INVALID_BASE, 0x618},
+	[DBG_MIB_M0SDR0]		= { DBG_INVALID_BASE, 0x010},
+	[DBG_MIB_M0SDR3]		= { DBG_INVALID_BASE, 0x014},
+	[DBG_MIB_M0SDR4]		= { DBG_INVALID_BASE, 0x018},
+	[DBG_MIB_M0SDR5]		= { DBG_INVALID_BASE, 0x01c},
+	[DBG_MIB_M0SDR7]		= { DBG_INVALID_BASE, 0x024},
+	[DBG_MIB_M0SDR8]		= { DBG_INVALID_BASE, 0x028},
+	[DBG_MIB_M0SDR9]		= { DBG_INVALID_BASE, 0x02C},
+	[DBG_MIB_M0SDR10]		= { DBG_INVALID_BASE, 0x030},
+	[DBG_MIB_M0SDR11]		= { DBG_INVALID_BASE, 0x034},
+	[DBG_MIB_M0SDR12]		= { DBG_INVALID_BASE, 0x038},
+	[DBG_MIB_M0SDR14]		= { DBG_INVALID_BASE, 0x040},
+	[DBG_MIB_M0SDR15]		= { DBG_INVALID_BASE, 0x044},
+	[DBG_MIB_M0SDR16]		= { DBG_INVALID_BASE, 0x048},
+	[DBG_MIB_M0SDR17]		= { DBG_INVALID_BASE, 0x04c},
+	[DBG_MIB_M0SDR18]		= { DBG_INVALID_BASE, 0x050},
+	[DBG_MIB_M0SDR19]		= { DBG_INVALID_BASE, 0x054},
+	[DBG_MIB_M0SDR20]		= { DBG_INVALID_BASE, 0x058},
+	[DBG_MIB_M0SDR21]		= { DBG_INVALID_BASE, 0x05c},
+	[DBG_MIB_M0SDR22]		= { DBG_INVALID_BASE, 0x060},
+	[DBG_MIB_M0SDR23]		= { DBG_INVALID_BASE, 0x064},
+	[DBG_MIB_M0DR0]			= { DBG_INVALID_BASE, 0x0a0},
+	[DBG_MIB_M0DR1]			= { DBG_INVALID_BASE, 0x0a4},
+	[DBG_MIB_MUBF]			= { DBG_INVALID_BASE, 0x090},
+	[DBG_MIB_M0DR6]			= { DBG_INVALID_BASE, 0x0b8},
+	[DBG_MIB_M0DR7]			= { DBG_INVALID_BASE, 0x0bc},
+	[DBG_MIB_M0DR8]			= { DBG_INVALID_BASE, 0x0c0},
+	[DBG_MIB_M0DR9]			= { DBG_INVALID_BASE, 0x0c4},
+	[DBG_MIB_M0DR10]		= { DBG_INVALID_BASE, 0x0c8},
+	[DBG_MIB_M0DR11]		= { DBG_INVALID_BASE, 0x0cc},
+	[DBG_MIB_M0DR12]		= { DBG_INVALID_BASE, 0x160},
+	[DBG_WTBLON_WDUCR]		= { DBG_INVALID_BASE, 0x0},
+	[DBG_UWTBL_WDUCR]		= { DBG_INVALID_BASE, 0x0},
+	[DBG_PLE_DRR_TABLE_CTRL]	= { DBG_INVALID_BASE, 0x388},
+	[DBG_PLE_DRR_TABLE_RDATA]	= { DBG_INVALID_BASE, 0x350},
+	[DBG_PLE_PBUF_CTRL]		= { DBG_INVALID_BASE, 0x014},
+	[DBG_PLE_QUEUE_EMPTY]		= { DBG_INVALID_BASE, 0x0b0},
+	[DBG_PLE_FREEPG_CNT]		= { DBG_INVALID_BASE, 0x100},
+	[DBG_PLE_FREEPG_HEAD_TAIL]	= { DBG_INVALID_BASE, 0x104},
+	[DBG_PLE_PG_HIF_GROUP]		= { DBG_INVALID_BASE, 0x110},
+	[DBG_PLE_HIF_PG_INFO]		= { DBG_INVALID_BASE, 0x114},
+	[DBG_PLE_PG_HIF_TXCMD_GROUP]	= { DBG_INVALID_BASE, 0x120},
+	[DBG_PLE_HIF_TXCMD_PG_INFO]	= { DBG_INVALID_BASE, 0x124},
+	[DBG_PLE_PG_CPU_GROUP]		= { DBG_INVALID_BASE, 0x150},
+	[DBG_PLE_CPU_PG_INFO]		= { DBG_INVALID_BASE, 0x154},
+	[DBG_PLE_FL_QUE_CTRL]		= { DBG_INVALID_BASE, 0x1b0},
+	[DBG_PLE_NATIVE_TXCMD_Q_EMPTY]	= { DBG_INVALID_BASE, 0x22c},
+	[DBG_PLE_TXCMD_Q_EMPTY]		= { DBG_INVALID_BASE, 0x230},
+	[DBG_PLE_AC_QEMPTY]		= { DBG_INVALID_BASE, 0x500},
+	[DBG_PLE_AC_OFFSET]		= { DBG_INVALID_BASE, 0x040},
+	[DBG_PLE_STATION_PAUSE]		= { DBG_INVALID_BASE, 0x400},
+	[DBG_PLE_DIS_STA_MAP]		= { DBG_INVALID_BASE, 0x440},
+	[DBG_PSE_PBUF_CTRL]		= { DBG_INVALID_BASE, 0x014},
+	[DBG_PSE_FREEPG_CNT]		= { DBG_INVALID_BASE, 0x100},
+	[DBG_PSE_FREEPG_HEAD_TAIL]	= { DBG_INVALID_BASE, 0x104},
+	[DBG_PSE_HIF0_PG_INFO]		= { DBG_INVALID_BASE, 0x114},
+	[DBG_PSE_PG_HIF1_GROUP]		= { DBG_INVALID_BASE, 0x118},
+	[DBG_PSE_HIF1_PG_INFO]		= { DBG_INVALID_BASE, 0x11c},
+	[DBG_PSE_PG_CPU_GROUP]		= { DBG_INVALID_BASE, 0x150},
+	[DBG_PSE_CPU_PG_INFO]		= { DBG_INVALID_BASE, 0x154},
+	[DBG_PSE_PG_PLE_GROUP]		= { DBG_INVALID_BASE, 0x160},
+	[DBG_PSE_PLE_PG_INFO]		= { DBG_INVALID_BASE, 0x164},
+	[DBG_PSE_PG_LMAC0_GROUP]	= { DBG_INVALID_BASE, 0x170},
+	[DBG_PSE_LMAC0_PG_INFO]		= { DBG_INVALID_BASE, 0x174},
+	[DBG_PSE_PG_LMAC1_GROUP]	= { DBG_INVALID_BASE, 0x178},
+	[DBG_PSE_LMAC1_PG_INFO]		= { DBG_INVALID_BASE, 0x17c},
+	[DBG_PSE_PG_LMAC2_GROUP]	= { DBG_INVALID_BASE, 0x180},
+	[DBG_PSE_LMAC2_PG_INFO]		= { DBG_INVALID_BASE, 0x184},
+	[DBG_PSE_PG_LMAC3_GROUP]	= { DBG_INVALID_BASE, 0x188},
+	[DBG_PSE_LMAC3_PG_INFO]		= { DBG_INVALID_BASE, 0x18c},
+	[DBG_PSE_PG_MDP_GROUP]		= { DBG_INVALID_BASE, 0x198},
+	[DBG_PSE_MDP_PG_INFO]		= { DBG_INVALID_BASE, 0x19c},
+	[DBG_PSE_PG_PLE1_GROUP]		= { DBG_INVALID_BASE, 0x168},
+	[DBG_PSE_PLE1_PG_INFO]		= { DBG_INVALID_BASE, 0x16c},
+	[DBG_AGG_AALCR0]		= { DBG_INVALID_BASE, 0x048},
+	[DBG_AGG_AALCR1]		= { DBG_INVALID_BASE, 0x04c},
+	[DBG_AGG_AALCR2]		= { DBG_INVALID_BASE, 0x050},
+	[DBG_AGG_AALCR3]		= { DBG_INVALID_BASE, 0x054},
+	[DBG_AGG_AALCR4]		= { DBG_INVALID_BASE, 0x058},
+	[DBG_AGG_B0BRR0]		= { DBG_INVALID_BASE, 0x100},
+	[DBG_AGG_B1BRR0]		= { DBG_INVALID_BASE, 0x104},
+	[DBG_AGG_B2BRR0]		= { DBG_INVALID_BASE, 0x108},
+	[DBG_AGG_B3BRR0]		= { DBG_INVALID_BASE, 0x10c},
+	[DBG_AGG_AWSCR0]		= { DBG_INVALID_BASE, 0x030},
+	[DBG_AGG_PCR0]			= { DBG_INVALID_BASE, 0x040},
+	[DBG_AGG_TTCR0]			= { DBG_INVALID_BASE, 0x04c},
+	[DBG_MIB_M0ARNG0]		= { DBG_INVALID_BASE, 0x4b8},
+	[DBG_MIB_M0DR2]			= { DBG_INVALID_BASE, 0x0a8},
+	[DBG_MIB_M0DR13]		= { DBG_INVALID_BASE, 0x164},
+};
+
+/* mt7986/mt7916 regs with different base and offset */
+static const struct __dbg_reg mt7916_dbg_reg[] = {
+	[DBG_WFDMA_WED_TX_CTRL]		= { MT_DBG_WFDMA_EXT_CSR_BASE, 0x300 },
+	[DBG_WFDMA_WED_RX_CTRL]		= { MT_DBG_WFDMA_EXT_CSR_BASE, 0x400 },
+	[DBG_INT_SOURCE_CSR]		= { MT_DBG_WFDMA0_BASE, 0x200 },
+	[DBG_INT_MASK_CSR]		= { MT_DBG_WFDMA0_BASE, 0x204 },
+	[DBG_INT1_SOURCE_CSR]		= { MT_DBG_WFDMA0_PCIE1_BASE, 0x200 },
+	[DBG_INT1_MASK_CSR]		= { MT_DBG_WFDMA0_PCIE1_BASE, 0x204 },
+	[DBG_TX_RING_BASE]		= { MT_DBG_WFDMA0_BASE, 0x400 },
+	[DBG_RX_EVENT_RING_BASE]	= { MT_DBG_WFDMA0_BASE, 0x500 },
+	[DBG_RX_STS_RING_BASE]		= { MT_DBG_WFDMA0_BASE, 0x520 },
+	[DBG_RX_DATA_RING_BASE]		= { MT_DBG_WFDMA0_BASE, 0x540 },
+	[DBG_DMA_ICSC_FR0]		= { DBG_INVALID_BASE, 0x05c },
+	[DBG_DMA_ICSC_FR1]		= { DBG_INVALID_BASE, 0x060 },
+	[DBG_TMAC_ICSCR0]		= { DBG_INVALID_BASE, 0x120 },
+	[DBG_RMAC_RXICSRPT]		= { DBG_INVALID_BASE, 0xd0 },
+	[DBG_MIB_M0SDR0]		= { DBG_INVALID_BASE, 0x7d8},
+	[DBG_MIB_M0SDR3]		= { DBG_INVALID_BASE, 0x698},
+	[DBG_MIB_M0SDR4]		= { DBG_INVALID_BASE, 0x788},
+	[DBG_MIB_M0SDR5]		= { DBG_INVALID_BASE, 0x780},
+	[DBG_MIB_M0SDR7]		= { DBG_INVALID_BASE, 0x5a8},
+	[DBG_MIB_M0SDR8]		= { DBG_INVALID_BASE, 0x78c},
+	[DBG_MIB_M0SDR9]		= { DBG_INVALID_BASE, 0x024},
+	[DBG_MIB_M0SDR10]		= { DBG_INVALID_BASE, 0x76c},
+	[DBG_MIB_M0SDR11]		= { DBG_INVALID_BASE, 0x790},
+	[DBG_MIB_M0SDR12]		= { DBG_INVALID_BASE, 0x558},
+	[DBG_MIB_M0SDR14]		= { DBG_INVALID_BASE, 0x564},
+	[DBG_MIB_M0SDR15]		= { DBG_INVALID_BASE, 0x564},
+	[DBG_MIB_M0SDR16]		= { DBG_INVALID_BASE, 0x7fc},
+	[DBG_MIB_M0SDR17]		= { DBG_INVALID_BASE, 0x800},
+	[DBG_MIB_M0SDR18]		= { DBG_INVALID_BASE, 0x030},
+	[DBG_MIB_M0SDR19]		= { DBG_INVALID_BASE, 0x5ac},
+	[DBG_MIB_M0SDR20]		= { DBG_INVALID_BASE, 0x5b0},
+	[DBG_MIB_M0SDR21]		= { DBG_INVALID_BASE, 0x5b4},
+	[DBG_MIB_M0SDR22]		= { DBG_INVALID_BASE, 0x770},
+	[DBG_MIB_M0SDR23]		= { DBG_INVALID_BASE, 0x774},
+	[DBG_MIB_M0DR0]			= { DBG_INVALID_BASE, 0x594},
+	[DBG_MIB_M0DR1]			= { DBG_INVALID_BASE, 0x598},
+	[DBG_MIB_MUBF]			= { DBG_INVALID_BASE, 0x7ac},
+	[DBG_MIB_M0DR6]			= { DBG_INVALID_BASE, 0x658},
+	[DBG_MIB_M0DR7]			= { DBG_INVALID_BASE, 0x65c},
+	[DBG_MIB_M0DR8]			= { DBG_INVALID_BASE, 0x56c},
+	[DBG_MIB_M0DR9]			= { DBG_INVALID_BASE, 0x570},
+	[DBG_MIB_M0DR10]		= { DBG_INVALID_BASE, 0x578},
+	[DBG_MIB_M0DR11]		= { DBG_INVALID_BASE, 0x574},
+	[DBG_MIB_M0DR12]		= { DBG_INVALID_BASE, 0x654},
+	[DBG_WTBLON_WDUCR]		= { DBG_INVALID_BASE, 0x200},
+	[DBG_UWTBL_WDUCR]		= { DBG_INVALID_BASE, 0x094},
+	[DBG_PLE_DRR_TABLE_CTRL]	= { DBG_INVALID_BASE, 0x490},
+	[DBG_PLE_DRR_TABLE_RDATA]	= { DBG_INVALID_BASE, 0x470},
+	[DBG_PLE_PBUF_CTRL]		= { DBG_INVALID_BASE, 0x004},
+	[DBG_PLE_QUEUE_EMPTY]		= { DBG_INVALID_BASE, 0x360},
+	[DBG_PLE_FREEPG_CNT]		= { DBG_INVALID_BASE, 0x380},
+	[DBG_PLE_FREEPG_HEAD_TAIL]	= { DBG_INVALID_BASE, 0x384},
+	[DBG_PLE_PG_HIF_GROUP]		= { DBG_INVALID_BASE, 0x00c},
+	[DBG_PLE_HIF_PG_INFO]		= { DBG_INVALID_BASE, 0x388},
+	[DBG_PLE_PG_HIF_TXCMD_GROUP]	= { DBG_INVALID_BASE, 0x014},
+	[DBG_PLE_HIF_TXCMD_PG_INFO]	= { DBG_INVALID_BASE, 0x390},
+	[DBG_PLE_PG_CPU_GROUP]		= { DBG_INVALID_BASE, 0x018},
+	[DBG_PLE_CPU_PG_INFO]		= { DBG_INVALID_BASE, 0x394},
+	[DBG_PLE_FL_QUE_CTRL]		= { DBG_INVALID_BASE, 0x3e0},
+	[DBG_PLE_NATIVE_TXCMD_Q_EMPTY]	= { DBG_INVALID_BASE, 0x370},
+	[DBG_PLE_TXCMD_Q_EMPTY]		= { DBG_INVALID_BASE, 0x36c},
+	[DBG_PLE_AC_QEMPTY]		= { DBG_INVALID_BASE, 0x600},
+	[DBG_PLE_AC_OFFSET]		= { DBG_INVALID_BASE, 0x080},
+	[DBG_PLE_STATION_PAUSE]		= { DBG_INVALID_BASE, 0x100},
+	[DBG_PLE_DIS_STA_MAP] 		= { DBG_INVALID_BASE, 0x180},
+	[DBG_PSE_PBUF_CTRL]		= { DBG_INVALID_BASE, 0x004},
+	[DBG_PSE_FREEPG_CNT]		= { DBG_INVALID_BASE, 0x380},
+	[DBG_PSE_FREEPG_HEAD_TAIL]	= { DBG_INVALID_BASE, 0x384},
+	[DBG_PSE_HIF0_PG_INFO]		= { DBG_INVALID_BASE, 0x150},
+	[DBG_PSE_PG_HIF1_GROUP]		= { DBG_INVALID_BASE, 0x114},
+	[DBG_PSE_HIF1_PG_INFO]		= { DBG_INVALID_BASE, 0x154},
+	[DBG_PSE_PG_CPU_GROUP]		= { DBG_INVALID_BASE, 0x118},
+	[DBG_PSE_CPU_PG_INFO]		= { DBG_INVALID_BASE, 0x158},
+	[DBG_PSE_PG_PLE_GROUP]		= { DBG_INVALID_BASE, 0x11c},
+	[DBG_PSE_PLE_PG_INFO]		= { DBG_INVALID_BASE, 0x15c},
+	[DBG_PSE_PG_LMAC0_GROUP]	= { DBG_INVALID_BASE, 0x124},
+	[DBG_PSE_LMAC0_PG_INFO]		= { DBG_INVALID_BASE, 0x164},
+	[DBG_PSE_PG_LMAC1_GROUP]	= { DBG_INVALID_BASE, 0x128},
+	[DBG_PSE_LMAC1_PG_INFO]		= { DBG_INVALID_BASE, 0x168},
+	[DBG_PSE_PG_LMAC2_GROUP]	= { DBG_INVALID_BASE, 0x12c},
+	[DBG_PSE_LMAC2_PG_INFO]		= { DBG_INVALID_BASE, 0x16c},
+	[DBG_PSE_PG_LMAC3_GROUP]	= { DBG_INVALID_BASE, 0x130},
+	[DBG_PSE_LMAC3_PG_INFO]		= { DBG_INVALID_BASE, 0x170},
+	[DBG_PSE_PG_MDP_GROUP]		= { DBG_INVALID_BASE, 0x134},
+	[DBG_PSE_MDP_PG_INFO]		= { DBG_INVALID_BASE, 0x174},
+	[DBG_PSE_PG_PLE1_GROUP]		= { DBG_INVALID_BASE, 0x120},
+	[DBG_PSE_PLE1_PG_INFO]		= { DBG_INVALID_BASE, 0x160},
+	[DBG_AGG_AALCR0]		= { DBG_INVALID_BASE, 0x028},
+	[DBG_AGG_AALCR1]		= { DBG_INVALID_BASE, 0x144},
+	[DBG_AGG_AALCR2]		= { DBG_INVALID_BASE, 0x14c},
+	[DBG_AGG_AALCR3]		= { DBG_INVALID_BASE, 0x154},
+	[DBG_AGG_AALCR4]		= { DBG_INVALID_BASE, 0x02c},
+	[DBG_AGG_B0BRR0]		= { DBG_INVALID_BASE, 0x08c},
+	[DBG_AGG_B1BRR0]		= { DBG_INVALID_BASE, 0x148},
+	[DBG_AGG_B2BRR0]		= { DBG_INVALID_BASE, 0x150},
+	[DBG_AGG_B3BRR0]		= { DBG_INVALID_BASE, 0x158},
+	[DBG_AGG_AWSCR0]		= { DBG_INVALID_BASE, 0x05c},
+	[DBG_AGG_PCR0]			= { DBG_INVALID_BASE,	0x06c},
+	[DBG_AGG_TTCR0]			= { DBG_INVALID_BASE, 0x07c},
+	[DBG_MIB_M0ARNG0]		= { DBG_INVALID_BASE, 0x0b0},
+	[DBG_MIB_M0DR2]			= { DBG_INVALID_BASE, 0x7dc},
+	[DBG_MIB_M0DR13]		= { DBG_INVALID_BASE, 0x7ec},
+};
+
+static const struct __dbg_mask mt7915_dbg_mask[] = {
+	[DBG_MIB_M0SDR10_RX_MDRDY_COUNT]= {25, 0},
+	[DBG_MIB_M0SDR14_AMPDU]		= {23, 0},
+	[DBG_MIB_M0SDR15_AMPDU_ACKED]	= {23, 0},
+	[DBG_MIB_RX_FCS_ERROR_COUNT]	= {15, 0},
+};
+
+static const struct __dbg_mask mt7916_dbg_mask[] = {
+	[DBG_MIB_M0SDR10_RX_MDRDY_COUNT]= {31, 0},
+	[DBG_MIB_M0SDR14_AMPDU]		= {31, 0},
+	[DBG_MIB_M0SDR15_AMPDU_ACKED]	= {31, 0},
+	[DBG_MIB_RX_FCS_ERROR_COUNT]	= {31, 16},
+};
+
+/* used to differentiate between generations */
+struct mt7915_dbg_reg_desc {
+	const u32 id;
+	const u32 *base_rev;
+	const struct __dbg_reg *reg_rev;
+	const struct __dbg_mask *mask_rev;
+};
+
+static const struct mt7915_dbg_reg_desc dbg_reg_s[] = {
+	{ 0x7915,
+	  mt7915_dbg_base,
+	  mt7915_dbg_reg,
+	  mt7915_dbg_mask
+	},
+	{ 0x7906,
+	  mt7916_dbg_base,
+	  mt7916_dbg_reg,
+	  mt7916_dbg_mask
+	},
+	{ 0x7981,
+	  mt7981_dbg_base,
+	  mt7916_dbg_reg,
+	  mt7916_dbg_mask
+	},
+	{ 0x7986,
+	  mt7986_dbg_base,
+	  mt7916_dbg_reg,
+	  mt7916_dbg_mask
+	},
+};
+
+struct bin_debug_hdr {
+	__le32 magic_num;
+	__le16 serial_id;
+	__le16 msg_type;
+	__le16 len;
+	__le16 des_len;	/* descriptor len for rxd */
+} __packed;
+
+/* fw wm info related strcture */
+struct cos_msg_trace_t {
+	u32 dest_id;
+	u8 msg_id;
+	u32 pcount;
+	u32 qread;
+	u32 ts_enq;
+	u32 ts_deq;
+	u32 ts_finshq;
+};
+
+struct cos_task_info_struct {
+	u32	task_name_ptr;
+	u32	task_qname_ptr;
+	u32	task_priority;
+	u16	task_stack_size;
+	u8 	task_ext_qsize;
+	u32	task_id;
+	u32	task_ext_qid;
+	u32 	task_main_func;
+	u32	task_init_func;
+};
+
+struct cos_program_trace_t{
+	u32    _dest_id;
+	u32    _msg_id;
+	u32    _msg_sn;
+	u32    _ts_gpt2;
+	u32    _LP;
+	char   _name[12];
+} ;
+
+struct mt7915_cos_program_trace_t{
+	u32    _dest_id;
+	u32    _msg_id;
+	u32    _msg_sn;
+	u32    _ts_gpt2;
+	u32    _ts_gpt4;
+	u32    _LP;
+	char   _name[12];
+} ;
+
+struct cos_msg_type {
+	u32	finish_cnt;
+	u32	exe_time;
+	u32 	exe_peak;
+};
+
+struct cos_task_type{
+	u32           tc_stack_start;
+	u32           tc_stack_end;
+	u32           tc_stack_pointer;
+	u32           tc_stack_size;
+	u32           tc_schedule_count;
+	u8            tc_status;
+	u8            tc_priority;
+	u8            tc_weight;
+	u8            RSVD[28];
+	u32    		 tc_entry_func;
+	u32           tc_exe_start;
+	u32           tc_exe_time;
+	u32           tc_exe_peak;
+	u32           tc_pcount;
+};
+
+#define __DBG_REG_MAP(_dev, id, ofs)	((_dev)->dbg_reg->base_rev[(id)] + (ofs))
+#define __DBG_REG_BASE(_dev, id)	((_dev)->dbg_reg->reg_rev[(id)].base)
+#define __DBG_REG_OFFS(_dev, id)	((_dev)->dbg_reg->reg_rev[(id)].offs)
+
+#define __DBG_MASK(_dev, id)		GENMASK((_dev)->dbg_reg->mask_rev[(id)].end,	\
+						(_dev)->dbg_reg->mask_rev[(id)].start)
+#define __DBG_REG(_dev, id)		__DBG_REG_MAP((_dev), __DBG_REG_BASE((_dev), (id)),	\
+						__DBG_REG_OFFS((_dev), (id)))
+
+#define __DBG_FIELD_GET(id, _reg)	(((_reg) & __DBG_MASK(dev, (id))) >>	\
+						dev->dbg_reg->mask_rev[(id)].start)
+#define __DBG_FIELD_PREP(id, _reg)	(((_reg) << dev->dbg_reg->mask_rev[(id)].start) &	\
+						__DBG_MASK(dev, (id)))
+
+
+#define MT_DBG_TX_RING_BASE			__DBG_REG(dev, DBG_TX_RING_BASE)
+#define MT_DBG_RX_EVENT_RING_BASE		__DBG_REG(dev, DBG_RX_EVENT_RING_BASE)
+#define MT_DBG_RX_STS_RING_BASE			__DBG_REG(dev, DBG_RX_STS_RING_BASE)
+#define MT_DBG_RX_DATA_RING_BASE		__DBG_REG(dev, DBG_RX_DATA_RING_BASE)
+#define MT_DBG_WFDMA_WED_TX_CTRL_BASE		__DBG_REG(dev, DBG_WFDMA_WED_TX_CTRL)
+#define MT_DBG_WFDMA_WED_RX_CTRL_BASE		__DBG_REG(dev, DBG_WFDMA_WED_RX_CTRL)
+
+#define MT_DBG_TX_RING_CTRL(n)			(MT_DBG_TX_RING_BASE + (0x10 * (n)))
+#define MT_DBG_RX_DATA_RING_CTRL(n)		(MT_DBG_RX_DATA_RING_BASE + (0x10 * (n)))
+#define MT_DBG_RX_EVENT_RING_CTRL(n)		(MT_DBG_RX_EVENT_RING_BASE + (0x10 * (n)))
+
+#define MT_DBG_WFDMA_WED_TX_CTRL(n)		(MT_DBG_WFDMA_WED_TX_CTRL_BASE + (0x10 * (n)))
+#define MT_DBG_WFDMA_WED_RX_CTRL(n)		(MT_DBG_WFDMA_WED_RX_CTRL_BASE + (0x10 * (n)))
+/* WFDMA COMMON */
+#define MT_DBG_INT_SOURCE_CSR			__DBG_REG(dev, DBG_INT_SOURCE_CSR)
+#define MT_DBG_INT_MASK_CSR			__DBG_REG(dev, DBG_INT_MASK_CSR)
+#define MT_DBG_INT1_SOURCE_CSR			__DBG_REG(dev, DBG_INT1_SOURCE_CSR)
+#define MT_DBG_INT1_MASK_CSR			__DBG_REG(dev, DBG_INT1_MASK_CSR)
+
+/* WFDMA0 */
+#define MT_DBG_WFDMA0(_ofs)			__DBG_REG_MAP(dev, MT_DBG_WFDMA0_BASE, (_ofs))
+
+#define MT_DBG_WFDMA0_INT_SOURCE_CSR		MT_DBG_WFDMA0(0x200)
+#define MT_DBG_WFDMA0_INT_MASK_CSR		MT_DBG_WFDMA0(0x204)
+
+#define MT_DBG_WFDMA0_GLO_CFG			MT_DBG_WFDMA0(0x208)
+#define MT_DBG_WFDMA0_GLO_CFG_TX_DMA_EN		BIT(0)
+#define MT_DBG_WFDMA0_GLO_CFG_RX_DMA_EN		BIT(2)
+#define MT_DBG_WFDMA0_GLO_CFG_TX_BUSY_MASK	BIT(1)
+#define MT_DBG_WFDMA0_GLO_CFG_RX_BUSY_MASK	BIT(3)
+
+
+/* WFDMA1 */
+#define MT_DBG_WFDMA1(_ofs)			__DBG_REG_MAP(dev, MT_DBG_WFDMA1_BASE, (_ofs))
+#define MT_DBG_WFDMA1_INT_SOURCE_CSR		MT_DBG_WFDMA1(0x200)
+#define MT_DBG_WFDMA1_INT_MASK_CSR		MT_DBG_WFDMA1(0x204)
+
+#define MT_DBG_WFDMA1_GLO_CFG			MT_DBG_WFDMA1(0x208)
+
+#define MT_DBG_WFDMA1_GLO_CFG_TX_DMA_EN		BIT(0)
+#define MT_DBG_WFDMA1_GLO_CFG_RX_DMA_EN		BIT(2)
+#define MT_DBG_WFDMA1_GLO_CFG_TX_BUSY_MASK	BIT(1)
+#define MT_DBG_WFDMA1_GLO_CFG_RX_BUSY_MASK	BIT(3)
+
+/* WFDMA0 PCIE1 */
+#define MT_DBG_WFDMA0_PCIE1(_ofs)		__DBG_REG_MAP(dev, MT_DBG_WFDMA0_PCIE1_BASE, (_ofs))
+
+#define MT_DBG_WFDMA0_PCIE1_INT_SOURCE_CSR	MT_DBG_WFDMA0_PCIE1(0x200)
+#define MT_DBG_WFDMA0_PCIE1_INT_MASK_CSR	MT_DBG_WFDMA0_PCIE1(0x204)
+#define MT_DBG_WFDMA0_PCIE1_GLO_CFG		MT_DBG_WFDMA0_PCIE1(0x208)
+#define MT_DBG_WFDMA0_PCIE1_RX1_CTRL0		MT_DBG_WFDMA1_PCIE1(0x510)
+
+#define MT_DBG_WFDMA0_PCIE1_GLO_CFG_TX_DMA_EN		BIT(0)
+#define MT_DBG_WFDMA0_PCIE1_GLO_CFG_TX_BUSY_MASK	BIT(1)
+#define MT_DBG_WFDMA0_PCIE1_GLO_CFG_RX_DMA_EN		BIT(2)
+#define MT_DBG_WFDMA0_PCIE1_GLO_CFG_RX_BUSY_MASK	BIT(3)
+
+/* WFDMA1 PCIE1 */
+#define MT_DBG_WFDMA1_PCIE1(_ofs)		__DBG_REG_MAP(dev, MT_DBG_WFDMA1_PCIE1_BASE, (_ofs))
+#define MT_DBG_WFDMA1_PCIE1_INT_SOURCE_CSR	MT_DBG_WFDMA1_PCIE1(0x200)
+#define MT_DBG_WFDMA1_PCIE1_INT_MASK_CSR	MT_DBG_WFDMA1_PCIE1(0x204)
+#define MT_DBG_WFDMA1_PCIE1_GLO_CFG		MT_DBG_WFDMA1_PCIE1(0x208)
+#define MT_DBG_WFDMA1_PCIE1_TX19_CTRL0		MT_DBG_WFDMA1_PCIE1(0x330)
+#define MT_DBG_WFDMA1_PCIE1_RX2_CTRL0		MT_DBG_WFDMA1_PCIE1(0x520)
+
+#define MT_DBG_WFDMA1_PCIE1_GLO_CFG_TX_DMA_EN		BIT(0)
+#define MT_DBG_WFDMA1_PCIE1_GLO_CFG_TX_BUSY_MASK	BIT(1)
+#define MT_DBG_WFDMA1_PCIE1_GLO_CFG_RX_DMA_EN		BIT(2)
+#define MT_DBG_WFDMA1_PCIE1_GLO_CFG_RX_BUSY_MASK	BIT(3)
+
+#define MT_DBG_WFDMA_HOST_DMA0_GLO_CFG_RX_DMA_EN_MASK	BIT(2)
+#define MT_DBG_WFDMA_HOST_DMA0_GLO_CFG_TX_DMA_EN_MASK	BIT(0)
+#define MT_DBG_WFDMA_HOST_DMA0_GLO_CFG_RX_DMA_BUSY_MASK	BIT(3)
+#define MT_DBG_WFDMA_HOST_DMA0_GLO_CFG_TX_DMA_BUSY_MASK	BIT(1)
+
+
+/* WF DMA TOP: band 0(0x820E7000),band 1(0x820F7000) */
+#define MT_DBG_WF_DMA_BASE(_band)		((_band) ? 0x820F7000 : 0x820E7000)
+#define MT_DBG_WF_DMA(_band, ofs)		(MT_WF_DMA_BASE(_band) + (ofs))
+
+#define MT_DBG_DMA_DCR0(_band)			MT_DBG_WF_DMA((_band), 0x000)
+#define MT_DBG_DMA_DCR0_MAX_RX_LEN		GENMASK(15, 3)
+#define MT_DBG_DMA_DCR0_RXD_G5_EN		BIT(23)
+
+#define MT_DBG_DMA_ICSC_FR0(_band)		MT_DBG_WF_DMA((_band), __DBG_REG_OFFS(dev, DBG_DMA_ICSC_FR0))
+#define MT_DBG_DMA_ICSC_FR0_RXBF_EN		BIT(25)
+#define MT_DBG_DMA_ICSC_FR0_EN			BIT(24)
+#define MT_DBG_DMA_ICSC_FR0_TOUT_MASK		GENMASK(23, 16)
+#define MT_DBG_DMA_ICSC_FR0_PID_MASK		GENMASK(9, 8)
+#define MT_DBG_DMA_ICSC_FR0_QID_MASK		GENMASK(6, 0)
+
+#define MT_DBG_DMA_ICSC_FR1(_band)		MT_DBG_WF_DMA((_band), __DBG_REG_OFFS(dev, DBG_DMA_ICSC_FR1))
+#define MT_DBG_DMA_ICSC_FR1_AGG_SIZE_MASK	GENMASK(26, 16)
+#define MT_DBG_DMA_ICSC_FR1_MAX_FRAME_SIZE_MASK	GENMASK(10, 0)
+
+/* TMAC: band 0(0x820e4000), band 1(0x820f4000) */
+#define MT_DBG_WF_TMAC_BASE(_band)		((_band) ? 0x820f4000 : 0x820e4000)
+#define MT_DBG_WF_TMAC(_band, ofs)		(MT_DBG_WF_TMAC_BASE(_band) + (ofs))
+
+#define MT_DBG_TMAC_ICSCR0(_band)		MT_DBG_WF_TMAC((_band), __DBG_REG_OFFS(dev, DBG_TMAC_ICSCR0))
+#define MT_DBG_TMAC_ICSCR0_ICSRPT_EN        	BIT(0)
+
+/* RMAC: band 0(0x820E5000), band 1(0x820f5000) */
+#define MT_DBG_WF_RMAC_BASE(_band)		((_band) ? 0x820f5000 : 0x820E5000)
+#define MT_DBG_WF_RMAC(_band, ofs)		(MT_DBG_WF_RMAC_BASE(_band) + (ofs))
+
+#define MT_DBG_RMAC_RXICSRPT(_band)		MT_DBG_WF_RMAC((_band), __DBG_REG_OFFS(dev, DBG_RMAC_RXICSRPT))
+#define MT_DBG_RMAC_RXICSRPT_ICSRPT_EN		BIT(0)
+
+/* MIB: band 0(0x820ed000), band 1(0x820fd000) */
+#define MT_DBG_MIB_BASE(_band)			((_band) ? 0x820fd000 : 0x820ed000)
+#define MT_DBG_MIB(_band, ofs)			(MT_DBG_MIB_BASE(_band) + (ofs))
+
+
+#define MT_DBG_MIB_M0SCR0(_band)		MT_DBG_MIB((_band), 0x00)
+#define MT_DBG_MIB_M0PBSCR(_band)		MT_DBG_MIB((_band), 0x04)
+
+#define MT_DBG_MIB_M0SDR0(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0SDR0))
+#define MT_DBG_MIB_M0SDR3(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0SDR3))
+#define MT_DBG_MIB_RX_FCS_ERROR_COUNT_MASK	__DBG_MASK(dev, DBG_MIB_RX_FCS_ERROR_COUNT)
+#define MT_DBG_MIB_M0SDR4(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0SDR4))
+#define MT_DBG_MIB_M0SDR5(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0SDR5))
+#define MT_DBG_MIB_M0SDR6(_band)		MT_DBG_MIB((_band), 0x20)
+#define MT_DBG_MIB_M0SDR7(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0SDR7))
+#define MT_DBG_MIB_M0SDR8(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0SDR8))
+#define MT_DBG_MIB_M0SDR9(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0SDR9))
+#define MT_DBG_MIB_M0SDR10(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0SDR10))
+#define MT_DBG_MIB_M0SDR10_RX_MDRDY_COUNT_MASK	__DBG_MASK(dev, DBG_MIB_M0SDR10_RX_MDRDY_COUNT)
+#define MT_DBG_MIB_M0SDR11(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0SDR11))
+
+#define MT_DBG_MIB_M0SDR12(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0SDR12))
+
+#define MT_DBG_MIB_M0SDR14(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0SDR14))
+#define MT_DBG_MIB_M0SDR14_AMPDU_MASK		__DBG_MASK(dev, DBG_MIB_M0SDR14_AMPDU)
+#define MT_DBG_MIB_M0SDR15(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0SDR15))
+#define MT_DBG_MIB_M0SDR15_AMPDU_ACKED_MASK	__DBG_MASK(dev, DBG_MIB_M0SDR15_AMPDU_ACKED)
+#define MT_DBG_MIB_M0SDR16(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0SDR16))
+#define MT_DBG_MIB_M0SDR17(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0SDR17))
+#define MT_DBG_MIB_M0SDR18(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0SDR18))
+#define MT_DBG_MIB_M0SDR19(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0SDR19))
+#define MT_DBG_MIB_M0SDR20(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0SDR20))
+#define MT_DBG_MIB_M0SDR21(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0SDR21))
+#define MT_DBG_MIB_M0SDR22(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0SDR22))
+#define MT_DBG_MIB_M0SDR23(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0SDR23))
+#define MT_DBG_MIB_M0DR0(_band)			MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0DR0))
+#define MT_DBG_MIB_M0DR1(_band)			MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0DR1))
+
+#define MT_DBG_MIB_MUBF(_band)			MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_MUBF))
+#define MT_DBG_MIB_M0DR6(_band)			MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0DR6))
+#define MT_DBG_MIB_M0DR7(_band)			MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0DR7))
+#define MT_DBG_MIB_M0DR8(_band)			MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0DR8))
+#define MT_DBG_MIB_M0DR9(_band)			MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0DR9))
+#define MT_DBG_MIB_M0DR10(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0DR10))
+#define MT_DBG_MIB_M0DR11(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0DR11))
+ #define MT_DBG_MIB_M0DR12(_band)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0DR12))
+
+/* WTBLON TOP: 0x820D4000/pcie(0x34000) rbus(0x434000) */
+#define MT_DBG_WTBLON_TOP_BASE			0x820D4000
+#define MT_DBG_WTBLON_TOP(ofs)			(MT_WTBLON_TOP_BASE + (ofs))
+#define MT_DBG_WTBLON_TOP_WDUCR			MT_DBG_WTBLON_TOP(__DBG_REG_OFFS(dev, DBG_WTBLON_WDUCR))
+#define MT_DBG_WTBLON_TOP_WDUCR_GROUP		GENMASK(2, 0)
+
+#define WF_WTBLON_TOP_B0BTCRn_ADDR		(MT_DBG_WTBLON_TOP_BASE + 0x1000) // 5000
+#define WF_WTBLON_TOP_B0BTBCRn_ADDR		(MT_DBG_WTBLON_TOP_BASE + 0x1010) // 5010
+#define WF_WTBLON_TOP_B0BRCRn_ADDR		(MT_DBG_WTBLON_TOP_BASE + 0x1020) // 5020
+#define WF_WTBLON_TOP_B0BRBCRn_ADDR		(MT_DBG_WTBLON_TOP_BASE + 0x1030) // 5030
+#define WF_WTBLON_TOP_B0BTDCRn_ADDR		(MT_DBG_WTBLON_TOP_BASE + 0x1040) // 5040
+#define WF_WTBLON_TOP_B0BRDCRn_ADDR		(MT_DBG_WTBLON_TOP_BASE + 0x1050) // 5050
+#define WF_WTBLON_TOP_B0MBTCRn_ADDR		(MT_DBG_WTBLON_TOP_BASE + 0x1100) // 5100
+#define WF_WTBLON_TOP_B0MBTBCRn_ADDR		(MT_DBG_WTBLON_TOP_BASE + 0x1140) // 5140
+#define WF_WTBLON_TOP_B0MBRCRn_ADDR		(MT_DBG_WTBLON_TOP_BASE + 0x1180) // 5180
+#define WF_WTBLON_TOP_B0MBRBCRn_ADDR 		(MT_DBG_WTBLON_TOP_BASE + 0x11C0) // 51C0
+
+#define WF_WTBLON_TOP_B1BTCRn_ADDR		(MT_DBG_WTBLON_TOP_BASE + 0x1800) // 5800
+
+/* WTBLON TOP: 0x820C4000/pcie(0xa8000) rbus(0x4a8000) */
+#define MT_DBG_UWTBL_TOP_BASE			0x820C4000
+#define MT_DBG_UWTBL_TOP(ofs)			(MT_DBG_UWTBL_TOP_BASE + (ofs))
+
+#define MT_DBG_UWTBL_TOP_WDUCR			MT_DBG_UWTBL_TOP(__DBG_REG_OFFS(dev, DBG_UWTBL_WDUCR))
+
+#define MT_UWTBL_TOP_WDUCR_TARGET		BIT(31)
+#define MT_UWTBL_TOP_WDUCR_GROUP		GENMASK(3, 0)
+
+
+/* WTBL : 0x820D8000/pcie(0x38000) rbus(0x438000) */
+#define MT_DBG_WTBL_BASE			0x820D8000
+
+/* PLE related CRs. */
+#define MT_DBG_PLE_BASE				0x820C0000
+#define MT_DBG_PLE(ofs)				(MT_DBG_PLE_BASE + (ofs))
+
+#define MT_DBG_PLE_DRR_TAB_CTRL			MT_DBG_PLE(__DBG_REG_OFFS(dev, DBG_PLE_DRR_TABLE_CTRL))
+#define MT_DBG_PLE_DRR_TAB_RD_OFS		__DBG_REG_OFFS(dev, DBG_PLE_DRR_TABLE_RDATA)
+
+#define MT_DBG_PLE_DRR_TABLE_RDATA0		MT_DBG_PLE(MT_DBG_PLE_DRR_TAB_RD_OFS + 0x0)
+#define MT_DBG_PLE_DRR_TABLE_RDATA1		MT_DBG_PLE(MT_DBG_PLE_DRR_TAB_RD_OFS + 0x4)
+#define MT_DBG_PLE_DRR_TABLE_RDATA2		MT_DBG_PLE(MT_DBG_PLE_DRR_TAB_RD_OFS + 0x8)
+#define MT_DBG_PLE_DRR_TABLE_RDATA3		MT_DBG_PLE(MT_DBG_PLE_DRR_TAB_RD_OFS + 0xc)
+#define MT_DBG_PLE_DRR_TABLE_RDATA4		MT_DBG_PLE(MT_DBG_PLE_DRR_TAB_RD_OFS + 0x10)
+#define MT_DBG_PLE_DRR_TABLE_RDATA5		MT_DBG_PLE(MT_DBG_PLE_DRR_TAB_RD_OFS + 0x14)
+#define MT_DBG_PLE_DRR_TABLE_RDATA6		MT_DBG_PLE(MT_DBG_PLE_DRR_TAB_RD_OFS + 0x18)
+#define MT_DBG_PLE_DRR_TABLE_RDATA7		MT_DBG_PLE(MT_DBG_PLE_DRR_TAB_RD_OFS+ 0x1c)
+
+#define MT_DBG_PLE_PBUF_CTRL_ADDR		MT_DBG_PLE(__DBG_REG_OFFS(dev, DBG_PLE_PBUF_CTRL))
+#define MT_DBG_PLE_QUEUE_EMPTY			MT_DBG_PLE(__DBG_REG_OFFS(dev, DBG_PLE_QUEUE_EMPTY))
+#define MT_DBG_PLE_FREEPG_CNT			MT_DBG_PLE(__DBG_REG_OFFS(dev, DBG_PLE_FREEPG_CNT))
+#define MT_DBG_PLE_FREEPG_HEAD_TAIL		MT_DBG_PLE(__DBG_REG_OFFS(dev, DBG_PLE_FREEPG_HEAD_TAIL))
+#define MT_DBG_PLE_PG_HIF_GROUP			MT_DBG_PLE(__DBG_REG_OFFS(dev, DBG_PLE_PG_HIF_GROUP))
+#define MT_DBG_PLE_HIF_PG_INFO			MT_DBG_PLE(__DBG_REG_OFFS(dev, DBG_PLE_HIF_PG_INFO))
+#define MT_DBG_PLE_PG_HIF_TXCMD_GROUP		MT_DBG_PLE(__DBG_REG_OFFS(dev, DBG_PLE_PG_HIF_TXCMD_GROUP))
+#define MT_DBG_PLE_HIF_TXCMD_PG_INFO		MT_DBG_PLE(__DBG_REG_OFFS(dev, DBG_PLE_HIF_TXCMD_PG_INFO))
+#define MT_DBG_PLE_PG_CPU_GROUP			MT_DBG_PLE(__DBG_REG_OFFS(dev, DBG_PLE_PG_CPU_GROUP))
+#define MT_DBG_PLE_CPU_PG_INFO			MT_DBG_PLE(__DBG_REG_OFFS(dev, DBG_PLE_CPU_PG_INFO))
+#define PLE_FL_QUE_CTRL_OFFSET			__DBG_REG_OFFS(dev, DBG_PLE_FL_QUE_CTRL)
+#define MT_DBG_PLE_FL_QUE_CTRL0			MT_DBG_PLE(PLE_FL_QUE_CTRL_OFFSET + 0x0)
+#define MT_DBG_PLE_FL_QUE_CTRL1			MT_DBG_PLE(PLE_FL_QUE_CTRL_OFFSET + 0x4)
+#define MT_DBG_PLE_FL_QUE_CTRL2			MT_DBG_PLE(PLE_FL_QUE_CTRL_OFFSET + 0x8)
+#define MT_DBG_PLE_FL_QUE_CTRL3			MT_DBG_PLE(PLE_FL_QUE_CTRL_OFFSET + 0xc)
+#define MT_DBG_PLE_NATIVE_TXCMD_Q_EMPTY		MT_DBG_PLE(__DBG_REG_OFFS(dev, DBG_PLE_NATIVE_TXCMD_Q_EMPTY))
+#define MT_DBG_PLE_TXCMD_Q_EMPTY		MT_DBG_PLE(__DBG_REG_OFFS(dev, DBG_PLE_TXCMD_Q_EMPTY))
+
+#define MT_DBG_PLE_PBUF_CTRL_PAGE_SIZE_MASK		BIT(31)
+#define MT_DBG_PLE_PBUF_CTRL_OFFSET_MASK 		GENMASK(25, 17)
+#define MT_DBG_PLE_PBUF_CTRL_TOTAL_PAGE_NUM_MASK	GENMASK(11, 0)
+
+#define MT_DBG_PLE_FREEPG_CNT_FREEPG_CNT_MASK		GENMASK(11, 0)
+#define MT_DBG_PLE_FREEPG_CNT_FFA_CNT_MASK		GENMASK(27, 16)
+#define MT_DBG_PLE_FREEPG_HEAD_TAIL_FREEPG_TAIL_MASK	GENMASK(27, 16)
+#define MT_DBG_PLE_FREEPG_HEAD_TAIL_FREEPG_HEAD_MASK	GENMASK(11, 0)
+#define MT_DBG_PLE_PG_HIF_GROUP_HIF_MAX_QUOTA_MASK	GENMASK(27, 16)
+#define MT_DBG_PLE_PG_HIF_GROUP_HIF_MIN_QUOTA_MASK	GENMASK(11, 0)
+
+#define MT_DBG_PLE_HIF_PG_INFO_HIF_SRC_CNT_MASK		GENMASK(27, 16)
+#define MT_DBG_PLE_HIF_PG_INFO_HIF_RSV_CNT_MASK		GENMASK(11, 0)
+
+#define MT_DBG_PLE_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MAX_QUOTA_MASK	GENMASK(27, 16)
+#define MT_DBG_PLE_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MIN_QUOTA_MASK	GENMASK(11, 0)
+
+#define MT_DBG_PLE_HIF_TXCMD_PG_INFO_HIF_TXCMD_SRC_CNT_MASK	GENMASK(27, 16)
+#define MT_DBG_PLE_HIF_TXCMD_PG_INFO_HIF_TXCMD_RSV_CNT_MASK	GENMASK(11, 0)
+
+#define MT_DBG_PLE_TXCMD_PG_INFO_HIF_TXCMD_SRC_CNT_MASK GENMASK(27, 16)
+#define MT_DBG_PLE_TXCMD_PG_INFO_HIF_TXCMD_RSV_CNT_MASK	GENMASK(11, 0)
+
+#define MT_DBG_PLE_PG_CPU_GROUP_CPU_MAX_QUOTA_MASK	GENMASK(27, 16)
+#define MT_DBG_PLE_PG_CPU_GROUP_CPU_MIN_QUOTA_MASK 	GENMASK(11, 0)
+
+#define MT_DBG_PLE_CPU_PG_INFO_CPU_SRC_CNT_MASK		GENMASK(27, 16)
+#define MT_DBG_PLE_CPU_PG_INFO_CPU_RSV_CNT_MASK 	GENMASK(11, 0)
+
+#define MT_DBG_PLE_Q_EMPTY_ALL_AC_EMPTY_MASK		BIT(24)
+#define MT_DBG_PLE_FL_QUE_CTRL0_EXECUTE_MASK		BIT(31)
+#define MT_DBG_PLE_FL_QUE_CTRL0_Q_BUF_QID_MASK 		GENMASK(30, 24)
+
+#define MT_PLE_FL_QUE_CTRL0_Q_BUF_QID_SHFT		24
+#define MT_PLE_FL_QUE_CTRL0_Q_BUF_PID_SHFT             	10
+
+#define MT_DBG_PLE_FL_QUE_CTRL2_Q_TAIL_FID_MASK		GENMASK(27, 16)
+#define MT_DBG_PLE_FL_QUE_CTRL2_Q_HEAD_FID_MASK		GENMASK(11, 0)
+#define MT_DBG_PLE_FL_QUE_CTRL3_Q_PKT_NUM_MASK		GENMASK(11, 0)
+
+#define MT_DBG_PLE_STATION_PAUSE(n)		MT_DBG_PLE(__DBG_REG_OFFS(dev, DBG_PLE_STATION_PAUSE) + ((n) << 2))
+#define MT_DBG_PLE_DIS_STA_MAP(n)		MT_DBG_PLE(__DBG_REG_OFFS(dev, DBG_PLE_DIS_STA_MAP) + ((n) << 2))
+#define MT_DBG_PLE_AC_QEMPTY(ac, n)		MT_DBG_PLE(__DBG_REG_OFFS(dev, DBG_PLE_AC_QEMPTY) +	\
+							   __DBG_REG_OFFS(dev, DBG_PLE_AC_OFFSET) * (ac) + ((n) << 2))
+
+#define MT_DBG_PLE_AMSDU_PACK_MSDU_CNT(n)	MT_DBG_PLE(0x10e0 + ((n) << 2))
+
+/* pseinfo related CRs. */
+#define MT_DBG_PSE_BASE				0x820C8000
+#define MT_DBG_PSE(ofs)				(MT_DBG_PSE_BASE + (ofs))
+
+#define MT_DBG_PSE_PBUF_CTRL			MT_DBG_PSE(__DBG_REG_OFFS(dev, DBG_PSE_PBUF_CTRL))
+#define MT_DBG_PSE_QUEUE_EMPTY			MT_DBG_PSE(0x0b0)
+#define MT_DBG_PSE_FREEPG_CNT			MT_DBG_PSE(__DBG_REG_OFFS(dev, DBG_PSE_FREEPG_CNT))
+#define MT_DBG_PSE_FREEPG_HEAD_TAIL		MT_DBG_PSE(__DBG_REG_OFFS(dev, DBG_PSE_FREEPG_HEAD_TAIL))
+#define MT_DBG_PSE_PG_HIF0_GROUP		MT_DBG_PSE(0x110)
+#define MT_DBG_PSE_HIF0_PG_INFO			MT_DBG_PSE(__DBG_REG_OFFS(dev, DBG_PSE_HIF0_PG_INFO))
+#define MT_DBG_PSE_PG_HIF1_GROUP		MT_DBG_PSE(__DBG_REG_OFFS(dev, DBG_PSE_PG_HIF1_GROUP))
+#define MT_DBG_PSE_HIF1_PG_INFO			MT_DBG_PSE(__DBG_REG_OFFS(dev, DBG_PSE_HIF1_PG_INFO))
+#define MT_DBG_PSE_PG_CPU_GROUP			MT_DBG_PSE(__DBG_REG_OFFS(dev, DBG_PSE_PG_CPU_GROUP))
+#define MT_DBG_PSE_CPU_PG_INFO			MT_DBG_PSE(__DBG_REG_OFFS(dev, DBG_PSE_CPU_PG_INFO))
+#define MT_DBG_PSE_PG_LMAC0_GROUP		MT_DBG_PSE(__DBG_REG_OFFS(dev, DBG_PSE_PG_LMAC0_GROUP))
+#define MT_DBG_PSE_LMAC0_PG_INFO		MT_DBG_PSE(__DBG_REG_OFFS(dev, DBG_PSE_LMAC0_PG_INFO))
+#define MT_DBG_PSE_PG_LMAC1_GROUP		MT_DBG_PSE(__DBG_REG_OFFS(dev, DBG_PSE_PG_LMAC1_GROUP))
+#define MT_DBG_PSE_LMAC1_PG_INFO		MT_DBG_PSE(__DBG_REG_OFFS(dev, DBG_PSE_LMAC1_PG_INFO))
+#define MT_DBG_PSE_PG_LMAC2_GROUP		MT_DBG_PSE(__DBG_REG_OFFS(dev, DBG_PSE_PG_LMAC2_GROUP))
+#define MT_DBG_PSE_LMAC2_PG_INFO		MT_DBG_PSE(__DBG_REG_OFFS(dev, DBG_PSE_LMAC2_PG_INFO))
+#define MT_DBG_PSE_PG_PLE_GROUP			MT_DBG_PSE(__DBG_REG_OFFS(dev, DBG_PSE_PG_PLE_GROUP))
+#define MT_DBG_PSE_PLE_PG_INFO			MT_DBG_PSE(__DBG_REG_OFFS(dev, DBG_PSE_PLE_PG_INFO))
+#define MT_DBG_PSE_PG_LMAC3_GROUP		MT_DBG_PSE(__DBG_REG_OFFS(dev, DBG_PSE_PG_LMAC3_GROUP))
+#define MT_DBG_PSE_LMAC3_PG_INFO		MT_DBG_PSE(__DBG_REG_OFFS(dev, DBG_PSE_LMAC3_PG_INFO))
+#define MT_DBG_PSE_PG_MDP_GROUP			MT_DBG_PSE(__DBG_REG_OFFS(dev, DBG_PSE_PG_MDP_GROUP))
+#define MT_DBG_PSE_MDP_PG_INFO			MT_DBG_PSE(__DBG_REG_OFFS(dev, DBG_PSE_MDP_PG_INFO))
+#define MT_DBG_PSE_PG_PLE1_GROUP		MT_DBG_PSE(__DBG_REG_OFFS(dev, DBG_PSE_PG_PLE1_GROUP))
+#define MT_DBG_PSE_PLE1_PG_INFO			MT_DBG_PSE(__DBG_REG_OFFS(dev, DBG_PSE_PLE1_PG_INFO))
+
+#define MT_DBG_PSE_PBUF_CTRL_PAGE_SIZE_CFG_MASK		BIT(31)
+#define MT_DBG_PSE_PBUF_CTRL_PBUF_OFFSET_MASK		GENMASK(25, 17)
+#define MT_DBG_PSE_PBUF_CTRL_TOTAL_PAGE_NUM_MASK	GENMASK(11, 0)
+#define MT_DBG_PSE_QUEUE_EMPTY_RLS_Q_EMTPY_MASK		BIT(31)
+#define MT_DBG_PSE_QUEUE_EMPTY_MDP_RXIOC_QUEUE_EMPTY_MASK	BIT(23)
+#define MT_DBG_PSE_QUEUE_EMPTY_MDP_TXIOC_QUEUE_EMPTY_MASK 	BIT(22)
+#define MT_DBG_PSE_QUEUE_EMPTY_SFD_PARK_QUEUE_EMPTY_MASK 	BIT(21)
+#define MT_DBG_PSE_QUEUE_EMPTY_SEC_RX_QUEUE_EMPTY_SHFT   	BIT(20)
+#define MT_DBG_PSE_QUEUE_EMPTY_SEC_TX_QUEUE_EMPTY_MASK 	BIT(19)
+#define MT_DBG_PSE_QUEUE_EMPTY_MDP_RX_QUEUE_EMPTY_MASK	BIT(18)
+#define MT_DBG_PSE_QUEUE_EMPTY_MDP_TX_QUEUE_EMPTY_MASK  BIT(17)
+#define MT_DBG_PSE_QUEUE_EMPTY_LMAC_TX_QUEUE_EMPTY_MASK BIT(16)
+#define MT_DBG_PSE_QUEUE_EMPTY_HIF_5_EMPTY_MASK		BIT(13)
+#define MT_DBG_PSE_QUEUE_EMPTY_HIF_4_EMPTY_MASK	   	BIT(12)
+#define MT_DBG_PSE_QUEUE_EMPTY_HIF_3_EMPTY_MASK		BIT(11)
+#define MT_DBG_PSE_QUEUE_EMPTY_HIF_2_EMPTY_MASK	   	BIT(10)
+#define MT_DBG_PSE_QUEUE_EMPTY_HIF_1_EMPTY_MASK		BIT(9)
+#define MT_DBG_PSE_QUEUE_EMPTY_HIF_0_EMPTY_MASK	   	BIT(8)
+#define MT_DBG_PSE_QUEUE_EMPTY_CPU_Q3_EMPTY_MASK	BIT(3)
+#define MT_DBG_PSE_QUEUE_EMPTY_CPU_Q2_EMPTY_MASK	BIT(2)
+#define MT_DBG_PSE_QUEUE_EMPTY_CPU_Q1_EMPTY_MASK	BIT(1)
+#define MT_DBG_PSE_QUEUE_EMPTY_CPU_Q0_EMPTY_MASK	BIT(0)
+#define MT_DBG_PSE_FREEPG_CNT_FFA_CNT_MASK		GENMASK(27, 16)
+#define MT_DBG_PSE_FREEPG_CNT_FREEPG_CNT_MASK	   	GENMASK(11, 0)
+#define MT_DBG_PSE_FREEPG_HEAD_TAIL_FREEPG_TAIL_MASK	GENMASK(27, 16)
+#define MT_DBG_PSE_FREEPG_HEAD_TAIL_FREEPG_HEAD_MASK	GENMASK(11, 0)
+#define MT_DBG_PSE_PG_HIF0_GROUP_HIF0_MAX_QUOTA_MASK 	GENMASK(27, 16)
+#define MT_DBG_PSE_PG_HIF0_GROUP_HIF0_MIN_QUOTA_MASK 	GENMASK(11, 0)
+#define MT_DBG_PSE_PG_HIF0_GROUP_HIF0_MAX_QUOTA_MASK	GENMASK(27, 16)
+#define MT_DBG_PSE_PG_HIF0_GROUP_HIF0_MIN_QUOTA_MASK	GENMASK(11, 0)
+#define MT_DBG_PSE_HIF0_PG_INFO_HIF0_SRC_CNT_MASK 	GENMASK(27, 16)
+#define MT_DBG_PSE_HIF0_PG_INFO_HIF0_RSV_CNT_MASK 	GENMASK(11, 0)
+#define MT_DBG_PSE_PG_HIF1_GROUP_HIF1_MAX_QUOTA_MASK 	GENMASK(27, 16)
+#define MT_DBG_PSE_PG_HIF1_GROUP_HIF1_MIN_QUOTA_MASK 	GENMASK(11, 0)
+#define MT_DBG_PSE_HIF1_PG_INFO_HIF1_SRC_CNT_MASK   	GENMASK(27, 16)
+#define MT_DBG_PSE_HIF1_PG_INFO_HIF1_RSV_CNT_MASK 	GENMASK(11, 0)
+#define MT_DBG_PSE_CPU_PG_INFO_CPU_SRC_CNT_MASK    	GENMASK(27, 16)
+#define MT_DBG_PSE_CPU_PG_INFO_CPU_RSV_CNT_MASK		GENMASK(11, 0)
+#define MT_DBG_PSE_PG_PLE_GROUP_PLE_MAX_QUOTA_MASK    	GENMASK(27, 16)
+#define MT_DBG_PSE_PG_PLE_GROUP_PLE_MIN_QUOTA_MASK 	GENMASK(11, 0)
+#define MT_DBG_PSE_PG_CPU_GROUP_CPU_MAX_QUOTA_MASK	GENMASK(27, 16)
+#define MT_DBG_PSE_PG_CPU_GROUP_CPU_MIN_QUOTA_MASK	GENMASK(11, 0)
+#define MT_DBG_PSE_PLE_PG_INFO_PLE_SRC_CNT_MASK    	GENMASK(27, 16)
+#define MT_DBG_PSE_PLE_PG_INFO_PLE_RSV_CNT_MASK		GENMASK(11, 0)
+#define MT_DBG_PSE_PG_LMAC0_GROUP_LMAC0_MAX_QUOTA_MASK	GENMASK(27, 16)
+#define MT_DBG_PSE_PG_LMAC0_GROUP_LMAC0_MIN_QUOTA_MASK	GENMASK(11, 0)
+#define MT_DBG_PSE_LMAC0_PG_INFO_LMAC0_SRC_CNT_MASK   	GENMASK(27, 16)
+#define MT_DBG_PSE_LMAC0_PG_INFO_LMAC0_RSV_CNT_MASK   	GENMASK(11, 0)
+#define MT_DBG_PSE_PG_LMAC1_GROUP_LMAC1_MAX_QUOTA_MASK	GENMASK(27, 16)
+#define MT_DBG_TOP_PG_LMAC1_GROUP_LMAC1_MIN_QUOTA_MASK 	GENMASK(11, 0)
+#define MT_DBG_PSE_LMAC1_PG_INFO_LMAC1_SRC_CNT_MASK	GENMASK(27, 16)
+#define MT_DBG_PSE_LMAC1_PG_INFO_LMAC1_RSV_CNT_MASK	GENMASK(11, 0)
+#define MT_DBG_PSE_PG_LMAC2_GROUP_LMAC2_MAX_QUOTA_MASK	GENMASK(27, 16)
+#define MT_DBG_PSE_PG_LMAC2_GROUP_LMAC2_MIN_QUOTA_MASK	GENMASK(11, 0)
+#define MT_DBG_PSE_LMAC2_PG_INFO_LMAC2_SRC_CNT_MASK	GENMASK(27, 16)
+#define MT_DBG_PSE_LMAC2_PG_INFO_LMAC2_RSV_CNT_MASK	GENMASK(11, 0)
+#define MT_DBG_PSE_PG_LMAC3_GROUP_LMAC3_MAX_QUOTA_MASK	GENMASK(27, 16)
+#define MT_DBG_TOP_PG_LMAC3_GROUP_LMAC3_MIN_QUOTA_MASK	GENMASK(11, 0)
+#define MT_DBG_PSE_LMAC3_PG_INFO_LMAC3_SRC_CNT_MASK	GENMASK(27, 16)
+#define MT_DBG_PSE_LMAC3_PG_INFO_LMAC3_RSV_CNT_MASK	GENMASK(11, 0)
+#define MT_DBG_PSE_PG_LMAC3_GROUP_LMAC3_MAX_QUOTA_MASK	GENMASK(27, 16)
+#define MT_DBG_TOP_PG_LMAC3_GROUP_LMAC3_MIN_QUOTA_MASK	GENMASK(11, 0)
+#define MT_DBG_PSE_PG_MDP_GROUP_MDP_MAX_QUOTA_MASK	GENMASK(27, 16)
+#define MT_DBG_PSE_PG_MDP_GROUP_MDP_MIN_QUOTA_MASK	GENMASK(11, 0)
+#define MT_DBG_PSE_MDP_PG_INFO_MDP_SRC_CNT_MASK		GENMASK(27, 16)
+#define MT_DBG_PSE_MDP_PG_INFO_MDP_RSV_CNT_MASK		GENMASK(11, 0)
+
+#define MT_DBG_PSE_FL_QUE_CTRL_0_ADDR			MT_DBG_PSE(0x1b0)
+#define MT_DBG_PSE_FL_QUE_CTRL_0_EXECUTE_MASK	   	BIT(31)
+#define MT_DBG_PSE_FL_QUE_CTRL_0_Q_BUF_QID_SHFT         24
+#define MT_DBG_PSE_FL_QUE_CTRL_0_Q_BUF_PID_SHFT         10
+#define MT_DBG_PSE_FL_QUE_CTRL_0_Q_BUF_WLANID_MASK    	GENMASK(9, 0)
+
+#define MT_DBG_PSE_FL_QUE_CTRL_2_ADDR			MT_DBG_PSE(0x1b8)
+#define MT_DBG_PSE_FL_QUE_CTRL_2_QUEUE_TAIL_FID_MASK    GENMASK(27, 16)
+#define MT_DBG_PSE_FL_QUE_CTRL_2_QUEUE_HEAD_FID_MASK    GENMASK(11, 0)
+
+#define MT_DBG_PSE_FL_QUE_CTRL_3_ADDR			MT_DBG_PSE(0x1bc)
+#define MT_DBG_PSE_FL_QUE_CTRL_3_QUEUE_PKT_NUM_MASK    	GENMASK(11, 0)
+
+
+/* AGG */
+#define MT_DBG_AGG_BASE(_band)			((_band) ? 0x820f2000 : 0x820e2000)
+#define MT_DBG_AGG(_band, ofs)			(MT_DBG_AGG_BASE(_band) + (ofs))
+
+#define MT_DBG_AGG_AALCR0(_band)		MT_DBG_AGG((_band), __DBG_REG_OFFS(dev, DBG_AGG_AALCR0))
+#define MT_DBG_AGG_AALCR1(_band)		MT_DBG_AGG((_band), __DBG_REG_OFFS(dev, DBG_AGG_AALCR1))
+#define MT_DBG_AGG_AALCR2(_band)		MT_DBG_AGG((_band), __DBG_REG_OFFS(dev, DBG_AGG_AALCR2))
+#define MT_DBG_AGG_AALCR3(_band)		MT_DBG_AGG((_band), __DBG_REG_OFFS(dev, DBG_AGG_AALCR3))
+#define MT_DBG_AGG_AALCR4(_band)		MT_DBG_AGG((_band), __DBG_REG_OFFS(dev, DBG_AGG_AALCR4))
+#define MT_DBG_AGG_B0BRR0(_band)		MT_DBG_AGG((_band), __DBG_REG_OFFS(dev, DBG_AGG_B0BRR0))
+#define MT_DBG_AGG_B1BRR0(_band)		MT_DBG_AGG((_band), __DBG_REG_OFFS(dev, DBG_AGG_B1BRR0))
+#define MT_DBG_AGG_B2BRR0(_band)		MT_DBG_AGG((_band), __DBG_REG_OFFS(dev, DBG_AGG_B2BRR0))
+#define MT_DBG_AGG_B3BRR0(_band)		MT_DBG_AGG((_band), __DBG_REG_OFFS(dev, DBG_AGG_B3BRR0))
+#define MT_DBG_AGG_AWSCR(_band, n)		MT_DBG_AGG((_band), __DBG_REG_OFFS(dev, DBG_AGG_AWSCR0) + ((n) << 2))
+#define MT_DBG_AGG_PCR(_band, n)		MT_DBG_AGG((_band), __DBG_REG_OFFS(dev, DBG_AGG_PCR0) + ((n) << 2))
+#define MT_DBG_AGG_TTCR(_band, n)		MT_DBG_AGG((_band), __DBG_REG_OFFS(dev, DBG_AGG_TTCR0) + ((n) << 2))
+#define MT_DBG_MIB_M0ARNG(_band, n)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0ARNG0) + ((n) << 2))
+#define MT_DBG_MIB_M0DR2(_band, n)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0DR2) + ((n) << 2))
+#define MT_DBG_MIB_M0DR13(_band, n)		MT_DBG_MIB((_band), __DBG_REG_OFFS(dev, DBG_MIB_M0DR13) + ((n) << 2))
+
+#define MT_DBG_AGG_AALCR_ACx3_AGG_LIMIT_MASK   	GENMASK(31, 24)
+#define MT_DBG_AGG_AALCR_ACx2_AGG_LIMIT_MASK  	GENMASK(23, 16)
+#define MT_DBG_AGG_AALCR_ACx1_AGG_LIMIT_MASK  	GENMASK(15, 8)
+#define MT_DBG_AGG_AALCR_ACx0_AGG_LIMIT_MASK  	GENMASK(7, 0)
+#define MT_DBG_AGG_AALCR4_ALTX0_AGG_LIMIT_MASK  GENMASK(7, 0)
+
+#define MT_DBG_AGG_AWSCR0_WINSIZE3_MASK	   	GENMASK(31, 24)
+#define MT_DBG_AGG_AWSCR0_WINSIZE2_MASK   	GENMASK(23, 16)
+#define MT_DBG_AGG_AWSCR0_WINSIZE1_MASK  	GENMASK(15, 8)
+#define MT_DBG_AGG_AWSCR0_WINSIZE0_MASK  	GENMASK(7, 0)
+
+#define MT_DBG_AGG_AWSCR1_WINSIZE7_MASK	   	GENMASK(31, 24)
+#define MT_DBG_AGG_AWSCR1_WINSIZE6_MASK   	GENMASK(23, 16)
+#define MT_DBG_AGG_AWSCR1_WINSIZE5_MASK  	GENMASK(15, 8)
+#define MT_DBG_AGG_AWSCR1_WINSIZE4_MASK  	GENMASK(7, 0)
+
+#define MT_DBG_AGG_AWSCR2_WINSIZEB_MASK	   	GENMASK(31, 24)
+#define MT_DBG_AGG_AWSCR2_WINSIZEA_MASK   	GENMASK(23, 16)
+#define MT_DBG_AGG_AWSCR2_WINSIZE9_MASK  	GENMASK(15, 8)
+#define MT_DBG_AGG_AWSCR2_WINSIZE8_MASK  	GENMASK(7, 0)
+
+#define MT_DBG_AGG_AWSCR3_WINSIZEE_MASK  	GENMASK(23, 16)
+#define MT_DBG_AGG_AWSCR3_WINSIZED_MASK  	GENMASK(15, 8)
+#define MT_DBG_AGG_AWSCR3_WINSIZEC_MASK  	GENMASK(7, 0)
+
+#define MT_DBG_MIB_M0ARNG0_AGG_RANG_SEL3_MASK	GENMASK(31, 24)
+#define MT_DBG_MIB_M0ARNG0_AGG_RANG_SEL2_MASK   GENMASK(23, 16)
+#define MT_DBG_MIB_M0ARNG0_AGG_RANG_SEL1_MASK  	GENMASK(15, 8)
+#define MT_DBG_MIB_M0ARNG0_AGG_RANG_SEL0_MASK  	GENMASK(7, 0)
+
+#define MT_DBG_MIB_M0ARNG1_AGG_RANG_SEL7_MASK	GENMASK(31, 24)
+#define MT_DBG_MIB_M0ARNG1_AGG_RANG_SEL6_MASK	GENMASK(23, 16)
+#define MT_DBG_MIB_M0ARNG1_AGG_RANG_SEL5_MASK  	GENMASK(15, 8)
+#define MT_DBG_MIB_M0ARNG1_AGG_RANG_SEL4_MASK  	GENMASK(7, 0)
+
+#define MT_DBG_MIB_M0ARNG2_AGG_RANG_SEL11_MASK	GENMASK(31, 24)
+#define MT_DBG_MIB_M0ARNG2_AGG_RANG_SEL10_MASK	GENMASK(23, 16)
+#define MT_DBG_MIB_M0ARNG2_AGG_RANG_SEL9_MASK  	GENMASK(15, 8)
+#define MT_DBG_MIB_M0ARNG2_AGG_RANG_SEL8_MASK  	GENMASK(7, 0)
+
+#define MT_DBG_MIB_M0ARNG3_AGG_RANG_SEL14_MASK	GENMASK(23, 16)
+#define MT_DBG_MIB_M0ARNG3_AGG_RANG_SEL13_MASK  GENMASK(15, 8)
+#define MT_DBG_MIB_M0ARNG3_AGG_RANG_SEL12_MASK	GENMASK(7, 0)
+
+#define MT_DBG_MIB_M0DR2_TRX_AGG_RANGE1_CNT_MASK	GENMASK(31, 16)
+#define MT_DBG_MIB_M0DR2_TRX_AGG_RANGE0_CNT_MASK	GENMASK(15, 0)
+#define MT_DBG_MIB_M0DR3_TRX_AGG_RANGE3_CNT_MASK  	GENMASK(31, 16)
+#define MT_DBG_MIB_M0DR3_TRX_AGG_RANGE2_CNT_MASK  	GENMASK(15, 0)
+#define MT_DBG_MIB_M0DR4_TRX_AGG_RANGE5_CNT_MASK  	GENMASK(31, 16)
+#define MT_DBG_MIB_M0DR4_TRX_AGG_RANGE4_CNT_MASK  	GENMASK(15, 0)
+#define MT_DBG_MIB_M0DR5_TRX_AGG_RANGE7_CNT_MASK  	GENMASK(31, 16)
+#define MT_DBG_MIB_M0DR5_TRX_AGG_RANGE6_CNT_MASK  	GENMASK(15, 0)
+#define MT_DBG_MIB_M0DR13_TRX_AGG_RANGE9_CNT_MASK  	GENMASK(31, 16)
+#define MT_DBG_MIB_M0DR13_TRX_AGG_RANGE8_CNT_MASK  	GENMASK(15, 0)
+#define MT_DBG_MIB_M0DR14_TRX_AGG_RANGE11_CNT_MASK  	GENMASK(31, 16)
+#define MT_DBG_MIB_M0DR14_TRX_AGG_RANGE10_CNT_MASK  	GENMASK(15, 0)
+#define MT_DBG_MIB_M0DR15_TRX_AGG_RANGE13_CNT_MASK  	GENMASK(31, 16)
+#define MT_DBG_MIB_M0DR15_TRX_AGG_RANGE12_CNT_MASK  	GENMASK(15, 0)
+#define MT_DBG_MIB_M0DR16_TRX_AGG_RANGE15_CNT_MASK  	GENMASK(31, 16)
+#define MT_DBG_MIB_M0DR16_TRX_AGG_RANGE14_CNT_MASK  	GENMASK(15, 0)
+
+/* mt7915 host DMA*/
+#define MT_DBG_INT_DMA1_R0_DONE			BIT(0)
+#define MT_DBG_INT_DMA1_R1_DONE			BIT(1)
+#define MT_DBG_INT_DMA1_R2_DONE			BIT(2)
+
+#define MT_DBG_INT_DMA1_T16_DONE		BIT(26)
+#define MT_DBG_INT_DMA1_T17_DONE		BIT(27)
+#define MT_DBG_INT_DMA1_T18_DONE		BIT(30)
+#define MT_DBG_INT_DMA1_T19_DONE		BIT(31)
+#define MT_DBG_INT_DMA1_T20_DONE		BIT(15)
+
+#define MT_DBG_EXT_WRAP_INT_DMA0_R0_DONE	BIT(16)
+#define MT_DBG_EXT_WRAP_INT_DMA0_R1_DONE	BIT(17)
+
+/* mt7986 host DMA */
+#define MT_DBG_INT_DMA0_R0_DONE			BIT(0)
+#define MT_DBG_INT_DMA0_R1_DONE			BIT(1)
+#define MT_DBG_INT_DMA0_R2_DONE			BIT(2)
+#define MT_DBG_INT_DMA0_R3_DONE			BIT(3)
+#define MT_DBG_INT_DMA0_R4_DONE			BIT(22)
+#define MT_DBG_INT_DMA0_R5_DONE			BIT(23)
+
+#define MT_DBG_INT_DMA0_T16_DONE		BIT(26)
+#define MT_DBG_INT_DMA0_T17_DONE		BIT(27)
+#define MT_DBG_INT_DMA0_T18_DONE		BIT(30)
+#define MT_DBG_INT_DMA0_T19_DONE		BIT(31)
+#define MT_DBG_INT_DMA0_T20_DONE		BIT(25)
+
+/* MCU DMA */
+#define WF_WFDMA_MCU_DMA0_BASE					0x54000000
+#define WF_WFDMA_MCU_DMA0_HOST_INT_STA_ADDR			(WF_WFDMA_MCU_DMA0_BASE + 0x200) // 0200
+#define WF_WFDMA_MCU_DMA0_HOST_INT_ENA_ADDR			(WF_WFDMA_MCU_DMA0_BASE + 0X204) // 0204
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_ADDR			(WF_WFDMA_MCU_DMA0_BASE + 0x208) // 0208
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK	0x00000008	// RX_DMA_BUSY[3]
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT	3
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_MASK		0x00000004	// RX_DMA_EN[2]
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_SHFT		2
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK	0x00000002	// TX_DMA_BUSY[1]
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT	1
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_MASK		0x00000001	// TX_DMA_EN[0]
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_SHFT	0
+
+#define WF_WFDMA_MCU_DMA1_BASE					0x55000000
+#define WF_WFDMA_MCU_DMA1_HOST_INT_STA_ADDR			(WF_WFDMA_MCU_DMA1_BASE + 0x200) // 0200
+#define WF_WFDMA_MCU_DMA1_HOST_INT_ENA_ADDR			(WF_WFDMA_MCU_DMA1_BASE + 0X204) // 0204
+#define WF_WFDMA_MCU_DMA1_WPDMA_GLO_CFG_ADDR			(WF_WFDMA_MCU_DMA1_BASE + 0x208) // 0208
+#define WF_WFDMA_MCU_DMA1_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK	0x00000008	// RX_DMA_BUSY[3]
+#define WF_WFDMA_MCU_DMA1_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT	3
+#define WF_WFDMA_MCU_DMA1_WPDMA_GLO_CFG_RX_DMA_EN_MASK		0x00000004	// RX_DMA_EN[2]
+#define WF_WFDMA_MCU_DMA1_WPDMA_GLO_CFG_RX_DMA_EN_SHFT		2
+#define WF_WFDMA_MCU_DMA1_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK	0x00000002	// TX_DMA_BUSY[1]
+#define WF_WFDMA_MCU_DMA1_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT	1
+#define WF_WFDMA_MCU_DMA1_WPDMA_GLO_CFG_TX_DMA_EN_MASK		0x00000001	// TX_DMA_EN[0]
+#define WF_WFDMA_MCU_DMA1_WPDMA_GLO_CFG_TX_DMA_EN_SHFT		0
+#define WF_WFDMA_MCU_DMA1_WPDMA_TX_RING0_CTRL0_ADDR		(WF_WFDMA_MCU_DMA1_BASE + 0x300) // 0300
+#define WF_WFDMA_MCU_DMA1_WPDMA_TX_RING1_CTRL0_ADDR		(WF_WFDMA_MCU_DMA1_BASE + 0x310) // 0310
+#define WF_WFDMA_MCU_DMA1_WPDMA_TX_RING2_CTRL0_ADDR		(WF_WFDMA_MCU_DMA1_BASE + 0x320) // 0320
+#define WF_WFDMA_MCU_DMA1_WPDMA_RX_RING0_CTRL0_ADDR		(WF_WFDMA_MCU_DMA1_BASE + 0x500) // 0500
+#define WF_WFDMA_MCU_DMA1_WPDMA_RX_RING1_CTRL0_ADDR		(WF_WFDMA_MCU_DMA1_BASE + 0x510) // 0510
+#define WF_WFDMA_MCU_DMA1_WPDMA_RX_RING2_CTRL0_ADDR		(WF_WFDMA_MCU_DMA1_BASE + 0x520) // 0520
+#define WF_WFDMA_MCU_DMA1_WPDMA_RX_RING3_CTRL0_ADDR		(WF_WFDMA_MCU_DMA1_BASE + 0x530) // 0530
+#define WF_WFDMA_MCU_DMA1_WPDMA_RX_RING4_CTRL0_ADDR		(WF_WFDMA_MCU_DMA1_BASE + 0x540) // 0540
+
+#define WF_WFDMA_MCU_DMA1_PCIE1_BASE				0x59000000
+#define WF_WFDMA_MCU_DMA1_PCIE1_HOST_INT_STA_ADDR		(WF_WFDMA_MCU_DMA1_PCIE1_BASE + 0x200) // 0200
+#define WF_WFDMA_MCU_DMA1_PCIE1_HOST_INT_ENA_ADDR		(WF_WFDMA_MCU_DMA1_PCIE1_BASE + 0X204) // 0204
+#define WF_WFDMA_MCU_DMA1_PCIE1_WPDMA_GLO_CFG_ADDR		(WF_WFDMA_MCU_DMA1_PCIE1_BASE + 0x208) // 0208
+#define WF_WFDMA_MCU_DMA1_PCIE1_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK	0x00000008	// RX_DMA_BUSY[3]
+#define WF_WFDMA_MCU_DMA1_PCIE1_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT	3
+#define WF_WFDMA_MCU_DMA1_PCIE1_WPDMA_GLO_CFG_RX_DMA_EN_MASK	0x00000004	// RX_DMA_EN[2]
+#define WF_WFDMA_MCU_DMA1_PCIE1_WPDMA_GLO_CFG_RX_DMA_EN_SHFT	2
+#define WF_WFDMA_MCU_DMA1_PCIE1_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK	0x00000002	// TX_DMA_BUSY[1]
+#define WF_WFDMA_MCU_DMA1_PCIE1_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT	1
+#define WF_WFDMA_MCU_DMA1_PCIE1_WPDMA_GLO_CFG_TX_DMA_EN_MASK	0x00000001	// TX_DMA_EN[0]
+#define WF_WFDMA_MCU_DMA1_PCIE1_WPDMA_GLO_CFG_TX_DMA_EN_SHFT	0
+#define WF_WFDMA_MCU_DMA1_PCIE1_WPDMA_TX_RING2_CTRL0_ADDR	(WF_WFDMA_MCU_DMA1_PCIE1_BASE + 0x320) // 0320
+#define WF_WFDMA_MCU_DMA1_PCIE1_WPDMA_RX_RING3_CTRL0_ADDR	(WF_WFDMA_MCU_DMA1_PCIE1_BASE + 0x530) // 0530
+
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING0_CTRL0_ADDR		(WF_WFDMA_MCU_DMA0_BASE + 0x300) // 0300
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING1_CTRL0_ADDR		(WF_WFDMA_MCU_DMA0_BASE + 0x310) // 0310
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING2_CTRL0_ADDR		(WF_WFDMA_MCU_DMA0_BASE + 0x320) // 0320
+/* mt7986 add */
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING3_CTRL0_ADDR     	(WF_WFDMA_MCU_DMA0_BASE + 0x330) // 0330
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING4_CTRL0_ADDR     	(WF_WFDMA_MCU_DMA0_BASE + 0x340) // 0340
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING5_CTRL0_ADDR     	(WF_WFDMA_MCU_DMA0_BASE + 0x350) // 0350
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING6_CTRL0_ADDR     	(WF_WFDMA_MCU_DMA0_BASE + 0x360) // 0360
+
+
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING0_CTRL0_ADDR		(WF_WFDMA_MCU_DMA0_BASE + 0x500) // 0500
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING1_CTRL0_ADDR		(WF_WFDMA_MCU_DMA0_BASE + 0x510) // 0510
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING2_CTRL0_ADDR		(WF_WFDMA_MCU_DMA0_BASE + 0x520) // 0520
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING3_CTRL0_ADDR		(WF_WFDMA_MCU_DMA0_BASE + 0x530) // 0530
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING4_CTRL0_ADDR		(WF_WFDMA_MCU_DMA0_BASE + 0x540) // 0540
+
+/* mt7986 add */
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING5_CTRL0_ADDR     	(WF_WFDMA_MCU_DMA0_BASE + 0x550) // 0550
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING6_CTRL0_ADDR     	(WF_WFDMA_MCU_DMA0_BASE + 0x560) // 0560
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING7_CTRL0_ADDR     	(WF_WFDMA_MCU_DMA0_BASE + 0x570) // 0570
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING8_CTRL0_ADDR     	(WF_WFDMA_MCU_DMA0_BASE + 0x580) // 0580
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING9_CTRL0_ADDR     	(WF_WFDMA_MCU_DMA0_BASE + 0x590) // 0590
+
+/* MEM DMA */
+#define WF_WFDMA_MEM_DMA_BASE					0x58000000
+#define WF_WFDMA_MEM_DMA_HOST_INT_STA_ADDR			(WF_WFDMA_MEM_DMA_BASE + 0x200) // 0200
+#define WF_WFDMA_MEM_DMA_HOST_INT_ENA_ADDR			(WF_WFDMA_MEM_DMA_BASE + 0X204) // 0204
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_ADDR			(WF_WFDMA_MEM_DMA_BASE + 0x208) // 0208
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK		0x00000008	// RX_DMA_BUSY[3]
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT		3
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_EN_MASK		0x00000004	// RX_DMA_EN[2]
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_EN_SHFT		2
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK		0x00000002	// TX_DMA_BUSY[1]
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT		1
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_EN_MASK		0x00000001	// TX_DMA_EN[0]
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_EN_SHFT		0
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING0_CTRL0_ADDR		(WF_WFDMA_MEM_DMA_BASE + 0x300) // 0300
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING1_CTRL0_ADDR		(WF_WFDMA_MEM_DMA_BASE + 0x310) // 0310
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING0_CTRL0_ADDR		(WF_WFDMA_MEM_DMA_BASE + 0x500) // 0500
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING1_CTRL0_ADDR		(WF_WFDMA_MEM_DMA_BASE + 0x510) // 0510
+
+enum resource_attr {
+	HIF_TX_DATA,
+	HIF_TX_CMD,
+	HIF_TX_CMD_WM, /* direct path to WMCPU, only exist for WFDMA arch with 2 CPU */
+	HIF_TX_FWDL,
+	HIF_RX_DATA,
+	HIF_RX_EVENT,
+	RING_ATTR_NUM
+};
+
+struct hif_pci_tx_ring_desc {
+	u32 hw_int_mask;
+	u16 ring_size;
+	enum resource_attr ring_attr;
+	u8 band_idx;
+	char *const ring_info;
+};
+
+struct hif_pci_rx_ring_desc {
+	u32 hw_desc_base;
+	u32 hw_int_mask;
+	u16 ring_size;
+	enum resource_attr ring_attr;
+	u16 max_rx_process_cnt;
+	u16 max_sw_read_idx_inc;
+	char *const ring_info;
+	bool flags;
+};
+
+const struct hif_pci_tx_ring_desc mt7915_tx_ring_layout[] = {
+	{
+	 .hw_int_mask = MT_DBG_INT_DMA1_T16_DONE,
+	 .ring_size = 128,
+	 .ring_attr = HIF_TX_FWDL,
+	 .ring_info = "FWDL"
+	},
+	{
+	 .hw_int_mask = MT_DBG_INT_DMA1_T17_DONE,
+	 .ring_size = 256,
+	 .ring_attr = HIF_TX_CMD_WM,
+	 .ring_info = "cmd to WM"
+	},
+	{
+	 .hw_int_mask = MT_DBG_INT_DMA1_T18_DONE,
+	 .ring_size = 2048,
+	 .ring_attr = HIF_TX_DATA,
+	 .ring_info = "band0 TXD"
+	},
+	{
+	 .hw_int_mask = MT_DBG_INT_DMA1_T19_DONE,
+	 .ring_size = 2048,
+	 .ring_attr = HIF_TX_DATA,
+	 .ring_info = "band1 TXD"
+	},
+	{
+	 .hw_int_mask = MT_DBG_INT_DMA1_T20_DONE,
+	 .ring_size = 256,
+	 .ring_attr = HIF_TX_CMD,
+	 .ring_info = "cmd to WA"
+	}
+};
+
+const struct hif_pci_rx_ring_desc mt7915_rx_ring_layout[] = {
+	{
+	 .hw_int_mask = MT_DBG_EXT_WRAP_INT_DMA0_R0_DONE,
+	 .ring_size = 1536,
+	 .ring_attr = HIF_RX_DATA,
+	 .ring_info = "band0 RX data"
+	},
+	{
+	 .hw_int_mask = MT_DBG_EXT_WRAP_INT_DMA0_R1_DONE,
+	 .ring_size = 1536,
+	 .ring_attr = HIF_RX_DATA,
+	 .ring_info = "band1 RX data"
+	},
+	{
+	 .hw_int_mask = MT_DBG_INT_DMA1_R0_DONE,
+	 .ring_size = 512,
+	 .ring_attr = HIF_RX_EVENT,
+	 .ring_info = "event from WM"
+	},
+	{
+	 .hw_int_mask = MT_DBG_INT_DMA1_R1_DONE,
+	 .ring_size = 1024,
+	 .ring_attr = HIF_RX_EVENT,
+	 .ring_info = "event from WA band0",
+	 .flags = true
+	},
+	{
+	 .hw_int_mask = MT_DBG_INT_DMA1_R2_DONE,
+	 .ring_size = 512,
+	 .ring_attr = HIF_RX_EVENT,
+	 .ring_info = "event from WA band1"
+	}
+};
+
+const struct hif_pci_tx_ring_desc mt7986_tx_ring_layout[] = {
+	{
+	 .hw_int_mask = MT_DBG_INT_DMA0_T16_DONE,
+	 .ring_size = 128,
+	 .ring_attr = HIF_TX_FWDL,
+	 .ring_info = "FWDL"
+	},
+	{
+	 .hw_int_mask = MT_DBG_INT_DMA0_T17_DONE,
+	 .ring_size = 256,
+	 .ring_attr = HIF_TX_CMD_WM,
+	 .ring_info = "cmd to WM"
+	},
+	{
+	 .hw_int_mask = MT_DBG_INT_DMA0_T18_DONE,
+	 .ring_size = 2048,
+	 .ring_attr = HIF_TX_DATA,
+	 .ring_info = "band0 TXD"
+	},
+	{
+	 .hw_int_mask = MT_DBG_INT_DMA0_T19_DONE,
+	 .ring_size = 2048,
+	 .ring_attr = HIF_TX_DATA,
+	 .ring_info = "band1 TXD"
+	},
+	{
+	 .hw_int_mask = MT_DBG_INT_DMA0_T20_DONE,
+	 .ring_size = 256,
+	 .ring_attr = HIF_TX_CMD,
+	 .ring_info = "cmd to WA"
+	}
+};
+
+const struct hif_pci_rx_ring_desc mt7986_rx_ring_layout[] = {
+	{
+	 .hw_int_mask = MT_DBG_INT_DMA0_R4_DONE,
+	 .ring_size = 1536,
+	 .ring_attr = HIF_RX_DATA,
+	 .ring_info = "band0 RX data"
+	},
+	{
+	 .hw_int_mask = MT_DBG_INT_DMA0_R5_DONE,
+	 .ring_size = 1536,
+	 .ring_attr = HIF_RX_DATA,
+	 .ring_info = "band1 RX data"
+	},
+	{
+	 .hw_int_mask = MT_DBG_INT_DMA0_R0_DONE,
+	 .ring_size = 512,
+	 .ring_attr = HIF_RX_EVENT,
+	 .ring_info = "event from WM"
+	},
+	{
+	 .hw_int_mask = MT_DBG_INT_DMA0_R1_DONE,
+	 .ring_size = 512,
+	 .ring_attr = HIF_RX_EVENT,
+	 .ring_info = "event from WA"
+	},
+	{
+	 .hw_int_mask = MT_DBG_INT_DMA0_R2_DONE,
+	 .ring_size = 1024,
+	 .ring_attr = HIF_RX_EVENT,
+	 .ring_info = "STS WA band0",
+	 .flags = true
+	},
+	{
+	 .hw_int_mask = MT_DBG_INT_DMA0_R3_DONE,
+	 .ring_size = 512,
+	 .ring_attr = HIF_RX_EVENT,
+	 .ring_info = "STS WA band1"
+	},
+};
+
+/* mibinfo related CRs. */
+#define BN0_WF_MIB_TOP_BASE                                    0x820ed000
+#define BN1_WF_MIB_TOP_BASE                                    0x820fd000
+
+#define BN0_WF_MIB_TOP_BTOCR_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x400) // D400
+#define BN0_WF_MIB_TOP_BTBCR_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x428) // D428
+#define BN0_WF_MIB_TOP_BTDCR_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x4F0) // D4F0
+
+#define BN0_WF_MIB_TOP_BSDR0_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x688) // D688
+#define BN0_WF_MIB_TOP_BSDR1_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x690) // D690
+
+#define BN0_WF_MIB_TOP_BSDR2_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x518) // D518
+#define BN0_WF_MIB_TOP_BSDR3_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x520) // D520
+#define BN0_WF_MIB_TOP_BSDR4_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x528) // D528
+#define BN0_WF_MIB_TOP_BSDR5_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x530) // D530
+#define BN0_WF_MIB_TOP_BSDR6_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x538) // D538
+
+#define BN0_WF_MIB_TOP_BROCR_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x5B8) // D5B8
+#define BN0_WF_MIB_TOP_BRBCR_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x5E0) // D5E0
+#define BN0_WF_MIB_TOP_BRDCR_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x630) // D630
+
+#define BN0_WF_MIB_TOP_M0SDR0_BEACONTXCOUNT_MASK               0x0000FFFF // BEACONTXCOUNT[15..0]
+
+#define BN0_WF_MIB_TOP_M0SDR4_RX_FIFO_FULL_COUNT_MASK          0x0000FFFF // RX_FIFO_FULL_COUNT[15..0]
+
+#define BN0_WF_MIB_TOP_M0SDR5_RX_MPDU_COUNT_MASK               0xFFFFFFFF // RX_MPDU_COUNT[31..0]
+
+#define BN0_WF_MIB_TOP_M0SDR6_CHANNEL_IDLE_COUNT_MASK          0x0000FFFF // CHANNEL_IDLE_COUNT[15..0]
+
+#define BN1_WF_MIB_TOP_BTOCR_ADDR                              (BN1_WF_MIB_TOP_BASE + 0x400) // D400
+
+#define BN0_WF_MIB_TOP_M0SDR7_VEC_MISS_COUNT_MASK              0x0000FFFF // VEC_MISS_COUNT[15..0]
+#define BN0_WF_MIB_TOP_M0SDR8_DELIMITER_FAIL_COUNT_MASK        0x0000FFFF // DELIMITER_FAIL_COUNT[15..0]
+#define BN0_WF_MIB_TOP_M0SDR9_CCA_NAV_TX_TIME_MASK             0x00FFFFFF // CCA_NAV_TX_TIME[23..0]
+
+#define BN0_WF_MIB_TOP_M0SDR11_RX_LEN_MISMATCH_MASK            0x0000FFFF // RX_LEN_MISMATCH[15..0]
+
+#define BN0_WF_MIB_TOP_M0SDR16_P_CCA_TIME_MASK                 0x00FFFFFF // P_CCA_TIME[23..0]
+#define BN0_WF_MIB_TOP_M0SDR17_S_CCA_TIME_MASK                 0x00FFFFFF // S_CCA_TIME[23..0]
+#define BN0_WF_MIB_TOP_M0SDR18_P_ED_TIME_MASK                  0x00FFFFFF // P_ED_TIME[23..0]
+#define BN0_WF_MIB_TOP_M0SDR19_CCK_MDRDY_TIME_MASK             0x00FFFFFF // CCK_MDRDY_TIME[23..0]
+#define BN0_WF_MIB_TOP_M0SDR20_OFDM_LG_MIXED_VHT_MDRDY_TIME_MASK 0x00FFFFFF  // OFDM_LG_MIXED_VHT_MDRDY_TIME[23..0]
+#define BN0_WF_MIB_TOP_M0SDR21_OFDM_GREEN_MDRDY_TIME_MASK      0x00FFFFFF // OFDM_GREEN_MDRDY_TIME[23..0]
+
+#define BN0_WF_MIB_TOP_M0SDR22_ADDR                            (BN0_WF_MIB_TOP_BASE + 0x60) // D060
+#define BN0_WF_MIB_TOP_M0SDR23_ADDR                            (BN0_WF_MIB_TOP_BASE + 0x64) // D064
+
+#define BN0_WF_MIB_TOP_M0SDR34_MUBF_TX_COUNT_MASK              0x0000FFFF                // MUBF_TX_COUNT[15..0]
+
+#define BN0_WF_MIB_TOP_M0DR0_TX_40MHZ_CNT_MASK                 0xFFFF0000                // TX_40MHZ_CNT[31..16]
+#define BN0_WF_MIB_TOP_M0DR0_TX_40MHZ_CNT_SHFT                 16
+#define BN0_WF_MIB_TOP_M0DR0_TX_20MHZ_CNT_MASK                 0x0000FFFF                // TX_20MHZ_CNT[15..0]
+#define BN0_WF_MIB_TOP_M0DR0_TX_20MHZ_CNT_SHFT                 0
+
+#define BN0_WF_MIB_TOP_M0DR1_TX_160MHZ_CNT_MASK                0xFFFF0000                // TX_160MHZ_CNT[31..16]
+#define BN0_WF_MIB_TOP_M0DR1_TX_160MHZ_CNT_SHFT                16
+#define BN0_WF_MIB_TOP_M0DR1_TX_80MHZ_CNT_MASK                 0x0000FFFF                // TX_80MHZ_CNT[15..0]
+#define BN0_WF_MIB_TOP_M0DR1_TX_80MHZ_CNT_SHFT                 0
+
+#define BN0_WF_MIB_TOP_M0DR6_TX_DDLMT_RNG2_CNT_MASK            0xFFFF0000                // TX_DDLMT_RNG2_CNT[31..16]
+#define BN0_WF_MIB_TOP_M0DR6_TX_DDLMT_RNG2_CNT_SHFT            16
+#define BN0_WF_MIB_TOP_M0DR6_TX_DDLMT_RNG1_CNT_MASK            0x0000FFFF                // TX_DDLMT_RNG1_CNT[15..0]
+#define BN0_WF_MIB_TOP_M0DR6_TX_DDLMT_RNG1_CNT_SHFT            0
+
+#define BN0_WF_MIB_TOP_M0DR7_TX_DDLMT_RNG4_CNT_MASK            0xFFFF0000                // TX_DDLMT_RNG4_CNT[31..16]
+#define BN0_WF_MIB_TOP_M0DR7_TX_DDLMT_RNG4_CNT_SHFT            16
+#define BN0_WF_MIB_TOP_M0DR7_TX_DDLMT_RNG3_CNT_MASK            0x0000FFFF                // TX_DDLMT_RNG3_CNT[15..0]
+#define BN0_WF_MIB_TOP_M0DR7_TX_DDLMT_RNG3_CNT_SHFT            0
+
+#define BN0_WF_MIB_TOP_M0DR10_MU_FAIL_PPDU_CNT_MASK            0x0000FFFF                // MU_FAIL_PPDU_CNT[15..0]
+
+#define BN0_WF_MIB_TOP_M0B0SDR0_ADDR                           (BN0_WF_MIB_TOP_BASE + 0x100) // D100
+#define BN0_WF_MIB_TOP_M0B0SDR0_RTSRETRYCOUNT_MASK             0xFFFF0000                // RTSRETRYCOUNT[31..16]
+#define BN0_WF_MIB_TOP_M0B0SDR0_RTSRETRYCOUNT_SHFT             16
+#define BN0_WF_MIB_TOP_M0B0SDR0_RTSTXCOUNT_MASK                0x0000FFFF                // RTSTXCOUNT[15..0]
+#define BN0_WF_MIB_TOP_M0B0SDR0_RTSTXCOUNT_SHFT                0
+#define BN0_WF_MIB_TOP_M0B0SDR1_ADDR                           (BN0_WF_MIB_TOP_BASE + 0x104) // D104
+#define BN0_WF_MIB_TOP_M0B0SDR1_ACKFAILCOUNT_MASK              0xFFFF0000                // ACKFAILCOUNT[31..16]
+#define BN0_WF_MIB_TOP_M0B0SDR1_ACKFAILCOUNT_SHFT              16
+#define BN0_WF_MIB_TOP_M0B0SDR1_BAMISSCOUNT_MASK               0x0000FFFF                // BAMISSCOUNT[15..0]
+#define BN0_WF_MIB_TOP_M0B0SDR1_BAMISSCOUNT_SHFT               0
+#define BN0_WF_MIB_TOP_M0B0SDR2_ADDR                           (BN0_WF_MIB_TOP_BASE + 0x108) // D108
+#define BN0_WF_MIB_TOP_M0B0SDR2_FRAMERETRY2COUNT_MASK          0xFFFF0000                // FRAMERETRY2COUNT[31..16]
+#define BN0_WF_MIB_TOP_M0B0SDR2_FRAMERETRY2COUNT_SHFT          16
+#define BN0_WF_MIB_TOP_M0B0SDR2_FRAMERETRYCOUNT_MASK           0x0000FFFF                // FRAMERETRYCOUNT[15..0]
+#define BN0_WF_MIB_TOP_M0B0SDR2_FRAMERETRYCOUNT_SHFT           0
+#define BN0_WF_MIB_TOP_M0B0SDR3_ADDR                           (BN0_WF_MIB_TOP_BASE + 0x10C) // D10C
+#define BN0_WF_MIB_TOP_M0B0SDR3_FRAMERETRY3COUNT_MASK          0x0000FFFF                // FRAMERETRY3COUNT[15..0]
+#define BN0_WF_MIB_TOP_M0B0SDR3_FRAMERETRY3COUNT_SHFT          0
+#define BN0_WF_MIB_TOP_M0DR12_TX_DDLMT_RNG0_CNT_MASK           0x0000FFFF                // TX_DDLMT_RNG0_CNT[15..0]
+
+
+#define BN0_WF_MIB_TOP_BTOCR_TX_OK_COUNT2np1_MASK              0xFFFF0000                // TX_OK_COUNT2np1[31..16]
+#define BN0_WF_MIB_TOP_BTOCR_TX_OK_COUNT2np1_SHFT              16
+#define BN0_WF_MIB_TOP_BTOCR_TX_OK_COUNT2n_MASK                0x0000FFFF                // TX_OK_COUNT2n[15..0]
+#define BN0_WF_MIB_TOP_BTOCR_TX_OK_COUNT2n_SHFT                0
+
+#define BN0_WF_MIB_TOP_BTDCR_TX_DATA_COUNT2np1_MASK            0xFFFF0000                // TX_DATA_COUNT2np1[31..16]
+#define BN0_WF_MIB_TOP_BTDCR_TX_DATA_COUNT2np1_SHFT            16
+#define BN0_WF_MIB_TOP_BTDCR_TX_DATA_COUNT2n_MASK              0x0000FFFF                // TX_DATA_COUNT2n[15..0]
+#define BN0_WF_MIB_TOP_BTDCR_TX_DATA_COUNT2n_SHFT              0
+
+#define BN0_WF_MIB_TOP_BROCR_RX_OK_COUNT2np1_MASK              0xFFFF0000                // RX_OK_COUNT2np1[31..16]
+#define BN0_WF_MIB_TOP_BROCR_RX_OK_COUNT2np1_SHFT              16
+#define BN0_WF_MIB_TOP_BROCR_RX_OK_COUNT2n_MASK                0x0000FFFF                // RX_OK_COUNT2n[15..0]
+#define BN0_WF_MIB_TOP_BROCR_RX_OK_COUNT2n_SHFT                0
+
+#define BN0_WF_MIB_TOP_BRDCR_RX_DATA_COUNT2np1_MASK            0xFFFF0000                // RX_DATA_COUNT2np1[31..16]
+#define BN0_WF_MIB_TOP_BRDCR_RX_DATA_COUNT2np1_SHFT            16
+#define BN0_WF_MIB_TOP_BRDCR_RX_DATA_COUNT2n_MASK              0x0000FFFF                // RX_DATA_COUNT2n[15..0]
+#define BN0_WF_MIB_TOP_BRDCR_RX_DATA_COUNT2n_SHFT              0
+
+#define BN0_WF_MIB_TOP_BSDR0_RTSTXCOUNT2np1_MASK               0xFFFF0000                // RTSTXCOUNT2np1[31..16]
+#define BN0_WF_MIB_TOP_BSDR0_RTSTXCOUNT2np1_SHFT               16
+#define BN0_WF_MIB_TOP_BSDR0_RTSTXCOUNT2n_MASK                 0x0000FFFF                // RTSTXCOUNT2n[15..0]
+#define BN0_WF_MIB_TOP_BSDR0_RTSTXCOUNT2n_SHFT                 0
+
+#define BN0_WF_MIB_TOP_BSDR1_RTSRETRYCOUNT2np1_MASK            0xFFFF0000                // RTSRETRYCOUNT2np1[31..16]
+#define BN0_WF_MIB_TOP_BSDR1_RTSRETRYCOUNT2np1_SHFT            16
+#define BN0_WF_MIB_TOP_BSDR1_RTSRETRYCOUNT2n_MASK              0x0000FFFF                // RTSRETRYCOUNT2n[15..0]
+#define BN0_WF_MIB_TOP_BSDR1_RTSRETRYCOUNT2n_SHFT              0
+
+#define BN0_WF_MIB_TOP_BSDR2_BAMISSCOUNT2np1_MASK              0xFFFF0000                // BAMISSCOUNT2np1[31..16]
+#define BN0_WF_MIB_TOP_BSDR2_BAMISSCOUNT2np1_SHFT              16
+#define BN0_WF_MIB_TOP_BSDR2_BAMISSCOUNT2n_MASK                0x0000FFFF                // BAMISSCOUNT2n[15..0]
+#define BN0_WF_MIB_TOP_BSDR2_BAMISSCOUNT2n_SHFT                0
+
+#define BN0_WF_MIB_TOP_BSDR3_ACKFAILCOUNT2np1_MASK             0xFFFF0000                // ACKFAILCOUNT2np1[31..16]
+#define BN0_WF_MIB_TOP_BSDR3_ACKFAILCOUNT2np1_SHFT             16
+#define BN0_WF_MIB_TOP_BSDR3_ACKFAILCOUNT2n_MASK               0x0000FFFF                // ACKFAILCOUNT2n[15..0]
+#define BN0_WF_MIB_TOP_BSDR3_ACKFAILCOUNT2n_SHFT               0
+
+#define BN0_WF_MIB_TOP_BSDR4_FRAMERETRYCOUNT2np1_MASK          0xFFFF0000                // FRAMERETRYCOUNT2np1[31..16]
+#define BN0_WF_MIB_TOP_BSDR4_FRAMERETRYCOUNT2np1_SHFT          16
+#define BN0_WF_MIB_TOP_BSDR4_FRAMERETRYCOUNT2n_MASK            0x0000FFFF                // FRAMERETRYCOUNT2n[15..0]
+#define BN0_WF_MIB_TOP_BSDR4_FRAMERETRYCOUNT2n_SHFT            0
+
+#define BN0_WF_MIB_TOP_BSDR5_FRAMERETRY2COUNT2np1_MASK         0xFFFF0000                // FRAMERETRY2COUNT2np1[31..16]
+#define BN0_WF_MIB_TOP_BSDR5_FRAMERETRY2COUNT2np1_SHFT         16
+#define BN0_WF_MIB_TOP_BSDR5_FRAMERETRY2COUNT2n_MASK           0x0000FFFF                // FRAMERETRY2COUNT2n[15..0]
+#define BN0_WF_MIB_TOP_BSDR5_FRAMERETRY2COUNT2n_SHFT           0
+
+#define BN0_WF_MIB_TOP_BSDR6_FRAMERETRY3COUNT2np1_MASK         0xFFFF0000                // FRAMERETRY3COUNT2np1[31..16]
+#define BN0_WF_MIB_TOP_BSDR6_FRAMERETRY3COUNT2np1_SHFT         16
+#define BN0_WF_MIB_TOP_BSDR6_FRAMERETRY3COUNT2n_MASK           0x0000FFFF                // FRAMERETRY3COUNT2n[15..0]
+#define BN0_WF_MIB_TOP_BSDR6_FRAMERETRY3COUNT2n_SHFT           0
+/* TXD */
+
+#define MT_TXD1_ETYP			BIT(15)
+#define MT_TXD1_VLAN			BIT(14)
+#define MT_TXD1_RMVL			BIT(13)
+#define MT_TXD1_AMS			BIT(13)
+#define MT_TXD1_EOSP			BIT(12)
+#define MT_TXD1_MRD			BIT(11)
+
+#define MT_TXD7_CTXD			BIT(26)
+#define MT_TXD7_CTXD_CNT		GENMASK(25, 23)
+#define MT_TXD7_TAT			GENMASK(9, 0)
+
+#endif
+#endif
diff --git a/mt7915/mtk_debugfs.c b/mt7915/mtk_debugfs.c
new file mode 100644
index 00000000..c0fcb2ee
--- /dev/null
+++ b/mt7915/mtk_debugfs.c
@@ -0,0 +1,3750 @@
+#include<linux/inet.h>
+#include "mt7915.h"
+#include "mt7915_debug.h"
+#include "mac.h"
+#include "mcu.h"
+
+#ifdef MTK_DEBUG
+#define LWTBL_IDX2BASE_ID		GENMASK(14, 8)
+#define LWTBL_IDX2BASE_DW		GENMASK(7, 2)
+#define LWTBL_IDX2BASE(_id, _dw)	(MT_DBG_WTBL_BASE | \
+					FIELD_PREP(LWTBL_IDX2BASE_ID, _id) | \
+					FIELD_PREP(LWTBL_IDX2BASE_DW, _dw))
+
+#define UWTBL_IDX2BASE_ID		GENMASK(12, 6)
+#define UWTBL_IDX2BASE_DW		GENMASK(5, 2)
+#define UWTBL_IDX2BASE(_id, _dw)	(MT_DBG_UWTBL_TOP_BASE | 0x2000 | \
+					FIELD_PREP(UWTBL_IDX2BASE_ID, _id) | \
+					FIELD_PREP(UWTBL_IDX2BASE_DW, _dw))
+
+#define KEYTBL_IDX2BASE_KEY		GENMASK(12, 6)
+#define KEYTBL_IDX2BASE_DW		GENMASK(5, 2)
+#define KEYTBL_IDX2BASE(_key, _dw)	(MT_DBG_UWTBL_TOP_BASE | 0x2000 | \
+					FIELD_PREP(KEYTBL_IDX2BASE_KEY, _key) | \
+					FIELD_PREP(KEYTBL_IDX2BASE_DW, _dw))
+
+enum mt7915_wtbl_type {
+	WTBL_TYPE_LMAC,		/* WTBL in LMAC */
+	WTBL_TYPE_UMAC,		/* WTBL in UMAC */
+	WTBL_TYPE_KEY,		/* Key Table */
+	MAX_NUM_WTBL_TYPE
+};
+
+static int mt7915_wtbl_read_raw(struct mt7915_dev *dev, u16 idx,
+			        enum mt7915_wtbl_type type, u16 start_dw,
+			        u16 len, void *buf)
+{
+	u32 *dest_cpy = (u32 *)buf;
+	u32 size_dw = len;
+	u32 src = 0;
+
+	if (!buf)
+		return 0xFF;
+
+	if (type == WTBL_TYPE_LMAC) {
+		mt76_wr(dev, MT_DBG_WTBLON_TOP_WDUCR,
+			FIELD_PREP(MT_DBG_WTBLON_TOP_WDUCR_GROUP, (idx >> 7)));
+		src = LWTBL_IDX2BASE(idx, start_dw);
+	} else if (type == WTBL_TYPE_UMAC) {
+		mt76_wr(dev,  MT_DBG_UWTBL_TOP_WDUCR,
+			FIELD_PREP(MT_UWTBL_TOP_WDUCR_GROUP, (idx >> 7)));
+		src = UWTBL_IDX2BASE(idx, start_dw);
+	} else if (type == WTBL_TYPE_KEY) {
+		mt76_wr(dev,  MT_DBG_UWTBL_TOP_WDUCR,
+			MT_UWTBL_TOP_WDUCR_TARGET |
+			FIELD_PREP(MT_UWTBL_TOP_WDUCR_GROUP, (idx >> 7)));
+		src = KEYTBL_IDX2BASE(idx, start_dw);
+	}
+
+	while (size_dw--) {
+		*dest_cpy++ = mt76_rr(dev, src);
+		src += 4;
+	};
+
+	return 0;
+}
+
+static int mt7915_wtbl_write_raw(struct mt7915_dev *dev, u16 idx,
+			         enum mt7915_wtbl_type type, u16 start_dw,
+			         u32 val)
+{
+	u32 addr = 0;
+
+	if (type == WTBL_TYPE_LMAC) {
+		mt76_wr(dev, MT_DBG_WTBLON_TOP_WDUCR,
+			FIELD_PREP(MT_WTBLON_TOP_WDUCR_GROUP, (idx >> 7)));
+		addr = LWTBL_IDX2BASE(idx, start_dw);
+	} else if (type == WTBL_TYPE_UMAC) {
+		mt76_wr(dev, MT_DBG_UWTBL_TOP_WDUCR,
+			FIELD_PREP(MT_UWTBL_TOP_WDUCR_GROUP, (idx >> 7)));
+		addr = UWTBL_IDX2BASE(idx, start_dw);
+	} else if (type == WTBL_TYPE_KEY) {
+		mt76_wr(dev, MT_DBG_UWTBL_TOP_WDUCR,
+			MT_UWTBL_TOP_WDUCR_TARGET |
+			FIELD_PREP(MT_UWTBL_TOP_WDUCR_GROUP, (idx >> 7)));
+		addr = KEYTBL_IDX2BASE(idx, start_dw);
+	}
+
+	mt76_wr(dev, addr, val);
+
+	return 0;
+}
+
+void mt7915_packet_log_to_host(struct mt7915_dev *dev, const void *data, int len, int type, int des_len)
+{
+	struct bin_debug_hdr *hdr;
+	char *buf;
+
+	if (len > 1500 - sizeof(*hdr))
+		len = 1500 - sizeof(*hdr);
+
+	buf = kzalloc(sizeof(*hdr) + len, GFP_KERNEL);
+	if (!buf)
+		return;
+
+	hdr = (struct bin_debug_hdr *)buf;
+	hdr->magic_num = cpu_to_le32(PKT_BIN_DEBUG_MAGIC);
+	hdr->serial_id = cpu_to_le16(dev->dbg.fwlog_seq++);
+	hdr->msg_type = cpu_to_le16(type);
+	hdr->len = cpu_to_le16(len);
+	hdr->des_len = cpu_to_le16(des_len);
+
+	memcpy(buf + sizeof(*hdr), data, len);
+
+	mt7915_debugfs_rx_log(dev, buf, sizeof(*hdr) + len);
+}
+
+static int
+mt7915_fw_debug_module_set(void *data, u64 module)
+{
+	struct mt7915_dev *dev = data;
+
+	dev->dbg.fw_dbg_module = module;
+	return 0;
+}
+
+static int
+mt7915_fw_debug_module_get(void *data, u64 *module)
+{
+	struct mt7915_dev *dev = data;
+
+	*module = dev->dbg.fw_dbg_module;
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_fw_debug_module, mt7915_fw_debug_module_get,
+			 mt7915_fw_debug_module_set, "%lld\n");
+
+static int
+mt7915_fw_debug_level_set(void *data, u64 level)
+{
+	struct mt7915_dev *dev = data;
+
+	dev->dbg.fw_dbg_lv = level;
+	mt7915_mcu_fw_dbg_ctrl(dev, dev->dbg.fw_dbg_module, dev->dbg.fw_dbg_lv);
+	return 0;
+}
+
+static int
+mt7915_fw_debug_level_get(void *data, u64 *level)
+{
+	struct mt7915_dev *dev = data;
+
+	*level = dev->dbg.fw_dbg_lv;
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_fw_debug_level, mt7915_fw_debug_level_get,
+			 mt7915_fw_debug_level_set, "%lld\n");
+
+#define MAX_TX_MODE 12
+static char *HW_TX_MODE_STR[] = {"CCK", "OFDM", "HT-Mix", "HT-GF", "VHT",
+				 "N/A", "N/A", "N/A", "HE_SU", "HE_EXT_SU",
+				 "HE_TRIG", "HE_MU", "N/A"};
+static char *HW_TX_RATE_CCK_STR[] = {"1M", "2Mlong", "5.5Mlong", "11Mlong",
+				     "N/A", "2Mshort", "5.5Mshort", "11Mshort",
+				     "N/A"};
+static char *HW_TX_RATE_OFDM_STR[] = {"6M", "9M", "12M", "18M", "24M", "36M",
+				      "48M", "54M", "N/A"};
+static char *fcap_str[] =  {"20MHz", "20/40MHz", "20/40/80MHz",
+			    "20/40/80/160/80+80MHz"};
+
+static char *hw_rate_ofdm_str(u16 ofdm_idx)
+{
+	switch (ofdm_idx) {
+	case 11: /* 6M */
+		return HW_TX_RATE_OFDM_STR[0];
+
+	case 15: /* 9M */
+		return HW_TX_RATE_OFDM_STR[1];
+
+	case 10: /* 12M */
+		return HW_TX_RATE_OFDM_STR[2];
+
+	case 14: /* 18M */
+		return HW_TX_RATE_OFDM_STR[3];
+
+	case 9: /* 24M */
+		return HW_TX_RATE_OFDM_STR[4];
+
+	case 13: /* 36M */
+		return HW_TX_RATE_OFDM_STR[5];
+
+	case 8: /* 48M */
+		return HW_TX_RATE_OFDM_STR[6];
+
+	case 12: /* 54M */
+		return HW_TX_RATE_OFDM_STR[7];
+
+	default:
+		return HW_TX_RATE_OFDM_STR[8];
+	}
+}
+
+static char *hw_rate_str(u8 mode, u16 rate_idx)
+{
+	if (mode == 0)
+		return rate_idx < 8 ? HW_TX_RATE_CCK_STR[rate_idx] : HW_TX_RATE_CCK_STR[8];
+	else if (mode == 1)
+		return hw_rate_ofdm_str(rate_idx);
+	else
+		return "MCS";
+}
+
+static void parse_rate(struct seq_file *s, u16 rate_idx, u16 txrate)
+{
+	u16 txmode, mcs, nss, stbc;
+
+	txmode = FIELD_GET(GENMASK(9, 6), txrate);
+	mcs = FIELD_GET(GENMASK(5, 0), txrate);
+	nss = FIELD_GET(GENMASK(12, 10), txrate);
+	stbc = FIELD_GET(BIT(13), txrate);
+
+	seq_printf(s, "\tRate%d(0x%x):TxMode=%d(%s), TxRate=%d(%s), Nsts=%d, STBC=%d\n",
+			rate_idx + 1, txrate,
+			txmode, (txmode < MAX_TX_MODE ? HW_TX_MODE_STR[txmode] : HW_TX_MODE_STR[MAX_TX_MODE]),
+			mcs, hw_rate_str(txmode, mcs), nss, stbc);
+}
+
+#define LWTBL_LEN_IN_DW 32
+#define UWTBL_LEN_IN_DW 8
+#define ONE_KEY_ENTRY_LEN_IN_DW 8
+static int mt7915_sta_info(struct seq_file *s, void *data)
+{
+	struct mt7915_dev *dev = dev_get_drvdata(s->private);
+	u8 lwtbl[LWTBL_LEN_IN_DW*4] = {0};
+	u16 i = 0;
+
+	for (i=0; i < mt7915_wtbl_size(dev); i++) {
+		mt7915_wtbl_read_raw(dev, i, WTBL_TYPE_LMAC, 0,
+					LWTBL_LEN_IN_DW, lwtbl);
+		if (lwtbl[4] || lwtbl[5] || lwtbl[6] || lwtbl[7] || lwtbl[0] || lwtbl[1])
+			seq_printf(s, "wcid:%d\tAddr: %02x:%02x:%02x:%02x:%02x:%02x\n",
+					i, lwtbl[4], lwtbl[5], lwtbl[6], lwtbl[7], lwtbl[0], lwtbl[1]);
+	}
+
+	return 0;
+}
+
+static int mt7915_wtbl_read(struct seq_file *s, void *data)
+{
+	struct mt7915_dev *dev = dev_get_drvdata(s->private);
+	u8 lwtbl[LWTBL_LEN_IN_DW*4] = {0};
+	int x;
+	u32 *addr = 0;
+	u32 dw_value = 0;
+
+	mt7915_wtbl_read_raw(dev, dev->wlan_idx, WTBL_TYPE_LMAC, 0,
+				 LWTBL_LEN_IN_DW, lwtbl);
+	seq_printf(s, "Dump WTBL info of WLAN_IDX:%d\n", dev->wlan_idx);
+	seq_printf(s, "LMAC WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
+				MT_DBG_WTBLON_TOP_WDUCR,
+				mt76_rr(dev, MT_DBG_WTBLON_TOP_WDUCR),
+				LWTBL_IDX2BASE(dev->wlan_idx, 0));
+	for (x = 0; x < LWTBL_LEN_IN_DW; x++) {
+		seq_printf(s, "DW%02d: %02x %02x %02x %02x\n",
+					x,
+					lwtbl[x * 4 + 3],
+					lwtbl[x * 4 + 2],
+					lwtbl[x * 4 + 1],
+					lwtbl[x * 4]);
+	}
+
+	seq_printf(s, "\n\tAddr: %02x:%02x:%02x:%02x:%02x:%02x(D0[B0~15], D1[B0~31])\n",
+			  lwtbl[4], lwtbl[5], lwtbl[6], lwtbl[7], lwtbl[0], lwtbl[1]);
+
+	// DW0, DW1
+	seq_printf(s, "LWTBL DW 0/1\n\t");
+	addr = (u32 *)&(lwtbl[0]);
+	dw_value = *addr;
+	seq_printf(s, "MUAR_IDX:%lu/ ",	FIELD_GET(GENMASK(21, 16),	dw_value));
+	seq_printf(s, "RCA1:%ld/ ",	FIELD_GET(BIT(22),		dw_value));
+	seq_printf(s, "KID:%lu/ ",	FIELD_GET(GENMASK(24, 23),	dw_value));
+	seq_printf(s, "RCID:%ld/ ",	FIELD_GET(BIT(25),		dw_value));
+	seq_printf(s, "FROM_DS:%ld\n\t",	FIELD_GET(BIT(26),		dw_value));
+	seq_printf(s, "TO_DS:%ld/ ",	FIELD_GET(BIT(27),		dw_value));
+	seq_printf(s, "RV:%ld/ ",	FIELD_GET(BIT(28),		dw_value));
+	seq_printf(s, "RCA2:%ld/ ",	FIELD_GET(BIT(29),		dw_value));
+	seq_printf(s, "WPI_FLAG:%ld\n",	FIELD_GET(BIT(30),		dw_value));
+
+	// DW2
+	seq_printf(s, "LWTBL DW 2\n\t");
+	addr = (u32 *)&(lwtbl[2*4]);
+	dw_value = *addr;
+	seq_printf(s, "AID12:%lu/ ",	FIELD_GET(GENMASK(11, 0),	dw_value));
+	seq_printf(s, "SU:%ld/ ",	FIELD_GET(BIT(12),		dw_value));
+	seq_printf(s, "SPP_EN:%ld/ ",	FIELD_GET(BIT(13),		dw_value));
+	seq_printf(s, "WPI_EVEN:%ld\n\t",FIELD_GET(BIT(14),		dw_value));
+	seq_printf(s, "CIPHER:%lu/ ",	FIELD_GET(GENMASK(20, 16),	dw_value));
+	seq_printf(s, "CIPHER_IGTK:%lu/ ",FIELD_GET(GENMASK(22, 21),	dw_value));
+	seq_printf(s, "AAD_OM:%ld\n\t",	FIELD_GET(BIT(15),		dw_value));
+	seq_printf(s, "SW:%ld/ ",	FIELD_GET(BIT(24),		dw_value));
+	seq_printf(s, "UL:%ld/ ",	FIELD_GET(BIT(25),		dw_value));
+	seq_printf(s, "TX_POWER_SAVE:%ld\n\t", FIELD_GET(BIT(26),	dw_value));
+	seq_printf(s, "QOS:%ld/ ",	FIELD_GET(BIT(27),		dw_value));
+	seq_printf(s, "HT:%ld/ ",	FIELD_GET(BIT(28),		dw_value));
+	seq_printf(s, "VHT:%ld/ ",	FIELD_GET(BIT(29),		dw_value));
+	seq_printf(s, "HE:%ld/ ",	FIELD_GET(BIT(30),		dw_value));
+	seq_printf(s, "MESH:%ld\n",	FIELD_GET(BIT(31),		dw_value));
+
+	// DW3
+	seq_printf(s, "LWTBL DW 3\n\t");
+	addr = (u32 *)&(lwtbl[3*4]);
+	dw_value = *addr;
+	seq_printf(s, "WMM_Q:%lu/ ",	FIELD_GET(GENMASK(1, 0),	dw_value));
+	seq_printf(s, "RXD_DUP_MODE:%lu\n\t", FIELD_GET(GENMASK(3, 2),	dw_value));
+	seq_printf(s, "VLAN2ETH:%ld/ ",	FIELD_GET(BIT(4),		dw_value));
+	seq_printf(s, "BEAM_CHG:%ld/ ",	FIELD_GET(BIT(5),		dw_value));
+	seq_printf(s, "DIS_BA256:%ld\n\t", FIELD_GET(BIT(6),		dw_value));
+	seq_printf(s, "PFMU_IDX:%lu/ ",	FIELD_GET(GENMASK(15, 8),	dw_value));
+	seq_printf(s, "ULPF_IDX:%lu\n\t", FIELD_GET(GENMASK(23, 16),	dw_value));
+	seq_printf(s, "RIBF:%ld/ ",	FIELD_GET(BIT(24),		dw_value));
+	seq_printf(s, "ULPF:%ld\n\t",	FIELD_GET(BIT(25),		dw_value));
+	seq_printf(s, "IGN_FBK:%ld/ ",	FIELD_GET(BIT(26),		dw_value));
+	seq_printf(s, "TBF:%ld/ ",	FIELD_GET(BIT(29),		dw_value));
+	seq_printf(s, "TBF_VHT:%ld/ ",	FIELD_GET(BIT(30),		dw_value));
+	seq_printf(s, "TBF_HE:%ld\n",	FIELD_GET(BIT(31),		dw_value));
+
+	// DW4
+	seq_printf(s, "LWTBL DW 4\n\t");
+	addr = (u32 *)&(lwtbl[4*4]);
+	dw_value = *addr;
+	seq_printf(s, "ANT_ID_STS0:%lu/ ", FIELD_GET(GENMASK(2, 0),	dw_value));
+	seq_printf(s, "STS1:%lu/ ",	FIELD_GET(GENMASK(5, 3),	dw_value));
+	seq_printf(s, "STS2:%lu/ ",	FIELD_GET(GENMASK(8, 6),	dw_value));
+	seq_printf(s, "STS3:%lu\n\t",	FIELD_GET(GENMASK(11, 9),	dw_value));
+	seq_printf(s, "ANT_ID_STS4:%lu/ ", FIELD_GET(GENMASK(14, 12),	dw_value));
+	seq_printf(s, "STS5:%lu/ ",	FIELD_GET(GENMASK(17, 15),	dw_value));
+	seq_printf(s, "STS6:%ld/ ",	FIELD_GET(GENMASK(20, 18),	dw_value));
+	seq_printf(s, "STS7:%lu\n\t",	FIELD_GET(GENMASK(23, 21),	dw_value));
+	seq_printf(s, "CASCAD:%ld/ ",	FIELD_GET(BIT(24),		dw_value));
+	seq_printf(s, "LDPC_HT:%ld/ ",	FIELD_GET(BIT(25),		dw_value));
+	seq_printf(s, "LDPC_VHT:%ld/ ", FIELD_GET(BIT(26),		dw_value));
+	seq_printf(s, "LDPC_HE:%ld\n\t", FIELD_GET(BIT(27),		dw_value));
+	seq_printf(s, "DIS_RHTR:%ld/ ",	FIELD_GET(BIT(28),		dw_value));
+	seq_printf(s, "ALL_ACK:%ld/ ",	FIELD_GET(BIT(29),		dw_value));
+	seq_printf(s, "DROP:%ld/ ",	FIELD_GET(BIT(30),		dw_value));
+	seq_printf(s, "ACK_EN:%ld\n",	FIELD_GET(BIT(31),		dw_value));
+
+	// DW5
+	seq_printf(s, "LWTBL DW 5\n\t");
+	addr = (u32 *)&(lwtbl[5*4]);
+	dw_value = *addr;
+	seq_printf(s, "AF:%lu/ ",	FIELD_GET(GENMASK(2, 0),	dw_value));
+	seq_printf(s, "AF_HE:%lu/ ",	FIELD_GET(GENMASK(4, 3),	dw_value));
+	seq_printf(s, "RTS:%ld/ ",	FIELD_GET(BIT(5),		dw_value));
+	seq_printf(s, "SMPS:%ld/ ",	FIELD_GET(BIT(6),		dw_value));
+	seq_printf(s, "DYN_BW:%ld\n\t",	FIELD_GET(BIT(7),		dw_value));
+	seq_printf(s, "MMSS:%lu/ ",	FIELD_GET(GENMASK(10, 8),	dw_value));
+	seq_printf(s, "USR:%ld/ ",	FIELD_GET(BIT(11),		dw_value));
+	seq_printf(s, "SR_RATE:%lu/ ",	FIELD_GET(GENMASK(14, 12),	dw_value));
+	seq_printf(s, "SR_ABORT:%ld\n\t", FIELD_GET(BIT(15),		dw_value));
+	seq_printf(s, "TX_POWER_OFFSET:%lu/ ", FIELD_GET(GENMASK(21, 16), dw_value));
+	seq_printf(s, "WTBL_MPDU_SIZE:%lu\n\t", FIELD_GET(GENMASK(23, 22), dw_value));
+	seq_printf(s, "PE:%lu/ ",	FIELD_GET(GENMASK(25, 24),	dw_value));
+	seq_printf(s, "DOPPL:%ld/ ",	FIELD_GET(BIT(26),		dw_value));
+	seq_printf(s, "TXOP_PS_CAP:%ld/ ", FIELD_GET(BIT(27),		dw_value));
+	seq_printf(s, "DONOT_UPDATE_I_PSM:%ld\n\t", FIELD_GET(BIT(28),	dw_value));
+	seq_printf(s, "I_PSM:%ld/ ",	FIELD_GET(BIT(29),		dw_value));
+	seq_printf(s, "PSM:%ld/ ",	FIELD_GET(BIT(30),		dw_value));
+	seq_printf(s, "SKIP_TX:%ld\n",	FIELD_GET(BIT(31),		dw_value));
+
+	// DW6
+	seq_printf(s, "LWTBL DW 6\n\t");
+	seq_printf(s, "TID 0/1/2/3/4/5/6/7 BA_WIN_SIZE:");
+	addr = (u32 *)&(lwtbl[6*4]);
+	dw_value = *addr;
+	seq_printf(s, "%lu/ ",	FIELD_GET(GENMASK(3, 0),	dw_value));
+	seq_printf(s, "%lu/ ",	FIELD_GET(GENMASK(7, 4),	dw_value));
+	seq_printf(s, "%lu/ ",	FIELD_GET(GENMASK(11, 8),	dw_value));
+	seq_printf(s, "%lu/ ",	FIELD_GET(GENMASK(15, 12),	dw_value));
+	seq_printf(s, "%lu/ ",	FIELD_GET(GENMASK(19, 16),	dw_value));
+	seq_printf(s, "%lu/ ",	FIELD_GET(GENMASK(23, 20),	dw_value));
+	seq_printf(s, "%lu/ ",	FIELD_GET(GENMASK(27, 24),	dw_value));
+	seq_printf(s, "%lu\n",	FIELD_GET(GENMASK(31, 28),	dw_value));
+
+	// DW7
+	seq_printf(s, "LWTBL DW 7\n\t");
+	addr = (u32 *)&(lwtbl[7*4]);
+	dw_value = *addr;
+	seq_printf(s, "CBRN:%lu/ ",	FIELD_GET(GENMASK(2, 0),	dw_value));
+	seq_printf(s, "DBNSS_EN:%ld/ ",	FIELD_GET(BIT(3),		dw_value));
+	seq_printf(s, "BAF_EN:%ld/ ",	FIELD_GET(BIT(4),		dw_value));
+	seq_printf(s, "RDGBA:%ld\n\t",	FIELD_GET(BIT(5),		dw_value));
+	seq_printf(s, "RDG:%ld/ ",	FIELD_GET(BIT(6),		dw_value));
+	seq_printf(s, "SPE_IDX:%lu/ ",	FIELD_GET(GENMASK(11, 7),	dw_value));
+	seq_printf(s, "G2:%ld/ ",	FIELD_GET(BIT(12),		dw_value));
+	seq_printf(s, "G4:%ld/ ",	FIELD_GET(BIT(13),		dw_value));
+	seq_printf(s, "G8:%ld/ ",	FIELD_GET(BIT(14),		dw_value));
+	seq_printf(s, "G16:%ld\n\t",	FIELD_GET(BIT(15),		dw_value));
+	seq_printf(s, "G2_LTF:%lu/ ", 	FIELD_GET(GENMASK(17, 16),	dw_value));
+	seq_printf(s, "G4_LTF:%lu/ ",	FIELD_GET(GENMASK(19, 18),	dw_value));
+	seq_printf(s, "G8_LTF:%lu/ ",	FIELD_GET(GENMASK(21, 20),	dw_value));
+	seq_printf(s, "G16_LTF:%lu\n\t", FIELD_GET(GENMASK(23, 22),	dw_value));
+	seq_printf(s, "G2_HE:%lu/ ", 	FIELD_GET(GENMASK(25, 24),	dw_value));
+	seq_printf(s, "G4_HE:%lu/ ",	FIELD_GET(GENMASK(27, 27),	dw_value));
+	seq_printf(s, "G8_HE:%lu/ ",	FIELD_GET(GENMASK(29, 28),	dw_value));
+	seq_printf(s, "G16_HE:%lu\n",	FIELD_GET(GENMASK(31, 30),	dw_value));
+
+	// DW8
+	seq_printf(s, "LWTBL DW 8\n\t");
+	addr = (u32 *)&(lwtbl[8*4]);
+	dw_value = *addr;
+	seq_printf(s, "FAIL_CNT_AC0:%lu/ ", FIELD_GET(GENMASK(4, 0),	dw_value));
+	seq_printf(s, "AC1:%lu/ ",	FIELD_GET(GENMASK(9, 5),	dw_value));
+	seq_printf(s, "AC2:%lu/ ",	FIELD_GET(GENMASK(14, 10),	dw_value));
+	seq_printf(s, "AC3:%lu\n\t",	FIELD_GET(GENMASK(19, 15),	dw_value));
+	seq_printf(s, "PARTIAL_AID:%lu/ ", FIELD_GET(GENMASK(28, 20),	dw_value));
+	seq_printf(s, "CHK_PER:%lu\n",	FIELD_GET(BIT(31),		dw_value));
+
+	// DW9
+	seq_printf(s, "LWTBL DW 9\n\t");
+	addr = (u32 *)&(lwtbl[9*4]);
+	dw_value = *addr;
+	seq_printf(s, "RX_AVG_MPDU:%lu/ ",	FIELD_GET(GENMASK(13, 0), dw_value));
+	seq_printf(s, "PRITX_SW_MODE:%ld/ ",	FIELD_GET(BIT(16),	dw_value));
+	seq_printf(s, "PRITX_PLR:%ld\n\t",	FIELD_GET(BIT(17),	dw_value));
+	seq_printf(s, "PRITX_DCM:%ld/ ",	FIELD_GET(BIT(18),	dw_value));
+	seq_printf(s, "PRITX_ER160:%ld/ ",	FIELD_GET(BIT(19),	dw_value));
+	seq_printf(s, "PRITX_ERSU:%lu\n\t",	FIELD_GET(BIT(20),	dw_value));
+	seq_printf(s, "MPDU_FAIL_CNT:%lu/ ",	FIELD_GET(GENMASK(25, 23), dw_value));
+	seq_printf(s, "MPDU_OK_CNT:%lu/ ",	FIELD_GET(GENMASK(28, 26), dw_value));
+	seq_printf(s, "RATE_IDX:%lu\n\t",	FIELD_GET(GENMASK(31, 29), dw_value));
+	seq_printf(s, "FCAP:%s\n", fcap_str[FIELD_GET(GENMASK(22, 21), dw_value)]);
+
+	// DW10
+	seq_printf(s, "LWTBL DW 10\n");
+	addr = (u32 *)&(lwtbl[10*4]);
+	dw_value = *addr;
+	parse_rate(s, 0, FIELD_GET(GENMASK(13, 0), dw_value));
+	parse_rate(s, 1, FIELD_GET(GENMASK(29, 16), dw_value));
+	// DW11
+	seq_printf(s, "LWTBL DW 11\n");
+	addr = (u32 *)&(lwtbl[11*4]);
+	dw_value = *addr;
+	parse_rate(s, 2, FIELD_GET(GENMASK(13, 0), dw_value));
+	parse_rate(s, 3, FIELD_GET(GENMASK(29, 16), dw_value));
+	// DW12
+	seq_printf(s, "LWTBL DW 12\n");
+	addr = (u32 *)&(lwtbl[12*4]);
+	dw_value = *addr;
+	parse_rate(s, 4, FIELD_GET(GENMASK(13, 0), dw_value));
+	parse_rate(s, 5, FIELD_GET(GENMASK(29, 16), dw_value));
+	// DW13
+	seq_printf(s, "LWTBL DW 13\n");
+	addr = (u32 *)&(lwtbl[13*4]);
+	dw_value = *addr;
+	parse_rate(s, 6, FIELD_GET(GENMASK(13, 0), dw_value));
+	parse_rate(s, 7, FIELD_GET(GENMASK(29, 16), dw_value));
+
+	//DW28
+	seq_printf(s, "LWTBL DW 28\n\t");
+	addr = (u32 *)&(lwtbl[28*4]);
+	dw_value = *addr;
+	seq_printf(s, "OM_INFO:%lu/ ",	FIELD_GET(GENMASK(11, 0), dw_value));
+	seq_printf(s, "OM_RXD_DUP_MODE:%u\n\t",	!!(dw_value & BIT(12)) );
+
+	//DW29
+	seq_printf(s, "LWTBL DW 29\n");
+	addr = (u32 *)&(lwtbl[29*4]);
+	dw_value = *addr;
+	seq_printf(s, "USER_RSSI:%lu/ ",	FIELD_GET(GENMASK(8, 0), dw_value));
+	seq_printf(s, "USER_SNR:%lu/ ", FIELD_GET(GENMASK(14, 9), dw_value));
+	seq_printf(s, "RAPID_REACTION_RATE:%lu/ ",	FIELD_GET(GENMASK(26, 16), dw_value));
+	seq_printf(s, "HT_AMSDU(Read Only):%u/ ",	!!(dw_value & BIT(30)) );
+	seq_printf(s, "AMSDU_CROSS_LG(Read Only):%u\n\t ", !!(dw_value & BIT(31)));
+
+	//DW30
+	seq_printf(s, "LWTBL DW 30\n\t");
+	addr = (u32 *)&(lwtbl[30*4]);
+	dw_value = *addr;
+	seq_printf(s, "RCPI 0:%lu/ ",	FIELD_GET(GENMASK(7, 0), dw_value));
+	seq_printf(s, "RCPI 1:%lu/ ",	FIELD_GET(GENMASK(15, 8), dw_value));
+	seq_printf(s, "RCPI 2:%lu/ ",	FIELD_GET(GENMASK(23, 16), dw_value));
+	seq_printf(s, "RCPI 3:%lu\n\t", FIELD_GET(GENMASK(31, 24), dw_value));
+
+	//DW31
+	seq_printf(s, "LWTBL DW 31\n\t");
+	addr = (u32 *)&(lwtbl[31*4]);
+	dw_value = *addr;
+	seq_printf(s, "RCPI 4:%lu/ ",	FIELD_GET(GENMASK(7, 0), dw_value));
+	seq_printf(s, "RCPI 5:%lu/ ",	FIELD_GET(GENMASK(15, 8), dw_value));
+	seq_printf(s, "RCPI 6:%lu/ ",	FIELD_GET(GENMASK(23, 16), dw_value));
+	seq_printf(s, "RCPI 7:%lu\n\t", FIELD_GET(GENMASK(31, 24), dw_value));
+
+	return 0;
+}
+
+static int mt7915_uwtbl_read(struct seq_file *s, void *data)
+{
+	struct mt7915_dev *dev = dev_get_drvdata(s->private);
+	u8 uwtbl[UWTBL_LEN_IN_DW * 4] = {0};
+	u8 keytbl[ONE_KEY_ENTRY_LEN_IN_DW*4] = {0};
+	int x;
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u32 amsdu_len = 0;
+	u32 u2SN = 0;
+	u16 keyloc0, keyloc1;
+
+	mt7915_wtbl_read_raw(dev, dev->wlan_idx, WTBL_TYPE_UMAC, 0,
+				 UWTBL_LEN_IN_DW, uwtbl);
+	seq_printf(s, "Dump WTBL info of WLAN_IDX:%d\n", dev->wlan_idx);
+	seq_printf(s, "UMAC WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
+		   MT_DBG_UWTBL_TOP_WDUCR,
+		   mt76_rr(dev, MT_DBG_UWTBL_TOP_BASE),
+		   UWTBL_IDX2BASE(dev->wlan_idx, 0));
+	for (x = 0; x < UWTBL_LEN_IN_DW; x++) {
+		seq_printf(s, "DW%02d: %02x %02x %02x %02x\n",
+			   x,
+			   uwtbl[x * 4 + 3],
+			   uwtbl[x * 4 + 2],
+			   uwtbl[x * 4 + 1],
+			   uwtbl[x * 4]);
+	}
+
+	/* UMAC WTBL DW 0 */
+	seq_printf(s, "\nUWTBL PN\n\t");
+	addr = (u32 *)&(uwtbl[0]);
+	dw_value = *addr;
+	seq_printf(s, "PN0:%lu/ ", FIELD_GET(GENMASK(7, 0), dw_value));
+	seq_printf(s, "PN1:%lu/ ", FIELD_GET(GENMASK(15, 8), dw_value));
+	seq_printf(s, "PN2:%lu\n\t", FIELD_GET(GENMASK(23, 16), dw_value));
+	seq_printf(s, "PN3:%lu/ ", FIELD_GET(GENMASK(31, 24), dw_value));
+
+	addr = (u32 *)&(uwtbl[1 * 4]);
+	dw_value = *addr;
+	seq_printf(s, "PN4:%lu/ ", FIELD_GET(GENMASK(7, 0), dw_value));
+	seq_printf(s, "PN5:%lu\n", FIELD_GET(GENMASK(15, 8), dw_value));
+
+	/* UMAC WTBL DW SN part */
+	seq_printf(s, "\nUWTBL SN\n");
+	addr = (u32 *)&(uwtbl[2 * 4]);
+	dw_value = *addr;
+	seq_printf(s, "TID0_AC0_SN:%lu\n", FIELD_GET(GENMASK(11, 0), dw_value));
+	seq_printf(s, "TID1_AC1_SN:%lu\n", FIELD_GET(GENMASK(23, 12), dw_value));
+
+	u2SN = FIELD_GET(GENMASK(31, 24), dw_value);
+	addr = (u32 *)&(uwtbl[3 * 4]);
+	dw_value = *addr;
+	u2SN |= FIELD_GET(GENMASK(3, 0), dw_value);
+	seq_printf(s, "TID2_AC2_SN:%u\n", u2SN);
+	seq_printf(s, "TID3_AC3_SN:%lu\n", FIELD_GET(GENMASK(15, 4), dw_value));
+	seq_printf(s, "TID4_SN:%lu\n", FIELD_GET(GENMASK(27, 16), dw_value));
+
+	u2SN = FIELD_GET(GENMASK(31, 28), dw_value);
+	addr = (u32 *)&(uwtbl[4 * 4]);
+	dw_value = *addr;
+	u2SN |= FIELD_GET(GENMASK(7, 0), dw_value);
+	seq_printf(s, "TID5_SN:%u\n", u2SN);
+	seq_printf(s, "TID6_SN:%lu\n", FIELD_GET(GENMASK(19, 8), dw_value));
+	seq_printf(s, "TID7_SN:%lu\n", FIELD_GET(GENMASK(31, 20), dw_value));
+
+	addr = (u32 *)&(uwtbl[1 * 4]);
+	dw_value = *addr;
+	seq_printf(s, "COM_SN:%lu\n", FIELD_GET(GENMASK(27, 16), dw_value));
+
+	/* UMAC WTBL DW 0 */
+	seq_printf(s, "\nUWTBL others\n");
+
+	addr = (u32 *)&(uwtbl[5 * 4]);
+	dw_value = *addr;
+	keyloc0 = FIELD_GET(GENMASK(10, 0), dw_value);
+	keyloc1 = FIELD_GET(GENMASK(26, 16), dw_value);
+	seq_printf(s, "\tKey Loc 1/2:%lu/%lu\n",
+		   FIELD_GET(GENMASK(10, 0), dw_value),
+		   FIELD_GET(GENMASK(26, 16), dw_value));
+	seq_printf(s, "\tUWTBL_QOS:%lu\n", FIELD_GET(BIT(27), dw_value));
+	seq_printf(s, "\tUWTBL_HT_VHT_HE:%lu\n", FIELD_GET(BIT(28), dw_value));
+
+	addr = (u32 *)&(uwtbl[6*4]);
+	dw_value = *addr;
+	seq_printf(s, "\tHW AMSDU Enable:%lu\n", FIELD_GET(BIT(9), dw_value));
+
+	amsdu_len = FIELD_GET(GENMASK(5, 0), dw_value);
+	if (amsdu_len == 0)
+		seq_printf(s, "\tHW AMSDU Len:invalid (WTBL value=0x%x)\n", amsdu_len);
+	else if (amsdu_len == 1)
+		seq_printf(s, "\tHW AMSDU Len:%d~%d (WTBL value=0x%x)\n",
+			   1,
+			   255,
+			   amsdu_len);
+	else
+		seq_printf(s, "\tHW AMSDU Len:%d~%d (WTBL value=0x%x)\n",
+			   256 * (amsdu_len - 1),
+			   256 * (amsdu_len - 1) + 255,
+			   amsdu_len
+			   );
+	seq_printf(s, "\tHW AMSDU Num:%lu (WTBL value=0x%lx)\n",
+		   FIELD_GET(GENMASK(8, 6), dw_value) + 1,
+		   FIELD_GET(GENMASK(8, 6), dw_value));
+
+	/* Parse KEY link */
+	seq_printf(s, "\n\tkeyloc0:%d\n", keyloc0);
+	if(keyloc0 != GENMASK(10, 0)) {
+		mt7915_wtbl_read_raw(dev, keyloc0, WTBL_TYPE_KEY,
+					 0, ONE_KEY_ENTRY_LEN_IN_DW, keytbl);
+		seq_printf(s, "KEY WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
+			   MT_DBG_UWTBL_TOP_WDUCR,
+			   mt76_rr(dev, MT_DBG_UWTBL_TOP_BASE),
+			   KEYTBL_IDX2BASE(keyloc0, 0));
+
+		for (x = 0; x < ONE_KEY_ENTRY_LEN_IN_DW; x++) {
+			seq_printf(s, "DW%02d: %02x %02x %02x %02x\n",
+				   x,
+				   keytbl[x * 4 + 3],
+				   keytbl[x * 4 + 2],
+				   keytbl[x * 4 + 1],
+				   keytbl[x * 4]);
+		}
+	}
+
+	seq_printf(s, "\n\tkeyloc1:%d\n", keyloc1);
+	if(keyloc1 != GENMASK(26, 16)) {
+		mt7915_wtbl_read_raw(dev, keyloc1, WTBL_TYPE_KEY,
+					 0, ONE_KEY_ENTRY_LEN_IN_DW, keytbl);
+		seq_printf(s, "KEY WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
+			   MT_DBG_UWTBL_TOP_WDUCR,
+			   mt76_rr(dev, MT_DBG_UWTBL_TOP_BASE),
+			   KEYTBL_IDX2BASE(keyloc1, 0));
+
+		for (x = 0; x < ONE_KEY_ENTRY_LEN_IN_DW; x++) {
+			seq_printf(s, "DW%02d: %02x %02x %02x %02x\n",
+				   x,
+				   keytbl[x * 4 + 3],
+				   keytbl[x * 4 + 2],
+				   keytbl[x * 4 + 1],
+				   keytbl[x * 4]);
+		}
+	}
+	return 0;
+}
+
+static void
+dump_dma_tx_ring_info(struct seq_file *s, struct mt7915_dev *dev,  char *str, u32 ring_base)
+{
+	u32 base, cnt, cidx, didx, queue_cnt;
+
+	base= mt76_rr(dev, ring_base);
+	cnt = mt76_rr(dev, ring_base + 4);
+	cidx = mt76_rr(dev, ring_base + 8);
+	didx = mt76_rr(dev, ring_base + 12);
+	queue_cnt = (cidx >= didx) ? (cidx - didx) : (cidx - didx + cnt);
+
+	seq_printf(s, "%20s %10x %10x %10x %10x %10x\n", str, base, cnt, cidx, didx, queue_cnt);
+}
+
+static void
+dump_dma_rx_ring_info(struct seq_file *s, struct mt7915_dev *dev,  char *str, u32 ring_base)
+{
+	u32 base, cnt, cidx, didx, queue_cnt;
+
+	base= mt76_rr(dev, ring_base);
+	cnt = mt76_rr(dev, ring_base + 4);
+	cidx = mt76_rr(dev, ring_base + 8);
+	didx = mt76_rr(dev, ring_base + 12);
+	queue_cnt = (didx > cidx) ? (didx - cidx - 1) : (didx - cidx + cnt - 1);
+
+	seq_printf(s, "%20s %10x %10x %10x %10x %10x\n", str, base, cnt, cidx, didx, queue_cnt);
+}
+
+static void
+mt7915_show_host_dma_info(struct seq_file *s, struct mt7915_dev *dev)
+{
+	u32 sys_ctrl[10] = {};
+
+	/* HOST DMA */
+	sys_ctrl[0] = mt76_rr(dev, MT_DBG_INT_SOURCE_CSR);
+	sys_ctrl[1] = mt76_rr(dev, MT_DBG_INT_MASK_CSR);
+	sys_ctrl[2] = mt76_rr(dev, MT_DBG_WFDMA0_INT_SOURCE_CSR);
+	sys_ctrl[3] = mt76_rr(dev, MT_DBG_WFDMA0_INT_MASK_CSR);
+	sys_ctrl[4] = mt76_rr(dev, MT_DBG_WFDMA1_INT_SOURCE_CSR);
+	sys_ctrl[5] = mt76_rr(dev, MT_DBG_WFDMA1_INT_MASK_CSR);
+	sys_ctrl[6] = mt76_rr(dev, MT_DBG_WFDMA0_GLO_CFG);
+	sys_ctrl[7] = mt76_rr(dev, MT_DBG_WFDMA1_GLO_CFG);
+	seq_printf(s, "HOST_DMA Configuration\n");
+	seq_printf(s, "%10s %10s %10s %10s %10s %10s\n",
+			"DMA", "IntCSR", "IntMask", "Glocfg", "Tx/RxEn", "Tx/RxBusy");
+	seq_printf(s, "%10s %10x %10x\n",
+			"Merge", sys_ctrl[0], sys_ctrl[1]);
+	seq_printf(s, "%10s %10x %10x %10x %4lx/%5lx %4lx/%5lx\n",
+			"DMA0", sys_ctrl[2], sys_ctrl[3], sys_ctrl[6],
+			FIELD_GET(MT_DBG_WFDMA0_GLO_CFG_TX_DMA_EN, sys_ctrl[6]),
+			FIELD_GET(MT_DBG_WFDMA0_GLO_CFG_RX_DMA_EN, sys_ctrl[6]),
+			FIELD_GET(MT_DBG_WFDMA0_GLO_CFG_TX_BUSY_MASK, sys_ctrl[6]),
+			FIELD_GET(MT_DBG_WFDMA0_GLO_CFG_RX_BUSY_MASK, sys_ctrl[6]));
+
+	seq_printf(s, "%10s %10x %10x %10x %4lx/%5lx %4lx/%5lx\n",
+			"DMA1", sys_ctrl[4], sys_ctrl[5], sys_ctrl[7],
+			FIELD_GET(MT_DBG_WFDMA1_GLO_CFG_TX_DMA_EN, sys_ctrl[7]),
+			FIELD_GET(MT_DBG_WFDMA1_GLO_CFG_RX_DMA_EN, sys_ctrl[7]),
+			FIELD_GET(MT_DBG_WFDMA1_GLO_CFG_TX_BUSY_MASK, sys_ctrl[7]),
+			FIELD_GET(MT_DBG_WFDMA1_GLO_CFG_RX_BUSY_MASK, sys_ctrl[7]));
+
+	sys_ctrl[0] = mt76_rr(dev, MT_DBG_INT1_SOURCE_CSR);
+	sys_ctrl[1] = mt76_rr(dev, MT_DBG_INT1_MASK_CSR);
+	sys_ctrl[2] = mt76_rr(dev, MT_DBG_WFDMA0_PCIE1_INT_SOURCE_CSR);
+	sys_ctrl[3] = mt76_rr(dev, MT_DBG_WFDMA0_PCIE1_INT_MASK_CSR);
+	sys_ctrl[4] = mt76_rr(dev, MT_DBG_WFDMA1_PCIE1_INT_SOURCE_CSR);
+	sys_ctrl[5] = mt76_rr(dev, MT_DBG_WFDMA1_PCIE1_INT_MASK_CSR);
+	sys_ctrl[6] = mt76_rr(dev, MT_DBG_WFDMA0_PCIE1_GLO_CFG);
+	sys_ctrl[7] = mt76_rr(dev, MT_DBG_WFDMA1_PCIE1_GLO_CFG);
+	seq_printf(s, "%10s %10x %10x\n",
+		      "MergeP1", sys_ctrl[0], sys_ctrl[1]);
+	seq_printf(s, "%10s %10x %10x %10x %4lx/%5lx %4lx/%5lx\n",
+		      "DMA0P1", sys_ctrl[2], sys_ctrl[3], sys_ctrl[6],
+		      FIELD_GET(MT_DBG_WFDMA0_PCIE1_GLO_CFG_TX_DMA_EN, sys_ctrl[6]),
+		      FIELD_GET(MT_DBG_WFDMA0_PCIE1_GLO_CFG_RX_DMA_EN, sys_ctrl[6]),
+		      FIELD_GET(MT_DBG_WFDMA0_PCIE1_GLO_CFG_TX_BUSY_MASK, sys_ctrl[6]),
+		      FIELD_GET(MT_DBG_WFDMA0_PCIE1_GLO_CFG_RX_BUSY_MASK, sys_ctrl[6]));
+	seq_printf(s, "%10s %10x %10x %10x %4lx/%5lx %4lx/%5lx\n",
+		      "DMA1P1", sys_ctrl[4], sys_ctrl[5], sys_ctrl[7],
+		      FIELD_GET(MT_DBG_WFDMA0_PCIE1_GLO_CFG_TX_DMA_EN, sys_ctrl[7]),
+		      FIELD_GET(MT_DBG_WFDMA0_PCIE1_GLO_CFG_RX_DMA_EN, sys_ctrl[7]),
+		      FIELD_GET(MT_DBG_WFDMA0_PCIE1_GLO_CFG_TX_BUSY_MASK, sys_ctrl[7]),
+		      FIELD_GET(MT_DBG_WFDMA0_PCIE1_GLO_CFG_RX_BUSY_MASK, sys_ctrl[7]));
+
+	seq_printf(s, "HOST_DMA0 Ring Configuration\n");
+	seq_printf(s, "%20s %10s %10s %10s %10s %10s\n",
+		      "Name", "Base", "Cnt", "CIDX", "DIDX", "QCnt");
+	dump_dma_rx_ring_info(s, dev, "R0:Data0(MAC2H)", MT_DBG_RX_DATA_RING_CTRL(0));
+	dump_dma_rx_ring_info(s, dev, "R1:Data1(MAC2H)", MT_DBG_RX_DATA_RING_CTRL(1));
+
+	seq_printf(s, "HOST_DMA0 PCIe 1 Ring Configuration\n");
+	seq_printf(s, "%20s %10s %10s %10s %10s %10s\n",
+		      "Name", "Base", "Cnt", "CIDX", "DIDX", "QCnt");
+	dump_dma_rx_ring_info(s, dev, "R1:Data1(MAC2H)", MT_DBG_WFDMA0_PCIE1_RX1_CTRL0);
+
+	seq_printf(s, "HOST_DMA1 Ring Configuration\n");
+	seq_printf(s, "%20s %10s %10s %10s %10s %10s\n",
+		      "Name", "Base", "Cnt", "CIDX", "DIDX", "QCnt");
+	dump_dma_tx_ring_info(s, dev, "T16:FWDL", MT_DBG_TX_RING_CTRL(0));
+	dump_dma_tx_ring_info(s, dev, "T17:Cmd(H2WM)", MT_DBG_TX_RING_CTRL(1));
+	if (mtk_wed_device_active(&dev->mt76.mmio.wed)) {
+		dump_dma_tx_ring_info(s, dev, "T18:TXD0(H2WA)",  MT_DBG_WFDMA_WED_TX_CTRL(0));
+		dump_dma_tx_ring_info(s, dev, "T19:TXD1(H2WA)",  MT_DBG_WFDMA_WED_TX_CTRL(1));
+	} else {
+		dump_dma_tx_ring_info(s, dev, "T18:TXD0(H2WA)", MT_DBG_TX_RING_CTRL(2));
+		dump_dma_tx_ring_info(s, dev, "T19:TXD1(H2WA)", MT_DBG_TX_RING_CTRL(3));
+	}
+	dump_dma_tx_ring_info(s, dev, "T20:Cmd(H2WA)", MT_DBG_TX_RING_CTRL(4));
+	dump_dma_rx_ring_info(s, dev, "R0:Event(WM2H)", MT_DBG_RX_EVENT_RING_CTRL(0));
+	if (mtk_wed_device_active(&dev->mt76.mmio.wed))
+		dump_dma_rx_ring_info(s, dev, "R1:TxDone(WA2H)", MT_DBG_WFDMA_WED_RX_CTRL(1));
+	else
+		dump_dma_rx_ring_info(s, dev, "R1:Event0(WA2H)", MT_DBG_RX_EVENT_RING_CTRL(1));
+	dump_dma_rx_ring_info(s, dev, "R2:Event1(WA2H)", MT_DBG_RX_EVENT_RING_CTRL(2));
+
+	seq_printf(s, "HOST_DMA1 PCIe 1 Ring Configuration\n");
+	seq_printf(s, "%20s %10s %10s %10s %10s %10s\n",
+		      "Name", "Base", "Cnt", "CIDX", "DIDX", "QCnt");
+	dump_dma_tx_ring_info(s, dev, "T19:TXD1(H2WA)", MT_DBG_WFDMA1_PCIE1_TX19_CTRL0);
+	dump_dma_rx_ring_info(s, dev, "R2:Event1(WA2H)", MT_DBG_WFDMA1_PCIE1_RX2_CTRL0);
+}
+
+static void
+mt7915_show_mcu_dma_info(struct seq_file *s, struct mt7915_dev *dev)
+{
+	u32 sys_ctrl[9] = {};
+
+	/* MCU DMA information */
+	sys_ctrl[0] = mt76_rr(dev, WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_ADDR);
+	sys_ctrl[1] = mt76_rr(dev, WF_WFDMA_MCU_DMA0_HOST_INT_STA_ADDR);
+	sys_ctrl[2] = mt76_rr(dev, WF_WFDMA_MCU_DMA0_HOST_INT_ENA_ADDR);
+
+	sys_ctrl[3] = mt76_rr(dev, WF_WFDMA_MCU_DMA1_WPDMA_GLO_CFG_ADDR);
+	sys_ctrl[4] = mt76_rr(dev, WF_WFDMA_MCU_DMA1_HOST_INT_STA_ADDR);
+	sys_ctrl[5] = mt76_rr(dev, WF_WFDMA_MCU_DMA1_HOST_INT_ENA_ADDR);
+	sys_ctrl[6] = mt76_rr(dev, WF_WFDMA_MCU_DMA1_PCIE1_WPDMA_GLO_CFG_ADDR);
+	sys_ctrl[7] = mt76_rr(dev, WF_WFDMA_MCU_DMA1_PCIE1_HOST_INT_STA_ADDR);
+	sys_ctrl[8] = mt76_rr(dev, WF_WFDMA_MCU_DMA1_PCIE1_HOST_INT_ENA_ADDR);
+
+	seq_printf(s, "MCU_DMA Configuration\n");
+	seq_printf(s, "%10s %10s %10s %10s %10s %10s\n",
+		      "DMA", "IntCSR", "IntMask", "Glocfg", "Tx/RxEn", "Tx/RxBusy");
+	seq_printf(s, "%10s %10x %10x %10x %4x/%5x %4x/%5x\n",
+		      "DMA0", sys_ctrl[1], sys_ctrl[2], sys_ctrl[0],
+		      (sys_ctrl[0] & WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_MASK) >> WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_SHFT,
+		      (sys_ctrl[0] & WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_MASK) >> WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_SHFT,
+		      (sys_ctrl[0] & WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK) >> WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT,
+		      (sys_ctrl[0] & WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK) >> WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT);
+
+	seq_printf(s, "%10s %10x %10x %10x %4x/%5x %4x/%5x\n",
+		      "DMA1", sys_ctrl[4], sys_ctrl[5], sys_ctrl[3],
+		      (sys_ctrl[3] & WF_WFDMA_MCU_DMA1_WPDMA_GLO_CFG_TX_DMA_EN_MASK) >> WF_WFDMA_MCU_DMA1_WPDMA_GLO_CFG_TX_DMA_EN_SHFT,
+		      (sys_ctrl[3] & WF_WFDMA_MCU_DMA1_WPDMA_GLO_CFG_RX_DMA_EN_MASK) >> WF_WFDMA_MCU_DMA1_WPDMA_GLO_CFG_RX_DMA_EN_SHFT,
+		      (sys_ctrl[3] & WF_WFDMA_MCU_DMA1_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK) >> WF_WFDMA_MCU_DMA1_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT,
+		      (sys_ctrl[3] & WF_WFDMA_MCU_DMA1_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK) >> WF_WFDMA_MCU_DMA1_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT);
+	seq_printf(s, "%10s %10x %10x %10x %4x/%5x %4x/%5x\n",
+		      "DMA1P1", sys_ctrl[7], sys_ctrl[8], sys_ctrl[6],
+		      (sys_ctrl[6] & WF_WFDMA_MCU_DMA1_PCIE1_WPDMA_GLO_CFG_TX_DMA_EN_MASK) >> WF_WFDMA_MCU_DMA1_PCIE1_WPDMA_GLO_CFG_TX_DMA_EN_SHFT,
+		      (sys_ctrl[6] & WF_WFDMA_MCU_DMA1_PCIE1_WPDMA_GLO_CFG_RX_DMA_EN_MASK) >> WF_WFDMA_MCU_DMA1_PCIE1_WPDMA_GLO_CFG_RX_DMA_EN_SHFT,
+		      (sys_ctrl[6] & WF_WFDMA_MCU_DMA1_PCIE1_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK) >> WF_WFDMA_MCU_DMA1_PCIE1_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT,
+		      (sys_ctrl[6] & WF_WFDMA_MCU_DMA1_PCIE1_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK) >> WF_WFDMA_MCU_DMA1_PCIE1_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT);
+
+	seq_printf(s, "MCU_DMA0 Ring Configuration\n");
+	seq_printf(s, "%20s %10s %10s %10s %10s %10s\n",
+		      "Name", "Base", "Cnt", "CIDX", "DIDX", "QCnt");
+	dump_dma_tx_ring_info(s, dev, "T0:TXD(WM2MAC)", WF_WFDMA_MCU_DMA0_WPDMA_TX_RING0_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T1:TXCMD(WM2MAC)", WF_WFDMA_MCU_DMA0_WPDMA_TX_RING1_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T2:TXD(WA2MAC)", WF_WFDMA_MCU_DMA0_WPDMA_TX_RING2_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R0:Data(MAC2WM)", WF_WFDMA_MCU_DMA0_WPDMA_RX_RING0_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R1:TxDone(MAC2WM)", WF_WFDMA_MCU_DMA0_WPDMA_RX_RING1_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R2:SPL(MAC2WM)", WF_WFDMA_MCU_DMA0_WPDMA_RX_RING2_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R3:TxDone(MAC2WA)", WF_WFDMA_MCU_DMA0_WPDMA_RX_RING3_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R4:TXS(MAC2WA)", WF_WFDMA_MCU_DMA0_WPDMA_RX_RING4_CTRL0_ADDR);
+
+	seq_printf(s, "MCU_DMA1 Ring Configuration\n");
+	seq_printf(s, "%20s %10s %10s %10s %10s %10s\n",
+		      "Name", "Base", "Cnt", "CIDX", "DIDX", "QCnt");
+	dump_dma_tx_ring_info(s, dev, "T0:Event(WM2H)", WF_WFDMA_MCU_DMA1_WPDMA_TX_RING0_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T1:Event0(WA2H)", WF_WFDMA_MCU_DMA1_WPDMA_TX_RING1_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T2:Event1(WA2H)", WF_WFDMA_MCU_DMA1_WPDMA_TX_RING2_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R0:FWDL", WF_WFDMA_MCU_DMA1_WPDMA_RX_RING0_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R1:Cmd(H2WM)", WF_WFDMA_MCU_DMA1_WPDMA_RX_RING1_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R2:TXD0(H2WA)", WF_WFDMA_MCU_DMA1_WPDMA_RX_RING2_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R3:TXD1(H2WA)", WF_WFDMA_MCU_DMA1_WPDMA_RX_RING3_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R4:Cmd(H2WA)", WF_WFDMA_MCU_DMA1_WPDMA_RX_RING4_CTRL0_ADDR);
+
+	seq_printf(s, "MCU_DMA1 PCIe 1 Ring Configuration\n");
+	seq_printf(s, "%20s %10s %10s %10s %10s %10s\n",
+		      "Name", "Base", "Cnt", "CIDX", "DIDX", "QCnt");
+	dump_dma_tx_ring_info(s, dev, "T2:Event1(WA2H)", WF_WFDMA_MCU_DMA1_PCIE1_WPDMA_TX_RING2_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R3:TXD1(H2WA)", WF_WFDMA_MCU_DMA1_PCIE1_WPDMA_RX_RING3_CTRL0_ADDR);
+}
+
+static void
+mt7986_show_host_dma_info(struct seq_file *s, struct mt7915_dev *dev)
+{
+	u32 sys_ctrl[5] = {};
+
+	/* HOST DMA */
+	sys_ctrl[0] = mt76_rr(dev, MT_DBG_INT_SOURCE_CSR);
+	sys_ctrl[1] = mt76_rr(dev, MT_DBG_INT_MASK_CSR);
+	sys_ctrl[2] = mt76_rr(dev, MT_DBG_WFDMA0_INT_SOURCE_CSR);
+	sys_ctrl[3] = mt76_rr(dev, MT_DBG_WFDMA0_INT_MASK_CSR);
+	sys_ctrl[4] = mt76_rr(dev, MT_DBG_WFDMA0_GLO_CFG);
+
+	seq_printf(s, "HOST_DMA Configuration\n");
+	seq_printf(s, "%10s %10s %10s %10s %10s %10s\n",
+			"DMA", "IntCSR", "IntMask", "Glocfg", "Tx/RxEn", "Tx/RxBusy");
+	seq_printf(s, "%10s %10x %10x\n",
+			"Merge", sys_ctrl[0], sys_ctrl[1]);
+	seq_printf(s, "%10s %10x %10x %10x %4lx/%5lx %4lx/%5lx\n",
+			"DMA0", sys_ctrl[2], sys_ctrl[3], sys_ctrl[4],
+			FIELD_GET(MT_DBG_WFDMA_HOST_DMA0_GLO_CFG_TX_DMA_EN_MASK, sys_ctrl[4]),
+			FIELD_GET(MT_DBG_WFDMA_HOST_DMA0_GLO_CFG_RX_DMA_EN_MASK, sys_ctrl[4]),
+			FIELD_GET(MT_DBG_WFDMA_HOST_DMA0_GLO_CFG_TX_DMA_BUSY_MASK, sys_ctrl[4]),
+			FIELD_GET(MT_DBG_WFDMA_HOST_DMA0_GLO_CFG_RX_DMA_BUSY_MASK, sys_ctrl[4]));
+
+
+	seq_printf(s, "HOST_DMA0 Ring Configuration\n");
+	seq_printf(s, "%20s %10s %10s %10s %10s %10s\n",
+		      "Name", "Base", "Cnt", "CIDX", "DIDX", "QCnt");
+	dump_dma_tx_ring_info(s, dev, "T16:FWDL", MT_DBG_TX_RING_CTRL(0));
+	dump_dma_tx_ring_info(s, dev, "T17:Cmd(H2WM)",	MT_DBG_TX_RING_CTRL(1));
+
+	if (is_mt7916(&dev->mt76) && mtk_wed_device_active(&dev->mt76.mmio.wed)) {
+		dump_dma_tx_ring_info(s, dev, "T18:TXD0(H2WA)",  MT_DBG_WFDMA_WED_TX_CTRL(0));
+		dump_dma_tx_ring_info(s, dev, "T19:TXD1(H2WA)",  MT_DBG_WFDMA_WED_TX_CTRL(1));
+	} else {
+		dump_dma_tx_ring_info(s, dev, "T18:TXD0(H2WA)",  MT_DBG_TX_RING_CTRL(2));
+		dump_dma_tx_ring_info(s, dev, "T19:TXD1(H2WA)",  MT_DBG_TX_RING_CTRL(3));
+	}
+
+	dump_dma_tx_ring_info(s, dev, "T20:Cmd(H2WA)",	MT_DBG_TX_RING_CTRL(4));
+	dump_dma_rx_ring_info(s, dev, "R0:Event(WM2H)", MT_DBG_RX_DATA_RING_CTRL(0));
+	dump_dma_rx_ring_info(s, dev, "R1:Event(WA2H)", MT_DBG_RX_EVENT_RING_CTRL(1));
+	if (is_mt7916(&dev->mt76) && mtk_wed_device_active(&dev->mt76.mmio.wed))
+		dump_dma_rx_ring_info(s, dev, "R2:TxDone(WA2H)", MT_DBG_WFDMA_WED_RX_CTRL(1));
+	else
+		dump_dma_rx_ring_info(s, dev, "R2:TxDone(WA2H)", MT_DBG_RX_EVENT_RING_CTRL(2));
+	dump_dma_rx_ring_info(s, dev, "R3:TxDone1(WA2H)", MT_DBG_RX_EVENT_RING_CTRL(3));
+	dump_dma_rx_ring_info(s, dev, "R4:Data0(MAC2H)", MT_DBG_RX_DATA_RING_CTRL(0));
+	dump_dma_rx_ring_info(s, dev, "R5:Data1(MAC2H)", MT_DBG_RX_DATA_RING_CTRL(1));
+}
+
+static void
+mt7986_show_mcu_dma_info(struct seq_file *s, struct mt7915_dev *dev)
+{
+	u32 sys_ctrl[3] = {};
+
+	/* MCU DMA information */
+	sys_ctrl[0] = mt76_rr(dev, WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_ADDR);
+	sys_ctrl[1] = mt76_rr(dev, WF_WFDMA_MCU_DMA0_HOST_INT_STA_ADDR);
+	sys_ctrl[2] = mt76_rr(dev, WF_WFDMA_MCU_DMA0_HOST_INT_ENA_ADDR);
+
+	seq_printf(s, "MCU_DMA Configuration\n");
+	seq_printf(s, "%10s %10s %10s %10s %10s %10s\n",
+		      "DMA", "IntCSR", "IntMask", "Glocfg", "Tx/RxEn", "Tx/RxBusy");
+	seq_printf(s, "%10s %10x %10x %10x %4x/%5x %4x/%5x\n",
+		      "DMA0", sys_ctrl[1], sys_ctrl[2], sys_ctrl[0],
+		      (sys_ctrl[0] & WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_MASK) >> WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_SHFT,
+		      (sys_ctrl[0] & WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_MASK) >> WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_SHFT,
+		      (sys_ctrl[0] & WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK) >> WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT,
+		      (sys_ctrl[0] & WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK) >> WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT);
+
+	seq_printf(s, "MCU_DMA0 Ring Configuration\n");
+	seq_printf(s, "%22s %10s %10s %10s %10s %10s\n",
+		      "Name", "Base", "Cnt", "CIDX", "DIDX", "QCnt");
+	dump_dma_tx_ring_info(s, dev, "T0:Event (WM2H)", WF_WFDMA_MCU_DMA0_WPDMA_TX_RING0_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T1:Event (WA2H)", WF_WFDMA_MCU_DMA0_WPDMA_TX_RING1_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T2:TxDone (WA2H)", WF_WFDMA_MCU_DMA0_WPDMA_TX_RING2_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T3:TxDone1 (WA2H)", WF_WFDMA_MCU_DMA0_WPDMA_TX_RING3_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T4:TXD (WM2MAC)", WF_WFDMA_MCU_DMA0_WPDMA_TX_RING4_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T5:TXCMD (WM2MAC)", WF_WFDMA_MCU_DMA0_WPDMA_TX_RING5_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T6:TXD (WA2MAC)", WF_WFDMA_MCU_DMA0_WPDMA_TX_RING6_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R0:FWDL", WF_WFDMA_MCU_DMA0_WPDMA_RX_RING0_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R1:Cmd (H2WM)", WF_WFDMA_MCU_DMA0_WPDMA_RX_RING1_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R2:TXD (H2WA)", WF_WFDMA_MCU_DMA0_WPDMA_RX_RING2_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R3:TXD1 (H2WA)", WF_WFDMA_MCU_DMA0_WPDMA_RX_RING3_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R4:Cmd (H2WA)", WF_WFDMA_MCU_DMA0_WPDMA_RX_RING4_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R5:Data (MAC2WM)", WF_WFDMA_MCU_DMA0_WPDMA_RX_RING5_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R6:TxDone/STS (MAC2WM)", WF_WFDMA_MCU_DMA0_WPDMA_RX_RING6_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R7:RPT (MAC2WM)", WF_WFDMA_MCU_DMA0_WPDMA_RX_RING7_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R8:TxDone/STS (MAC2WA)", WF_WFDMA_MCU_DMA0_WPDMA_RX_RING8_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R9:Data1 (MAC2WM)", WF_WFDMA_MCU_DMA0_WPDMA_RX_RING9_CTRL0_ADDR);
+
+}
+
+static void
+mt7915_show_dma_info(struct seq_file *s, struct mt7915_dev *dev)
+{
+	u32 sys_ctrl[10] = {};
+
+	if(is_mt7915(&dev->mt76)) {
+		mt7915_show_host_dma_info(s, dev);
+		mt7915_show_mcu_dma_info(s, dev);
+	} else {
+		mt7986_show_host_dma_info(s, dev);
+		mt7986_show_mcu_dma_info(s, dev);
+	}
+
+	/* MEM DMA information */
+	sys_ctrl[0] = mt76_rr(dev, WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_ADDR);
+	sys_ctrl[1] = mt76_rr(dev, WF_WFDMA_MEM_DMA_HOST_INT_STA_ADDR);
+	sys_ctrl[2] = mt76_rr(dev, WF_WFDMA_MEM_DMA_HOST_INT_ENA_ADDR);
+
+	seq_printf(s, "MEM_DMA Configuration\n");
+	seq_printf(s, "%10s %10s %10s %10s %10s %10s\n",
+		      "DMA", "IntCSR", "IntMask", "Glocfg", "Tx/RxEn", "Tx/RxBusy");
+	seq_printf(s, "%10s %10x %10x %10x %4x/%5x %4x/%5x\n",
+		      "MEM", sys_ctrl[1], sys_ctrl[2], sys_ctrl[0],
+		      (sys_ctrl[0] & WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_EN_MASK) >> WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_EN_SHFT,
+		      (sys_ctrl[0] & WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_EN_MASK) >> WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_EN_SHFT,
+		      (sys_ctrl[0] & WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK) >> WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT,
+		      (sys_ctrl[0] & WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK) >> WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT);
+
+	seq_printf(s, "MEM_DMA Ring Configuration\n");
+	seq_printf(s, "%20s %10s %10s %10s %10s %10s\n",
+		      "Name", "Base", "Cnt", "CIDX", "DIDX", "QCnt");
+	dump_dma_tx_ring_info(s, dev, "T0:CmdEvent(WM2WA)", WF_WFDMA_MEM_DMA_WPDMA_TX_RING0_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T1:CmdEvent(WA2WM)", WF_WFDMA_MEM_DMA_WPDMA_TX_RING1_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R0:CmdEvent(WM2WA)", WF_WFDMA_MEM_DMA_WPDMA_RX_RING0_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R1:CmdEvent(WA2WM)", WF_WFDMA_MEM_DMA_WPDMA_RX_RING1_CTRL0_ADDR);
+}
+
+static int mt7915_trinfo_read(struct seq_file *s, void *data)
+{
+	struct mt7915_dev *dev = dev_get_drvdata(s->private);
+	const struct hif_pci_tx_ring_desc *tx_ring_layout;
+	const struct hif_pci_rx_ring_desc *rx_ring_layout;
+	struct mtk_wed_device *wed = &dev->mt76.mmio.wed;
+	u32 tx_ring_num, rx_ring_num;
+	u32 tbase[5], tcnt[5];
+	u32 tcidx[5], tdidx[5];
+	u32 rbase[6], rcnt[6];
+	u32 rcidx[6], rdidx[6];
+	int idx;
+	bool flags = false;
+
+	if(is_mt7915(&dev->mt76)) {
+		tx_ring_layout = &mt7915_tx_ring_layout[0];
+		rx_ring_layout = &mt7915_rx_ring_layout[0];
+		tx_ring_num = ARRAY_SIZE(mt7915_tx_ring_layout);
+		rx_ring_num = ARRAY_SIZE(mt7915_rx_ring_layout);
+	} else {
+		tx_ring_layout = &mt7986_tx_ring_layout[0];
+		rx_ring_layout = &mt7986_rx_ring_layout[0];
+		tx_ring_num = ARRAY_SIZE(mt7986_tx_ring_layout);
+		rx_ring_num = ARRAY_SIZE(mt7986_rx_ring_layout);
+	}
+
+	for (idx = 0; idx < tx_ring_num; idx++) {
+		if (mtk_wed_device_active(wed) &&
+		    (tx_ring_layout[idx].ring_attr == HIF_TX_DATA)) {
+			struct mt76_phy *phy = dev->mt76.phys[MT_BAND0];
+			struct mt76_phy *ext_phy = dev->mt76.phys[MT_BAND1];
+			struct mt76_queue *q;
+
+			tbase[idx] = tcnt[idx] = tcidx[idx] = tdidx[idx] = 0;
+
+			if (!phy)
+				continue;
+
+			if (flags && !ext_phy)
+				continue;
+
+			if (flags && ext_phy)
+				phy = ext_phy;
+
+			q = phy->q_tx[0];
+
+			if (q->wed_regs) {
+				tbase[idx] = mtk_wed_device_reg_read(wed, q->wed_regs);
+				tcnt[idx]  = mtk_wed_device_reg_read(wed, q->wed_regs + 0x04);
+				tcidx[idx] = mtk_wed_device_reg_read(wed, q->wed_regs + 0x08);
+				tdidx[idx] = mtk_wed_device_reg_read(wed, q->wed_regs + 0x0c);
+			}
+
+			flags = true;
+		} else {
+			tbase[idx] = mt76_rr(dev, MT_DBG_TX_RING_CTRL(idx));
+			tcnt[idx]  = mt76_rr(dev, MT_DBG_TX_RING_CTRL(idx) + 0x04);
+			tcidx[idx] = mt76_rr(dev, MT_DBG_TX_RING_CTRL(idx) + 0x08);
+			tdidx[idx] = mt76_rr(dev, MT_DBG_TX_RING_CTRL(idx) + 0x0c);}
+	}
+
+	for (idx = 0; idx < rx_ring_num; idx++) {
+		if (rx_ring_layout[idx].ring_attr == HIF_RX_DATA) {
+			if (mtk_wed_device_active(wed) && mtk_wed_get_rx_capa(wed)) {
+				struct mt76_queue *q = &dev->mt76.q_rx[MT_RXQ_MAIN];
+
+				rbase[idx] = rcnt[idx] = rcidx[idx] = rdidx[idx] = 0;
+
+				if (idx == 1)
+					q = &dev->mt76.q_rx[MT_RXQ_BAND1];
+
+				if (q->wed_regs) {
+					rbase[idx] = mtk_wed_device_reg_read(wed, q->wed_regs);
+					rcnt[idx]  = mtk_wed_device_reg_read(wed, q->wed_regs + 0x04);
+					rcidx[idx] = mtk_wed_device_reg_read(wed, q->wed_regs + 0x08);
+					rdidx[idx] = mtk_wed_device_reg_read(wed, q->wed_regs + 0x0c);
+				}
+			} else {
+				rbase[idx] = mt76_rr(dev, MT_DBG_RX_DATA_RING_CTRL(idx));
+				rcnt[idx]  = mt76_rr(dev, MT_DBG_RX_DATA_RING_CTRL(idx) + 0x04);
+				rcidx[idx] = mt76_rr(dev, MT_DBG_RX_DATA_RING_CTRL(idx) + 0x08);
+				rdidx[idx] = mt76_rr(dev, MT_DBG_RX_DATA_RING_CTRL(idx) + 0x0c);
+			}
+		} else {
+			if (mtk_wed_device_active(wed) && rx_ring_layout[idx].flags) {
+				struct mt76_queue *q = &dev->mt76.q_rx[MT_RXQ_MAIN_WA];
+
+				if (is_mt7915(&dev->mt76))
+					q = &dev->mt76.q_rx[MT_RXQ_MCU_WA];
+
+				rbase[idx] = mtk_wed_device_reg_read(wed, q->wed_regs);
+				rcnt[idx]  = mtk_wed_device_reg_read(wed, q->wed_regs + 0x04);
+				rcidx[idx] = mtk_wed_device_reg_read(wed, q->wed_regs + 0x08);
+				rdidx[idx] = mtk_wed_device_reg_read(wed, q->wed_regs + 0x0c);
+
+			} else {
+				rbase[idx] = mt76_rr(dev, MT_DBG_RX_EVENT_RING_CTRL(idx - 2));
+				rcnt[idx]  = mt76_rr(dev, MT_DBG_RX_EVENT_RING_CTRL(idx - 2) + 0x04);
+				rcidx[idx] = mt76_rr(dev, MT_DBG_RX_EVENT_RING_CTRL(idx - 2) + 0x08);
+				rdidx[idx] = mt76_rr(dev, MT_DBG_RX_EVENT_RING_CTRL(idx - 2) + 0x0c);
+			}
+		}
+	}
+
+	seq_printf(s, "=================================================\n");
+	seq_printf(s, "TxRing Configuration\n");
+	seq_printf(s, "%4s %10s %8s %1s %6s %6s %6s %6s\n",
+		      "Idx", "Attr", "Reg", "Base", "Cnt", "CIDX", "DIDX",
+		      "QCnt");
+	for (idx = 0; idx < tx_ring_num; idx++) {
+		u32 queue_cnt;
+
+		queue_cnt = (tcidx[idx] >= tdidx[idx]) ?
+			    (tcidx[idx] - tdidx[idx]) :
+			    (tcidx[idx] - tdidx[idx] + tcnt[idx]);
+		seq_printf(s, "%4d %8s %8x %10x %6x %6x %6x %6x\n",
+			   idx, tx_ring_layout[idx].ring_info,
+			   MT_DBG_TX_RING_CTRL(idx), tbase[idx],
+			   tcnt[idx], tcidx[idx], tdidx[idx], queue_cnt);
+	}
+
+	seq_printf(s, "RxRing Configuration\n");
+	seq_printf(s, "%4s %10s %8s %10s %6s %6s %6s %6s\n",
+		      "Idx", "Attr", "Reg", "Base", "Cnt", "CIDX", "DIDX",
+		      "QCnt");
+
+	for (idx = 0; idx < rx_ring_num; idx++) {
+		u32 queue_cnt;
+
+		queue_cnt = (rdidx[idx] > rcidx[idx]) ?
+			    (rdidx[idx] - rcidx[idx] - 1) :
+			    (rdidx[idx] - rcidx[idx] + rcnt[idx] - 1);
+		seq_printf(s, "%4d %8s %8x %10x %6x %6x %6x %6x\n",
+			   idx, rx_ring_layout[idx].ring_info,
+			   (idx < 2) ? MT_DBG_RX_DATA_RING_CTRL(idx): MT_DBG_RX_EVENT_RING_CTRL(idx - 2),
+			   rbase[idx], rcnt[idx], rcidx[idx], rdidx[idx], queue_cnt);
+	}
+
+	mt7915_show_dma_info(s, dev);
+	return 0;
+}
+
+static int mt7915_drr_info(struct seq_file *s, void *data)
+{
+#define DL_AC_START	0x00
+#define DL_AC_END	0x0F
+#define UL_AC_START	0x10
+#define UL_AC_END	0x1F
+
+	struct mt7915_dev *dev = dev_get_drvdata(s->private);
+	u32 drr_sta_status[16];
+	u32 drr_ctrl_def_val = 0x80220000, drr_ctrl_val = 0;
+	bool is_show = false;
+	int idx, sta_line = 0, sta_no = 0, max_sta_line = (mt7915_wtbl_size(dev) + 31) / 32;
+	seq_printf(s, "DRR Table STA Info:\n");
+
+	for (idx = DL_AC_START; idx <= DL_AC_END; idx++) {
+		is_show = true;
+		drr_ctrl_val = (drr_ctrl_def_val | idx);
+		mt76_wr(dev, MT_DBG_PLE_DRR_TAB_CTRL, drr_ctrl_val);
+		drr_sta_status[0] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA0);
+		drr_sta_status[1] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA1);
+		drr_sta_status[2] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA2);
+		drr_sta_status[3] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA3);
+		drr_sta_status[4] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA4);
+		drr_sta_status[5] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA5);
+		drr_sta_status[6] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA6);
+		drr_sta_status[7] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA7);
+
+		if (is_mt7915(&dev->mt76) && max_sta_line > 8) {
+			drr_ctrl_val = (drr_ctrl_def_val | idx | 1 << 10);
+			mt76_wr(dev, MT_DBG_PLE_DRR_TAB_CTRL, drr_ctrl_val);
+			drr_sta_status[8] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA0);
+			drr_sta_status[9] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA1);
+			drr_sta_status[10] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA2);
+			drr_sta_status[11] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA3);
+			drr_sta_status[12] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA4);
+			drr_sta_status[13] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA5);
+			drr_sta_status[14] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA6);
+			drr_sta_status[15] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA7);
+		}
+		if (!is_mt7915(&dev->mt76))
+			max_sta_line = 8;
+
+		for (sta_line = 0; sta_line < max_sta_line; sta_line++) {
+			if (drr_sta_status[sta_line] > 0) {
+				for (sta_no = 0; sta_no < 32; sta_no++) {
+					if (((drr_sta_status[sta_line] & (0x1 << sta_no)) >> sta_no)) {
+						if (is_show) {
+							seq_printf(s, "\n DL AC%02d Queue Non-Empty STA:\n", idx);
+							is_show = false;
+						}
+						seq_printf(s, "%d ", sta_no + (sta_line * 32));
+					}
+				}
+			}
+		}
+	}
+
+	for (idx = UL_AC_START; idx <= UL_AC_END; idx++) {
+		is_show = true;
+		drr_ctrl_val = (drr_ctrl_def_val | idx);
+		mt76_wr(dev, MT_DBG_PLE_DRR_TAB_CTRL, drr_ctrl_val);
+		drr_sta_status[0] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA0);
+		drr_sta_status[1] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA1);
+		drr_sta_status[2] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA2);
+		drr_sta_status[3] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA3);
+		drr_sta_status[4] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA4);
+		drr_sta_status[5] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA5);
+		drr_sta_status[6] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA6);
+		drr_sta_status[7] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA7);
+
+		if (is_mt7915(&dev->mt76) && max_sta_line > 8) {
+			drr_ctrl_val = (drr_ctrl_def_val | idx | 1 << 10);
+			mt76_wr(dev, MT_DBG_PLE_DRR_TAB_CTRL, drr_ctrl_val);
+			drr_sta_status[8] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA0);
+			drr_sta_status[9] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA1);
+			drr_sta_status[10] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA2);
+			drr_sta_status[11] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA3);
+			drr_sta_status[12] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA4);
+			drr_sta_status[13] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA5);
+			drr_sta_status[14] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA6);
+			drr_sta_status[15] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA7);
+		}
+
+		if (!is_mt7915(&dev->mt76))
+			max_sta_line = 8;
+
+		for (sta_line = 0; sta_line < max_sta_line; sta_line++) {
+			if (drr_sta_status[sta_line] > 0) {
+				for (sta_no = 0; sta_no < 32; sta_no++) {
+					if (((drr_sta_status[sta_line] & (0x1 << sta_no)) >> sta_no)) {
+						if (is_show) {
+							seq_printf(s, "\n UL AC%02d Queue Non-Empty STA:\n", idx);
+							is_show = false;
+						}
+						seq_printf(s, "%d ", sta_no + (sta_line * 32));
+					}
+				}
+			}
+		}
+	}
+
+	for (idx = DL_AC_START; idx <= DL_AC_END; idx++) {
+		drr_ctrl_def_val = 0x80420000;
+		drr_ctrl_val = (drr_ctrl_def_val | idx);
+		mt76_wr(dev, MT_DBG_PLE_DRR_TAB_CTRL, drr_ctrl_val);
+		drr_sta_status[0] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA0);
+		drr_sta_status[1] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA1);
+		drr_sta_status[2] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA2);
+		drr_sta_status[3] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA3);
+		drr_sta_status[4] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA4);
+		drr_sta_status[5] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA5);
+		drr_sta_status[6] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA6);
+		drr_sta_status[7] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA7);
+
+		if (is_mt7915(&dev->mt76) && max_sta_line > 8) {
+			drr_ctrl_val = (drr_ctrl_def_val | idx | 1<<10);
+			mt76_wr(dev, MT_DBG_PLE_DRR_TAB_CTRL, drr_ctrl_val);
+			drr_sta_status[8] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA0);
+			drr_sta_status[9] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA1);
+			drr_sta_status[10] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA2);
+			drr_sta_status[11] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA3);
+			drr_sta_status[12] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA4);
+			drr_sta_status[13] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA5);
+			drr_sta_status[14] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA6);
+			drr_sta_status[15] = mt76_rr(dev, MT_DBG_PLE_DRR_TABLE_RDATA7);
+		}
+
+		seq_printf(s, "\nBSSGrp[%d]:\n", idx);
+		if (!is_mt7915(&dev->mt76))
+			max_sta_line = 8;
+
+		for (sta_line = 0; sta_line < max_sta_line; sta_line++) {
+			seq_printf(s, "0x%08x ", drr_sta_status[sta_line]);
+
+			if ((sta_line % 4) == 3)
+				seq_printf(s, "\n");
+		}
+	}
+
+	return 0;
+}
+
+#define CR_NUM_OF_AC 17
+
+typedef enum _ENUM_UMAC_PORT_T {
+	ENUM_UMAC_HIF_PORT_0         = 0,
+	ENUM_UMAC_CPU_PORT_1         = 1,
+	ENUM_UMAC_LMAC_PORT_2        = 2,
+	ENUM_PLE_CTRL_PSE_PORT_3     = 3,
+	ENUM_UMAC_PSE_PLE_PORT_TOTAL_NUM = 4
+} ENUM_UMAC_PORT_T, *P_ENUM_UMAC_PORT_T;
+
+/* N9 MCU QUEUE LIST */
+typedef enum _ENUM_UMAC_CPU_P_QUEUE_T {
+	ENUM_UMAC_CTX_Q_0 = 0,
+	ENUM_UMAC_CTX_Q_1 = 1,
+	ENUM_UMAC_CTX_Q_2 = 2,
+	ENUM_UMAC_CTX_Q_3 = 3,
+	ENUM_UMAC_CRX     = 0,
+	ENUM_UMAC_CIF_QUEUE_TOTAL_NUM = 4
+} ENUM_UMAC_CPU_P_QUEUE_T, *P_ENUM_UMAC_CPU_P_QUEUE_T;
+
+/* LMAC PLE TX QUEUE LIST */
+typedef enum _ENUM_UMAC_LMAC_PLE_TX_P_QUEUE_T {
+	ENUM_UMAC_LMAC_PLE_TX_Q_00           = 0x00,
+	ENUM_UMAC_LMAC_PLE_TX_Q_01           = 0x01,
+	ENUM_UMAC_LMAC_PLE_TX_Q_02           = 0x02,
+	ENUM_UMAC_LMAC_PLE_TX_Q_03           = 0x03,
+
+	ENUM_UMAC_LMAC_PLE_TX_Q_10           = 0x04,
+	ENUM_UMAC_LMAC_PLE_TX_Q_11           = 0x05,
+	ENUM_UMAC_LMAC_PLE_TX_Q_12           = 0x06,
+	ENUM_UMAC_LMAC_PLE_TX_Q_13           = 0x07,
+
+	ENUM_UMAC_LMAC_PLE_TX_Q_20           = 0x08,
+	ENUM_UMAC_LMAC_PLE_TX_Q_21           = 0x09,
+	ENUM_UMAC_LMAC_PLE_TX_Q_22           = 0x0a,
+	ENUM_UMAC_LMAC_PLE_TX_Q_23           = 0x0b,
+
+	ENUM_UMAC_LMAC_PLE_TX_Q_30           = 0x0c,
+	ENUM_UMAC_LMAC_PLE_TX_Q_31           = 0x0d,
+	ENUM_UMAC_LMAC_PLE_TX_Q_32           = 0x0e,
+	ENUM_UMAC_LMAC_PLE_TX_Q_33           = 0x0f,
+
+	ENUM_UMAC_LMAC_PLE_TX_Q_ALTX_0      = 0x10,
+	ENUM_UMAC_LMAC_PLE_TX_Q_BMC_0       = 0x11,
+	ENUM_UMAC_LMAC_PLE_TX_Q_BNC_0       = 0x12,
+	ENUM_UMAC_LMAC_PLE_TX_Q_PSMP_0      = 0x13,
+
+	ENUM_UMAC_LMAC_PLE_TX_Q_ALTX_1      = 0x14,
+	ENUM_UMAC_LMAC_PLE_TX_Q_BMC_1       = 0x15,
+	ENUM_UMAC_LMAC_PLE_TX_Q_BNC_1       = 0x16,
+	ENUM_UMAC_LMAC_PLE_TX_Q_PSMP_1      = 0x17,
+	ENUM_UMAC_LMAC_PLE_TX_Q_NAF         = 0x18,
+	ENUM_UMAC_LMAC_PLE_TX_Q_NBCN        = 0x19,
+	ENUM_UMAC_LMAC_PLE_TX_Q_RELEASE     = 0x1f, /* DE suggests not to use 0x1f, it's only for hw free queue */
+	ENUM_UMAC_LMAC_QUEUE_TOTAL_NUM      = 24,
+
+} ENUM_UMAC_LMAC_TX_P_QUEUE_T, *P_ENUM_UMAC_LMAC_TX_P_QUEUE_T;
+
+typedef struct _EMPTY_QUEUE_INFO_T {
+	char *QueueName;
+	u32 Portid;
+	u32 Queueid;
+} EMPTY_QUEUE_INFO_T, *P_EMPTY_QUEUE_INFO_T;
+
+static EMPTY_QUEUE_INFO_T ple_queue_empty_info[] = {
+	{"CPU Q0",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_0},
+	{"CPU Q1",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_1},
+	{"CPU Q2",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_2},
+	{"CPU Q3",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_3},
+	{NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, /* 4~7 not defined */
+	{"ALTX Q0", ENUM_UMAC_LMAC_PORT_2,    ENUM_UMAC_LMAC_PLE_TX_Q_ALTX_0}, /* Q16 */
+	{"BMC Q0",  ENUM_UMAC_LMAC_PORT_2,    ENUM_UMAC_LMAC_PLE_TX_Q_BMC_0},
+	{"BCN Q0",  ENUM_UMAC_LMAC_PORT_2,    ENUM_UMAC_LMAC_PLE_TX_Q_BNC_0},
+	{"PSMP Q0", ENUM_UMAC_LMAC_PORT_2,    ENUM_UMAC_LMAC_PLE_TX_Q_PSMP_0},
+	{"ALTX Q1", ENUM_UMAC_LMAC_PORT_2,    ENUM_UMAC_LMAC_PLE_TX_Q_ALTX_1},
+	{"BMC Q1",  ENUM_UMAC_LMAC_PORT_2,    ENUM_UMAC_LMAC_PLE_TX_Q_BMC_1},
+	{"BCN Q1",  ENUM_UMAC_LMAC_PORT_2,    ENUM_UMAC_LMAC_PLE_TX_Q_BNC_1},
+	{"PSMP Q1", ENUM_UMAC_LMAC_PORT_2,    ENUM_UMAC_LMAC_PLE_TX_Q_PSMP_1},
+	{"NAF Q",   ENUM_UMAC_LMAC_PORT_2,    ENUM_UMAC_LMAC_PLE_TX_Q_NAF},
+	{"NBCN Q",  ENUM_UMAC_LMAC_PORT_2,    ENUM_UMAC_LMAC_PLE_TX_Q_NBCN},
+	{NULL, 0, 0}, {NULL, 0, 0}, /* 18, 19 not defined */
+	{"FIXFID Q", ENUM_UMAC_LMAC_PORT_2, 0x1a},
+	{NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0},
+	{NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, /* 21~29 not defined */
+	{"RLS Q",   ENUM_PLE_CTRL_PSE_PORT_3, 0x7e},
+	{"RLS2 Q",  ENUM_PLE_CTRL_PSE_PORT_3, 0x7f}
+};
+
+static EMPTY_QUEUE_INFO_T ple_txcmd_queue_empty_info[] = {
+	{"AC00Q", ENUM_UMAC_LMAC_PORT_2, 0x40},
+	{"AC01Q", ENUM_UMAC_LMAC_PORT_2, 0x41},
+	{"AC02Q", ENUM_UMAC_LMAC_PORT_2, 0x42},
+	{"AC03Q", ENUM_UMAC_LMAC_PORT_2, 0x43},
+	{"AC10Q", ENUM_UMAC_LMAC_PORT_2, 0x44},
+	{"AC11Q", ENUM_UMAC_LMAC_PORT_2, 0x45},
+	{"AC12Q", ENUM_UMAC_LMAC_PORT_2, 0x46},
+	{"AC13Q", ENUM_UMAC_LMAC_PORT_2, 0x47},
+	{"AC20Q", ENUM_UMAC_LMAC_PORT_2, 0x48},
+	{"AC21Q", ENUM_UMAC_LMAC_PORT_2, 0x49},
+	{"AC22Q", ENUM_UMAC_LMAC_PORT_2, 0x4a},
+	{"AC23Q", ENUM_UMAC_LMAC_PORT_2, 0x4b},
+	{"AC30Q", ENUM_UMAC_LMAC_PORT_2, 0x4c},
+	{"AC31Q", ENUM_UMAC_LMAC_PORT_2, 0x4d},
+	{"AC32Q", ENUM_UMAC_LMAC_PORT_2, 0x4e},
+	{"AC33Q", ENUM_UMAC_LMAC_PORT_2, 0x4f},
+	{"ALTX Q0", ENUM_UMAC_LMAC_PORT_2, 0x50},
+	{"TF Q0", ENUM_UMAC_LMAC_PORT_2, 0x51},
+	{"TWT TSF-TF Q0", ENUM_UMAC_LMAC_PORT_2, 0x52},
+	{"TWT DL Q0", ENUM_UMAC_LMAC_PORT_2, 0x53},
+	{"TWT UL Q0", ENUM_UMAC_LMAC_PORT_2, 0x54},
+	{"ALTX Q1", ENUM_UMAC_LMAC_PORT_2, 0x55},
+	{"TF Q1", ENUM_UMAC_LMAC_PORT_2, 0x56},
+	{"TWT TSF-TF Q1", ENUM_UMAC_LMAC_PORT_2, 0x57},
+	{"TWT DL Q1", ENUM_UMAC_LMAC_PORT_2, 0x58},
+	{"TWT UL Q1", ENUM_UMAC_LMAC_PORT_2, 0x59},
+	{NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0},
+};
+
+static char* sta_ctrl_reg[] = {"ENABLE", "DISABLE", "PAUSE"};
+static u32 chip_show_sta_acq_info(struct seq_file *s, struct mt7915_dev *dev, u32 *ple_stat,
+				  u32 *sta_pause, u32 *dis_sta_map,
+				  u32 dumptxd)
+{
+	int i, j;
+	u32 total_nonempty_cnt = 0;
+	u32 ac_num = 9, all_ac_num;
+
+	/* TDO: ac_num = 16 for mt7986 */
+	if (!is_mt7915(&dev->mt76))
+		ac_num = 17;
+
+	all_ac_num = ac_num * 4;
+
+	for (j = 0; j < all_ac_num; j++) { /* show AC Q info */
+		for (i = 0; i < 32; i++) {
+			if (((ple_stat[j + 1] & (0x1 << i)) >> i) == 0) {
+				u32 hfid, tfid, pktcnt, ac_n = j / ac_num, ctrl = 0;
+				u32 sta_num = i + (j % ac_num) * 32, fl_que_ctrl[3] = {0};
+				//struct wifi_dev *wdev = wdev_search_by_wcid(pAd, sta_num);
+				u32 wmmidx = 0;
+				struct mt7915_sta *msta;
+				struct mt76_wcid *wcid;
+
+				wcid = rcu_dereference(dev->mt76.wcid[sta_num]);
+				if (!wcid) {
+					printk("ERROR!! no found STA wcid=%d\n", sta_num);
+					continue;
+				}
+				msta = container_of(wcid, struct mt7915_sta, wcid);
+				wmmidx = msta->vif->mt76.wmm_idx;
+
+				seq_printf(s, "\tSTA%d AC%d: ", sta_num, ac_n);
+
+				fl_que_ctrl[0] |= MT_DBG_PLE_FL_QUE_CTRL0_EXECUTE_MASK;
+				fl_que_ctrl[0] |= (ENUM_UMAC_LMAC_PORT_2 << MT_PLE_FL_QUE_CTRL0_Q_BUF_PID_SHFT);
+				fl_que_ctrl[0] |= (ac_n << MT_PLE_FL_QUE_CTRL0_Q_BUF_QID_SHFT);
+				fl_que_ctrl[0] |= sta_num;
+				mt76_wr(dev, MT_DBG_PLE_FL_QUE_CTRL0, fl_que_ctrl[0]);
+				fl_que_ctrl[1] = mt76_rr(dev, MT_DBG_PLE_FL_QUE_CTRL2);
+				fl_que_ctrl[2] = mt76_rr(dev, MT_DBG_PLE_FL_QUE_CTRL3);
+				hfid = FIELD_GET(MT_DBG_PLE_FL_QUE_CTRL2_Q_HEAD_FID_MASK, fl_que_ctrl[1]);
+				tfid = FIELD_GET(MT_DBG_PLE_FL_QUE_CTRL2_Q_TAIL_FID_MASK, fl_que_ctrl[1]);
+				pktcnt = FIELD_GET(MT_DBG_PLE_FL_QUE_CTRL3_Q_PKT_NUM_MASK, fl_que_ctrl[2]);
+				seq_printf(s, "tail/head fid = 0x%03x/0x%03x, pkt cnt = 0x%03x",
+						  tfid, hfid, pktcnt);
+
+				if (((sta_pause[j % ac_num] & 0x1 << i) >> i) == 1)
+					ctrl = 2;
+
+				if (((dis_sta_map[j % ac_num] & 0x1 << i) >> i) == 1)
+					ctrl = 1;
+
+				seq_printf(s, " ctrl = %s", sta_ctrl_reg[ctrl]);
+				seq_printf(s, " (wmmidx=%d)\n", wmmidx);
+
+				total_nonempty_cnt++;
+
+				// TODO
+				//if (pktcnt > 0 && dumptxd > 0)
+				//	ShowTXDInfo(pAd, hfid);
+			}
+		}
+	}
+
+	return total_nonempty_cnt;
+}
+
+static void chip_show_txcmdq_info(struct seq_file *s, struct mt7915_dev *dev, u32 ple_txcmd_stat)
+{
+	int i;
+
+	seq_printf(s, "Nonempty TXCMD Q info:\n");
+	for (i = 0; i < 32; i++) {
+		if (((ple_txcmd_stat & (0x1 << i)) >> i) == 0) {
+			u32 hfid, tfid, pktcnt, fl_que_ctrl[3] = {0};
+
+			if (ple_txcmd_queue_empty_info[i].QueueName != NULL) {
+				seq_printf(s, "\t%s: ", ple_txcmd_queue_empty_info[i].QueueName);
+				fl_que_ctrl[0] |= MT_DBG_PLE_FL_QUE_CTRL0_EXECUTE_MASK;
+				fl_que_ctrl[0] |= (ple_txcmd_queue_empty_info[i].Portid <<
+							MT_PLE_FL_QUE_CTRL0_Q_BUF_PID_SHFT);
+				fl_que_ctrl[0] |= (ple_txcmd_queue_empty_info[i].Queueid <<
+							MT_PLE_FL_QUE_CTRL0_Q_BUF_QID_SHFT);
+			} else
+				continue;
+
+			mt76_wr(dev, MT_DBG_PLE_FL_QUE_CTRL0, fl_que_ctrl[0]);
+			fl_que_ctrl[1] = mt76_rr(dev, MT_DBG_PLE_FL_QUE_CTRL2);
+			fl_que_ctrl[2] = mt76_rr(dev, MT_DBG_PLE_FL_QUE_CTRL3);
+			hfid = FIELD_GET(MT_DBG_PLE_FL_QUE_CTRL2_Q_HEAD_FID_MASK, fl_que_ctrl[1]);
+			tfid = FIELD_GET(MT_DBG_PLE_FL_QUE_CTRL2_Q_TAIL_FID_MASK, fl_que_ctrl[1]);
+			pktcnt = FIELD_GET(MT_DBG_PLE_FL_QUE_CTRL3_Q_PKT_NUM_MASK, fl_que_ctrl[2]);
+			seq_printf(s, "tail/head fid = 0x%03x/0x%03x, pkt cnt = 0x%03x\n",
+					  tfid, hfid, pktcnt);
+		}
+	}
+}
+
+static void chip_get_ple_acq_stat(struct mt7915_dev *dev, u32 *ple_stat)
+{
+	int i;
+	int cr_num = 9, all_cr_num;
+	u32 ac , index;
+
+	/* TDO: cr_num = 16 for mt7986 */
+	if(!is_mt7915(&dev->mt76))
+		cr_num = 17;
+
+	all_cr_num =  cr_num * 4;
+
+	ple_stat[0] = mt76_rr(dev, MT_DBG_PLE_QUEUE_EMPTY);
+
+	for(i = 0; i < all_cr_num; i++) {
+		ac = i / cr_num;
+		index = i % cr_num;
+		ple_stat[i + 1] =
+			mt76_rr(dev, MT_DBG_PLE_AC_QEMPTY(ac, index));
+
+	}
+}
+
+static void chip_get_dis_sta_map(struct mt7915_dev *dev, u32 *dis_sta_map)
+{
+	int i;
+	u32 ac_num = 9;
+
+	/* TDO: ac_num = 16 for mt7986 */
+	if (!is_mt7915(&dev->mt76))
+		ac_num = 17;
+
+	for(i = 0; i < ac_num; i++) {
+		dis_sta_map[i] = mt76_rr(dev, MT_DBG_PLE_DIS_STA_MAP(i));
+	}
+}
+
+static void chip_get_sta_pause(struct mt7915_dev *dev, u32 *sta_pause)
+{
+	int i;
+	u32 ac_num = 9;
+
+	/* TDO: ac_num = 16 for mt7986 */
+	if (!is_mt7915(&dev->mt76))
+		ac_num = 17;
+
+	for(i = 0; i < ac_num; i++) {
+		sta_pause[i] = mt76_rr(dev, MT_DBG_PLE_STATION_PAUSE(i));
+	}
+}
+
+static int mt7915_pleinfo_read(struct seq_file *s, void *data)
+{
+	struct mt7915_dev *dev = dev_get_drvdata(s->private);
+	u32 ple_buf_ctrl, pg_sz, pg_num;
+	u32 ple_stat[70] = {0}, pg_flow_ctrl[8] = {0};
+	u32 ple_native_txcmd_stat;
+	u32 ple_txcmd_stat;
+	u32 sta_pause[CR_NUM_OF_AC] = {0}, dis_sta_map[CR_NUM_OF_AC] = {0};
+	u32 fpg_cnt, ffa_cnt, fpg_head, fpg_tail, hif_max_q, hif_min_q;
+	u32 rpg_hif, upg_hif, cpu_max_q, cpu_min_q, rpg_cpu, upg_cpu;
+	int i, j;
+	u32 ac_num = 9, all_ac_num;
+
+	/* TDO: ac_num = 16 for mt7986 */
+	if (!is_mt7915(&dev->mt76))
+		ac_num = 17;
+
+	all_ac_num = ac_num * 4;
+
+	ple_buf_ctrl = mt76_rr(dev, MT_DBG_PLE_PBUF_CTRL_ADDR);
+	chip_get_ple_acq_stat(dev, ple_stat);
+	ple_txcmd_stat = mt76_rr(dev, MT_DBG_PLE_TXCMD_Q_EMPTY);
+	ple_native_txcmd_stat = mt76_rr(dev, MT_DBG_PLE_NATIVE_TXCMD_Q_EMPTY);
+	pg_flow_ctrl[0] = mt76_rr(dev, MT_DBG_PLE_FREEPG_CNT);
+	pg_flow_ctrl[1] = mt76_rr(dev, MT_DBG_PLE_FREEPG_HEAD_TAIL);
+	pg_flow_ctrl[2] = mt76_rr(dev, MT_DBG_PLE_PG_HIF_GROUP);
+	pg_flow_ctrl[3] = mt76_rr(dev, MT_DBG_PLE_HIF_PG_INFO);
+	pg_flow_ctrl[4] = mt76_rr(dev, MT_DBG_PLE_PG_CPU_GROUP);
+	pg_flow_ctrl[5] = mt76_rr(dev, MT_DBG_PLE_CPU_PG_INFO);
+	pg_flow_ctrl[6] = mt76_rr(dev, MT_DBG_PLE_PG_HIF_TXCMD_GROUP);
+	pg_flow_ctrl[7] = mt76_rr(dev, MT_DBG_PLE_HIF_TXCMD_PG_INFO);
+	chip_get_dis_sta_map(dev, dis_sta_map);
+	chip_get_sta_pause(dev, sta_pause);
+
+	seq_printf(s, "PLE Configuration Info:\n");
+	seq_printf(s, "\tPacket Buffer Control(0x%x): 0x%08x\n",
+		      MT_DBG_PLE_PBUF_CTRL_ADDR, ple_buf_ctrl);
+
+	pg_sz = FIELD_GET(MT_DBG_PLE_PBUF_CTRL_PAGE_SIZE_MASK, ple_buf_ctrl);
+	seq_printf(s, "\t\tPage Size=%d(%d bytes per page)\n",
+		       pg_sz, (pg_sz == 1 ? 128 : 64));
+	seq_printf(s, "\t\tPage Offset=%ld(in unit of 2KB)\n",
+		        FIELD_GET(MT_DBG_PLE_PBUF_CTRL_OFFSET_MASK, ple_buf_ctrl));
+
+	pg_num = FIELD_GET(MT_DBG_PLE_PBUF_CTRL_TOTAL_PAGE_NUM_MASK, ple_buf_ctrl);
+	seq_printf(s, "\t\tTotal Page=%d pages\n", pg_num);
+
+	/* Page Flow Control */
+	seq_printf(s, "PLE Page Flow Control:\n");
+	seq_printf(s, "\tFree page counter(0x%x): 0x%08x\n",
+		      MT_DBG_PLE_FREEPG_CNT, pg_flow_ctrl[0]);
+	fpg_cnt = FIELD_GET(MT_DBG_PLE_FREEPG_CNT_FREEPG_CNT_MASK, pg_flow_ctrl[0]);
+
+	seq_printf(s, "\t\tThe toal page number of free=0x%03x\n", fpg_cnt);
+	ffa_cnt = FIELD_GET(MT_DBG_PLE_FREEPG_CNT_FFA_CNT_MASK, pg_flow_ctrl[0]);
+
+	seq_printf(s, "\t\tThe free page numbers of free for all=0x%03x\n", ffa_cnt);
+	seq_printf(s, "\tFree page head and tail(0x%x): 0x%08x\n",
+	              MT_DBG_PLE_FREEPG_HEAD_TAIL, pg_flow_ctrl[1]);
+
+	fpg_head = FIELD_GET(MT_DBG_PLE_FREEPG_HEAD_TAIL_FREEPG_HEAD_MASK, pg_flow_ctrl[1]);
+	fpg_tail = FIELD_GET(MT_DBG_PLE_FREEPG_HEAD_TAIL_FREEPG_TAIL_MASK, pg_flow_ctrl[1]);
+	seq_printf(s, "\t\tThe tail/head page of free page list=0x%03x/0x%03x\n", fpg_tail, fpg_head);
+	seq_printf(s, "\tReserved page counter of HIF group(0x%x): 0x%08x\n",
+	              MT_DBG_PLE_PG_HIF_GROUP, pg_flow_ctrl[2]);
+	seq_printf(s, "\tHIF group page status(0x%x): 0x%08x\n",
+	              MT_DBG_PLE_HIF_PG_INFO, pg_flow_ctrl[3]);
+
+	hif_min_q = FIELD_GET(MT_DBG_PLE_PG_HIF_GROUP_HIF_MIN_QUOTA_MASK, pg_flow_ctrl[2]);
+	hif_max_q = FIELD_GET(MT_DBG_PLE_PG_HIF_GROUP_HIF_MAX_QUOTA_MASK, pg_flow_ctrl[2]);
+	seq_printf(s, "\t\tThe max/min quota pages of HIF group=0x%03x/0x%03x\n", hif_max_q, hif_min_q);
+
+	rpg_hif = FIELD_GET(MT_DBG_PLE_HIF_PG_INFO_HIF_RSV_CNT_MASK, pg_flow_ctrl[3]);
+	upg_hif = FIELD_GET(MT_DBG_PLE_HIF_PG_INFO_HIF_SRC_CNT_MASK, pg_flow_ctrl[3]);
+	seq_printf(s, "\t\tThe used/reserved pages of HIF group=0x%03x/0x%03x\n", upg_hif, rpg_hif);
+
+	seq_printf(s, "\tReserved page counter of HIF_TXCMD group(0x%x): 0x%08x\n",
+		      MT_DBG_PLE_PG_HIF_TXCMD_GROUP, pg_flow_ctrl[6]);
+	seq_printf(s, "\tHIF_TXCMD group page status(0x%x): 0x%08x\n",
+	              MT_DBG_PLE_HIF_TXCMD_PG_INFO, pg_flow_ctrl[7]);
+	cpu_min_q = FIELD_GET(MT_DBG_PLE_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MIN_QUOTA_MASK, pg_flow_ctrl[6]);
+	cpu_max_q = FIELD_GET(MT_DBG_PLE_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MAX_QUOTA_MASK, pg_flow_ctrl[6]);
+	seq_printf(s, "\t\tThe max/min quota pages of HIF_TXCMD group=0x%03x/0x%03x\n", cpu_max_q, cpu_min_q);
+
+	rpg_cpu = FIELD_GET(MT_DBG_PLE_TXCMD_PG_INFO_HIF_TXCMD_RSV_CNT_MASK, pg_flow_ctrl[7]);
+	upg_cpu = FIELD_GET(MT_DBG_PLE_TXCMD_PG_INFO_HIF_TXCMD_SRC_CNT_MASK, pg_flow_ctrl[7]);
+	seq_printf(s, "\t\tThe used/reserved pages of HIF_TXCMD group=0x%03x/0x%03x\n", upg_cpu, rpg_cpu);
+
+	seq_printf(s, "\tReserved page counter of CPU group(0x%x): 0x%08x\n",
+			MT_DBG_PLE_PG_CPU_GROUP, pg_flow_ctrl[4]);
+	seq_printf(s, "\tCPU group page status(0x%x): 0x%08x\n",
+			MT_DBG_PLE_CPU_PG_INFO, pg_flow_ctrl[5]);
+	cpu_min_q = FIELD_GET(MT_DBG_PLE_PG_CPU_GROUP_CPU_MIN_QUOTA_MASK, pg_flow_ctrl[4]);
+	cpu_max_q = FIELD_GET(MT_DBG_PLE_PG_CPU_GROUP_CPU_MAX_QUOTA_MASK, pg_flow_ctrl[4]);
+	seq_printf(s, "\t\tThe max/min quota pages of CPU group=0x%03x/0x%03x\n", cpu_max_q, cpu_min_q);
+
+	rpg_cpu = FIELD_GET(MT_DBG_PLE_CPU_PG_INFO_CPU_RSV_CNT_MASK, pg_flow_ctrl[5]);
+	upg_cpu = FIELD_GET(MT_DBG_PLE_CPU_PG_INFO_CPU_SRC_CNT_MASK, pg_flow_ctrl[5]);
+	seq_printf(s, "\t\tThe used/reserved pages of CPU group=0x%03x/0x%03x\n", upg_cpu, rpg_cpu);
+
+	if ((ple_stat[0] & MT_DBG_PLE_Q_EMPTY_ALL_AC_EMPTY_MASK) == 0) {
+		for (j = 0; j < all_ac_num; j++) {
+			if (j % ac_num == 0) {
+				seq_printf(s, "\n\tNonempty AC%d Q of STA#: ", j / ac_num);
+			}
+
+			for (i = 0; i < 32; i++) {
+				if (((ple_stat[j + 1] & (0x1 << i)) >> i) == 0) {
+					seq_printf(s, "%d ", i + (j % ac_num) * 32);
+				}
+			}
+		}
+
+		seq_printf(s, "\n");
+	}
+
+	seq_printf(s, "non-native/native txcmd queue empty = %d/%d\n", ple_txcmd_stat, ple_native_txcmd_stat);
+
+	seq_printf(s, "Nonempty Q info:\n");
+
+	for (i = 0; i < 32; i++) {
+		if (((ple_stat[0] & (0x1 << i)) >> i) == 0) {
+			u32 hfid, tfid, pktcnt, fl_que_ctrl[3] = {0};
+
+			if (ple_queue_empty_info[i].QueueName != NULL) {
+				seq_printf(s, "\t%s: ", ple_queue_empty_info[i].QueueName);
+				fl_que_ctrl[0] |= MT_DBG_PLE_FL_QUE_CTRL0_EXECUTE_MASK;
+				fl_que_ctrl[0] |= (ple_queue_empty_info[i].Portid << MT_PLE_FL_QUE_CTRL0_Q_BUF_PID_SHFT);
+				fl_que_ctrl[0] |= (ple_queue_empty_info[i].Queueid << MT_PLE_FL_QUE_CTRL0_Q_BUF_QID_SHFT);
+			} else
+				continue;
+
+			if (ple_queue_empty_info[i].Queueid >= ENUM_UMAC_LMAC_PLE_TX_Q_ALTX_0 &&
+				ple_queue_empty_info[i].Queueid <= ENUM_UMAC_LMAC_PLE_TX_Q_PSMP_0)
+				/* band0 set TGID 0, bit31 = 0 */
+				mt76_wr(dev, MT_DBG_PLE_FL_QUE_CTRL1, 0x0);
+			else if (ple_queue_empty_info[i].Queueid >= ENUM_UMAC_LMAC_PLE_TX_Q_ALTX_1 &&
+				ple_queue_empty_info[i].Queueid <= ENUM_UMAC_LMAC_PLE_TX_Q_PSMP_1)
+				/* band1 set TGID 1, bit31 = 1 */
+				mt76_wr(dev, MT_DBG_PLE_FL_QUE_CTRL1, 0x80000000);
+
+			mt76_wr(dev, MT_DBG_PLE_FL_QUE_CTRL0, fl_que_ctrl[0]);
+			fl_que_ctrl[1] = mt76_rr(dev, MT_DBG_PLE_FL_QUE_CTRL2);
+			fl_que_ctrl[2] = mt76_rr(dev, MT_DBG_PLE_FL_QUE_CTRL3);
+			hfid = FIELD_GET(MT_DBG_PLE_FL_QUE_CTRL2_Q_HEAD_FID_MASK, fl_que_ctrl[1]);
+			tfid = FIELD_GET(MT_DBG_PLE_FL_QUE_CTRL2_Q_TAIL_FID_MASK, fl_que_ctrl[1]);
+			pktcnt = FIELD_GET(MT_DBG_PLE_FL_QUE_CTRL3_Q_PKT_NUM_MASK, fl_que_ctrl[2]);
+			seq_printf(s, "tail/head fid = 0x%03x/0x%03x, pkt cnt = 0x%03x\n",
+				      tfid, hfid, pktcnt);
+
+			/* TODO */
+			//if (pktcnt > 0 && dumptxd > 0)
+			//	ShowTXDInfo(pAd, hfid);
+		}
+	}
+
+	chip_show_sta_acq_info(s, dev, ple_stat, sta_pause, dis_sta_map, 0/*dumptxd*/);
+	chip_show_txcmdq_info(s, dev, ple_native_txcmd_stat);
+
+	return 0;
+}
+
+typedef enum _ENUM_UMAC_PLE_CTRL_P3_QUEUE_T {
+	ENUM_UMAC_PLE_CTRL_P3_Q_0X1E            = 0x1e,
+	ENUM_UMAC_PLE_CTRL_P3_Q_0X1F            = 0x1f,
+	ENUM_UMAC_PLE_CTRL_P3_TOTAL_NUM         = 2
+} ENUM_UMAC_PLE_CTRL_P3_QUEUE_T, *P_ENUM_UMAC_PLE_CTRL_P3_QUEUE_T;
+
+static EMPTY_QUEUE_INFO_T pse_queue_empty_info[] = {
+	{"CPU Q0",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_0},
+	{"CPU Q1",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_1},
+	{"CPU Q2",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_2},
+	{"CPU Q3",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_3},
+	{NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, /* 4~7 not defined */
+	{"HIF Q0", ENUM_UMAC_HIF_PORT_0,    0}, /* Q8 */
+	{"HIF Q1", ENUM_UMAC_HIF_PORT_0,    1},
+	{"HIF Q2", ENUM_UMAC_HIF_PORT_0,    2},
+	{"HIF Q3", ENUM_UMAC_HIF_PORT_0,    3},
+	{"HIF Q4", ENUM_UMAC_HIF_PORT_0,    4},
+	{"HIF Q5", ENUM_UMAC_HIF_PORT_0,    5},
+	{NULL, 0, 0}, {NULL, 0, 0},  /* 14~15 not defined */
+	{"LMAC Q",  ENUM_UMAC_LMAC_PORT_2,    0},
+	{"MDP TX Q", ENUM_UMAC_LMAC_PORT_2, 1},
+	{"MDP RX Q", ENUM_UMAC_LMAC_PORT_2, 2},
+	{"SEC TX Q", ENUM_UMAC_LMAC_PORT_2, 3},
+	{"SEC RX Q", ENUM_UMAC_LMAC_PORT_2, 4},
+	{"SFD_PARK Q", ENUM_UMAC_LMAC_PORT_2, 5},
+	{"MDP_TXIOC Q", ENUM_UMAC_LMAC_PORT_2, 6},
+	{"MDP_RXIOC Q", ENUM_UMAC_LMAC_PORT_2, 7},
+	{NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, /* 24~30 not defined */
+	{"RLS Q",  ENUM_PLE_CTRL_PSE_PORT_3, ENUM_UMAC_PLE_CTRL_P3_Q_0X1F}
+};
+
+static int mt7915_pseinfo_read(struct seq_file *s, void *data)
+{
+	struct mt7915_dev *dev = dev_get_drvdata(s->private);
+	u32 pse_buf_ctrl, pg_sz, pg_num;
+	u32 pse_stat, pg_flow_ctrl[22] = {0};
+	u32 fpg_cnt, ffa_cnt, fpg_head, fpg_tail;
+	u32 max_q, min_q, rsv_pg, used_pg;
+	int i;
+
+	pse_buf_ctrl     = mt76_rr(dev, MT_DBG_PSE_PBUF_CTRL);
+	pse_stat         = mt76_rr(dev, MT_DBG_PSE_QUEUE_EMPTY);
+	pg_flow_ctrl[0]  = mt76_rr(dev, MT_DBG_PSE_FREEPG_CNT);
+	pg_flow_ctrl[1]  = mt76_rr(dev, MT_DBG_PSE_FREEPG_HEAD_TAIL);
+	pg_flow_ctrl[2]  = mt76_rr(dev, MT_DBG_PSE_PG_HIF0_GROUP);
+	pg_flow_ctrl[3]  = mt76_rr(dev, MT_DBG_PSE_HIF0_PG_INFO);
+	pg_flow_ctrl[4]  = mt76_rr(dev, MT_DBG_PSE_PG_HIF1_GROUP);
+	pg_flow_ctrl[5]  = mt76_rr(dev, MT_DBG_PSE_HIF1_PG_INFO);
+	pg_flow_ctrl[6]  = mt76_rr(dev, MT_DBG_PSE_PG_CPU_GROUP);
+	pg_flow_ctrl[7]  = mt76_rr(dev, MT_DBG_PSE_CPU_PG_INFO);
+	pg_flow_ctrl[8]  = mt76_rr(dev, MT_DBG_PSE_PG_LMAC0_GROUP);
+	pg_flow_ctrl[9]  = mt76_rr(dev, MT_DBG_PSE_LMAC0_PG_INFO);
+	pg_flow_ctrl[10] = mt76_rr(dev, MT_DBG_PSE_PG_LMAC1_GROUP);
+	pg_flow_ctrl[11] = mt76_rr(dev, MT_DBG_PSE_LMAC1_PG_INFO);
+	pg_flow_ctrl[12] = mt76_rr(dev, MT_DBG_PSE_PG_LMAC2_GROUP);
+	pg_flow_ctrl[13] = mt76_rr(dev, MT_DBG_PSE_LMAC2_PG_INFO);
+	pg_flow_ctrl[14] = mt76_rr(dev, MT_DBG_PSE_PG_PLE_GROUP);
+	pg_flow_ctrl[15] = mt76_rr(dev, MT_DBG_PSE_PLE_PG_INFO);
+	pg_flow_ctrl[16] = mt76_rr(dev, MT_DBG_PSE_PG_LMAC3_GROUP);
+	pg_flow_ctrl[17] = mt76_rr(dev, MT_DBG_PSE_LMAC3_PG_INFO);
+	pg_flow_ctrl[18] = mt76_rr(dev, MT_DBG_PSE_PG_MDP_GROUP);
+	pg_flow_ctrl[19] = mt76_rr(dev, MT_DBG_PSE_MDP_PG_INFO);
+	pg_flow_ctrl[20] = mt76_rr(dev, MT_DBG_PSE_PG_PLE1_GROUP);
+	pg_flow_ctrl[21] = mt76_rr(dev,MT_DBG_PSE_PLE1_PG_INFO);
+
+	/* Configuration Info */
+	seq_printf(s, "PSE Configuration Info:\n");
+	seq_printf(s, "\tPacket Buffer Control(0x82068014): 0x%08x\n", pse_buf_ctrl);
+	pg_sz = FIELD_GET(MT_DBG_PSE_PBUF_CTRL_PAGE_SIZE_CFG_MASK, pse_buf_ctrl);
+
+	seq_printf(s, "\t\tPage Size=%d(%d bytes per page)\n", pg_sz, (pg_sz == 1 ? 256 : 128));
+	seq_printf(s, "\t\tPage Offset=%ld(in unit of 64KB)\n",
+			 FIELD_GET(MT_DBG_PSE_PBUF_CTRL_PBUF_OFFSET_MASK, pse_buf_ctrl));
+	pg_num = FIELD_GET(MT_DBG_PSE_PBUF_CTRL_TOTAL_PAGE_NUM_MASK, pse_buf_ctrl);
+
+	seq_printf(s, "\t\tTotal page numbers=%d pages\n", pg_num);
+
+	/* Page Flow Control */
+	seq_printf(s, "PSE Page Flow Control:\n");
+	seq_printf(s, "\tFree page counter(0x82068100): 0x%08x\n", pg_flow_ctrl[0]);
+	fpg_cnt = FIELD_GET(MT_DBG_PSE_FREEPG_CNT_FREEPG_CNT_MASK, pg_flow_ctrl[0]);
+	seq_printf(s, "\t\tThe toal page number of free=0x%03x\n", fpg_cnt);
+
+	ffa_cnt =  FIELD_GET(MT_DBG_PSE_FREEPG_CNT_FFA_CNT_MASK, pg_flow_ctrl[0]);
+	seq_printf(s, "\t\tThe free page numbers of free for all=0x%03x\n", ffa_cnt);
+
+	seq_printf(s, "\tFree page head and tail(0x82068104): 0x%08x\n", pg_flow_ctrl[1]);
+	fpg_head =  FIELD_GET(MT_DBG_PSE_FREEPG_HEAD_TAIL_FREEPG_HEAD_MASK, pg_flow_ctrl[1]);
+
+	fpg_tail = FIELD_GET(MT_DBG_PSE_FREEPG_HEAD_TAIL_FREEPG_TAIL_MASK, pg_flow_ctrl[1]);
+	seq_printf(s, "\t\tThe tail/head page of free page list=0x%03x/0x%03x\n", fpg_tail, fpg_head);
+	seq_printf(s, "\tReserved page counter of HIF0 group(0x82068110): 0x%08x\n", pg_flow_ctrl[2]);
+	seq_printf(s, "\tHIF0 group page status(0x82068114): 0x%08x\n", pg_flow_ctrl[3]);
+	min_q = FIELD_GET(MT_DBG_PSE_PG_HIF0_GROUP_HIF0_MIN_QUOTA_MASK, pg_flow_ctrl[2]);
+	max_q =  FIELD_GET(MT_DBG_PSE_PG_HIF0_GROUP_HIF0_MAX_QUOTA_MASK, pg_flow_ctrl[2]);
+	seq_printf(s, "\t\tThe max/min quota pages of HIF0 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = FIELD_GET(MT_DBG_PSE_HIF0_PG_INFO_HIF0_RSV_CNT_MASK, pg_flow_ctrl[3]);;
+	used_pg = FIELD_GET(MT_DBG_PSE_HIF0_PG_INFO_HIF0_SRC_CNT_MASK, pg_flow_ctrl[3]);
+	seq_printf(s, "\t\tThe used/reserved pages of HIF0 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of HIF1 group(0x82068118): 0x%08x\n", pg_flow_ctrl[4]);
+	seq_printf(s, "\tHIF1 group page status(0x8206811c): 0x%08x\n", pg_flow_ctrl[5]);
+	min_q = FIELD_GET(MT_DBG_PSE_PG_HIF1_GROUP_HIF1_MIN_QUOTA_MASK, pg_flow_ctrl[4]);
+	max_q = FIELD_GET(MT_DBG_PSE_PG_HIF1_GROUP_HIF1_MAX_QUOTA_MASK, pg_flow_ctrl[4]);
+	seq_printf(s, "\t\tThe max/min quota pages of HIF1 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = FIELD_GET(MT_DBG_PSE_HIF1_PG_INFO_HIF1_RSV_CNT_MASK, pg_flow_ctrl[5]);
+	used_pg = FIELD_GET(MT_DBG_PSE_HIF1_PG_INFO_HIF1_SRC_CNT_MASK, pg_flow_ctrl[5]);
+
+	seq_printf(s, "\t\tThe used/reserved pages of HIF1 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of CPU group(0x82068150): 0x%08x\n", pg_flow_ctrl[6]);
+	seq_printf(s, "\tCPU group page status(0x82068154): 0x%08x\n", pg_flow_ctrl[7]);
+	min_q = FIELD_GET(MT_DBG_PSE_PG_CPU_GROUP_CPU_MIN_QUOTA_MASK, pg_flow_ctrl[6]);
+	max_q = FIELD_GET(MT_DBG_PSE_PG_CPU_GROUP_CPU_MAX_QUOTA_MASK, pg_flow_ctrl[6]);
+	seq_printf(s, "\t\tThe max/min quota pages of CPU group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = FIELD_GET(MT_DBG_PSE_CPU_PG_INFO_CPU_RSV_CNT_MASK, pg_flow_ctrl[7]);
+	used_pg = FIELD_GET(MT_DBG_PSE_CPU_PG_INFO_CPU_SRC_CNT_MASK, pg_flow_ctrl[7]);
+	seq_printf(s, "\t\tThe used/reserved pages of CPU group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of LMAC0 group(0x82068170): 0x%08x\n", pg_flow_ctrl[8]);
+	seq_printf(s, "\tLMAC0 group page status(0x82068174): 0x%08x\n", pg_flow_ctrl[9]);
+	min_q = FIELD_GET(MT_DBG_PSE_PG_LMAC0_GROUP_LMAC0_MIN_QUOTA_MASK, pg_flow_ctrl[8]);
+	max_q = FIELD_GET(MT_DBG_PSE_PG_LMAC0_GROUP_LMAC0_MAX_QUOTA_MASK, pg_flow_ctrl[8]);
+	seq_printf(s, "\t\tThe max/min quota pages of LMAC0 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = FIELD_GET(MT_DBG_PSE_LMAC0_PG_INFO_LMAC0_RSV_CNT_MASK, pg_flow_ctrl[9]);
+	used_pg = FIELD_GET(MT_DBG_PSE_LMAC0_PG_INFO_LMAC0_SRC_CNT_MASK, pg_flow_ctrl[9]);
+	seq_printf(s, "\t\tThe used/reserved pages of LMAC0 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of LMAC1 group(0x82068178): 0x%08x\n", pg_flow_ctrl[10]);
+	seq_printf(s, "\tLMAC1 group page status(0x8206817c): 0x%08x\n", pg_flow_ctrl[11]);
+	min_q = FIELD_GET(MT_DBG_TOP_PG_LMAC1_GROUP_LMAC1_MIN_QUOTA_MASK, pg_flow_ctrl[10]);
+	max_q = FIELD_GET(MT_DBG_PSE_PG_LMAC1_GROUP_LMAC1_MAX_QUOTA_MASK, pg_flow_ctrl[10]);
+	seq_printf(s, "\t\tThe max/min quota pages of LMAC1 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = FIELD_GET(MT_DBG_PSE_LMAC1_PG_INFO_LMAC1_RSV_CNT_MASK, pg_flow_ctrl[11]);
+	used_pg = FIELD_GET(MT_DBG_PSE_LMAC1_PG_INFO_LMAC1_SRC_CNT_MASK, pg_flow_ctrl[11]);
+	seq_printf(s, "\t\tThe used/reserved pages of LMAC1 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of LMAC2 group(0x82068180): 0x%08x\n", pg_flow_ctrl[12]);
+	seq_printf(s, "\tLMAC2 group page status(0x82068184): 0x%08x\n", pg_flow_ctrl[13]);
+	min_q = FIELD_GET(MT_DBG_PSE_PG_LMAC2_GROUP_LMAC2_MIN_QUOTA_MASK, pg_flow_ctrl[12]);
+	max_q = FIELD_GET(MT_DBG_PSE_PG_LMAC2_GROUP_LMAC2_MAX_QUOTA_MASK, pg_flow_ctrl[12]);
+	seq_printf(s, "\t\tThe max/min quota pages of LMAC2 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = FIELD_GET(MT_DBG_PSE_LMAC2_PG_INFO_LMAC2_RSV_CNT_MASK, pg_flow_ctrl[13]);
+	used_pg = FIELD_GET(MT_DBG_PSE_LMAC2_PG_INFO_LMAC2_SRC_CNT_MASK, pg_flow_ctrl[13]);
+	seq_printf(s, "\t\tThe used/reserved pages of LMAC2 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+
+	seq_printf(s, "\tReserved page counter of LMAC3 group(0x82068188): 0x%08x\n", pg_flow_ctrl[16]);
+	seq_printf(s, "\tLMAC3 group page status(0x8206818c): 0x%08x\n", pg_flow_ctrl[17]);
+	min_q = FIELD_GET(MT_DBG_TOP_PG_LMAC3_GROUP_LMAC3_MIN_QUOTA_MASK, pg_flow_ctrl[16]);
+	max_q = FIELD_GET(MT_DBG_PSE_PG_LMAC3_GROUP_LMAC3_MAX_QUOTA_MASK, pg_flow_ctrl[16]);
+	seq_printf(s, "\t\tThe max/min quota pages of LMAC3 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = FIELD_GET(MT_DBG_PSE_LMAC3_PG_INFO_LMAC3_RSV_CNT_MASK, pg_flow_ctrl[17]);
+	used_pg = FIELD_GET(MT_DBG_PSE_LMAC3_PG_INFO_LMAC3_SRC_CNT_MASK, pg_flow_ctrl[17]);
+	seq_printf(s, "\t\tThe used/reserved pages of LMAC3 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+
+	seq_printf(s, "\tReserved page counter of PLE group(0x82068160): 0x%08x\n", pg_flow_ctrl[14]);
+	seq_printf(s, "\tPLE group page status(0x82068164): 0x%08x\n", pg_flow_ctrl[15]);
+	min_q = FIELD_GET(MT_DBG_PSE_PG_PLE_GROUP_PLE_MIN_QUOTA_MASK, pg_flow_ctrl[14]);
+	max_q = FIELD_GET(MT_DBG_PSE_PG_PLE_GROUP_PLE_MAX_QUOTA_MASK, pg_flow_ctrl[14]);
+	seq_printf(s, "\t\tThe max/min quota pages of PLE group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = FIELD_GET(MT_DBG_PSE_PLE_PG_INFO_PLE_RSV_CNT_MASK, pg_flow_ctrl[15]);
+	used_pg = FIELD_GET(MT_DBG_PSE_PLE_PG_INFO_PLE_SRC_CNT_MASK, pg_flow_ctrl[15]);
+	seq_printf(s, "\t\tThe used/reserved pages of PLE group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+
+	seq_printf(s, "\tReserved page counter of PLE1 group(0x82068168): 0x%08x\n", pg_flow_ctrl[20]);
+	seq_printf(s, "\tPLE1 group page status(0x8206816c): 0x%08x\n", pg_flow_ctrl[21]);
+	min_q = FIELD_GET(MT_DBG_PSE_PG_PLE_GROUP_PLE_MIN_QUOTA_MASK, pg_flow_ctrl[20]);
+	max_q = FIELD_GET(MT_DBG_PSE_PG_PLE_GROUP_PLE_MAX_QUOTA_MASK, pg_flow_ctrl[20]);
+	seq_printf(s, "\t\tThe max/min quota pages of PLE1 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = FIELD_GET(MT_DBG_PSE_PLE_PG_INFO_PLE_RSV_CNT_MASK, pg_flow_ctrl[21]);
+	used_pg = FIELD_GET(MT_DBG_PSE_PLE_PG_INFO_PLE_SRC_CNT_MASK, pg_flow_ctrl[21]);
+	seq_printf(s, "\t\tThe used/reserved pages of PLE1 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+
+	seq_printf(s, "\tReserved page counter of MDP group(0x82068198): 0x%08x\n", pg_flow_ctrl[18]);
+	seq_printf(s, "\tMDP group page status(0x8206819c): 0x%08x\n", pg_flow_ctrl[19]);
+	min_q = FIELD_GET(MT_DBG_PSE_PG_MDP_GROUP_MDP_MIN_QUOTA_MASK, pg_flow_ctrl[18]);
+	max_q = FIELD_GET(MT_DBG_PSE_PG_MDP_GROUP_MDP_MAX_QUOTA_MASK, pg_flow_ctrl[18]);
+	seq_printf(s, "\t\tThe max/min quota pages of MDP group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = FIELD_GET(MT_DBG_PSE_MDP_PG_INFO_MDP_RSV_CNT_MASK, pg_flow_ctrl[19]);
+	used_pg = FIELD_GET(MT_DBG_PSE_MDP_PG_INFO_MDP_SRC_CNT_MASK, pg_flow_ctrl[19]);
+	seq_printf(s, "\t\tThe used/reserved pages of MDP group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+
+	/* Queue Empty Status */
+	seq_printf(s, "PSE Queue Empty Status:\n");
+	seq_printf(s, "\tQUEUE_EMPTY(0x820680b0): 0x%08x\n", pse_stat);
+	seq_printf(s, "\t\tCPU Q0/1/2/3 empty=%ld/%ld/%ld/%ld\n",
+			 FIELD_GET(MT_DBG_PSE_QUEUE_EMPTY_CPU_Q0_EMPTY_MASK, pse_stat),
+			 FIELD_GET(MT_DBG_PSE_QUEUE_EMPTY_CPU_Q1_EMPTY_MASK, pse_stat),
+			 FIELD_GET(MT_DBG_PSE_QUEUE_EMPTY_CPU_Q2_EMPTY_MASK, pse_stat),
+			 FIELD_GET(MT_DBG_PSE_QUEUE_EMPTY_CPU_Q3_EMPTY_MASK, pse_stat));
+
+	seq_printf(s, "\t\tHIF Q0/1/2/3/4/5 empty=%ld/%ld/%ld/%ld/%ld/%ld\n",
+			 FIELD_GET(MT_DBG_PSE_QUEUE_EMPTY_HIF_0_EMPTY_MASK, pse_stat),
+			 FIELD_GET(MT_DBG_PSE_QUEUE_EMPTY_HIF_1_EMPTY_MASK, pse_stat),
+			 FIELD_GET(MT_DBG_PSE_QUEUE_EMPTY_HIF_2_EMPTY_MASK, pse_stat),
+			 FIELD_GET(MT_DBG_PSE_QUEUE_EMPTY_HIF_3_EMPTY_MASK, pse_stat),
+			 FIELD_GET(MT_DBG_PSE_QUEUE_EMPTY_HIF_4_EMPTY_MASK, pse_stat),
+			 FIELD_GET(MT_DBG_PSE_QUEUE_EMPTY_HIF_5_EMPTY_MASK, pse_stat));
+
+	seq_printf(s, "\t\tLMAC TX Q empty=%ld\n",
+			FIELD_GET(MT_DBG_PSE_QUEUE_EMPTY_LMAC_TX_QUEUE_EMPTY_MASK, pse_stat));
+	seq_printf(s, "\t\tMDP TX Q/RX Q empty=%ld/%ld\n",
+			FIELD_GET(MT_DBG_PSE_QUEUE_EMPTY_MDP_TX_QUEUE_EMPTY_MASK, pse_stat),
+			FIELD_GET(MT_DBG_PSE_QUEUE_EMPTY_MDP_RX_QUEUE_EMPTY_MASK, pse_stat));
+	seq_printf(s, "\t\tSEC TX Q/RX Q empty=%ld/%ld\n",
+			FIELD_GET(MT_DBG_PSE_QUEUE_EMPTY_SEC_TX_QUEUE_EMPTY_MASK, pse_stat),
+			FIELD_GET(MT_DBG_PSE_QUEUE_EMPTY_SEC_RX_QUEUE_EMPTY_SHFT, pse_stat));
+	seq_printf(s, "\t\tSFD PARK Q empty=%ld\n",
+			FIELD_GET(MT_DBG_PSE_QUEUE_EMPTY_SFD_PARK_QUEUE_EMPTY_MASK, pse_stat));
+	seq_printf(s, "\t\tMDP TXIOC Q/RXIOC Q empty=%ld/%ld\n",
+			FIELD_GET(MT_DBG_PSE_QUEUE_EMPTY_MDP_TXIOC_QUEUE_EMPTY_MASK, pse_stat),
+			FIELD_GET(MT_DBG_PSE_QUEUE_EMPTY_MDP_RXIOC_QUEUE_EMPTY_MASK, pse_stat));
+	seq_printf(s, "\t\tRLS Q empty=%ld\n",
+		FIELD_GET(MT_DBG_PSE_QUEUE_EMPTY_RLS_Q_EMTPY_MASK, pse_stat));
+	seq_printf(s, "Nonempty Q info:\n");
+
+	for (i = 0; i < 31; i++) {
+		if (((pse_stat & (0x1 << i)) >> i) == 0) {
+			u32 hfid, tfid, pktcnt, fl_que_ctrl[3] = {0};
+
+			if (pse_queue_empty_info[i].QueueName != NULL) {
+				seq_printf(s, "\t%s: ", pse_queue_empty_info[i].QueueName);
+				fl_que_ctrl[0] |= MT_DBG_PSE_FL_QUE_CTRL_0_EXECUTE_MASK;
+				fl_que_ctrl[0] |= (pse_queue_empty_info[i].Portid << MT_DBG_PSE_FL_QUE_CTRL_0_Q_BUF_PID_SHFT);
+				fl_que_ctrl[0] |= (pse_queue_empty_info[i].Queueid << MT_DBG_PSE_FL_QUE_CTRL_0_Q_BUF_QID_SHFT);
+			} else
+				continue;
+
+			fl_que_ctrl[0] |= (0x1 << 31);
+
+			mt76_wr(dev,  MT_DBG_PSE_FL_QUE_CTRL_0_ADDR, fl_que_ctrl[0]);
+			fl_que_ctrl[1] = mt76_rr(dev, MT_DBG_PSE_FL_QUE_CTRL_2_ADDR);
+			fl_que_ctrl[2] = mt76_rr(dev, MT_DBG_PSE_FL_QUE_CTRL_3_ADDR);
+
+			hfid = FIELD_GET(MT_DBG_PSE_FL_QUE_CTRL_2_QUEUE_HEAD_FID_MASK, fl_que_ctrl[1]);
+			tfid = FIELD_GET(MT_DBG_PSE_FL_QUE_CTRL_2_QUEUE_TAIL_FID_MASK, fl_que_ctrl[1]);
+			pktcnt = FIELD_GET(MT_DBG_PSE_FL_QUE_CTRL_3_QUEUE_PKT_NUM_MASK, fl_que_ctrl[2]);
+			seq_printf(s, "tail/head fid = 0x%03x/0x%03x, pkt cnt = 0x%03x\n",
+					  tfid, hfid, pktcnt);
+		}
+	}
+
+	return 0;
+}
+
+static int mt7915_mibinfo_read_per_band(struct seq_file *s, int band_idx)
+{
+#define BSS_NUM	4
+	struct mt7915_dev *dev = dev_get_drvdata(s->private);
+	u32 mac_val0, mac_val, mac_val1, idx, band_offset = 0;
+	u32 msdr6, msdr7, msdr8, msdr9, msdr10, msdr16, msdr17, msdr18, msdr19, msdr20, msdr21;
+	u32 mbxsdr[BSS_NUM][7];
+	u32 mbtcr[16], mbtbcr[16], mbrcr[16], mbrbcr[16];
+	u32 btcr[BSS_NUM], btbcr[BSS_NUM], brcr[BSS_NUM], brbcr[BSS_NUM], btdcr[BSS_NUM], brdcr[BSS_NUM];
+	u32 mu_cnt[5];
+	u32 ampdu_cnt[3];
+	unsigned long per;
+
+	seq_printf(s, "Band %d MIB Status\n", band_idx);
+	seq_printf(s, "===============================\n");
+	mac_val = mt76_rr(dev, MT_DBG_MIB_M0SCR0(band_idx));
+	seq_printf(s, "MIB Status Control=0x%x\n", mac_val);
+	if (is_mt7915(&dev->mt76)) {
+		mac_val = mt76_rr(dev, MT_DBG_MIB_M0PBSCR(band_idx));
+		seq_printf(s, "MIB Per-BSS Status Control=0x%x\n", mac_val);
+	}
+
+	msdr6 = mt76_rr(dev, MT_DBG_MIB_M0SDR6(band_idx));
+	msdr7 = mt76_rr(dev, MT_DBG_MIB_M0SDR7(band_idx));
+	msdr8 = mt76_rr(dev, MT_DBG_MIB_M0SDR8(band_idx));
+	msdr9 = mt76_rr(dev, MT_DBG_MIB_M0SDR9(band_idx));
+	msdr10 = mt76_rr(dev, MT_DBG_MIB_M0SDR10(band_idx));
+	msdr16 = mt76_rr(dev, MT_DBG_MIB_M0SDR16(band_idx));
+	msdr17 = mt76_rr(dev, MT_DBG_MIB_M0SDR17(band_idx));
+	msdr18 = mt76_rr(dev, MT_DBG_MIB_M0SDR18(band_idx));
+	msdr19 = mt76_rr(dev, MT_DBG_MIB_M0SDR19(band_idx));
+	msdr20 = mt76_rr(dev, MT_DBG_MIB_M0SDR20(band_idx));
+	msdr21 = mt76_rr(dev, MT_DBG_MIB_M0SDR21(band_idx));
+	ampdu_cnt[0] = mt76_rr(dev, MT_DBG_MIB_M0SDR12(band_idx));
+	ampdu_cnt[1] = mt76_rr(dev, MT_DBG_MIB_M0SDR14(band_idx));
+	ampdu_cnt[2] = mt76_rr(dev, MT_DBG_MIB_M0SDR15(band_idx));
+	ampdu_cnt[1] &= MT_DBG_MIB_M0SDR14_AMPDU_MASK;
+	ampdu_cnt[2] &= MT_DBG_MIB_M0SDR15_AMPDU_ACKED_MASK;
+
+	seq_printf(s, "===Phy/Timing Related Counters===\n");
+	seq_printf(s, "\tChannelIdleCnt=0x%x\n", msdr6 & BN0_WF_MIB_TOP_M0SDR6_CHANNEL_IDLE_COUNT_MASK);
+	seq_printf(s, "\tCCA_NAV_Tx_Time=0x%x\n", msdr9 & BN0_WF_MIB_TOP_M0SDR9_CCA_NAV_TX_TIME_MASK);
+	seq_printf(s, "\tRx_MDRDY_CNT=0x%lx\n", msdr10 & MT_DBG_MIB_M0SDR10_RX_MDRDY_COUNT_MASK);
+	seq_printf(s, "\tCCK_MDRDY_TIME=0x%x, OFDM_MDRDY_TIME=0x%x, OFDM_GREEN_MDRDY_TIME=0x%x\n",
+			 msdr19 & BN0_WF_MIB_TOP_M0SDR19_CCK_MDRDY_TIME_MASK,
+			 msdr20 & BN0_WF_MIB_TOP_M0SDR20_OFDM_LG_MIXED_VHT_MDRDY_TIME_MASK,
+			 msdr21 & BN0_WF_MIB_TOP_M0SDR21_OFDM_GREEN_MDRDY_TIME_MASK);
+	seq_printf(s, "\tPrim CCA Time=0x%x\n", msdr16 & BN0_WF_MIB_TOP_M0SDR16_P_CCA_TIME_MASK);
+	seq_printf(s, "\tSec CCA Time=0x%x\n", msdr17 & BN0_WF_MIB_TOP_M0SDR17_S_CCA_TIME_MASK);
+	seq_printf(s, "\tPrim ED Time=0x%x\n", msdr18 & BN0_WF_MIB_TOP_M0SDR18_P_ED_TIME_MASK);
+
+	seq_printf(s, "===Tx Related Counters(Generic)===\n");
+	mac_val = mt76_rr(dev, MT_DBG_MIB_M0SDR0(band_idx));
+	dev->dbg.bcn_total_cnt[band_idx] += (mac_val & BN0_WF_MIB_TOP_M0SDR0_BEACONTXCOUNT_MASK);
+	seq_printf(s, "\tBeaconTxCnt=0x%x\n",dev->dbg.bcn_total_cnt[band_idx]);
+	dev->dbg.bcn_total_cnt[band_idx] = 0;
+	mac_val = mt76_rr(dev, MT_DBG_MIB_M0DR0(band_idx));
+	seq_printf(s, "\tTx 20MHz Cnt=0x%x\n", mac_val & BN0_WF_MIB_TOP_M0DR0_TX_20MHZ_CNT_MASK);
+	seq_printf(s, "\tTx 40MHz Cnt=0x%x\n", (mac_val & BN0_WF_MIB_TOP_M0DR0_TX_40MHZ_CNT_MASK) >> BN0_WF_MIB_TOP_M0DR0_TX_40MHZ_CNT_SHFT);
+	mac_val = mt76_rr(dev, MT_DBG_MIB_M0DR1(band_idx));
+	seq_printf(s, "\tTx 80MHz Cnt=0x%x\n", mac_val & BN0_WF_MIB_TOP_M0DR1_TX_80MHZ_CNT_MASK);
+	seq_printf(s, "\tTx 160MHz Cnt=0x%x\n", (mac_val & BN0_WF_MIB_TOP_M0DR1_TX_160MHZ_CNT_MASK) >> BN0_WF_MIB_TOP_M0DR1_TX_160MHZ_CNT_SHFT);
+	seq_printf(s, "\tAMPDU Cnt=0x%x\n", ampdu_cnt[0]);
+	seq_printf(s, "\tAMPDU MPDU Cnt=0x%x\n", ampdu_cnt[1]);
+	seq_printf(s, "\tAMPDU MPDU Ack Cnt=0x%x\n", ampdu_cnt[2]);
+	per = (ampdu_cnt[2] == 0 ? 0 : 1000 * (ampdu_cnt[1] - ampdu_cnt[2]) / ampdu_cnt[1]);
+	seq_printf(s, "\tAMPDU MPDU PER=%ld.%1ld%%\n", per / 10, per % 10);
+
+	seq_printf(s, "===MU Related Counters===\n");
+	mu_cnt[0] = mt76_rr(dev, MT_DBG_MIB_MUBF(band_idx));
+	mu_cnt[1] = mt76_rr(dev, MT_DBG_MIB_M0DR8(band_idx));
+	mu_cnt[2] = mt76_rr(dev, MT_DBG_MIB_M0DR9(band_idx));
+	mu_cnt[3] = mt76_rr(dev, MT_DBG_MIB_M0DR10(band_idx));
+	mu_cnt[4] = mt76_rr(dev, MT_DBG_MIB_M0DR11(band_idx));
+	seq_printf(s, "\tMUBF_TX_COUNT=0x%x\n", mu_cnt[0] & BN0_WF_MIB_TOP_M0SDR34_MUBF_TX_COUNT_MASK);
+	seq_printf(s, "\tMU_TX_MPDU_COUNT(Ok+Fail)=0x%x\n", mu_cnt[1]);
+	seq_printf(s, "\tMU_TX_OK_MPDU_COUNT=0x%x\n", mu_cnt[2]);
+	seq_printf(s, "\tMU_TO_SU_PPDU_COUNT=0x%x\n", mu_cnt[3] & BN0_WF_MIB_TOP_M0DR10_MU_FAIL_PPDU_CNT_MASK);
+	seq_printf(s, "\tSU_TX_OK_MPDU_COUNT=0x%x\n", mu_cnt[4]);
+
+	seq_printf(s, "===Rx Related Counters(Generic)===\n");
+	seq_printf(s, "\tVector Mismacth Cnt=0x%x\n", msdr7 & BN0_WF_MIB_TOP_M0SDR7_VEC_MISS_COUNT_MASK);
+	seq_printf(s, "\tDelimiter Fail Cnt=0x%x\n", msdr8 & BN0_WF_MIB_TOP_M0SDR8_DELIMITER_FAIL_COUNT_MASK);
+
+	mac_val = mt76_rr(dev, MT_DBG_MIB_M0SDR3(band_idx));
+	seq_printf(s, "\tRxFCSErrCnt=0x%lx\n", __DBG_FIELD_GET(DBG_MIB_RX_FCS_ERROR_COUNT, mac_val));
+	mac_val = mt76_rr(dev, MT_DBG_MIB_M0SDR4(band_idx));
+	seq_printf(s, "\tRxFifoFullCnt=0x%x\n", (mac_val & BN0_WF_MIB_TOP_M0SDR4_RX_FIFO_FULL_COUNT_MASK));
+	mac_val = mt76_rr(dev, MT_DBG_MIB_M0SDR11(band_idx));
+	seq_printf(s, "\tRxLenMismatch=0x%x\n", (mac_val & BN0_WF_MIB_TOP_M0SDR11_RX_LEN_MISMATCH_MASK));
+	mac_val = mt76_rr(dev, MT_DBG_MIB_M0SDR5(band_idx));
+	seq_printf(s, "\tRxMPDUCnt=0x%x\n", (mac_val & BN0_WF_MIB_TOP_M0SDR5_RX_MPDU_COUNT_MASK));
+	mac_val = mt76_rr(dev, MT_DBG_MIB_M0SDR22(band_idx));
+	seq_printf(s, "\tRx AMPDU Cnt=0x%x\n", mac_val);
+	/* TODO: shiang-MT7615, is MIB_M0SDR23 used for Rx total byte count for all or just AMPDU only??? */
+	mac_val = mt76_rr(dev, MT_DBG_MIB_M0SDR23(band_idx));
+	seq_printf(s, "\tRx Total ByteCnt=0x%x\n", mac_val);
+
+	if (is_mt7915(&dev->mt76)) {
+		band_offset = WF_WTBLON_TOP_B1BTCRn_ADDR - WF_WTBLON_TOP_B0BTCRn_ADDR;//check
+		seq_printf(s, "===Per-BSS Related Tx/Rx Counters===\n");
+		seq_printf(s, "BSS Idx   TxCnt/DataCnt  TxByteCnt  RxCnt/DataCnt  RxByteCnt\n");
+
+		for (idx = 0; idx < BSS_NUM; idx++) {
+			btcr[idx] = mt76_rr(dev, WF_WTBLON_TOP_B0BTCRn_ADDR + band_offset + idx * 4);
+			btbcr[idx] = mt76_rr(dev, WF_WTBLON_TOP_B0BTBCRn_ADDR + band_offset + idx * 4);
+			brcr[idx] = mt76_rr(dev, WF_WTBLON_TOP_B0BRCRn_ADDR + band_offset + idx * 4);
+			brbcr[idx] = mt76_rr(dev, WF_WTBLON_TOP_B0BRBCRn_ADDR + band_offset + idx * 4);
+			btdcr[idx] = mt76_rr(dev, WF_WTBLON_TOP_B0BTDCRn_ADDR + band_offset + idx * 4);
+			brdcr[idx] = mt76_rr(dev, WF_WTBLON_TOP_B0BRDCRn_ADDR + band_offset + idx * 4);
+		}
+
+		for (idx = 0; idx < BSS_NUM; idx++) {
+			seq_printf(s, "%d\t 0x%x/0x%x\t 0x%x \t 0x%x/0x%x \t 0x%x\n",
+				      idx, btcr[idx], btdcr[idx], btbcr[idx],
+				      brcr[idx], brdcr[idx], brbcr[idx]);
+		}
+
+		band_offset = (BN1_WF_MIB_TOP_BASE - BN0_WF_MIB_TOP_BASE) * band_idx;
+		seq_printf(s, "===Per-MBSS Related MIB Counters===\n");
+		seq_printf(s, "BSS Idx   RTSTx/RetryCnt  BAMissCnt  AckFailCnt  FrmRetry1/2/3Cnt\n");
+
+		for (idx = 0; idx < BSS_NUM; idx++) {
+			mbxsdr[idx][0] = mt76_rr(dev, BN0_WF_MIB_TOP_M0B0SDR0_ADDR + band_offset + idx * 0x10);
+			mbxsdr[idx][1] = mt76_rr(dev, BN0_WF_MIB_TOP_M0B0SDR1_ADDR + band_offset + idx * 0x10);
+			mbxsdr[idx][2] = mt76_rr(dev, BN0_WF_MIB_TOP_M0B0SDR2_ADDR + band_offset + idx * 0x10);
+			mbxsdr[idx][3] = mt76_rr(dev, BN0_WF_MIB_TOP_M0B0SDR3_ADDR + band_offset + idx * 0x10);
+		}
+
+		for (idx = 0; idx < BSS_NUM; idx++) {
+			seq_printf(s, "%d:\t0x%08x/0x%08x  0x%08x \t 0x%08x \t  0x%08x/0x%08x/0x%08x\n",
+				      idx, (mbxsdr[idx][0] & BN0_WF_MIB_TOP_M0B0SDR0_RTSTXCOUNT_MASK),
+				      (mbxsdr[idx][0] & BN0_WF_MIB_TOP_M0B0SDR0_RTSRETRYCOUNT_MASK) >> BN0_WF_MIB_TOP_M0B0SDR0_RTSRETRYCOUNT_SHFT,
+				      (mbxsdr[idx][1] & BN0_WF_MIB_TOP_M0B0SDR1_BAMISSCOUNT_MASK),
+				      (mbxsdr[idx][1] & BN0_WF_MIB_TOP_M0B0SDR1_ACKFAILCOUNT_MASK) >> BN0_WF_MIB_TOP_M0B0SDR1_ACKFAILCOUNT_SHFT,
+				      (mbxsdr[idx][2] & BN0_WF_MIB_TOP_M0B0SDR2_FRAMERETRYCOUNT_MASK),
+				      (mbxsdr[idx][2] & BN0_WF_MIB_TOP_M0B0SDR2_FRAMERETRY2COUNT_MASK) >> BN0_WF_MIB_TOP_M0B0SDR2_FRAMERETRY2COUNT_SHFT,
+				      (mbxsdr[idx][3] & BN0_WF_MIB_TOP_M0B0SDR3_FRAMERETRY3COUNT_MASK));
+		}
+
+		band_offset = WF_WTBLON_TOP_B1BTCRn_ADDR - WF_WTBLON_TOP_B0BTCRn_ADDR;
+		seq_printf(s, "===Per-MBSS Related Tx/Rx Counters===\n");
+		seq_printf(s, "MBSSIdx   TxCnt  TxByteCnt  RxCnt  RxByteCnt\n");
+
+		for (idx = 0; idx < 16; idx++) {
+			mbtcr[idx] = mt76_rr(dev, WF_WTBLON_TOP_B0MBTCRn_ADDR + band_offset + idx * 4);
+			mbtbcr[idx] = mt76_rr(dev, WF_WTBLON_TOP_B0MBTBCRn_ADDR + band_offset + idx * 4);
+			mbrcr[idx] = mt76_rr(dev, WF_WTBLON_TOP_B0MBRCRn_ADDR + band_offset + idx * 4);
+			mbrbcr[idx] = mt76_rr(dev, WF_WTBLON_TOP_B0MBRBCRn_ADDR + band_offset + idx * 4);
+		}
+
+		for (idx = 0; idx < 16; idx++) {
+			seq_printf(s, "%d\t 0x%08x\t 0x%08x \t 0x%08x \t 0x%08x\n",
+						idx, mbtcr[idx], mbtbcr[idx], mbrcr[idx], mbrbcr[idx]);
+		}
+		return 0;
+	} else {
+		u32 btocr[BSS_NUM], mbtocr[16],mbrocr[16], brocr[BSS_NUM];
+		u8 bss_nums = BSS_NUM;
+
+		band_offset = (BN1_WF_MIB_TOP_BTOCR_ADDR - BN0_WF_MIB_TOP_BTOCR_ADDR) * band_idx;
+		seq_printf(s, "===Per-BSS Related Tx/Rx Counters===\n");
+		seq_printf(s, "BSS Idx   TxCnt/DataCnt  TxByteCnt  RxCnt/DataCnt  RxByteCnt\n");
+
+		for (idx = 0; idx < BSS_NUM; idx++) {
+			btocr[idx] = mt76_rr(dev, (BN0_WF_MIB_TOP_BTOCR_ADDR + band_offset + (idx >> 1) * 4));
+			btdcr[idx] = mt76_rr(dev, (BN0_WF_MIB_TOP_BTDCR_ADDR + band_offset + (idx >> 1) * 4));
+			btbcr[idx] = mt76_rr(dev, (BN0_WF_MIB_TOP_BTBCR_ADDR + band_offset + (idx * 4)));
+			brocr[idx] = mt76_rr(dev, (BN0_WF_MIB_TOP_BROCR_ADDR + band_offset + (idx >> 1) * 4));
+			brdcr[idx] = mt76_rr(dev, (BN0_WF_MIB_TOP_BRDCR_ADDR + band_offset + (idx >> 1) * 4));
+			brbcr[idx] = mt76_rr(dev, (BN0_WF_MIB_TOP_BRBCR_ADDR + band_offset + (idx * 4)));
+
+			if ((idx % 2) == 0) {
+				btocr[idx] = ((btocr[idx] & BN0_WF_MIB_TOP_BTOCR_TX_OK_COUNT2n_MASK) >> BN0_WF_MIB_TOP_BTOCR_TX_OK_COUNT2n_SHFT);
+				btdcr[idx] = ((btdcr[idx] & BN0_WF_MIB_TOP_BTDCR_TX_DATA_COUNT2n_MASK) >> BN0_WF_MIB_TOP_BTDCR_TX_DATA_COUNT2n_SHFT);
+				brocr[idx] = ((brocr[idx] & BN0_WF_MIB_TOP_BROCR_RX_OK_COUNT2n_MASK) >> BN0_WF_MIB_TOP_BROCR_RX_OK_COUNT2n_SHFT);
+				brdcr[idx] = ((brdcr[idx] & BN0_WF_MIB_TOP_BRDCR_RX_DATA_COUNT2n_MASK) >> BN0_WF_MIB_TOP_BRDCR_RX_DATA_COUNT2n_SHFT);
+			} else {
+				btocr[idx] = ((btocr[idx] & BN0_WF_MIB_TOP_BTOCR_TX_OK_COUNT2np1_MASK) >> BN0_WF_MIB_TOP_BTOCR_TX_OK_COUNT2np1_SHFT);
+				btdcr[idx] = ((btdcr[idx] & BN0_WF_MIB_TOP_BTDCR_TX_DATA_COUNT2np1_MASK) >> BN0_WF_MIB_TOP_BTDCR_TX_DATA_COUNT2np1_SHFT);
+				brocr[idx] = ((brocr[idx] & BN0_WF_MIB_TOP_BROCR_RX_OK_COUNT2np1_MASK) >> BN0_WF_MIB_TOP_BROCR_RX_OK_COUNT2np1_SHFT);
+				brdcr[idx] = ((brdcr[idx] & BN0_WF_MIB_TOP_BRDCR_RX_DATA_COUNT2np1_MASK) >> BN0_WF_MIB_TOP_BRDCR_RX_DATA_COUNT2np1_SHFT);
+			}
+		}
+
+		for (idx = 0; idx < BSS_NUM; idx++) {
+			seq_printf(s, "%d\t 0x%x/0x%x\t 0x%x \t 0x%x/0x%x \t 0x%x\n",
+							idx, btocr[idx], btdcr[idx], btbcr[idx], brocr[idx], brdcr[idx], brbcr[idx]);
+		}
+
+		band_offset = (BN1_WF_MIB_TOP_BASE - BN0_WF_MIB_TOP_BASE) * band_idx;
+		seq_printf(s, "===Per-MBSS Related MIB Counters===\n");
+		seq_printf(s, "BSS Idx   RTSTx/RetryCnt  BAMissCnt  AckFailCnt  FrmRetry1/2/3Cnt\n");
+
+		for (idx = 0; idx < BSS_NUM; idx++) {
+			mbxsdr[idx][0] = mt76_rr(dev, BN0_WF_MIB_TOP_BSDR0_ADDR + band_offset + ((idx >> 1) * 4));
+			mbxsdr[idx][1] = mt76_rr(dev, BN0_WF_MIB_TOP_BSDR1_ADDR + band_offset + ((idx >> 1) * 4));
+			mbxsdr[idx][2] = mt76_rr(dev, BN0_WF_MIB_TOP_BSDR2_ADDR + band_offset + ((idx >> 1) * 4));
+			mbxsdr[idx][3] = mt76_rr(dev, BN0_WF_MIB_TOP_BSDR3_ADDR + band_offset + ((idx >> 1) * 4));
+			mbxsdr[idx][4] = mt76_rr(dev, BN0_WF_MIB_TOP_BSDR4_ADDR + band_offset + ((idx >> 1) * 4));
+			mbxsdr[idx][5] = mt76_rr(dev, BN0_WF_MIB_TOP_BSDR5_ADDR + band_offset + ((idx >> 1) * 4));
+			mbxsdr[idx][6] = mt76_rr(dev, BN0_WF_MIB_TOP_BSDR6_ADDR + band_offset + ((idx >> 1) * 4));
+
+			if ((idx % 2) == 0) {
+				mbxsdr[idx][0] = ((mbxsdr[idx][0] & BN0_WF_MIB_TOP_BSDR0_RTSTXCOUNT2n_MASK) >> BN0_WF_MIB_TOP_BSDR0_RTSTXCOUNT2n_SHFT);
+				mbxsdr[idx][1] = ((mbxsdr[idx][1] & BN0_WF_MIB_TOP_BSDR1_RTSRETRYCOUNT2n_MASK) >> BN0_WF_MIB_TOP_BSDR1_RTSRETRYCOUNT2n_SHFT);
+				mbxsdr[idx][2] = ((mbxsdr[idx][2] & BN0_WF_MIB_TOP_BSDR2_BAMISSCOUNT2n_MASK) >> BN0_WF_MIB_TOP_BSDR2_BAMISSCOUNT2n_SHFT);
+				mbxsdr[idx][3] = ((mbxsdr[idx][3] & BN0_WF_MIB_TOP_BSDR3_ACKFAILCOUNT2n_MASK) >> BN0_WF_MIB_TOP_BSDR3_ACKFAILCOUNT2n_SHFT);
+				mbxsdr[idx][4] = ((mbxsdr[idx][4] & BN0_WF_MIB_TOP_BSDR4_FRAMERETRYCOUNT2n_MASK) >> BN0_WF_MIB_TOP_BSDR4_FRAMERETRYCOUNT2n_SHFT);
+				mbxsdr[idx][5] = ((mbxsdr[idx][5] & BN0_WF_MIB_TOP_BSDR5_FRAMERETRY2COUNT2n_MASK) >> BN0_WF_MIB_TOP_BSDR5_FRAMERETRY2COUNT2n_SHFT);
+				mbxsdr[idx][6] = ((mbxsdr[idx][6] & BN0_WF_MIB_TOP_BSDR6_FRAMERETRY3COUNT2n_MASK) >> BN0_WF_MIB_TOP_BSDR6_FRAMERETRY3COUNT2n_SHFT);
+			} else {
+				mbxsdr[idx][0] = ((mbxsdr[idx][0] & BN0_WF_MIB_TOP_BSDR0_RTSTXCOUNT2np1_MASK) >> BN0_WF_MIB_TOP_BSDR0_RTSTXCOUNT2np1_SHFT);
+				mbxsdr[idx][1] = ((mbxsdr[idx][1] & BN0_WF_MIB_TOP_BSDR1_RTSRETRYCOUNT2np1_MASK) >> BN0_WF_MIB_TOP_BSDR1_RTSRETRYCOUNT2np1_SHFT);
+				mbxsdr[idx][2] = ((mbxsdr[idx][2] & BN0_WF_MIB_TOP_BSDR2_BAMISSCOUNT2np1_MASK) >> BN0_WF_MIB_TOP_BSDR2_BAMISSCOUNT2np1_SHFT);
+				mbxsdr[idx][3] = ((mbxsdr[idx][3] & BN0_WF_MIB_TOP_BSDR3_ACKFAILCOUNT2np1_MASK) >> BN0_WF_MIB_TOP_BSDR3_ACKFAILCOUNT2np1_SHFT);
+				mbxsdr[idx][4] = ((mbxsdr[idx][4] & BN0_WF_MIB_TOP_BSDR4_FRAMERETRYCOUNT2np1_MASK) >> BN0_WF_MIB_TOP_BSDR4_FRAMERETRYCOUNT2np1_SHFT);
+				mbxsdr[idx][5] = ((mbxsdr[idx][5] & BN0_WF_MIB_TOP_BSDR5_FRAMERETRY2COUNT2np1_MASK) >> BN0_WF_MIB_TOP_BSDR5_FRAMERETRY2COUNT2np1_SHFT);
+				mbxsdr[idx][6] = ((mbxsdr[idx][6] & BN0_WF_MIB_TOP_BSDR6_FRAMERETRY3COUNT2np1_MASK) >> BN0_WF_MIB_TOP_BSDR6_FRAMERETRY3COUNT2np1_SHFT);
+			}
+		}
+
+		for (idx = 0; idx < BSS_NUM; idx++) {
+			seq_printf(s, "%d:\t0x%x/0x%x  0x%x \t 0x%x \t  0x%x/0x%x/0x%x\n",
+				      idx,
+				      mbxsdr[idx][0], mbxsdr[idx][1], mbxsdr[idx][2], mbxsdr[idx][3],
+				      mbxsdr[idx][4], mbxsdr[idx][5], mbxsdr[idx][6]);
+		}
+
+		band_offset = (BN1_WF_MIB_TOP_BTOCR_ADDR - BN0_WF_MIB_TOP_BTOCR_ADDR) * band_idx;
+		seq_printf(s, "===Per-MBSS Related Tx/Rx Counters===\n");
+		seq_printf(s, "MBSSIdx   TxCnt  TxByteCnt  RxCnt  RxByteCnt\n");
+
+		for (idx = 0; idx < 16; idx++) {
+			mbtocr[idx] = mt76_rr(dev, BN0_WF_MIB_TOP_BTOCR_ADDR + band_offset + (((bss_nums >> 1) * 4) + ((idx >> 1) * 4)));
+			mbtbcr[idx] = mt76_rr(dev, BN0_WF_MIB_TOP_BTBCR_ADDR + band_offset + (((bss_nums >> 1) * 4) + (idx * 4)));
+			mbrocr[idx] = mt76_rr(dev, BN0_WF_MIB_TOP_BROCR_ADDR + band_offset + (((bss_nums >> 1) * 4) + ((idx >> 1) * 4)));
+			mbrbcr[idx] = mt76_rr(dev, BN0_WF_MIB_TOP_BRBCR_ADDR + band_offset + (((bss_nums >> 1) * 4) + (idx * 4)));
+
+			if ((idx % 2) == 0) {
+				mbtocr[idx] = ((mbtocr[idx] & BN0_WF_MIB_TOP_BTOCR_TX_OK_COUNT2n_MASK) >> BN0_WF_MIB_TOP_BTOCR_TX_OK_COUNT2n_SHFT);
+				mbrocr[idx] = ((mbrocr[idx] & BN0_WF_MIB_TOP_BROCR_RX_OK_COUNT2n_MASK) >> BN0_WF_MIB_TOP_BROCR_RX_OK_COUNT2n_SHFT);
+			} else {
+				mbtocr[idx] = ((mbtocr[idx] & BN0_WF_MIB_TOP_BTOCR_TX_OK_COUNT2np1_MASK) >> BN0_WF_MIB_TOP_BTOCR_TX_OK_COUNT2np1_SHFT);
+				mbrocr[idx] = ((mbrocr[idx] & BN0_WF_MIB_TOP_BROCR_RX_OK_COUNT2np1_MASK) >> BN0_WF_MIB_TOP_BROCR_RX_OK_COUNT2np1_SHFT);
+			}
+		}
+
+		for (idx = 0; idx < 16; idx++) {
+			seq_printf(s, "%d\t 0x%08x\t 0x%08x \t 0x%08x \t 0x%08x\n",
+						idx, mbtocr[idx], mbtbcr[idx], mbrocr[idx], mbrbcr[idx]);
+		}
+	}
+
+	seq_printf(s, "===Dummy delimiter insertion result===\n");
+	mac_val0 = mt76_rr(dev, MT_DBG_MIB_M0DR11(band_idx));
+	mac_val = mt76_rr(dev, MT_DBG_MIB_M0DR6(band_idx));
+	mac_val1 = mt76_rr(dev, MT_DBG_MIB_M0DR7(band_idx));
+	seq_printf(s, "Range0 = %d\t Range1 = %d\t Range2 = %d\t Range3 = %d\t Range4 = %d\n",
+				(mac_val0 & BN0_WF_MIB_TOP_M0DR12_TX_DDLMT_RNG0_CNT_MASK),
+				(mac_val & BN0_WF_MIB_TOP_M0DR6_TX_DDLMT_RNG1_CNT_MASK),
+				(mac_val & BN0_WF_MIB_TOP_M0DR6_TX_DDLMT_RNG2_CNT_MASK) >> BN0_WF_MIB_TOP_M0DR6_TX_DDLMT_RNG2_CNT_SHFT,
+				(mac_val1 & BN0_WF_MIB_TOP_M0DR7_TX_DDLMT_RNG3_CNT_MASK),
+				(mac_val1 & BN0_WF_MIB_TOP_M0DR7_TX_DDLMT_RNG4_CNT_MASK) >> BN0_WF_MIB_TOP_M0DR7_TX_DDLMT_RNG4_CNT_SHFT);
+
+	return 0;
+}
+
+static int mt7915_mibinfo_band0(struct seq_file *s, void *data)
+{
+	mt7915_mibinfo_read_per_band(s, 0);
+	return 0;
+}
+
+static int mt7915_mibinfo_band1(struct seq_file *s, void *data)
+{
+	mt7915_mibinfo_read_per_band(s, 1);
+	return 0;
+}
+
+static int mt7915_token_read(struct seq_file *s, void *data)
+{
+	struct mt7915_dev *dev = dev_get_drvdata(s->private);
+	int id, count = 0;
+	struct mt76_txwi_cache *txwi;
+
+	seq_printf(s, "Cut through token:\n");
+	spin_lock_bh(&dev->mt76.token_lock);
+	idr_for_each_entry(&dev->mt76.token, txwi, id) {
+		seq_printf(s, "%4d ", id);
+		count++;
+		if (count % 8 == 0)
+			seq_printf(s, "\n");
+	}
+	spin_unlock_bh(&dev->mt76.token_lock);
+	seq_printf(s, "\n");
+
+	return 0;
+}
+
+struct txd_l {
+	u32 txd_0;
+	u32 txd_1;
+	u32 txd_2;
+	u32 txd_3;
+	u32 txd_4;
+	u32 txd_5;
+	u32 txd_6;
+	u32 txd_7;
+} __packed;
+
+char *pkt_ft_str[] = {"cut_through", "store_forward", "cmd", "PDA_FW_Download"};
+char *hdr_fmt_str[] = {
+	"Non-80211-Frame",
+	"Command-Frame",
+	"Normal-80211-Frame",
+	"enhanced-80211-Frame",
+};
+/* TMAC_TXD_1.hdr_format */
+#define TMI_HDR_FT_NON_80211	0x0
+#define TMI_HDR_FT_CMD		0x1
+#define TMI_HDR_FT_NOR_80211	0x2
+#define TMI_HDR_FT_ENH_80211	0x3
+
+void mt7915_dump_tmac_info(u8 *tmac_info)
+{
+	struct txd_l *txd = (struct txd_l *)tmac_info;
+
+	printk("txd raw data: size=%d\n", MT_TXD_SIZE);
+	print_hex_dump(KERN_ERR , "", DUMP_PREFIX_OFFSET, 16, 1, tmac_info, MT_TXD_SIZE, false);
+
+	printk("TMAC_TXD Fields:\n");
+	printk("\tTMAC_TXD_0:\n");
+
+	/* DW0 */
+	/* TX Byte Count [15:0]  */
+	printk("\t\tTxByteCnt = %ld\n", FIELD_GET(MT_TXD0_TX_BYTES, txd->txd_0));
+
+	/* PKT_FT: Packet Format [24:23] */
+	printk("\t\tpkt_ft = %ld(%s)\n",
+			FIELD_GET(MT_TXD0_PKT_FMT, txd->txd_0),
+			pkt_ft_str[FIELD_GET(MT_TXD0_PKT_FMT, txd->txd_0)]);
+
+	/* Q_IDX [31:25]  */
+	printk("\t\tQueID =0x%lx\n", FIELD_GET(MT_TXD0_Q_IDX, txd->txd_0));
+
+	printk("\tTMAC_TXD_1:\n");
+
+	/* DW1 */
+	/* WLAN Indec [9:0] */
+	printk("\t\tWlan Index = %ld\n", FIELD_GET(MT_TXD1_WLAN_IDX, txd->txd_1));
+
+	/* VTA [10] */
+	printk("\t\tVTA = %d\n", ((txd->txd_1 & MT_TXD1_VTA) ? 1 : 0));
+
+	/* HF: Header Format [17:16] */
+	printk("\t\tHdrFmt = %ld(%s)\n",
+			FIELD_GET(MT_TXD1_HDR_FORMAT, txd->txd_1),
+			FIELD_GET(MT_TXD1_HDR_FORMAT, txd->txd_1) < 4 ?
+			hdr_fmt_str[FIELD_GET(MT_TXD1_HDR_FORMAT, txd->txd_1)] : "N/A");
+
+	switch (FIELD_GET(MT_TXD1_HDR_FORMAT, txd->txd_1)) {
+	case TMI_HDR_FT_NON_80211:
+		/* MRD [11], EOSP [12], RMVL [13], VLAN [14], ETYPE [15] */
+		printk("\t\t\tMRD = %d, EOSP = %d,\
+				RMVL = %d, VLAN = %d, ETYP = %d\n",
+				(txd->txd_1 & MT_TXD1_MRD) ? 1 : 0,
+				(txd->txd_1 & MT_TXD1_EOSP) ? 1 : 0,
+				(txd->txd_1 & MT_TXD1_RMVL) ? 1 : 0,
+				(txd->txd_1 & MT_TXD1_VLAN) ? 1 : 0,
+				(txd->txd_1 & MT_TXD1_ETYP) ? 1 : 0);
+		break;
+	case TMI_HDR_FT_NOR_80211:
+		/* HEADER_LENGTH [15:11] */
+		printk("\t\t\tHeader Len = %ld(WORD)\n", FIELD_GET(MT_TXD1_HDR_INFO, txd->txd_1));
+		break;
+
+	case TMI_HDR_FT_ENH_80211:
+		/* EOSP [12], AMS [13]  */
+		printk("\t\t\tEOSP = %d, AMS = %d\n",
+				(txd->txd_1 & MT_TXD1_EOSP) ? 1 : 0,
+				(txd->txd_1 & MT_TXD1_AMS) ? 1 : 0);
+		break;
+	}
+
+	/* Header Padding [19:18] */
+	printk("\t\tHdrPad = %ld\n", FIELD_GET(MT_TXD1_HDR_PAD, txd->txd_1));
+
+	/* TID [22:20] */
+	printk("\t\tTID = %ld\n", FIELD_GET(MT_TXD1_TID, txd->txd_1));
+
+
+	/* UtxB/AMSDU_C/AMSDU [23] */
+	printk("\t\tamsdu = %d\n", ((txd->txd_1 & MT_TXD1_AMSDU) ? 1 : 0));
+
+	/* OM [29:24] */
+	printk("\t\town_mac = %ld\n", FIELD_GET(MT_TXD1_OWN_MAC, txd->txd_1));
+
+
+	/* TGID [30] */
+	printk("\t\tTGID = %d\n", ((txd->txd_1 & MT_TXD1_TGID) ? 1 : 0));
+
+
+	/* FT [31] */
+	printk("\t\tTxDFormatType = %d\n", (txd->txd_1 & MT_TXD1_LONG_FORMAT) ? 1 : 0);
+
+	printk("\tTMAC_TXD_2:\n");
+	/* DW2 */
+	/* Subtype [3:0] */
+	printk("\t\tsub_type = %ld\n", FIELD_GET(MT_TXD2_SUB_TYPE, txd->txd_2));
+
+	/* Type[5:4] */
+	printk("\t\tfrm_type = %ld\n", FIELD_GET(MT_TXD2_FRAME_TYPE, txd->txd_2));
+
+	/* NDP [6] */
+	printk("\t\tNDP = %d\n", ((txd->txd_2 & MT_TXD2_NDP) ? 1 : 0));
+
+	/* NDPA [7] */
+	printk("\t\tNDPA = %d\n", ((txd->txd_2 & MT_TXD2_NDPA) ? 1 : 0));
+
+	/* SD [8] */
+	printk("\t\tSounding = %d\n", ((txd->txd_2 & MT_TXD2_SOUNDING) ? 1 : 0));
+
+	/* RTS [9] */
+	printk("\t\tRTS = %d\n", ((txd->txd_2 & MT_TXD2_RTS) ? 1 : 0));
+
+	/* BM [10] */
+	printk("\t\tbc_mc_pkt = %d\n", ((txd->txd_2 & MT_TXD2_MULTICAST) ? 1 : 0));
+
+	/* B [11]  */
+	printk("\t\tBIP = %d\n", ((txd->txd_2 & MT_TXD2_BIP) ? 1 : 0));
+
+	/* DU [12] */
+	printk("\t\tDuration = %d\n", ((txd->txd_2 & MT_TXD2_DURATION) ? 1 : 0));
+
+	/* HE [13] */
+	printk("\t\tHE(HTC Exist) = %d\n", ((txd->txd_2 & MT_TXD2_HTC_VLD) ? 1 : 0));
+
+	/* FRAG [15:14] */
+	printk("\t\tFRAG = %ld\n", FIELD_GET(MT_TXD2_FRAG, txd->txd_2));
+
+
+	/* Remaining Life Time [23:16]*/
+	printk("\t\tReamingLife/MaxTx time = %ld (unit: 64TU)\n",
+		FIELD_GET(MT_TXD2_MAX_TX_TIME, txd->txd_2));
+
+	/* Power Offset [29:24] */
+	printk("\t\tpwr_offset = %ld\n", FIELD_GET(MT_TXD2_POWER_OFFSET, txd->txd_2));
+
+	/* FRM [30] */
+	printk("\t\tfix rate mode = %d\n", (txd->txd_2 & MT_TXD2_FIXED_RATE) ? 1 : 0);
+
+	/* FR[31] */
+	printk("\t\tfix rate = %d\n", (txd->txd_2 & MT_TXD2_FIX_RATE) ? 1 : 0);
+
+
+	printk("\tTMAC_TXD_3:\n");
+
+	/* DW3 */
+	/* NA [0] */
+	printk("\t\tNoAck = %d\n", (txd->txd_3 & MT_TXD3_NO_ACK) ? 1 : 0);
+
+	/* PF [1] */
+	printk("\t\tPF = %d\n", (txd->txd_3 & MT_TXD3_PROTECT_FRAME) ? 1 : 0);
+
+	/* EMRD [2] */
+	printk("\t\tEMRD = %d\n", (txd->txd_3 & MT_TXD3_EMRD) ? 1 : 0);
+
+	/* EEOSP [3] */
+	printk("\t\tEEOSP = %d\n", (txd->txd_3 & MT_TXD3_EEOSP) ? 1 : 0);
+
+	/* DAS [4] */
+	printk("\t\tda_select = %d\n", (txd->txd_3 & MT_TXD3_DAS) ? 1 : 0);
+
+	/* TM [5] */
+	printk("\t\ttm = %d\n", (txd->txd_3 & MT_TXD3_TIMING_MEASURE) ? 1 : 0);
+
+	/* TX Count [10:6] */
+	printk("\t\ttx_cnt = %ld\n", FIELD_GET(MT_TXD3_TX_COUNT, txd->txd_3));
+
+	/* Remaining TX Count [15:11] */
+	printk("\t\tremain_tx_cnt = %ld\n", FIELD_GET(MT_TXD3_REM_TX_COUNT, txd->txd_3));
+
+	/* SN [27:16] */
+	printk("\t\tsn = %ld\n", FIELD_GET(MT_TXD3_SEQ, txd->txd_3));
+
+	/* BA_DIS [28] */
+	printk("\t\tba dis = %d\n", (txd->txd_3 & MT_TXD3_BA_DISABLE) ? 1 : 0);
+
+	/* Power Management [29] */
+	printk("\t\tpwr_mgmt = 0x%x\n", (txd->txd_3 & MT_TXD3_SW_POWER_MGMT) ? 1 : 0);
+
+	/* PN_VLD [30] */
+	printk("\t\tpn_vld = %d\n", (txd->txd_3 & MT_TXD3_PN_VALID) ? 1 : 0);
+
+	/* SN_VLD [31] */
+	printk("\t\tsn_vld = %d\n", (txd->txd_3 & MT_TXD3_SN_VALID) ? 1 : 0);
+
+
+	/* DW4 */
+	printk("\tTMAC_TXD_4:\n");
+
+	/* PN_LOW [31:0] */
+	printk("\t\tpn_low = 0x%lx\n", FIELD_GET(MT_TXD4_PN_LOW, txd->txd_4));
+
+
+	/* DW5 */
+	printk("\tTMAC_TXD_5:\n");
+
+	/* PID [7:0] */
+	printk("\t\tpid = %ld\n", FIELD_GET(MT_TXD5_PID, txd->txd_5));
+
+	/* TXSFM [8] */
+	printk("\t\ttx_status_fmt = %d\n", (txd->txd_5 & MT_TXD5_TX_STATUS_FMT) ? 1 : 0);
+
+	/* TXS2M [9] */
+	printk("\t\ttx_status_2_mcu = %d\n", (txd->txd_5 & MT_TXD5_TX_STATUS_MCU) ? 1 : 0);
+
+	/* TXS2H [10] */
+	printk("\t\ttx_status_2_host = %d\n", (txd->txd_5 & MT_TXD5_TX_STATUS_HOST) ? 1 : 0);
+
+	/* ADD_BA [14] */
+	printk("\t\tADD_BA = %d\n", (txd->txd_5 & MT_TXD5_ADD_BA) ? 1 : 0);
+
+	/* MD [15] */
+	printk("\t\tMD = %d\n", (txd->txd_5 & MT_TXD5_MD) ? 1 : 0);
+
+	/* PN_HIGH [31:16]  */
+	printk("\t\tpn_high = 0x%lx\n", FIELD_GET(MT_TXD5_PN_HIGH, txd->txd_5));
+
+	/* DW6 */
+	printk("\tTMAC_TXD_6:\n");
+
+	if (txd->txd_2 & MT_TXD2_FIX_RATE) {
+		/* Fixed BandWidth mode [2:0] */
+		printk("\t\tbw = %ld\n",
+		       FIELD_GET(MT_TXD6_BW, txd->txd_6) | (txd->txd_6 & MT_TXD6_FIXED_BW));
+
+		/* DYN_BW [3] */
+		printk("\t\tdyn_bw = %d\n", (txd->txd_6 & MT_TXD6_DYN_BW) ? 1 : 0);
+
+		/* ANT_ID [7:4] */
+		printk("\t\tant_id = %ld\n", FIELD_GET(MT_TXD6_ANT_ID, txd->txd_6));
+
+		/* SPE_IDX_SEL [10] */
+		printk("\t\tspe_idx_sel = %d\n", (txd->txd_6 & MT_TXD6_SPE_ID_IDX) ? 1 : 0);
+
+		/* LDPC [11] */
+		printk("\t\tldpc = %d\n", (txd->txd_6 & MT_TXD6_LDPC) ? 1 : 0);
+
+		/* HELTF Type[13:12] */
+		printk("\t\tHELTF Type = %ld\n", FIELD_GET(MT_TXD6_HELTF, txd->txd_6));
+
+		/* GI Type [15:14] */
+		printk("\t\tGI = %ld\n", FIELD_GET(MT_TXD6_SGI, txd->txd_6));
+
+		/* Rate to be Fixed [29:16] */
+		printk("\t\ttx_rate = 0x%lx\n", FIELD_GET(MT_TXD6_TX_RATE, txd->txd_6));
+	}
+
+	/* TXEBF [30] */
+	printk("\t\ttxebf = %d\n", (txd->txd_6 & MT_TXD6_TX_EBF)  ? 1 : 0);
+
+	/* TXIBF [31] */
+	printk("\t\ttxibf = %d\n", (txd->txd_6 & MT_TXD6_TX_IBF) ? 1 : 0);
+
+	/* DW7 */
+	printk("\tTMAC_TXD_7:\n");
+
+	if ((txd->txd_1 & MT_TXD1_VTA) == 0) {
+		/* SW Tx Time [9:0] */
+		printk("\t\tsw_tx_time = %ld\n", FIELD_GET(MT_TXD7_TX_TIME, txd->txd_7));
+	} else {
+		/* TXD Arrival Time [9:0] */
+		printk("\t\tat = %ld\n", FIELD_GET(MT_TXD7_TAT, txd->txd_7));
+	}
+
+	/* HW_AMSDU_CAP [10] */
+	printk("\t\thw amsdu cap = %d\n",(txd->txd_7 & MT_TXD7_HW_AMSDU) ? 1 : 0);
+
+	/* SPE_IDX [15:11] */
+	if (txd->txd_2 & MT_TXD2_FIX_RATE) {
+		printk("\t\tspe_idx = 0x%lx\n", FIELD_GET(MT_TXD7_SPE_IDX, txd->txd_7));
+	}
+
+	/* PSE_FID [27:16] */
+	printk("\t\tpse_fid = 0x%lx\n", FIELD_GET(MT_TXD7_PSE_FID, txd->txd_7));
+
+	/* Subtype [19:16] */
+	printk("\t\tpp_sub_type=%ld\n", FIELD_GET(MT_TXD7_SUB_TYPE, txd->txd_7));
+
+	/* Type [21:20] */
+	printk("\t\tpp_type=%ld\n", FIELD_GET(MT_TXD7_TYPE, txd->txd_7));
+
+	/* CTXD_CNT [25:23] */
+	printk("\t\tctxd cnt=0x%lx\n", FIELD_GET(MT_TXD7_CTXD_CNT, txd->txd_7));
+
+	/* CTXD [26] */
+	printk("\t\tctxd = %d\n", (txd->txd_7 & MT_TXD7_CTXD) ? 1 : 0);
+
+	/* I [28]  */
+	printk("\t\ti = %d\n", (txd->txd_7 & MT_TXD7_IP_SUM) ? 1 : 0);
+
+	/* UT [29] */
+	printk("\t\tUT = %d\n", (txd->txd_7 & MT_TXD7_UDP_TCP_SUM) ? 1 : 0);
+
+	/* TXDLEN [31:30] */
+	printk("\t\t txd len= %ld\n", FIELD_GET(MT_TXD7_TXD_LEN, txd->txd_7));
+}
+
+
+static int mt7915_token_txd_read(struct seq_file *s, void *data)
+{
+	struct mt7915_dev *dev = dev_get_drvdata(s->private);
+	struct mt76_txwi_cache *t;
+	u8* txwi;
+
+	seq_printf(s, "\n");
+	spin_lock_bh(&dev->mt76.token_lock);
+
+	t = idr_find(&dev->mt76.token, dev->dbg.token_idx);
+
+	if (t != NULL) {
+		struct mt76_dev *mdev = &dev->mt76;
+		txwi = ((u8*)(t)) - (mdev->drv->txwi_size);
+		mt7915_dump_tmac_info((u8*) txwi);
+		seq_printf(s, "\n");
+		printk("[SKB]\n");
+		print_hex_dump(KERN_ERR , "", DUMP_PREFIX_OFFSET, 16, 1, (u8 *)t->skb->data, t->skb->len, false);
+		seq_printf(s, "\n");
+	}
+	spin_unlock_bh(&dev->mt76.token_lock);
+	return 0;
+}
+
+static int mt7915_amsduinfo_read(struct seq_file *s, void *data)
+{
+	struct mt7915_dev *dev = dev_get_drvdata(s->private);
+	u32 ple_stat[8] = {0}, total_amsdu = 0;
+	u8 i;
+
+	for (i = 0; i < 8; i++)
+		ple_stat[i] = mt76_rr(dev, MT_DBG_PLE_AMSDU_PACK_MSDU_CNT(i));
+
+	seq_printf(s, "TXD counter status of MSDU:\n");
+
+	for (i = 0; i < 8; i++)
+		total_amsdu += ple_stat[i];
+
+	for (i = 0; i < 8; i++) {
+		seq_printf(s, "AMSDU pack count of %d MSDU in TXD: 0x%x ", i + 1, ple_stat[i]);
+		if (total_amsdu != 0)
+			seq_printf(s, "(%d%%)\n", ple_stat[i] * 100 / total_amsdu);
+		else
+			seq_printf(s, "\n");
+	}
+
+	return 0;
+
+}
+
+static int mt7915_agginfo_read_per_band(struct seq_file *s, int band_idx)
+{
+	struct mt7915_dev *dev = dev_get_drvdata(s->private);
+	u32 value, idx, agg_rang_sel[15], ampdu_cnt[11], total_ampdu = 0;
+
+	seq_printf(s, "Band %d AGG Status\n", band_idx);
+	seq_printf(s, "===============================\n");
+	value = mt76_rr(dev, MT_DBG_AGG_AALCR0(band_idx));
+	seq_printf(s, "AC00 Agg limit = %ld\t", FIELD_GET(MT_DBG_AGG_AALCR_ACx0_AGG_LIMIT_MASK, value));
+	seq_printf(s, "AC01 Agg limit = %ld\t", FIELD_GET(MT_DBG_AGG_AALCR_ACx1_AGG_LIMIT_MASK, value));
+	seq_printf(s, "AC02 Agg limit = %ld\t", FIELD_GET(MT_DBG_AGG_AALCR_ACx2_AGG_LIMIT_MASK, value));
+	seq_printf(s, "AC03 Agg limit = %ld\n", FIELD_GET(MT_DBG_AGG_AALCR_ACx3_AGG_LIMIT_MASK, value));
+
+	value = mt76_rr(dev, MT_DBG_AGG_AALCR1(band_idx));
+	seq_printf(s, "AC10 Agg limit = %ld\t", FIELD_GET(MT_DBG_AGG_AALCR_ACx0_AGG_LIMIT_MASK, value));
+	seq_printf(s, "AC11 Agg limit = %ld\t", FIELD_GET(MT_DBG_AGG_AALCR_ACx1_AGG_LIMIT_MASK, value));
+	seq_printf(s, "AC12 Agg limit = %ld\t", FIELD_GET(MT_DBG_AGG_AALCR_ACx2_AGG_LIMIT_MASK, value));
+	seq_printf(s, "AC13 Agg limit = %ld\n", FIELD_GET(MT_DBG_AGG_AALCR_ACx3_AGG_LIMIT_MASK, value));
+
+	value = mt76_rr(dev, MT_DBG_AGG_AALCR2(band_idx));
+	seq_printf(s, "AC20 Agg limit = %ld\t", FIELD_GET(MT_DBG_AGG_AALCR_ACx0_AGG_LIMIT_MASK, value));
+	seq_printf(s, "AC21 Agg limit = %ld\t", FIELD_GET(MT_DBG_AGG_AALCR_ACx1_AGG_LIMIT_MASK, value));
+	seq_printf(s, "AC22 Agg limit = %ld\t", FIELD_GET(MT_DBG_AGG_AALCR_ACx2_AGG_LIMIT_MASK, value));
+	seq_printf(s, "AC23 Agg limit = %ld\n", FIELD_GET(MT_DBG_AGG_AALCR_ACx3_AGG_LIMIT_MASK, value));
+
+	value = mt76_rr(dev, MT_DBG_AGG_AALCR3(band_idx));
+	seq_printf(s, "AC30 Agg limit = %ld\t", FIELD_GET(MT_DBG_AGG_AALCR_ACx0_AGG_LIMIT_MASK, value));
+	seq_printf(s, "AC31 Agg limit = %ld\t", FIELD_GET(MT_DBG_AGG_AALCR_ACx1_AGG_LIMIT_MASK, value));
+	seq_printf(s, "AC32 Agg limit = %ld\t", FIELD_GET(MT_DBG_AGG_AALCR_ACx2_AGG_LIMIT_MASK, value));
+	seq_printf(s, "AC33 Agg limit = %ld\n", FIELD_GET(MT_DBG_AGG_AALCR_ACx3_AGG_LIMIT_MASK, value));
+
+	value = mt76_rr(dev, MT_DBG_AGG_AALCR4(band_idx));
+	seq_printf(s, "ALTX Agg limit = %ld\n", FIELD_GET(MT_DBG_AGG_AALCR4_ALTX0_AGG_LIMIT_MASK, value));
+
+	value = mt76_rr(dev, MT_DBG_AGG_AWSCR(band_idx, 0));
+	seq_printf(s, "Winsize0 limit = %ld\t", FIELD_GET(MT_DBG_AGG_AWSCR0_WINSIZE0_MASK, value));
+	seq_printf(s, "Winsize1 limit = %ld\t", FIELD_GET(MT_DBG_AGG_AWSCR0_WINSIZE1_MASK, value));
+	seq_printf(s, "Winsize2 limit = %ld\t", FIELD_GET(MT_DBG_AGG_AWSCR0_WINSIZE2_MASK, value));
+	seq_printf(s, "Winsize3 limit = %ld\n", FIELD_GET(MT_DBG_AGG_AWSCR0_WINSIZE3_MASK, value));
+
+	value = mt76_rr(dev, MT_DBG_AGG_AWSCR(band_idx, 1));
+	seq_printf(s, "Winsize4 limit = %ld\t", FIELD_GET(MT_DBG_AGG_AWSCR1_WINSIZE4_MASK, value));
+	seq_printf(s, "Winsize5 limit = %ld\t", FIELD_GET(MT_DBG_AGG_AWSCR1_WINSIZE5_MASK, value));
+	seq_printf(s, "Winsize6 limit = %ld\t", FIELD_GET(MT_DBG_AGG_AWSCR1_WINSIZE6_MASK, value));
+	seq_printf(s, "Winsize7 limit = %ld\n", FIELD_GET(MT_DBG_AGG_AWSCR1_WINSIZE7_MASK, value));
+
+	value = mt76_rr(dev, MT_DBG_AGG_AWSCR(band_idx, 2));
+	seq_printf(s, "Winsize8 limit = %ld\t", FIELD_GET(MT_DBG_AGG_AWSCR2_WINSIZE8_MASK, value));
+	seq_printf(s, "Winsize9 limit = %ld\t", FIELD_GET(MT_DBG_AGG_AWSCR2_WINSIZE9_MASK, value));
+	seq_printf(s, "WinsizeA limit = %ld\t", FIELD_GET(MT_DBG_AGG_AWSCR2_WINSIZEA_MASK, value));
+	seq_printf(s, "WinsizeB limit = %ld\n", FIELD_GET(MT_DBG_AGG_AWSCR2_WINSIZEB_MASK, value));
+
+
+	value = mt76_rr(dev, MT_DBG_AGG_AWSCR(band_idx, 3));
+	seq_printf(s, "WinsizeC limit = %ld\t", FIELD_GET(MT_DBG_AGG_AWSCR3_WINSIZEC_MASK, value));
+	seq_printf(s, "WinsizeD limit = %ld\t", FIELD_GET(MT_DBG_AGG_AWSCR3_WINSIZED_MASK, value));
+	seq_printf(s, "WinsizeE limit = %ld\n", FIELD_GET(MT_DBG_AGG_AWSCR3_WINSIZEE_MASK, value));
+
+	seq_printf(s, "===AMPDU Related Counters===\n");
+
+	value = mt76_rr(dev, MT_DBG_MIB_M0ARNG(band_idx, 0));
+	agg_rang_sel[0] = FIELD_GET(MT_DBG_MIB_M0ARNG0_AGG_RANG_SEL0_MASK, value);
+	agg_rang_sel[1] = FIELD_GET(MT_DBG_MIB_M0ARNG0_AGG_RANG_SEL1_MASK, value);
+	agg_rang_sel[2] = FIELD_GET(MT_DBG_MIB_M0ARNG0_AGG_RANG_SEL2_MASK, value);
+	agg_rang_sel[3] = FIELD_GET(MT_DBG_MIB_M0ARNG0_AGG_RANG_SEL3_MASK, value);
+
+	value = mt76_rr(dev, MT_DBG_MIB_M0ARNG(band_idx, 1));
+	agg_rang_sel[4] = FIELD_GET(MT_DBG_MIB_M0ARNG1_AGG_RANG_SEL4_MASK, value);
+	agg_rang_sel[5] = FIELD_GET(MT_DBG_MIB_M0ARNG1_AGG_RANG_SEL5_MASK, value);
+	agg_rang_sel[6] = FIELD_GET(MT_DBG_MIB_M0ARNG1_AGG_RANG_SEL6_MASK, value);
+	agg_rang_sel[7] = FIELD_GET(MT_DBG_MIB_M0ARNG1_AGG_RANG_SEL7_MASK, value);
+
+	value = mt76_rr(dev, MT_DBG_MIB_M0ARNG(band_idx, 2));
+	agg_rang_sel[8] = FIELD_GET(MT_DBG_MIB_M0ARNG2_AGG_RANG_SEL8_MASK, value);
+	agg_rang_sel[9] = FIELD_GET(MT_DBG_MIB_M0ARNG2_AGG_RANG_SEL9_MASK, value);
+	agg_rang_sel[10] = FIELD_GET(MT_DBG_MIB_M0ARNG2_AGG_RANG_SEL10_MASK, value);
+	agg_rang_sel[11] = FIELD_GET(MT_DBG_MIB_M0ARNG2_AGG_RANG_SEL11_MASK, value);
+
+	value = mt76_rr(dev, MT_DBG_MIB_M0ARNG(band_idx, 3));
+	agg_rang_sel[12] = FIELD_GET(MT_DBG_MIB_M0ARNG3_AGG_RANG_SEL12_MASK, value);
+	agg_rang_sel[13] = FIELD_GET(MT_DBG_MIB_M0ARNG3_AGG_RANG_SEL13_MASK, value);
+	agg_rang_sel[14] = FIELD_GET(MT_DBG_MIB_M0ARNG3_AGG_RANG_SEL14_MASK, value);
+
+	/* Need to add 1 after read from AGG_RANG_SEL CR */
+	for (idx = 0; idx < 15; idx++)
+		agg_rang_sel[idx]++;
+
+	ampdu_cnt[3] = mt76_rr(dev, MT_DBG_MIB_M0DR2(band_idx, 0));
+	ampdu_cnt[4] = mt76_rr(dev, MT_DBG_MIB_M0DR2(band_idx, 1));
+	ampdu_cnt[5] = mt76_rr(dev, MT_DBG_MIB_M0DR2(band_idx, 2));
+	ampdu_cnt[6] = mt76_rr(dev, MT_DBG_MIB_M0DR2(band_idx, 3));
+	ampdu_cnt[7] = mt76_rr(dev, MT_DBG_MIB_M0DR13(band_idx, 0));
+	ampdu_cnt[8] = mt76_rr(dev, MT_DBG_MIB_M0DR13(band_idx, 1));
+	ampdu_cnt[9] = mt76_rr(dev, MT_DBG_MIB_M0DR13(band_idx, 2));
+	ampdu_cnt[10] = mt76_rr(dev, MT_DBG_MIB_M0DR13(band_idx, 3));
+
+	seq_printf(s, "\tTx Agg Range: \t%d \t%d~%d \t%d~%d \t%d~%d \t%d~%d \t%d~%d \t%d~%d \t%d~%d\n",
+			 agg_rang_sel[0],
+			 agg_rang_sel[0] + 1, agg_rang_sel[1],
+			 agg_rang_sel[1] + 1, agg_rang_sel[2],
+			 agg_rang_sel[2] + 1, agg_rang_sel[3],
+			 agg_rang_sel[3] + 1, agg_rang_sel[4],
+			 agg_rang_sel[4] + 1, agg_rang_sel[5],
+			 agg_rang_sel[5] + 1, agg_rang_sel[6],
+			 agg_rang_sel[6] + 1, agg_rang_sel[7]);
+
+#define BIT_0_to_15_MASK 0x0000FFFF
+#define BIT_15_to_31_MASK 0xFFFF0000
+#define SHFIT_16_BIT 16
+
+	for (idx = 3; idx < 11; idx++)
+		total_ampdu = total_ampdu + (ampdu_cnt[idx] & BIT_0_to_15_MASK) + ((ampdu_cnt[idx] & BIT_15_to_31_MASK) >> SHFIT_16_BIT);
+
+	seq_printf(s, "\t\t\t0x%lx \t0x%lx \t0x%lx \t0x%lx \t0x%lx \t0x%lx \t0x%lx \t0x%lx\n",
+			 (ampdu_cnt[3]) & MT_DBG_MIB_M0DR2_TRX_AGG_RANGE0_CNT_MASK,
+			 FIELD_GET(MT_DBG_MIB_M0DR2_TRX_AGG_RANGE1_CNT_MASK, ampdu_cnt[3]),
+			 (ampdu_cnt[4]) & MT_DBG_MIB_M0DR3_TRX_AGG_RANGE2_CNT_MASK,
+			 FIELD_GET(MT_DBG_MIB_M0DR3_TRX_AGG_RANGE3_CNT_MASK, ampdu_cnt[4]),
+			 (ampdu_cnt[5]) & MT_DBG_MIB_M0DR4_TRX_AGG_RANGE4_CNT_MASK,
+			 FIELD_GET(MT_DBG_MIB_M0DR4_TRX_AGG_RANGE5_CNT_MASK, ampdu_cnt[5]),
+			 (ampdu_cnt[6]) & MT_DBG_MIB_M0DR5_TRX_AGG_RANGE6_CNT_MASK,
+			 FIELD_GET(MT_DBG_MIB_M0DR5_TRX_AGG_RANGE7_CNT_MASK, ampdu_cnt[6]));
+
+	if (total_ampdu != 0) {
+		seq_printf(s, "\t\t\t(%ld%%) \t(%ld%%) \t(%ld%%) \t(%ld%%) \t(%ld%%) \t(%ld%%) \t(%ld%%) \t(%ld%%)\n",
+				((ampdu_cnt[3]) & MT_DBG_MIB_M0DR2_TRX_AGG_RANGE0_CNT_MASK) * 100 / total_ampdu,
+				FIELD_GET(MT_DBG_MIB_M0DR2_TRX_AGG_RANGE1_CNT_MASK, ampdu_cnt[3]) * 100 / total_ampdu,
+				((ampdu_cnt[4]) & MT_DBG_MIB_M0DR3_TRX_AGG_RANGE2_CNT_MASK) * 100 / total_ampdu,
+				FIELD_GET(MT_DBG_MIB_M0DR3_TRX_AGG_RANGE3_CNT_MASK, ampdu_cnt[4]) * 100 / total_ampdu,
+				((ampdu_cnt[5]) & MT_DBG_MIB_M0DR4_TRX_AGG_RANGE4_CNT_MASK) * 100 / total_ampdu,
+				FIELD_GET(MT_DBG_MIB_M0DR4_TRX_AGG_RANGE5_CNT_MASK, ampdu_cnt[5]) * 100 / total_ampdu,
+				((ampdu_cnt[6]) & MT_DBG_MIB_M0DR5_TRX_AGG_RANGE6_CNT_MASK) * 100 / total_ampdu,
+				 FIELD_GET(MT_DBG_MIB_M0DR5_TRX_AGG_RANGE7_CNT_MASK, ampdu_cnt[6]) * 100 / total_ampdu);
+		}
+
+		seq_printf(s, "\t\t\t%d~%d\t%d~%d\t%d~%d\t%d~%d\t%d~%d\t%d~%d\t%d~%d\t%d~256\n",
+			 agg_rang_sel[7] + 1, agg_rang_sel[8],
+			 agg_rang_sel[8] + 1, agg_rang_sel[9],
+			 agg_rang_sel[9] + 1, agg_rang_sel[10],
+			 agg_rang_sel[10] + 1, agg_rang_sel[11],
+			 agg_rang_sel[11] + 1, agg_rang_sel[12],
+			 agg_rang_sel[12] + 1, agg_rang_sel[13],
+			 agg_rang_sel[13] + 1, agg_rang_sel[14],
+			 agg_rang_sel[14] + 1);
+
+		seq_printf(s, "\t\t\t0x%lx \t0x%lx \t0x%lx \t0x%lx \t0x%lx \t0x%lx \t0x%lx \t0x%lx\n",
+			(ampdu_cnt[7]) & MT_DBG_MIB_M0DR13_TRX_AGG_RANGE8_CNT_MASK,
+			FIELD_GET(MT_DBG_MIB_M0DR13_TRX_AGG_RANGE9_CNT_MASK, ampdu_cnt[7]),
+			(ampdu_cnt[8]) & MT_DBG_MIB_M0DR14_TRX_AGG_RANGE10_CNT_MASK,
+			FIELD_GET(MT_DBG_MIB_M0DR14_TRX_AGG_RANGE11_CNT_MASK, ampdu_cnt[8]),
+			(ampdu_cnt[9]) & MT_DBG_MIB_M0DR15_TRX_AGG_RANGE12_CNT_MASK,
+			FIELD_GET(MT_DBG_MIB_M0DR15_TRX_AGG_RANGE13_CNT_MASK, ampdu_cnt[9]),
+			(ampdu_cnt[10]) & MT_DBG_MIB_M0DR16_TRX_AGG_RANGE14_CNT_MASK,
+			FIELD_GET(MT_DBG_MIB_M0DR16_TRX_AGG_RANGE15_CNT_MASK, ampdu_cnt[10]));
+
+	if (total_ampdu != 0) {
+		seq_printf(s, "\t\t\t(%ld%%) \t(%ld%%) \t(%ld%%) \t(%ld%%) \t(%ld%%) \t(%ld%%) \t(%ld%%) \t(%ld%%)\n",
+		       ((ampdu_cnt[7]) & MT_DBG_MIB_M0DR2_TRX_AGG_RANGE0_CNT_MASK) * 100 / total_ampdu,
+			FIELD_GET(MT_DBG_MIB_M0DR2_TRX_AGG_RANGE1_CNT_MASK, ampdu_cnt[7]) * 100 / total_ampdu,
+			((ampdu_cnt[8]) & MT_DBG_MIB_M0DR3_TRX_AGG_RANGE2_CNT_MASK) * 100 / total_ampdu,
+			FIELD_GET(MT_DBG_MIB_M0DR3_TRX_AGG_RANGE3_CNT_MASK, ampdu_cnt[8]) * 100 / total_ampdu,
+			((ampdu_cnt[9]) & MT_DBG_MIB_M0DR4_TRX_AGG_RANGE4_CNT_MASK) * 100 / total_ampdu,
+			FIELD_GET(MT_DBG_MIB_M0DR4_TRX_AGG_RANGE5_CNT_MASK, ampdu_cnt[9]) * 100 / total_ampdu,
+			((ampdu_cnt[10]) & MT_DBG_MIB_M0DR5_TRX_AGG_RANGE6_CNT_MASK) * 100 / total_ampdu,
+			FIELD_GET(MT_DBG_MIB_M0DR5_TRX_AGG_RANGE7_CNT_MASK, ampdu_cnt[10]) * 100 / total_ampdu);
+	}
+
+	return 0;
+}
+
+static int mt7915_agginfo_read_band0(struct seq_file *s, void *data)
+{
+	mt7915_agginfo_read_per_band(s, 0);
+	return 0;
+}
+
+static int mt7915_agginfo_read_band1(struct seq_file *s, void *data)
+{
+	mt7915_agginfo_read_per_band(s, 1);
+	return 0;
+}
+
+/*usage: <en> <num> <len>
+	en: BIT(16) 0: sw amsdu  1: hw amsdu
+	num: GENMASK(15, 8) range 1-8
+	len: GENMASK(7, 0) unit: 256 bytes */
+static int mt7915_sta_tx_amsdu_set(void *data, u64 tx_amsdu)
+{
+/* UWTBL DW 6 */
+#define WTBL_AMSDU_LEN_MASK              GENMASK(5, 0)
+#define WTBL_AMSDU_NUM_MASK              GENMASK(8, 6)
+#define WTBL_AMSDU_EN_MASK               BIT(9)
+#define UWTBL_HW_AMSDU_DW                 6
+
+	struct mt7915_dev *dev = data;
+	u32 len = FIELD_GET(GENMASK(7, 0), tx_amsdu);
+	u32 num = FIELD_GET(GENMASK(15, 8), tx_amsdu);
+	u32 uwtbl;
+
+	mt7915_mcu_set_amsdu_algo(dev, dev->wlan_idx, 0);
+
+	mt7915_wtbl_read_raw(dev, dev->wlan_idx, WTBL_TYPE_UMAC,
+			UWTBL_HW_AMSDU_DW, 1, &uwtbl);
+
+	if (len) {
+		uwtbl &= ~WTBL_AMSDU_LEN_MASK;
+		uwtbl |= FIELD_PREP(WTBL_AMSDU_LEN_MASK, len);
+	}
+
+	uwtbl &= ~WTBL_AMSDU_NUM_MASK;
+	uwtbl |= FIELD_PREP(WTBL_AMSDU_NUM_MASK, num);
+
+	if (tx_amsdu & BIT(16))
+		uwtbl |= WTBL_AMSDU_EN_MASK;
+
+	mt7915_wtbl_write_raw(dev, dev->wlan_idx, WTBL_TYPE_UMAC,
+			UWTBL_HW_AMSDU_DW, uwtbl);
+
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_tx_amsdu, NULL,
+			 mt7915_sta_tx_amsdu_set, "%llx\n");
+
+static int mt7915_red_enable_set(void *data, u64 en)
+{
+	struct mt7915_dev *dev = data;
+
+	return mt7915_mcu_set_red(dev, en);
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_red_en, NULL,
+			 mt7915_red_enable_set, "%llx\n");
+
+static int mt7915_red_show_sta_set(void *data, u64 wlan_idx)
+{
+	struct mt7915_dev *dev = data;
+
+	mt7915_dbg_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(SET),
+			  MCU_WA_PARAM_RED_SHOW_STA,
+			  wlan_idx, 0, true);
+
+	return 0;
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_red_show_sta, NULL,
+			 mt7915_red_show_sta_set, "%llx\n");
+
+static int mt7915_red_target_dly_set(void *data, u64 delay)
+{
+	struct mt7915_dev *dev = data;
+
+	if (delay > 0 && delay <= 32767)
+		mt7915_dbg_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(SET),
+				  MCU_WA_PARAM_RED_TARGET_DELAY,
+				  delay, 0, true);
+
+	return 0;
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_red_target_dly, NULL,
+			 mt7915_red_target_dly_set, "%llx\n");
+
+static int
+mt7915_txpower_level_set(void *data, u64 val)
+{
+	struct mt7915_dev *dev = data;
+	struct mt7915_phy *ext_phy = mt7915_ext_phy(dev);
+	mt7915_mcu_set_txpower_level(&dev->phy, val);
+	if (ext_phy)
+		mt7915_mcu_set_txpower_level(ext_phy, val);
+
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_txpower_level, NULL,
+			 mt7915_txpower_level_set, "%lld\n");
+
+/* usage: echo 0x[arg3][arg2][arg1] > fw_wa_set */
+static int
+mt7915_wa_set(void *data, u64 val)
+{
+	struct mt7915_dev *dev = data;
+	u32 arg1, arg2, arg3;
+
+	arg1 = FIELD_GET(GENMASK_ULL(7, 0), val);
+	arg2 = FIELD_GET(GENMASK_ULL(15, 8), val);
+	arg3 = FIELD_GET(GENMASK_ULL(23, 16), val);
+
+	mt7915_dbg_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(SET), arg1, arg2, arg3, false);
+
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_wa_set, NULL, mt7915_wa_set,
+			 "0x%llx\n");
+/* usage: echo 0x[arg3][arg2][arg1] > fw_wa_query */
+static int
+mt7915_wa_query(void *data, u64 val)
+{
+	struct mt7915_dev *dev = data;
+	u32 arg1, arg2, arg3;
+
+	arg1 = FIELD_GET(GENMASK_ULL(7, 0), val);
+	arg2 = FIELD_GET(GENMASK_ULL(15, 8), val);
+	arg3 = FIELD_GET(GENMASK_ULL(23, 16), val);
+
+	mt7915_dbg_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(QUERY), arg1, arg2, arg3, false);
+
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_wa_query, NULL, mt7915_wa_query,
+					 "0x%llx\n");
+/* set wa debug level
+     usage:
+	echo 0x[arg] > fw_wa_debug
+	bit0 : DEBUG_WIFI_TX
+	bit1 : DEBUG_CMD_EVENT
+	bit2 : DEBUG_RED
+	bit3 : DEBUG_WARN
+	bit4 : DEBUG_WIFI_RX
+	bit5 : DEBUG_TIME_STAMP
+	bit6 : DEBUG_TX_FREE_DONE_EVENT
+	bit12 : DEBUG_WIFI_TXD */
+static int
+mt7915_wa_debug(void *data, u64 val)
+{
+	struct mt7915_dev *dev = data;
+	u32 arg;
+
+	arg = FIELD_GET(GENMASK_ULL(15, 0), val);
+
+	mt7915_dbg_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(DEBUG), arg, 0, 0, false);
+
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_wa_debug, NULL, mt7915_wa_debug,
+			 "0x%llx\n");
+
+static int mt7915_dump_version(struct seq_file *s, void *data)
+{
+	struct mt7915_dev *dev = dev_get_drvdata(s->private);
+	struct mt76_dev *mdev = NULL;
+	int i;
+
+	seq_printf(s, "Version: 2.2.24.7\n");
+
+	if (!test_bit(MT76_STATE_MCU_RUNNING, &dev->mphy.state))
+		return 0;
+
+	mdev = &dev->mt76;
+	seq_printf(s, "Rom Patch Build Time: %.16s\n", mdev->patch_hdr->build_date);
+	seq_printf(s, "WM Patch Build Time: %.16s\n", mdev->wm_hdr->build_date);
+	seq_printf(s, "WA Patch Build Time: %.16s\n", mdev->wa_hdr->build_date);
+
+	for (i = 0; i < ADIE_MAX_CNT; i++) {
+		seq_printf(s, "adie[%d]: id=0x%04x version=0x%04x\n",
+			   i, dev->adie[i].id, dev->adie[i].version);
+	}
+	return 0;
+}
+
+static void mt7915_show_lp_history(struct seq_file *s, bool fgIsExp)
+{
+	struct mt7915_dev *dev = dev_get_drvdata(s->private);
+	u32 macVal, gpr_log_idx, oldest_idx;
+	u32 idx, i;
+
+	if (!fgIsExp) {
+		/* disable LP recored */
+		macVal = mt76_rr(dev, 0x89050200);
+		macVal &= (~0x1);
+		mt76_wr(dev, 0x89050200, macVal);
+		udelay(100);
+	}
+
+	macVal = mt76_rr(dev, 0x89050200);
+	gpr_log_idx = ((macVal >> 16) & 0x1f);
+	oldest_idx = gpr_log_idx + 2;
+
+	seq_printf(s, "       lp history (from old to new):\n");
+	for (i = 0; i < 16; i++) {
+		idx = ((oldest_idx + 2*i + 1)%32);
+		macVal = mt76_rr(dev, (0x89050204 + idx*4));
+		seq_printf(s, "       %d: 0x%x\n", i, macVal);
+	}
+
+	if (!fgIsExp) {
+		/* enable LP recored */
+		macVal = mt76_rr(dev, 0x89050200);
+		macVal |= 0x1;
+		mt76_wr(dev, 0x89050200, macVal);
+	}
+}
+
+static void mt7915_show_irq_history(struct seq_file *s)
+{
+#define SYSIRQ_INTERRUPT_HISTORY_NUM	10
+	struct mt7915_dev *dev = dev_get_drvdata(s->private);
+	u32 macVal, i, start, idx;
+	u8 ucIrqDisIdx, ucIrqResIdx;
+	u32 irq_dis_time[SYSIRQ_INTERRUPT_HISTORY_NUM], irq_dis_lp[SYSIRQ_INTERRUPT_HISTORY_NUM];
+	u32 irq_res_time[SYSIRQ_INTERRUPT_HISTORY_NUM], irq_res_lp[SYSIRQ_INTERRUPT_HISTORY_NUM];
+	u32 irq_idx_addr, irq_dis_addr, irq_res_addr;
+
+	switch (mt76_chip(&dev->mt76)) {
+	case 0x7915:
+		irq_idx_addr = 0x2170BC;
+		irq_dis_addr = 0x2170B8;
+		irq_res_addr = 0x2170B4;
+		break;
+	case 0x7981:
+		irq_idx_addr = 0x02205138;
+		irq_dis_addr = 0x02205140;
+		irq_res_addr = 0x0220513C;
+		break;
+	case 0x7906:
+		irq_idx_addr = 0x02205288;
+		irq_dis_addr = 0x02205290;
+		irq_res_addr = 0x0220528C;
+		break;
+	case 0x7986:
+	default:
+		irq_idx_addr = 0x022051C0;
+		irq_dis_addr = 0x022051C8;
+		irq_res_addr = 0x022051C4;
+		break;
+	}
+
+	macVal = mt76_rr(dev, irq_idx_addr);
+	ucIrqResIdx = (macVal & 0xff);
+	ucIrqDisIdx = ((macVal >> 8) & 0xff);
+
+	seq_printf(s, "\n\n\n       Irq Idx (Dis=%d Res=%d):\n",
+		   ucIrqDisIdx, ucIrqResIdx);
+
+	start = mt76_rr(dev, irq_dis_addr);
+	for (i = 0; i < SYSIRQ_INTERRUPT_HISTORY_NUM; i++) {
+		macVal = mt76_rr(dev, (start + (i * 8)));
+		irq_dis_time[i] = macVal;
+		macVal = mt76_rr(dev, (start + (i * 8) + 4));
+		irq_dis_lp[i] = macVal;
+	}
+
+	start = mt76_rr(dev, irq_res_addr);
+	for (i = 0; i < SYSIRQ_INTERRUPT_HISTORY_NUM; i++) {
+		macVal = mt76_rr(dev, (start + (i * 8)));
+		irq_res_time[i] = macVal;
+		macVal = mt76_rr(dev, (start + (i * 8) + 4));
+		irq_res_lp[i] = macVal;
+	}
+
+	seq_printf(s, "\n       Dis Irq history (from old to new):\n");
+	for (i = 0; i < SYSIRQ_INTERRUPT_HISTORY_NUM; i++) {
+		idx = (i + ucIrqDisIdx) % SYSIRQ_INTERRUPT_HISTORY_NUM;
+		seq_printf(s, "      [%d].LP = 0x%x   time=%u\n",
+			idx, irq_dis_lp[idx], irq_dis_time[idx]);
+	}
+
+	seq_printf(s, "\n       Restore Irq history (from old to new):\n");
+	for (i = 0; i < SYSIRQ_INTERRUPT_HISTORY_NUM; i++) {
+		idx = (i + ucIrqResIdx) % SYSIRQ_INTERRUPT_HISTORY_NUM;
+		seq_printf(s, "      [%d].LP = 0x%x   time=%u\n",
+			idx, irq_res_lp[idx], irq_res_time[idx]);
+	}
+}
+
+static void MemSectionRead(struct mt7915_dev *dev, char *buf, u32 length, u32 addr)
+{
+	int idx = 0;
+	u32 *ptr =(u32 *)buf;
+
+	while (idx < length) {
+		*ptr = mt76_rr(dev, (addr + idx));
+		idx += 4;
+		ptr++;
+	}
+}
+
+static int MemReadOneByte(struct mt7915_dev *dev, u32 addr)
+{
+	u32 val, tmpval;
+
+	val = mt76_rr(dev, (addr & ~(0x3)));
+	tmpval = (val >> (8 * (addr & (0x3)))) & 0xff;
+	return tmpval;
+}
+
+static void mt7915_show_msg_trace(struct seq_file *s)
+{
+	struct mt7915_dev *dev = dev_get_drvdata(s->private);
+	struct cos_msg_trace_t *msg_trace = NULL;
+	u32 ptr_addr, length;
+	u32 idx = 0, cnt = 0;
+	u32 msg_history_num, num_addr;
+	u32 trace_ptr_addr, trace_num_addr;
+
+	switch (mt76_chip(&dev->mt76)) {
+	case 0x7915:
+		trace_ptr_addr = 0x41F054;
+		trace_num_addr = 0x41F058;
+		num_addr = mt76_rr(dev, 0x41F05C);
+		break;
+	case 0x7981:
+		trace_ptr_addr = 0x02205100;
+		trace_num_addr = 0x02205104;
+		break;
+	case 0x7906:
+		trace_ptr_addr = 0x02205250;
+		trace_num_addr = 0x02205254;
+		break;
+	case 0x7986:
+	default:
+		trace_ptr_addr = 0x02205188;
+		trace_num_addr = 0x0220518C;
+		break;
+	}
+
+
+
+	ptr_addr = mt76_rr(dev, trace_ptr_addr);
+	msg_history_num = mt76_rr(dev, trace_num_addr);
+	idx = (is_mt7915(&dev->mt76) ? MemReadOneByte(dev, num_addr) : (msg_history_num >> 8)) & 0xff;
+	msg_history_num = msg_history_num & 0xff;
+	msg_trace = kzalloc(msg_history_num * sizeof(struct cos_msg_trace_t), GFP_KERNEL);
+
+	if (!msg_trace) {
+		seq_printf(s, "can not allocate cmd msg_trace\n");
+		return;
+	}
+
+	if (idx >= msg_history_num) {
+		kfree(msg_trace);
+		return;
+	}
+
+	length = msg_history_num * sizeof(struct cos_msg_trace_t);
+	MemSectionRead(dev, (char *)&(msg_trace[0]), length, ptr_addr);
+	seq_printf(s, "\n");
+	seq_printf(s, "       msg trace:\n");
+	seq_printf(s, "       format: t_id=task_id/task_prempt_cnt/msg_read_idx\n");
+
+	while (1) {
+		seq_printf(s, "       (m_%d)t_id=%x/%d/%d, m_id=%d, ts_en=%u, ts_de = %u, ts_fin=%u, wait=%d, exe=%d\n",
+			idx,
+			msg_trace[idx].dest_id,
+			msg_trace[idx].pcount,
+			msg_trace[idx].qread,
+			msg_trace[idx].msg_id,
+			msg_trace[idx].ts_enq,
+			msg_trace[idx].ts_deq,
+			msg_trace[idx].ts_finshq,
+			(msg_trace[idx].ts_deq - msg_trace[idx].ts_enq),
+			(msg_trace[idx].ts_finshq - msg_trace[idx].ts_deq));
+
+		if (++idx >= msg_history_num)
+			idx = 0;
+
+		if (++cnt >= msg_history_num)
+			break;
+	}
+	if (msg_trace)
+		kfree(msg_trace);
+}
+
+static int mt7915_show_assert_line(struct seq_file *s)
+{
+	struct mt7915_dev *dev = dev_get_drvdata(s->private);
+	char *msg;
+	u32 addr;
+	u32 macVal = 0;
+	char *ptr;
+	char idx;
+
+	msg = kmalloc(256, GFP_KERNEL);
+	if (!msg)
+		return 0;
+
+	memset(msg, 0, 256);
+	addr = 0x00400000;
+	ptr = msg;
+	for (idx = 0 ; idx < 32; idx++) {
+		macVal = 0;
+		macVal = mt76_rr(dev, addr);
+		memcpy(ptr, &macVal, 4);
+		addr += 4;
+		ptr += 4;
+	}
+
+	*ptr = 0;
+	seq_printf(s, "\n\n");
+	seq_printf(s, "       Assert line\n");
+	seq_printf(s, "       %s\n", msg);
+	if (msg)
+		kfree(msg);
+
+	return 0;
+}
+
+
+static void mt7915_show_sech_trace(struct seq_file *s)
+{
+	struct mt7915_dev *dev = dev_get_drvdata(s->private);
+	struct cos_task_info_struct  task_info_g[2];
+	u32 length, idx;
+	u32 addr, km_total_time;
+	u32 task_info_addr, km_total_time_addr;
+	struct cos_task_type tcb;
+	struct cos_task_type *tcb_ptr;
+	char   name[2][15] = {
+		"WIFI	", "WIFI2   "
+	};
+
+	switch (mt76_chip(&dev->mt76)) {
+	case 0x7915:
+		task_info_addr = 0x215400;
+		km_total_time_addr = 0x219838;
+		break;
+	case 0x7981:
+		task_info_addr = 0x02202978;
+		km_total_time_addr = 0x0220512C;
+		break;
+	case 0x7906:
+		task_info_addr = 0x02202ACC;
+		km_total_time_addr = 0x0220527C;
+		break;
+	case 0x7986:
+	default:
+		task_info_addr = 0x02202A18;
+		km_total_time_addr = 0x022051B4;
+		break;
+	}
+
+	length = 2 * sizeof(struct cos_task_info_struct);
+	MemSectionRead(dev, (char *)&(task_info_g[0]), length, task_info_addr);
+
+	km_total_time = mt76_rr(dev, km_total_time_addr);
+	if (km_total_time == 0) {
+		seq_printf(s, "km_total_time zero!\n");
+		return;
+	}
+
+	seq_printf(s, "\n\n\n	  TASK	 XTIME	  RATIO    PREMPT CNT\n");
+	for (idx = 0 ;	idx < 2 ; idx++) {
+		addr = task_info_g[idx].task_id;
+		MemSectionRead(dev, (char *)&(tcb), sizeof(struct cos_task_type), addr);
+
+		length = sizeof(struct cos_task_type);
+
+		tcb_ptr = &(tcb);
+
+		if (tcb_ptr) {
+			seq_printf(s, "	   %s	 %d    %d	%d\n",
+				name[idx],
+				tcb_ptr->tc_exe_time,
+				(tcb_ptr->tc_exe_time*100/km_total_time),
+				tcb_ptr->tc_pcount);
+		}
+	}
+
+}
+
+static void mt7915_show_prog_trace(struct seq_file *s)
+{
+#define mt7915_cos_access_ptr(_idx, _member)	(is_mt7915(&dev->mt76) ? \
+						mt7915_cos_program_trace_ptr[_idx]._##_member : \
+						cos_program_trace_ptr[_idx]._##_member)
+	struct mt7915_dev *dev = dev_get_drvdata(s->private);
+	struct cos_program_trace_t *cos_program_trace_ptr = NULL;
+	struct mt7915_cos_program_trace_t *mt7915_cos_program_trace_ptr = NULL;
+	char *buf;
+	u32 trace_ptr;
+	u32 idx;
+	u32 old_idx;
+	u32 old_idx_addr;
+	u32 prev_idx, diff;
+	u32 prev_time, prev_dest_id, prev_msg_sn;
+	u32 old_time, old_dest_id, old_msg_sn;
+	u32 trace_ptr_addr, trace_idx_addr, trace_num_addr, trace_num;
+	int size;
+
+	switch (mt76_chip(&dev->mt76)) {
+	case 0x7915:
+		trace_ptr_addr = 0x41F0E0;
+		trace_idx_addr = 0x41F0E8;
+		trace_num_addr = mt76_rr(dev, 0x41F0E4);
+		break;
+	case 0x7981:
+		trace_ptr_addr = 0x022050C4;
+		trace_idx_addr = 0x022050C0;
+		break;
+	case 0x7906:
+		trace_ptr_addr = 0x02205214;
+		trace_idx_addr = 0x02205210;
+		break;
+	case 0x7986:
+	default:
+		trace_ptr_addr = 0x0220514C;
+		trace_idx_addr = 0x02205148;
+		break;
+	}
+
+	size = is_mt7915(&dev->mt76) ? sizeof(struct mt7915_cos_program_trace_t) : sizeof(struct cos_program_trace_t);
+	trace_num = is_mt7915(&dev->mt76) ? MemReadOneByte(dev, trace_num_addr) & 0xff : 32;
+	buf = kzalloc(trace_num * size, GFP_KERNEL);
+	if (!buf) {
+		seq_printf(s, "can not allocate cos_program_trace_ptr memory\n");
+		return;
+	}
+
+	trace_ptr = mt76_rr(dev, trace_ptr_addr);
+	old_idx_addr = mt76_rr(dev, trace_idx_addr);
+	old_idx = (is_mt7915(&dev->mt76) ? MemReadOneByte(dev, old_idx_addr) : (old_idx_addr >> 8)) & 0xff;
+
+	MemSectionRead(dev, &buf[0], trace_num * size, trace_ptr);
+
+	if (is_mt7915(&dev->mt76))
+		mt7915_cos_program_trace_ptr = (struct mt7915_cos_program_trace_t *)buf;
+	else
+		cos_program_trace_ptr = (struct cos_program_trace_t *)buf;
+
+	seq_printf(s, "\n");
+	seq_printf(s, "       program trace:\n");
+	for (idx = 0 ; idx < trace_num ; idx++) {
+		prev_idx = ((old_idx + trace_num - 1) % trace_num);
+
+		prev_time = mt7915_cos_access_ptr(prev_idx, ts_gpt2);
+		old_time = mt7915_cos_access_ptr(old_idx, ts_gpt2);
+		prev_dest_id = mt7915_cos_access_ptr(prev_idx, dest_id);
+		old_dest_id = mt7915_cos_access_ptr(old_idx, dest_id);
+		prev_msg_sn = mt7915_cos_access_ptr(prev_idx, msg_sn);
+		old_msg_sn = mt7915_cos_access_ptr(old_idx, msg_sn);
+
+		seq_printf(s, "       (p_%d)t_id=%x/%d, m_id=%d, LP=0x%x, name=%s, ts2=%d, ",
+			old_idx,
+			old_dest_id,
+			old_msg_sn,
+			mt7915_cos_access_ptr(old_idx, msg_id),
+			mt7915_cos_access_ptr(old_idx, LP),
+			mt7915_cos_access_ptr(old_idx, name),
+			old_time);
+
+		/* diff for gpt2 */
+
+		diff = 0xFFFFFFFF;
+
+		if (prev_time) {
+			if ((prev_dest_id == old_dest_id) && (prev_msg_sn == old_msg_sn)) {
+				if (old_time > prev_time)
+					diff = old_time - prev_time;
+				else
+					diff = 0xFFFFFFFF - prev_time + old_time + 1;
+			}
+		}
+
+		if (diff == 0xFFFFFFFF)
+			seq_printf(s, "diff2=NA, \n");
+		else
+			seq_printf(s, "diff2=%8d\n", diff);
+
+		old_idx++;
+		if (old_idx >= trace_num)
+			old_idx = 0;
+	}
+	if (buf)
+		kfree(buf);
+}
+
+static int mt7915_fw_wm_info_read(struct seq_file *s, void *data)
+{
+	struct mt7915_dev *dev = dev_get_drvdata(s->private);
+	u32 macVal, g_exp_type, COS_Interrupt_Count;
+	u8 exp_assert_proc_entry_cnt, exp_assert_state, g_irq_history_num;
+	u16 processing_irqx;
+	u32 processing_lisr, Current_Task_Id, Current_Task_Indx;
+	u8 km_irq_info_idx, km_eint_info_idx, km_sched_info_idx, g_sched_history_num;
+	u32 km_sched_trace_ptr, km_irq_trace_ptr, km_total_time;
+	bool fgIsExp = false, fgIsAssert = false;
+	u32 TaskStart[2], TaskEnd[2];
+	u32 exp_assert_state_addr, g1_exp_counter_addr;
+	u32 g_exp_type_addr, cos_interrupt_count_addr;
+	u32 processing_irqx_addr, processing_lisr_addr;
+	u32 Current_Task_Id_addr, Current_Task_Indx_addr, last_dequeued_msg_id_addr;
+	u32 km_irq_info_idx_addr, km_eint_info_idx_addr, km_sched_info_idx_addr;
+	u32 g_sched_history_num_addr, km_sched_trace_ptr_addr;
+	u32 km_irq_trace_ptr_addr, km_total_time_addr, last_dequeued_msg_id;
+	u32 TaskStart_0, TaskEnd_0, TaskStart_1, TaskEnd_1;
+	u32 t1_base_addr, t2_base_addr, t3_base_addr, t_addr_ofs;
+	u32 cpu_itype_addr, cpu_eva_addr, cpu_ipc_addr, pc_addr;
+	u32 busy_addr, peak_addr;
+	u32 i, t1, t2, t3;
+	u8 idx, exp_type[64];
+
+	switch (mt76_chip(&dev->mt76)) {
+	case 0x7915:
+		g_exp_type_addr = 0x21987C;
+		exp_assert_state_addr = 0x219848;
+		g1_exp_counter_addr = 0x219848;
+		cos_interrupt_count_addr = 0x216F94;
+		processing_irqx_addr = 0x216EF8;
+		processing_lisr_addr = 0x2170AC;
+		Current_Task_Id_addr = 0x216F90;
+		Current_Task_Indx_addr = 0x216F9C;
+		last_dequeued_msg_id_addr = 0x216F70;
+		km_irq_info_idx_addr = 0x219820;
+		km_eint_info_idx_addr = 0x219818;
+		km_sched_info_idx_addr = 0x219828;
+		g_sched_history_num_addr = 0x219828;
+		km_sched_trace_ptr_addr = 0x219824;
+		km_irq_trace_ptr_addr = 0x21981C;
+		km_total_time_addr = 0x219838;
+		TaskStart_0 = 0x2195A0;
+		TaskEnd_0 = 0x21959C;
+		TaskStart_1 = 0x219680;
+		TaskEnd_1 = 0x21967C;
+		t1_base_addr = 0x219558;
+		t2_base_addr = 0x219554;
+		t3_base_addr = 0x219560;
+		cpu_itype_addr = 0x41F088;
+		cpu_eva_addr = 0x41F08C;
+		cpu_ipc_addr = 0x41F094;
+		pc_addr = 0x7C060204;
+		busy_addr = 0x41F030;
+		peak_addr = 0x41F034;
+		break;
+	case 0x7981:
+		g_exp_type_addr = 0x02205054;
+		exp_assert_state_addr = 0x02204AC0;
+		g1_exp_counter_addr = 0x02204F68;
+		cos_interrupt_count_addr = 0x02204FFC;
+		processing_irqx_addr = 0x02204E30;
+		processing_lisr_addr = 0x02204F7C;
+		Current_Task_Id_addr = 0x02204F18;
+		Current_Task_Indx_addr = 0x02204F18;
+		last_dequeued_msg_id_addr = 0x02204E94;
+		km_irq_info_idx_addr = 0x02205114;
+		km_eint_info_idx_addr = 0x0220510C;
+		km_sched_info_idx_addr = 0x0220511C;
+		g_sched_history_num_addr = 0x0220511C;
+		km_sched_trace_ptr_addr = 0x02205118;
+		km_irq_trace_ptr_addr = 0x02205110;
+		km_total_time_addr = 0x0220512C;
+		TaskStart_0 = 0x022028B4;
+		TaskEnd_0 = 0x022028C0;
+		TaskStart_1 = 0x02202A38;
+		TaskEnd_1 = 0x02202934;
+		t1_base_addr = 0x02202718;
+		t2_base_addr = 0x0220287C;
+		t3_base_addr = 0x02202884;
+		cpu_itype_addr = 0x02205058;
+		cpu_eva_addr = 0x02205060;
+		cpu_ipc_addr = 0x0220505C;
+		pc_addr = 0x7C060204;
+		busy_addr = 0x7C053B20;
+		peak_addr = 0x7C053B24;
+		break;
+	case 0x7906:
+		g_exp_type_addr = 0x022051A4;
+		exp_assert_state_addr = 0x02204C14;
+		g1_exp_counter_addr = 0x022050BC;
+		cos_interrupt_count_addr = 0x022001AC;
+		processing_irqx_addr = 0x02204F84;
+		processing_lisr_addr = 0x022050D0;
+		Current_Task_Id_addr = 0x0220406C;
+		Current_Task_Indx_addr = 0x0220500C;
+		last_dequeued_msg_id_addr = 0x02204FE8;
+		km_irq_info_idx_addr = 0x02205264;
+		km_eint_info_idx_addr = 0x0220525C;
+		km_sched_info_idx_addr = 0x0220526C;
+		g_sched_history_num_addr = 0x0220516C;
+		km_sched_trace_ptr_addr = 0x02205268;
+		km_irq_trace_ptr_addr = 0x02205260;
+		km_total_time_addr = 0x0220517C;
+		TaskStart_0 = 0x022028C8;
+		TaskEnd_0 = 0x022028C4;
+		TaskStart_1 = 0x02202A38;
+		TaskEnd_1 = 0x02202934;
+		t1_base_addr = 0x0220286C;
+		t2_base_addr = 0x02202870;
+		t3_base_addr = 0x02202878;
+		cpu_itype_addr = 0x022051A8;
+		cpu_eva_addr = 0x022051B0;
+		cpu_ipc_addr = 0x022051AC;
+		pc_addr = 0x7C060204;
+		busy_addr = 0x7C053B20;
+		peak_addr = 0x7C053B24;
+		break;
+	case 0x7986:
+	default:
+		g_exp_type_addr = 0x022050DC;
+		exp_assert_state_addr = 0x02204B54;
+		g1_exp_counter_addr = 0x02204FFC;
+		cos_interrupt_count_addr = 0x022001AC;
+		processing_irqx_addr = 0x02204EC4;
+		processing_lisr_addr = 0x02205010;
+		Current_Task_Id_addr = 0x02204FAC;
+		Current_Task_Indx_addr = 0x02204F4C;
+		last_dequeued_msg_id_addr = 0x02204F28;
+		km_irq_info_idx_addr = 0x0220519C;
+		km_eint_info_idx_addr = 0x02205194;
+		km_sched_info_idx_addr = 0x022051A4;
+		g_sched_history_num_addr = 0x022051A4;
+		km_sched_trace_ptr_addr = 0x022051A0;
+		km_irq_trace_ptr_addr = 0x02205198;
+		km_total_time_addr = 0x022051B4;
+		TaskStart_0 = 0x02202814;
+		TaskEnd_0 = 0x02202810;
+		TaskStart_1 = 0x02202984;
+		TaskEnd_1 = 0x02202980;
+		t1_base_addr = 0x022027B8;
+		t2_base_addr = 0x022027BC;
+		t3_base_addr = 0x022027C4;
+		cpu_itype_addr = 0x022050E0;
+		cpu_eva_addr = 0x022050E8;
+		cpu_ipc_addr = 0x022050E4;
+		pc_addr = 0x7C060204;
+		busy_addr = 0x7C053B20;
+		peak_addr = 0x7C053B24;
+		break;
+	}
+
+	macVal = mt76_rr(dev, exp_assert_state_addr);
+	exp_assert_state = (macVal & 0xff);
+
+	macVal = mt76_rr(dev, g1_exp_counter_addr);
+	exp_assert_proc_entry_cnt = (is_mt7915(&dev->mt76) ? (macVal >> 8) : macVal) & 0xff;
+
+	macVal = mt76_rr(dev, g_exp_type_addr);
+	g_exp_type = is_mt7915(&dev->mt76) ? ((macVal >> 8) & 0xff) : macVal;
+
+	COS_Interrupt_Count = mt76_rr(dev, cos_interrupt_count_addr);
+
+	macVal = mt76_rr(dev, processing_irqx_addr);
+	processing_irqx = (is_mt7915(&dev->mt76) ? (macVal >> 16) : macVal) & 0xffff;
+
+	processing_lisr = mt76_rr(dev, processing_lisr_addr);
+	Current_Task_Id = mt76_rr(dev, Current_Task_Id_addr);
+	Current_Task_Indx = mt76_rr(dev, Current_Task_Indx_addr);
+	last_dequeued_msg_id = mt76_rr(dev, last_dequeued_msg_id_addr);
+
+	macVal = mt76_rr(dev, km_eint_info_idx_addr);
+	km_eint_info_idx = (is_mt7915(&dev->mt76) ? macVal : (macVal >> 8)) & 0xff;
+
+	macVal = mt76_rr(dev, g_sched_history_num_addr);
+	g_sched_history_num = (is_mt7915(&dev->mt76) ? (macVal >> 8) : macVal) & 0xff;
+	km_sched_info_idx = (is_mt7915(&dev->mt76) ? macVal : (macVal >> 8)) & 0xff;
+
+	km_sched_trace_ptr = mt76_rr(dev, km_sched_trace_ptr_addr);
+
+	macVal = mt76_rr(dev, km_irq_info_idx_addr);
+	g_irq_history_num = (is_mt7915(&dev->mt76) ? (macVal >> 8) : macVal) & 0xff;
+	km_irq_info_idx = (is_mt7915(&dev->mt76) ? macVal : (macVal >> 16)) & 0xff;
+
+	km_irq_trace_ptr = mt76_rr(dev, km_irq_trace_ptr_addr);
+	km_total_time = mt76_rr(dev, km_total_time_addr);
+
+	TaskStart[0] = mt76_rr(dev, TaskStart_0);
+	TaskEnd[0] = mt76_rr(dev, TaskEnd_0);
+	TaskStart[1] = mt76_rr(dev, TaskStart_1);
+	TaskEnd[1] = mt76_rr(dev, TaskEnd_1);
+
+	seq_printf(s, "================FW DBG INFO===================\n");
+	seq_printf(s, "       exp_assert_proc_entry_cnt = 0x%x\n",
+		   exp_assert_proc_entry_cnt);
+	seq_printf(s, "       exp_assert_state = 0x%x\n",
+		  exp_assert_state);
+
+	if (exp_assert_proc_entry_cnt == 0) {
+		snprintf(exp_type, sizeof(exp_type), "%s", "exp_type : Normal");
+	} else if (exp_assert_proc_entry_cnt == 1 && exp_assert_state > 1 && g_exp_type == 5) {
+		snprintf(exp_type, sizeof(exp_type), "%s", "exp_type : Assert");
+		fgIsExp = true;
+		fgIsAssert = true;
+	} else if (exp_assert_proc_entry_cnt == 1 && exp_assert_state > 1) {
+		snprintf(exp_type, sizeof(exp_type), "%s", "exp_type : Exception");
+		fgIsExp = true;
+	} else if (exp_assert_proc_entry_cnt > 1) {
+		snprintf(exp_type, sizeof(exp_type), "%s", "exp_type : Exception re-entry");
+		fgIsExp = true;
+	} else {
+		snprintf(exp_type, sizeof(exp_type), "%s", "exp_type : Unknown?");
+	}
+
+	seq_printf(s, "       COS_Interrupt_Count = 0x%x\n", COS_Interrupt_Count);
+	seq_printf(s, "       processing_irqx = 0x%x\n", processing_irqx);
+	seq_printf(s, "       processing_lisr = 0x%x\n", processing_lisr);
+	seq_printf(s, "       Current_Task_Id = 0x%x\n", Current_Task_Id);
+	seq_printf(s, "       Current_Task_Indx = 0x%x\n", Current_Task_Indx);
+	seq_printf(s, "       last_dequeued_msg_id = %d\n", last_dequeued_msg_id);
+
+	seq_printf(s, "       km_irq_info_idx = 0x%x\n", km_irq_info_idx);
+	seq_printf(s, "       km_eint_info_idx = 0x%x\n", km_eint_info_idx);
+	seq_printf(s, "       km_sched_info_idx = 0x%x\n", km_sched_info_idx);
+	seq_printf(s, "       g_sched_history_num = %d\n", g_sched_history_num);
+	seq_printf(s, "       km_sched_trace_ptr = 0x%x\n", km_sched_trace_ptr);
+
+	if (fgIsExp) {
+		seq_printf(s, "\n        <1>print sched trace\n");
+		if (g_sched_history_num > 60)
+			g_sched_history_num = 60;
+
+		idx = km_sched_info_idx;
+		for (i = 0 ; i < g_sched_history_num ; i++) {
+			t1 = mt76_rr(dev, (km_sched_trace_ptr+(idx*12)));
+			t2 = mt76_rr(dev,  (km_sched_trace_ptr+(idx*12)+4));
+			t3 = mt76_rr(dev,  (km_sched_trace_ptr+(idx*12)+8));
+			seq_printf(s, "       (sched_info_%d)sched_t=0x%x, sched_start=%d, PC=0x%x\n",
+				idx, t1, t2, t3);
+			idx++;
+			if (idx >= g_sched_history_num)
+				idx = 0;
+		}
+
+		seq_printf(s, "\n        <2>print irq trace\n");
+		if (g_irq_history_num > 60)
+			g_irq_history_num = 60;
+
+		idx = km_irq_info_idx;
+		for (i = 0 ; i < g_irq_history_num ; i++) {
+			t1 = mt76_rr(dev, (km_irq_trace_ptr+(idx*16)));
+			t2 = mt76_rr(dev, (km_irq_trace_ptr+(idx*16) + 4));
+			seq_printf(s, "       (irq_info_%d)irq_t=%x, sched_start=%d\n",
+				   idx, t1, t2);
+			idx++;
+			if (idx >= g_irq_history_num)
+				idx = 0;
+		}
+	}
+
+	seq_printf(s, "\n       <3>task q_id.read q_id.write\n");
+	seq_printf(s, "       (WIFI )1 0x%x 0x%x\n", TaskStart[0], TaskEnd[0]);
+	seq_printf(s, "       (WIFI2 )2 0x%x 0x%x\n", TaskStart[1], TaskEnd[1]);
+	seq_printf(s, "\n       <4>TASK STACK INFO (size in byte)\n");
+	seq_printf(s, "       TASK  START       END       SIZE  PEAK  INTEGRITY\n");
+
+	t_addr_ofs = is_mt7915(&dev->mt76) ? 224 : 368;
+	for (i = 0 ; i < 2 ; i++) {
+		t1 = mt76_rr(dev,  t1_base_addr + (i*t_addr_ofs));
+		t2 = mt76_rr(dev,  t2_base_addr + (i*t_addr_ofs));
+		t3 = mt76_rr(dev,  t3_base_addr + (i*t_addr_ofs));
+
+		seq_printf(s, "       %s  0x%x  0x%x  %d\n",
+			i == 0 ? "WIFI" : "WIFI2", t1, t2, t3);
+	}
+
+	seq_printf(s, "\n       <5>fw state\n");
+	seq_printf(s, "       %s\n", exp_type);
+	if (COS_Interrupt_Count > 0)
+		seq_printf(s, "       FW in Interrupt CIRQ index (0x%x) CIRQ handler(0x%x)\n"
+			 , processing_irqx, processing_lisr);
+	else {
+		if (Current_Task_Id == 0 && Current_Task_Indx == 3)
+			seq_printf(s, "       FW in IDLE\n");
+
+		if (Current_Task_Id != 0 && Current_Task_Indx != 3)
+			seq_printf(s, "       FW in Task , Task id(0x%x) Task index(0x%x)\n",
+				Current_Task_Id, Current_Task_Indx);
+	}
+
+	macVal = mt76_rr(dev, is_mt7915(&dev->mt76) ? 0x41F080 : g1_exp_counter_addr);
+	seq_printf(s, "       EXCP_CNT = 0x%x\n", macVal);
+
+	seq_printf(s, "       EXCP_TYPE = 0x%x\n", g_exp_type);
+	seq_printf(s, "       CPU_ITYPE = 0x%x\n", mt76_rr(dev, cpu_itype_addr));
+	seq_printf(s, "       CPU_EVA = 0x%x\n", mt76_rr(dev, cpu_eva_addr));
+	seq_printf(s, "       CPU_IPC = 0x%x\n", mt76_rr(dev, cpu_ipc_addr));
+	seq_printf(s, "       PC = 0x%x\n\n\n", mt76_rr(dev, pc_addr));
+
+	mt7915_show_lp_history(s, fgIsExp);
+	mt7915_show_irq_history(s);
+
+	seq_printf(s, "\n\n       cpu utility\n");
+	seq_printf(s, "       Busy:%d%% Peak:%d%%\n\n",
+		   mt76_rr(dev, busy_addr), mt76_rr(dev, peak_addr));
+
+	mt7915_show_msg_trace(s);
+	mt7915_show_sech_trace(s);
+	mt7915_show_prog_trace(s);
+
+	if (fgIsAssert)
+		mt7915_show_assert_line(s);
+
+	seq_printf(s, "============================================\n");
+	return 0;
+}
+
+int mt7915_mtk_init_debugfs(struct mt7915_phy *phy, struct dentry *dir)
+{
+	struct mt7915_dev *dev = phy->dev;
+	u32 device_id = (dev->mt76.rev) >> 16;
+	int i = 0;
+
+	for (i = 0; i < ARRAY_SIZE(dbg_reg_s); i++) {
+		if (device_id == dbg_reg_s[i].id) {
+			dev->dbg_reg = &dbg_reg_s[i];
+			break;
+		}
+	}
+
+	mt7915_mcu_fw_log_2_host(dev, MCU_FW_LOG_WM, 0);
+
+	debugfs_create_file("fw_debug_module", 0600, dir, dev,
+			    &fops_fw_debug_module);
+	debugfs_create_file("fw_debug_level", 0600, dir, dev,
+			    &fops_fw_debug_level);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "sta_info", dir,
+				    mt7915_sta_info);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "wtbl_info", dir,
+				    mt7915_wtbl_read);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "uwtbl_info", dir,
+				    mt7915_uwtbl_read);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "tr_info", dir,
+				    mt7915_trinfo_read);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "drr_info", dir,
+				    mt7915_drr_info);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "ple_info", dir,
+				    mt7915_pleinfo_read);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "pse_info", dir,
+				    mt7915_pseinfo_read);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "mib_info0", dir,
+				    mt7915_mibinfo_band0);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "mib_info1", dir,
+				    mt7915_mibinfo_band1);
+
+	debugfs_create_u32("token_idx", 0600, dir, &dev->dbg.token_idx);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "token", dir,
+				    mt7915_token_read);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "token_txd", dir,
+				    mt7915_token_txd_read);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "amsdu_info", dir,
+				    mt7915_amsduinfo_read);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "agg_info0", dir,
+				    mt7915_agginfo_read_band0);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "agg_info1", dir,
+				    mt7915_agginfo_read_band1);
+
+	debugfs_create_file("tx_amsdu", 0600, dir, dev, &fops_tx_amsdu);
+
+	debugfs_create_file("fw_wa_query", 0600, dir, dev, &fops_wa_query);
+	debugfs_create_file("fw_wa_set", 0600, dir, dev, &fops_wa_set);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "fw_version", dir,
+				    mt7915_dump_version);
+	debugfs_create_file("fw_wa_debug", 0600, dir, dev, &fops_wa_debug);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "fw_wm_info", dir,
+				    mt7915_fw_wm_info_read);
+
+	debugfs_create_file("red_en", 0600, dir, dev,
+			    &fops_red_en);
+	debugfs_create_file("red_show_sta", 0600, dir, dev,
+			    &fops_red_show_sta);
+	debugfs_create_file("red_target_dly", 0600, dir, dev,
+			    &fops_red_target_dly);
+
+	debugfs_create_file("txpower_level", 0400, dir, dev,
+			    &fops_txpower_level);
+
+	debugfs_create_u8("sku_disable", 0600, dir, &dev->dbg.sku_disable);
+
+	return 0;
+}
+#endif
diff --git a/mt7915/mtk_mcu.c b/mt7915/mtk_mcu.c
new file mode 100644
index 00000000..143dae26
--- /dev/null
+++ b/mt7915/mtk_mcu.c
@@ -0,0 +1,51 @@
+#include <linux/firmware.h>
+#include <linux/fs.h>
+#include<linux/inet.h>
+#include "mt7915.h"
+#include "mcu.h"
+#include "mac.h"
+
+int mt7915_mcu_set_txpower_level(struct mt7915_phy *phy, u8 drop_level)
+{
+	struct mt7915_dev *dev = phy->dev;
+	struct mt7915_sku_val {
+		u8 format_id;
+		u8 val;
+		u8 band;
+		u8 _rsv;
+	} __packed req = {
+		.format_id = 1,
+		.band = phy->mt76->band_idx,
+		.val = !!drop_level,
+	};
+	int ret;
+
+	ret = mt76_mcu_send_msg(&dev->mt76,
+				MCU_EXT_CMD(TX_POWER_FEATURE_CTRL), &req,
+				sizeof(req), true);
+	if (ret)
+		return ret;
+
+	req.format_id = 2;
+	if ((drop_level > 90 && drop_level < 100) || !drop_level)
+		req.val = 0;
+	else if (drop_level > 60 && drop_level <= 90)
+		/* reduce Pwr for 1 dB. */
+		req.val = 2;
+	else if (drop_level > 30 && drop_level <= 60)
+		/* reduce Pwr for 3 dB. */
+		req.val = 6;
+	else if (drop_level > 15 && drop_level <= 30)
+		/* reduce Pwr for 6 dB. */
+		req.val = 12;
+	else if (drop_level > 9 && drop_level <= 15)
+		/* reduce Pwr for 9 dB. */
+		req.val = 18;
+	else if (drop_level > 0 && drop_level <= 9)
+		/* reduce Pwr for 12 dB. */
+		req.val = 24;
+
+	return mt76_mcu_send_msg(&dev->mt76,
+				 MCU_EXT_CMD(TX_POWER_FEATURE_CTRL), &req,
+				 sizeof(req), true);
+}
diff --git a/mt7915/soc.c b/mt7915/soc.c
index bb3468a9..b941a49d 100644
--- a/mt7915/soc.c
+++ b/mt7915/soc.c
@@ -360,6 +360,13 @@ static int mt798x_wmac_sku_setup(struct mt7915_dev *dev, u32 *adie_type)
 	*adie_type = FIELD_GET(MT_ADIE_CHIP_ID_MASK, adie_main) |
 		     (MT_ADIE_CHIP_ID_MASK & adie_ext);
 
+#ifdef MTK_DEBUG
+	dev->adie[ADIE0].id = FIELD_GET(MT_ADIE_CHIP_ID_MASK, adie_main);
+	dev->adie[ADIE0].version = FIELD_GET(MT_ADIE_VERSION_MASK, adie_main);
+	dev->adie[ADIE1].id = FIELD_GET(MT_ADIE_CHIP_ID_MASK, adie_ext);
+	dev->adie[ADIE1].version = FIELD_GET(MT_ADIE_VERSION_MASK, adie_ext);
+#endif
+
 out:
 	mt76_wmac_spi_unlock(dev);
 
diff --git a/tools/fwlog.c b/tools/fwlog.c
index e5d4a105..3d51d9ec 100644
--- a/tools/fwlog.c
+++ b/tools/fwlog.c
@@ -26,7 +26,7 @@ static const char *debugfs_path(const char *phyname, const char *file)
 	return path;
 }
 
-static int mt76_set_fwlog_en(const char *phyname, bool en)
+static int mt76_set_fwlog_en(const char *phyname, bool en, char *val)
 {
 	FILE *f = fopen(debugfs_path(phyname, "fw_debug_bin"), "w");
 
@@ -35,7 +35,13 @@ static int mt76_set_fwlog_en(const char *phyname, bool en)
 		return 1;
 	}
 
-	fprintf(f, "7");
+	if (en && val)
+		fprintf(f, "%s", val);
+	else if (en)
+		fprintf(f, "7");
+	else
+		fprintf(f, "0");
+
 	fclose(f);
 
 	return 0;
@@ -76,6 +82,7 @@ static void handle_signal(int sig)
 
 int mt76_fwlog(const char *phyname, int argc, char **argv)
 {
+#define BUF_SIZE 1504
 	struct sockaddr_in local = {
 		.sin_family = AF_INET,
 		.sin_addr.s_addr = INADDR_ANY,
@@ -84,9 +91,10 @@ int mt76_fwlog(const char *phyname, int argc, char **argv)
 		.sin_family = AF_INET,
 		.sin_port = htons(55688),
 	};
-	char buf[1504];
+	char *buf = calloc(BUF_SIZE, sizeof(char));
+	FILE *logfile = NULL;
 	int ret = 0;
-	int yes = 1;
+	/* int yes = 1; */
 	int s, fd;
 
 	if (argc < 1) {
@@ -99,19 +107,28 @@ int mt76_fwlog(const char *phyname, int argc, char **argv)
 		return 1;
 	}
 
+	if (argc == 3) {
+		fprintf(stdout, "start logging to file %s\n", argv[2]);
+		logfile = fopen(argv[2], "wb");
+		if (!logfile) {
+			perror("fopen");
+			return 1;
+		}
+	}
+
 	s = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
 	if (s < 0) {
 		perror("socket");
 		return 1;
 	}
 
-	setsockopt(s, SOL_SOCKET, SO_BROADCAST, &yes, sizeof(yes));
+	/* setsockopt(s, SOL_SOCKET, SO_BROADCAST, &yes, sizeof(yes)); */
 	if (bind(s, (struct sockaddr *)&local, sizeof(local)) < 0) {
 		perror("bind");
 		return 1;
 	}
 
-	if (mt76_set_fwlog_en(phyname, true))
+	if (mt76_set_fwlog_en(phyname, true, argv[1]))
 		return 1;
 
 	fd = open(debugfs_path(phyname, "fwlog_data"), O_RDONLY);
@@ -145,8 +162,8 @@ int mt76_fwlog(const char *phyname, int argc, char **argv)
 		if (!r)
 			continue;
 
-		if (len > sizeof(buf)) {
-			fprintf(stderr, "Length error: %d > %d\n", len, (int)sizeof(buf));
+		if (len > BUF_SIZE) {
+			fprintf(stderr, "Length error: %d > %d\n", len, BUF_SIZE);
 			ret = 1;
 			break;
 		}
@@ -164,14 +181,19 @@ int mt76_fwlog(const char *phyname, int argc, char **argv)
 			break;
 		}
 
-		/* send buf */
-		sendto(s, buf, len, 0, (struct sockaddr *)&remote, sizeof(remote));
+		if (logfile)
+			fwrite(buf, 1, len, logfile);
+		else
+			/* send buf */
+			sendto(s, buf, len, 0, (struct sockaddr *)&remote, sizeof(remote));
 	}
 
 	close(fd);
 
 out:
-	mt76_set_fwlog_en(phyname, false);
+	mt76_set_fwlog_en(phyname, false, NULL);
+	free(buf);
+	fclose(logfile);
 
 	return ret;
 }
-- 
2.45.2

