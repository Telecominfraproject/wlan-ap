From ac0d3754703e11e054269e05650a2fd59bec0070 Mon Sep 17 00:00:00 2001
From: Ramanathan Choodamani <quic_rchoodam@quicinc.com>
Date: Wed, 26 Apr 2023 16:37:13 -0700
Subject: [PATCH] ath12k: Add support for Bond interface

Add support for bonded interface to represent each wifi link with a separate
netdevice. With the new code changes, there will be new interfaces in the system.
Add support to collect statistics for the bonded devices.

wlan0 - Original netdevice that gets created as per ath12k control path
        This netdevice will continue to exist and will be used for all
        control path communications. All NL messages from userspace applications
        are processed on the context of this device. This device will not be
        exposed to the bridge anymore
wlan0_b - This represents the bonded interface. No NL messages will be processed
        on the context of this device. This device is purely meant for only
        datapath. This device will be exposed to the bridge layer
link0 - wlan_l0 (link netdevice)
        Will be used for registering with PPE module during MLO DS operation
link1 - wlan_l1 (link netdevice)
        Will be used for registering with PPE module during MLO DS operation

Signed-off-by: Ramanathan Choodamani <quic_rchoodam@quicinc.com>
Signed-off-by: Balamurugan Mahalingam <quic_bmahalin@quicinc.com>
Signed-off-by: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
Signed-off-by: Aloka Dixit <quic_alokad@quicinc.com>
Signed-off-by: Shivani Tambatkar <quic_stambatk@quicinc.com>
Signed-off-by: Sidhanta Sahu <quic_sidhanta@quicinc.com>
---
 drivers/net/wireless/ath/ath12k/Kconfig    |   9 +
 drivers/net/wireless/ath/ath12k/Makefile   |   1 +
 drivers/net/wireless/ath/ath12k/bondif.c   | 783 +++++++++++++++++++++
 drivers/net/wireless/ath/ath12k/bondif.h   |  43 ++
 drivers/net/wireless/ath/ath12k/core.h     |  18 +
 drivers/net/wireless/ath/ath12k/dp.c       |   7 +
 drivers/net/wireless/ath/ath12k/dp_rx.c    |  15 +-
 drivers/net/wireless/ath/ath12k/dp_tx.c    |   5 +-
 drivers/net/wireless/ath/ath12k/mac.c      |  80 ++-
 drivers/net/wireless/ath/ath12k/pci.c      |  23 +
 drivers/net/wireless/ath/ath12k/ppe.c      |  82 ++-
 drivers/net/wireless/ath/ath12k/ppe.h      |  15 +-
 drivers/net/wireless/ath/ath6kl/cfg80211.c |   2 +-
 drivers/net/wireless/ath/wil6210/netdev.c  |   2 +-
 include/net/cfg80211.h                     |   3 +-
 include/net/mac80211.h                     |   6 +-
 include/uapi/linux/nl80211.h               |   3 +
 local-symbols                              |   2 +
 net/mac80211/Kconfig                       |  18 +
 net/mac80211/cfg.c                         |  30 +-
 net/mac80211/chan.c                        |   8 +
 net/mac80211/ieee80211_i.h                 |   5 +-
 net/mac80211/iface.c                       |  24 +-
 net/mac80211/main.c                        |   8 +-
 net/mac80211/mlme.c                        |   3 +-
 net/mac80211/rx.c                          |  18 +-
 net/mac80211/util.c                        |   4 +
 net/wireless/chan.c                        |   8 +
 net/wireless/core.c                        |  50 +-
 net/wireless/nl80211.c                     |  29 +-
 net/wireless/util.c                        |   4 +
 32 files changed, 1268 insertions(+), 89 deletions(-)
 create mode 100644 drivers/net/wireless/ath/ath12k/bondif.c
 create mode 100644 drivers/net/wireless/ath/ath12k/bondif.h

--- a/drivers/net/wireless/ath/ath12k/Kconfig
+++ b/drivers/net/wireless/ath/ath12k/Kconfig
@@ -70,3 +70,12 @@ config ATH12K_PPE_DS_SUPPORT
 		Enable ath12k PPE-DS support
 
 		Say Y to enable PPE DS Support. If unsure, say N.
+
+config ATH12K_BONDED_DS_SUPPORT
+	bool "QTI ath12k bonded-ds support"
+	depends on ATH12K_DEBUGFS
+	depends on RELAY
+	help
+		Enable ath12k Bonded-DS support
+
+		Say Y to enable Bonded DS Support. If unsure, say N.
--- a/drivers/net/wireless/ath/ath12k/Makefile
+++ b/drivers/net/wireless/ath/ath12k/Makefile
@@ -33,6 +33,7 @@ ath12k-$(CPTCFG_WANT_DEV_COREDUMP) += co
 ath12k-$(CPTCFG_ATH12K_PKTLOG) += pktlog.o
 ath12k-$(CPTCFG_ATH12K_AHB) += ahb.o
 ath12k-$(CPTCFG_ATH12K_PPE_DS_SUPPORT) += ppe.o
+ath12k-$(CPTCFG_ATH12K_BONDED_DS_SUPPORT) += bondif.o
 
 # for tracing framework to find trace.h
 CFLAGS_trace.o := -I$(src)
--- /dev/null
+++ b/drivers/net/wireless/ath/ath12k/bondif.c
@@ -0,0 +1,967 @@
+// SPDX-License-Identifier: BSD-3-Clause-Clear
+/*
+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#include <net/mac80211.h>
+#include <linux/module.h>
+#include <net/bonding.h>
+#include <linux/ieee80211.h>
+#include "core.h"
+#include "ppe.h"
+#include "bondif.h"
+#include "debug.h"
+#include "dp_tx.h"
+
+static const struct net_device_ops ieee80211_link_dataif_8023_ops;
+extern struct ath12k_link_vif *ath12k_mac_assign_link_vif( struct ath12k_hw *ah,
+					struct ieee80211_vif *vif, u8 link_id);
+extern int g_bonded_interface_model;
+extern bool ath12k_mac_tx_check_max_limit(struct ath12k *ar, struct sk_buff *skb);
+
+static void ath12k_ieee80211_if_free(struct net_device *dev)
+{
+	free_percpu(dev->tstats);
+}
+
+static void ath12k_ieee80211_if_setup(struct net_device *dev)
+{
+	ether_setup(dev);
+	dev->priv_flags &= ~IFF_TX_SKB_SHARING;
+	dev->netdev_ops = &ieee80211_link_dataif_8023_ops;
+	netdev_set_priv_destructor(dev, ath12k_ieee80211_if_free);
+}
+
+static bool ath12k_ppe_vp_set_mtu(struct net_device *dev, struct ath12k_link_vif *arvif,
+				  const int mtu)
+{
+	if (!arvif->ndev_pvt->vp_num)
+		return true;
+
+	if (ppe_vp_mtu_set(arvif->ndev_pvt->vp_num, mtu) != PPE_VP_STATUS_SUCCESS) {
+		ath12k_err(NULL, "Setting mtu to %d for link_ndev:%s (vp num:%d) failed\n",
+			   mtu, arvif->ndev_pvt->link_ndev->name,
+			   arvif->ndev_pvt->vp_num);
+		return false;
+	}
+
+	return true;
+}
+
+static bool ath12k_dst_ppe_vp(struct net_device *dev,
+                                         struct sk_buff *skb, void *cb_data)
+{
+	if (unlikely(dev == NULL)) {
+		dev_kfree_skb_any(skb);
+		return false;
+	}
+
+	skb->dev = dev;
+	dev_queue_xmit(skb);
+
+	return true;
+}
+
+int ath12k_bond_link_enslave(struct ath12k_link_vif *arvif, struct net_device *link_dev)
+{
+	struct ath12k_link_vif_pvt *link_ndev_pvt = NULL;
+	int ret;
+
+	if (!g_bonded_interface_model)
+		return 0;
+
+	link_ndev_pvt = netdev_priv(link_dev);
+
+	ath12k_info(NULL, "Enslave bond_dev %px link_ndev %px\n", link_ndev_pvt->bond_dev, link_dev);
+	ret = bond_enslave(link_ndev_pvt->bond_dev, link_dev, NULL);
+	if (ret) {
+		ath12k_err(NULL, "Error bond enslave error\n");
+		return -EINVAL;
+	}
+	else {
+		ath12k_info(NULL, "Successfully enslaved link_ndev %s %px\n",
+			    link_dev->name, link_dev);
+	}
+
+	return 0;
+}
+
+void ath12k_bond_link_release(struct ath12k_link_vif *arvif)
+{
+	struct ath12k_link_vif_pvt *link_ndev_pvt = NULL;
+	int err;
+
+	if (!g_bonded_interface_model)
+		return;
+
+	if (!arvif->ndev_pvt || !arvif->ndev_pvt->link_ndev) {
+		ath12k_err(NULL, "ERR no link dev for this vif to release from bond\n");
+		return;
+	}
+
+	link_ndev_pvt = netdev_priv(arvif->ndev_pvt->link_ndev);
+	if (link_ndev_pvt && link_ndev_pvt->bond_dev) {
+		ath12k_info(NULL, "Bond_release link netdevice %s link ndev %px \n",
+			    arvif->ndev_pvt->link_ndev->name, arvif->ndev_pvt->link_ndev);
+
+		/* bond_release expects slave netdevices to be in down state */
+		link_ndev_pvt->link_ndev->flags &= ~IFF_UP;
+		err = bond_release(link_ndev_pvt->bond_dev, link_ndev_pvt->link_ndev);
+		if (err) {
+			ath12k_err(NULL, "Error bond release link ndev:%s from bond ndev:%s: due to err: %d\n",
+					link_ndev_pvt->link_ndev->name,
+					link_ndev_pvt->bond_dev->name, err);
+			return;
+		}
+	} else {
+		ath12k_err(NULL, "ERR unable to release Bond %s link ndev %px \n",
+			   arvif->ndev_pvt->link_ndev->name, arvif->ndev_pvt->link_ndev);
+	}
+}
+
+static bool ath12k_stats_update_ppe_vp(struct net_device *dev, ppe_vp_hw_stats_t *vp_stats)
+{
+        struct pcpu_sw_netstats *tstats = this_cpu_ptr(netdev_tstats(dev));
+
+        u64_stats_update_begin(&tstats->syncp);
+        tstats->tx_packets += vp_stats->tx_pkt_cnt;
+        tstats->tx_bytes += vp_stats->tx_byte_cnt;
+        tstats->rx_packets += vp_stats->rx_pkt_cnt;
+        tstats->rx_bytes += vp_stats->rx_byte_cnt;
+        u64_stats_update_end(&tstats->syncp);
+
+        return true;
+}
+
+void ath12k_enable_ppe_for_link_netdev(struct ath12k_link_vif *arvif,
+				       struct net_device *link_dev)
+{
+	struct ppe_vp_ai vpai;
+	struct ieee80211_ppe_vp_ds_params vp_params = {0};
+	struct ath12k_link_vif_pvt *link_ndev_pvt = NULL;
+	int ret;
+	int ppe_vp_num = -1;
+
+	arvif->ppe_vp_num = -1;
+	arvif->ppe_vp_type = -1;
+	if (!g_bonded_interface_model)
+		return;
+
+	memset(&vpai, 0, sizeof(struct ppe_vp_ai));
+
+	vpai.type = PPE_VP_TYPE_SW_L2;
+	vpai.dst_cb = ath12k_dst_ppe_vp;
+	vpai.dst_cb_data = arvif;
+	vpai.src_cb = NULL;
+	vpai.src_cb_data = NULL;
+	vpai.stats_cb = ath12k_stats_update_ppe_vp;
+	vpai.queue_num = 0;
+	vpai.net_dev_type = PPE_VP_NET_DEV_TYPE_WIFI;
+	link_ndev_pvt = netdev_priv(link_dev);
+
+	vpai.core_mask = ATH12K_PPE_DS_DEFAULT_CORE_MASK;
+	vp_params.dev = link_dev;
+
+	if (test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &arvif->ar->ab->dev_flags)) {
+		vpai.usr_type = PPE_VP_USER_TYPE_DS;
+
+		ret = ath12k_mac_op_ppeds_attach_vdev(arvif, &vpai,
+						      &ppe_vp_num, &vp_params);
+		if (ret) {
+			ath12k_err(NULL, "Error in enabling DS for arvif %pM\n", arvif->addr);
+			return;
+		}
+		arvif->ppe_vp_type = PPE_VP_USER_TYPE_DS;
+		link_ndev_pvt->ppe_vp_profile_idx = vp_params.ppe_vp_profile_idx;
+		link_ndev_pvt->vp_num = ppe_vp_num;
+		arvif->ppe_vp_num = ppe_vp_num;
+		ath12k_dbg(arvif->ar->ab, ATH12K_DBG_PPE,
+			   "Enabling DS index %d vp %d link_id %d %pM core_mask 0x%x\n",
+			   vp_params.ppe_vp_profile_idx, ppe_vp_num,
+			   arvif->link_id, arvif->addr, vpai.core_mask);
+	} else {
+		vpai.usr_type = PPE_VP_USER_TYPE_ACTIVE;
+
+		ppe_vp_num = ppe_vp_alloc(vp_params.dev, &vpai);
+		if (ppe_vp_num <= 0) {
+			ath12k_err(NULL, "Error in enabling Active VP for arvif %pM\n", arvif->addr);
+			return;
+		}
+		link_ndev_pvt->vp_num = ppe_vp_num;
+		arvif->ppe_vp_num = ppe_vp_num;
+		arvif->ppe_vp_type = vpai.usr_type;
+		ath12k_dbg(ab, ATH12K_DBG_PPE,
+			   "Enabling Active VP for arvif %pM dev %s vp_num %d core_mask 0x%x\n",
+			   arvif->addr, vp_params.dev->name,
+			   arvif->ppe_vp_num, vpai.core_mask);
+	}
+
+	return;
+}
+
+void ath12k_disable_ppe_for_link_netdev(struct ath12k_link_vif *arvif, struct net_device *link_dev)
+{
+	struct ieee80211_ppe_vp_ds_params vp_params = {0};
+	struct ath12k_link_vif_pvt *link_ndev_pvt = NULL;
+
+	if (!g_bonded_interface_model)
+		return;
+
+	if (!arvif->ndev_pvt || !arvif->ndev_pvt->link_ndev) {
+		ath12k_err(NULL, "ERR no link dev for this vif to disable DS.\n");
+		return;
+	}
+
+	link_ndev_pvt = netdev_priv(link_dev);
+	vp_params.ppe_vp_profile_idx = link_ndev_pvt->ppe_vp_profile_idx;
+	if (arvif->ppe_vp_num == -1)
+		return;
+
+	if (test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags)) {
+		ath12k_mac_op_ppeds_detach_vdev (arvif, &vp_params);
+		if (arvif->ppe_vp_type != PPE_VP_USER_TYPE_DS)
+			ppe_vp_free(arvif->ppe_vp_num);
+
+	} else {
+		ppe_vp_free(arvif->ppe_vp_num);
+	}
+
+	ath12k_dbg(arvif->ar->ab, ATH12K_DBG_PPE,
+		   "Destroyed PPE VP port type %d no:%d for dev:%s\n",
+		   arvif->ppe_vp_type, arvif->ppe_vp_num, link_dev->name);
+	arvif->ppe_vp_num = -1;
+	arvif->ppe_vp_type = -1;
+}
+
+int ath12k_mac_op_change_vif_links(struct ieee80211_hw *hw,
+					  struct ieee80211_vif *vif,
+					  u16 old_links, u16 new_links,
+					  struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS])
+{
+	u16  new_link_id;
+	struct wireless_dev *wdev = ieee80211_vif_to_wdev(vif);
+	struct net_device *cp_netdev = wdev->netdev;
+	struct ath12k_link_vif_pvt *link_ndev_pvt = NULL;
+	struct net_device *link_ndev;
+	struct ath12k_mld_dev *mldev = NULL;
+	u16 link_num;
+	struct net_device *bond_dev = NULL;
+	char name[20] = {0};
+	int ret = 0, chip_id = 0, pdev_id = 0;
+
+	if (!g_bonded_interface_model)
+		return 0;
+
+	bond_dev = wdev->bond_netdev;
+	if (!bond_dev)
+		return 0;
+	mldev = bond_get_mlo_ctx(bond_dev);
+
+	new_link_id = new_links ^ old_links;
+	link_num =  ffs(new_link_id) - 1;
+	/* TODO: Do this assignment only for the Add link case */
+
+	if (new_links > old_links)  {
+		/* Add Link operation */
+		snprintf(name, sizeof(name), "%s_l%d", cp_netdev->name, link_num);
+		link_ndev = alloc_netdev_mqs(sizeof (struct ath12k_link_vif_pvt), name, NET_NAME_ENUM, ath12k_ieee80211_if_setup, 1, 1);
+		if (!link_ndev) {
+			ath12k_err(NULL, "ERR: link netdev allocation failed\n");
+			//TODO: Graceful cleanup
+			return -EINVAL;
+		}
+
+		memcpy(&link_ndev->perm_addr, wdev->links[link_num].addr, ETH_ALEN);
+		link_ndev->dev_addr = &link_ndev->perm_addr;
+		link_ndev_pvt = netdev_priv(link_ndev);
+		memset(link_ndev_pvt, 0, sizeof(*link_ndev_pvt));
+		link_ndev->netdev_ops = &ieee80211_link_dataif_8023_ops;
+		link_ndev_pvt->hw = hw;
+		link_ndev_pvt->link_ndev = link_ndev;
+		link_ndev_pvt->bond_dev = bond_dev;
+		link_ndev_pvt->is_started = false;
+		mldev->vif = vif;
+		mutex_lock(&vif->bond_mutex);
+		vif->link_ndev[link_num] = link_ndev;
+		mutex_unlock(&vif->bond_mutex);
+		link_ndev->max_mtu = IEEE80211_MAX_DATA_LEN;
+		link_ndev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);
+		ret = register_netdevice(link_ndev);
+		if (ret) {
+			ath12k_err(NULL, "Error register link netdevice\n");
+			//TODO: Graceful cleanup
+			return -EINVAL;
+		}
+
+		memcpy(&bond_dev->perm_addr, vif->addr, ETH_ALEN);
+		bond_dev->dev_addr = &bond_dev->perm_addr;
+
+		if (mldev && !mldev->mcast_dev_set) {
+			mldev->mcast_dev_set = true;
+			mldev->primary_chipid = chip_id;
+			mldev->primary_pdevid = pdev_id;
+		}
+		if (mldev)
+			mldev->link_dev[chip_id][pdev_id] =  link_ndev;
+
+		} else {
+			/* Delete Link operation */
+			mutex_lock(&vif->bond_mutex);
+			link_ndev = vif->link_ndev[link_num];
+			link_ndev_pvt = netdev_priv(link_ndev);
+			if (link_ndev) {
+				ath12k_info(NULL, "Unregister link netdevice %s link ndev %px link_num %d\n", link_ndev->name, link_ndev, link_num);
+				unregister_netdevice(link_ndev);
+				link_ndev_pvt->link_ndev = NULL;
+				vif->link_ndev[link_num] = NULL;
+			} else {
+				ath12k_err(NULL, "ERR Unregister link netdevice %s link ndev %px link_num %d\n", link_ndev->name, link_ndev, link_num);
+			}
+			mutex_unlock(&vif->bond_mutex);
+		}
+	ath12k_info(NULL, "%s:%d link changed for MLD %pM old 0x%x new 0x%x\n", __func__, __LINE__, vif->addr, old_links, new_links);
+	return 0;
+}
+
+
+static struct net_device *ath12k_mac_get_tx_link_netdev(struct ath12k_mld_dev *mldev, u8 *dst_mac_addr)
+{
+	struct net_device *ndev = NULL, *dvlan_ndev = NULL;
+	struct ieee80211_sta *sta= NULL;
+	struct ath12k_sta *ahsta;
+	struct ath12k_vif *ahvif = ath12k_vif_to_ahvif(mldev->vif);
+
+	rcu_read_lock();
+	sta = ieee80211_find_sta(mldev->vif, dst_mac_addr);
+
+	if (!sta) {
+		rcu_read_unlock();
+		ndev = mldev->vif->link_ndev[ahvif->deflink.link_id];
+		ath12k_dbg(NULL, ATH12K_DBG_DP_TX, "(%s,%d) PPE %s:%d ahvif->deflink.link_id %d dev %s\n",
+				current->comm, current->pid, __func__, __LINE__,
+				ahvif->deflink.link_id, ndev->name);
+		return ndev;
+	}
+
+	ahsta = (struct ath12k_sta *)sta->drv_priv;
+
+	if (!sta->mlo) {
+		ndev = mldev->vif->link_ndev[ahsta->deflink.link_id];
+		//todo: check changing addr3 needed as in ath12k_mac_get_tx_link
+
+		ath12k_dbg(NULL, ATH12K_DBG_DP_TX, "(%s,%d) PPE %s:%d pkt delivered to sta.deflink.link_id %d dev %s\n",
+				current->comm, current->pid, __func__, __LINE__,
+				ahsta->deflink.link_id, ndev->name);
+		goto dvlan_check;
+	}
+
+	if (sta) {
+		/* TODO: Use Primary Link */
+		ndev = mldev->vif->link_ndev[ahsta->assoc_link_id];
+		ath12k_dbg(NULL, ATH12K_DBG_DP_TX, "[%s] %s:%d deliver packets for sta %pM ahsta->assoc_link_id %d ndev %s\n",
+				 current->comm, __func__, __LINE__,
+				 sta, ahsta->assoc_link_id, ndev->name);
+	}
+
+dvlan_check:
+	dvlan_ndev = ieee80211_sta_get_dvlan_iface(sta);
+	if (dvlan_ndev)
+		ndev = dvlan_ndev;
+
+	rcu_read_unlock();
+
+	/* TODO: Verify what happens with NULL. Understand what is the fall back*/
+	return ndev;
+}
+
+static void ath12k_dp_tx_release_txbuf(struct ath12k_dp *dp,
+				       struct ath12k_tx_desc_info *tx_desc,
+				       u8 ring_id)
+{
+	tx_desc->skb = NULL;
+	tx_desc->skb_ext_desc = NULL;
+	spin_lock_bh(&dp->tx_desc_lock[ring_id]);
+	list_move_tail(&tx_desc->list, &dp->tx_desc_free_list[ring_id]);
+	spin_unlock_bh(&dp->tx_desc_lock[ring_id]);
+}
+
+static inline
+struct ath12k_tx_desc_info *ath12k_dp_tx_assign_buffer(struct ath12k_dp *dp,
+							      u8 pool_id)
+{
+	struct ath12k_tx_desc_info *desc = NULL;
+
+	spin_lock_bh(&dp->tx_desc_lock[pool_id]);
+	desc = list_first_entry_or_null(&dp->tx_desc_free_list[pool_id],
+					struct ath12k_tx_desc_info,
+					list);
+	if (!desc) {
+		ath12k_dbg(dp->ab, ATH12K_DBG_DP_TX, "failed to allocate data Tx desc\n");
+		spin_unlock_bh(&dp->tx_desc_lock[pool_id]);
+		return NULL;
+	}
+
+	prefetch(desc);
+	list_move_tail(&desc->list, &dp->tx_desc_used_list[pool_id]);
+	spin_unlock_bh(&dp->tx_desc_lock[pool_id]);
+
+	return desc;
+}
+
+int ath12k_mcast_dp_tx(struct ath12k *ar, struct ath12k_link_vif *arvif,
+		       struct sk_buff *skb, bool gsn_valid, int mcbc_gsn)
+{
+	struct ath12k_vif *ahvif = arvif->ahvif;
+	struct ath12k_base *ab = ar->ab;
+	struct ath12k_dp *dp = &ab->dp;
+	struct hal_tx_info ti = {0};
+	struct ath12k_tx_desc_info *tx_desc = NULL;
+	struct ath12k_skb_cb *skb_cb = ATH12K_SKB_CB(skb);
+	struct hal_srng *tcl_ring;
+	struct dp_tx_ring *tx_ring;
+	void *hal_tcl_desc;
+	struct hal_tcl_data_cmd *tcl_cmd;
+	u8 hal_ring_id;
+	int ret;
+
+	if (unlikely(test_bit(ATH12K_FLAG_CRASH_FLUSH, &ar->ab->dev_flags))) {
+		return -ESHUTDOWN;
+	}
+
+	ti.ring_id =
+		ab->hw_params->hw_ops->get_ring_selector(skb);
+
+	tx_ring = &dp->tx_ring[ti.ring_id];
+
+	tx_desc = ath12k_dp_tx_assign_buffer(dp, ti.ring_id);
+	if (unlikely(!tx_desc)) {
+		ab->soc_stats.tx_err.txbuf_na[ti.ring_id]++;
+		return -ENOMEM;
+	}
+
+	ATH12K_SKB_CB(skb)->link_id = arvif->link_id;
+	ti.bank_id = arvif->bank_id;
+	ti.meta_data_flags = arvif->tcl_metadata;
+
+	if (gsn_valid) {
+		ti.meta_data_flags = u32_encode_bits(HTT_TCL_META_DATA_TYPE_GLOBAL_SEQ_NUM,
+						     HTT_TCL_META_DATA_TYPE_MISSION) |
+				     u32_encode_bits(mcbc_gsn, HTT_TCL_META_DATA_GLOBAL_SEQ_NUM);
+		ti.vdev_id = arvif->vdev_id +
+			     HTT_TX_MLO_MCAST_HOST_REINJECT_BASE_VDEV_ID;
+	} else {
+		ti.vdev_id = arvif->vdev_id;
+	}
+
+	ti.encap_type = HAL_TCL_ENCAP_TYPE_ETHERNET;
+	ti.addr_search_flags = arvif->hal_addr_search_flags;
+	ti.search_type = arvif->search_type;
+	ti.type = HAL_TCL_DESC_TYPE_BUFFER;
+
+	if (likely(skb->ip_summed == CHECKSUM_PARTIAL &&
+		   ti.encap_type != HAL_TCL_ENCAP_TYPE_RAW)) {
+		ti.flags0 |= TX_IP_CHECKSUM;
+	}
+
+	ti.paddr = dma_map_single(ab->dev, skb->data, skb->len, DMA_TO_DEVICE);
+	if (unlikely(dma_mapping_error(ab->dev, ti.paddr))) {
+		atomic_inc(&ab->soc_stats.tx_err.misc_fail);
+		ath12k_warn(ab, "failed to DMA map data Tx buffer\n");
+		ret = -ENOMEM;
+		goto fail_remove_tx_buf;
+	}
+
+
+	/* Add metadata for sw encrypted vlan group traffic */
+
+	tx_desc->skb = skb;
+	tx_desc->mac_id = ar->pdev_idx;
+	tx_desc->recycler_fast_xmit = 0;
+	ti.desc_id = tx_desc->desc_id;
+	ti.data_len = skb->len - ti.pkt_offset;
+	skb_cb->paddr = ti.paddr;
+	skb_cb->vif = ahvif->vif;
+	skb_cb->ar = ar;
+
+	hal_ring_id = tx_ring->tcl_data_ring.ring_id;
+	tcl_ring = &ab->hal.srng_list[hal_ring_id];
+
+	spin_lock_bh(&tcl_ring->lock);
+	ath12k_hal_srng_access_src_ring_begin_nolock(tcl_ring);
+	hal_tcl_desc = ath12k_hal_srng_src_get_next_entry(ab, tcl_ring);
+	if (unlikely(!hal_tcl_desc)) {
+		/* NOTE: It is highly unlikely we'll be running out of tcl_ring
+		 * desc because the desc is directly enqueued onto hw queue.
+		 */
+		ath12k_hal_srng_access_umac_src_ring_end_nolock(tcl_ring);
+		spin_unlock_bh(&tcl_ring->lock);
+		ab->soc_stats.tx_err.desc_na[ti.ring_id]++;
+		ret = -ENOMEM;
+
+		goto fail_unmap_dma;
+	}
+
+	ab->soc_stats.tx_enqueued[ti.ring_id]++;
+	arvif->link_stats.tx_encap_type[ti.encap_type]++;
+	arvif->link_stats.tx_encrypt_type[ti.encrypt_type]++;
+	arvif->link_stats.tx_desc_type[ti.type]++;
+	tcl_cmd = (struct hal_tcl_data_cmd *)hal_tcl_desc;
+
+	tcl_cmd->buf_addr_info.info0 = (u32)ti.paddr;
+	/* TODO: Copy the upper 8 bits here */
+	tcl_cmd->buf_addr_info.info1 = (ti.desc_id << 12);
+	tcl_cmd->info0 = (ti.type << 1) | arvif->desc.info0;
+	tcl_cmd->info1 = ti.meta_data_flags << 16;
+	tcl_cmd->info2 = ti.flags0 | ti.data_len;
+
+	/* In tcl_cmd->info3, Bit 24 to 31 represents vdev_id
+	 * LSH 24 times to add updated vdev_id to info3
+	 */
+	tcl_cmd->info3 = (ti.vdev_id << 24) | arvif->desc.info3;
+	tcl_cmd->info4 = arvif->desc.info4;
+	tcl_cmd->info5 = 0;
+
+	dsb(st);
+	ath12k_hal_srng_access_umac_src_ring_end_nolock(tcl_ring);
+	spin_unlock_bh(&tcl_ring->lock);
+
+	ath12k_dbg_dump(ab, ATH12K_DBG_DP_TX, NULL, "dp tx msdu: ", skb->data, skb->len);
+	arvif->link_stats.tx_enqueued++;
+	atomic_inc(&ar->dp.num_tx_pending);
+
+	return 0;
+
+fail_unmap_dma:
+	dma_unmap_single(ab->dev, skb_cb->paddr, skb->len, DMA_TO_DEVICE);
+
+fail_remove_tx_buf:
+	ath12k_dp_tx_release_txbuf(dp, tx_desc, ti.ring_id);
+	if (ti.pkt_offset)
+		skb_pull(skb, ti.pkt_offset);
+
+	arvif->link_stats.tx_dropped++;
+
+	return ret;
+}
+
+int ath12k_dp_mlo_xmit_netdev(struct sk_buff *skb, struct net_device *bond_dev)
+{
+	struct net_device *link_dev = NULL;
+	struct ethhdr *eh = NULL;
+	struct ath12k_mld_dev *mldev = bond_get_mlo_ctx(bond_dev);
+	struct ath12k_link_vif_pvt *arvif_pvt = NULL;
+	struct ath12k_link_vif *arvif, *tmp_arvif;
+	struct ath12k_vif *ahvif = NULL;
+	struct sk_buff *msdu_copied;
+	struct ath12k *tmp_ar;
+	int is_mcast;
+	u16 mcbc_gsn;
+	int ret;
+	int link_id, ring_id = 0;
+	struct ath12k_skb_cb *skb_cb;
+	struct ieee80211_tx_info *info;
+
+	if (!(bond_dev->flags & IFF_UP)) {
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	eh = (struct ethhdr *)skb->data;
+	is_mcast = is_multicast_ether_addr(eh->h_dest);
+	skb_cb = ATH12K_SKB_CB(skb);
+	skb_cb->flags |= ATH12K_SKB_HW_80211_ENCAP;
+	info = IEEE80211_SKB_CB(skb);
+	info->flags |= IEEE80211_TX_CTL_HW_80211_ENCAP;
+
+	if (is_mcast) {
+		uint8_t chip_id = mldev->primary_chipid;
+		uint8_t pdev_id = mldev->primary_pdevid;
+
+		link_dev = mldev->link_dev[chip_id][pdev_id];
+		arvif_pvt = netdev_priv(link_dev);
+		arvif = arvif_pvt->arvif;
+		if (!arvif) {
+			dev_kfree_skb_any(skb);
+			return NETDEV_TX_OK;
+		}
+
+		ahvif = arvif->ahvif;
+		if (!ahvif) {
+			dev_kfree_skb_any(skb);
+			return NETDEV_TX_OK;
+		}
+
+		spin_lock(&ahvif->mcbc_gsn_lock);
+		mcbc_gsn = ahvif->mcbc_gsn++;
+		if (ahvif->mcbc_gsn > 0xFFF)
+			ahvif->mcbc_gsn = 0;
+		spin_unlock(&ahvif->mcbc_gsn_lock);
+
+		for_each_set_bit(link_id, &ahvif->links_map,
+				IEEE80211_MLD_MAX_NUM_LINKS) {
+			tmp_arvif = ahvif->link[link_id];
+			if (tmp_arvif && tmp_arvif->ar)
+				tmp_ar = tmp_arvif->ar;
+			else
+				break;
+
+			ret = ath12k_mac_tx_check_max_limit(tmp_ar, skb);
+			if (ret) {
+				ath12k_dbg(tmp_ar->ab, ATH12K_DBG_MAC,
+						"failed fast tx due to limit check pdev idx %d\n",
+						tmp_ar->pdev_idx);
+				continue;
+			}
+
+			ring_id = tmp_arvif->ar->ab->hw_params->hw_ops->get_ring_selector(skb);
+
+			if (test_bit(ATH12K_FLAG_RECOVERY, &tmp_ar->ab->dev_flags)) {
+				tmp_ar->ab->soc_stats.bond_tx_mcast_dropped[ring_id]++;
+				break;
+			}
+
+			tmp_ar->ab->soc_stats.bond_tx_mcast_enqueued[ring_id]++;
+			msdu_copied = skb_copy(skb, GFP_ATOMIC);
+			if (!msdu_copied) {
+				tmp_ar->ab->soc_stats.bond_tx_mcast_dropped[ring_id]++;
+				continue;
+			}
+
+			ret = ath12k_mcast_dp_tx(tmp_ar, tmp_arvif, msdu_copied, true, mcbc_gsn);
+			if (ret) {
+				tmp_ar->ab->soc_stats.bond_tx_mcast_dropped[ring_id]++;
+				dev_kfree_skb_any(msdu_copied);
+				continue;
+			}
+		}
+		dev_kfree_skb_any(skb);
+		return NETDEV_TX_OK;
+	} else {
+		link_dev = ath12k_mac_get_tx_link_netdev( mldev, eh->h_dest);
+	}
+
+	if (!link_dev) {
+		dev_kfree_skb_any(skb);
+		return NETDEV_TX_OK;
+	}
+
+	skb->fast_xmit = 0;
+	return link_dev->netdev_ops->ndo_start_xmit(skb, link_dev);
+}
+
+struct net_device *ath12k_dp_get_mlo_tx_netdev(void *bondctx, u8 *dst_mac_addr)
+{
+	struct ath12k_mld_dev *mldev = (struct ath12k_mld_dev *)bondctx;
+
+	return ath12k_mac_get_tx_link_netdev(mldev, dst_mac_addr);
+}
+
+int ieee80211_link_open(struct net_device *dev)
+{
+	struct ath12k_link_vif_pvt *arvif_pvt = netdev_priv(dev);
+	arvif_pvt->is_started = true;
+	return 0;
+}
+
+int ieee80211_link_stop(struct net_device *dev)
+{
+	struct ath12k_link_vif_pvt *arvif_pvt = netdev_priv(dev);
+	arvif_pvt->is_started = false;
+	return 0;
+}
+
+void ieee80211_link_uninit(struct net_device *dev)
+{
+	return;
+}
+
+static inline void ieee80211_tx_stats_bonded_if(struct net_device *dev, u32 len)
+{
+    struct pcpu_sw_netstats *tstats = this_cpu_ptr(netdev_tstats(dev));
+
+    u64_stats_update_begin(&tstats->syncp);
+    tstats->tx_packets++;
+    tstats->tx_bytes += len;
+    u64_stats_update_end(&tstats->syncp);
+}
+
+netdev_tx_t ieee80211_link_subif_start_xmit_8023(struct sk_buff *skb,
+					    struct net_device *dev)
+{
+	struct ath12k_link_vif_pvt *arvif_pvt = netdev_priv(dev);
+	struct ath12k_link_vif *arvif = arvif_pvt->arvif;
+	struct ath12k_base *ab;
+	int ret;
+	int is_mcast, ring_id = 0;
+	struct ethhdr *eh = NULL;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+
+	ieee80211_tx_stats_bonded_if(dev, skb->len);
+
+	if (!(dev->flags & IFF_UP)) {
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	eh = (struct ethhdr *)skb->data;
+	is_mcast = is_multicast_ether_addr(eh->h_dest);
+	info->flags |= IEEE80211_TX_CTL_HW_80211_ENCAP;
+	ATH12K_SKB_CB(skb)->link_id = arvif->link_id;
+
+	if (!arvif_pvt->is_started) {
+		ath12k_dbg(NULL, ATH12K_DBG_PPE, "Dropping frames as arvif is not started\n");
+		dev_kfree_skb_any(skb);
+		return NETDEV_TX_OK;
+	}
+	if (!arvif || !arvif->is_started) {
+		ath12k_dbg(NULL, ATH12K_DBG_PPE, "Dropping frames as arvif is not started\n");
+		dev_kfree_skb_any(skb);
+		return NETDEV_TX_OK;
+	}
+
+	ab = arvif->ar->ab;
+	ring_id = ab->hw_params->hw_ops->get_ring_selector(skb);
+
+	if (test_bit(ATH12K_FLAG_RECOVERY, &ab->dev_flags)) {
+		ath12k_dbg(NULL, ATH12K_DBG_PPE, "Dropping frames as radio is in recovery\n");
+		ab->soc_stats.bond_tx_ucast_dropped[ring_id]++;
+		dev_kfree_skb_any(skb);
+		return NETDEV_TX_OK;
+	}
+
+
+	ab->soc_stats.bond_tx_ucast_enqueued[ring_id]++;
+	/* TODO: debug why queue is always 15 */
+	info->hw_queue = 0;
+
+	ret = ath12k_mac_tx_check_max_limit(arvif->ar, skb);
+	if (ret) {
+		ath12k_dbg(arvif->ar->ab, ATH12K_DBG_MAC,
+				"failed fast tx due to limit check pdev idx %d\n",
+				arvif->ar->pdev_idx);
+		dev_kfree_skb_any(skb);
+		return NETDEV_TX_OK;
+	}
+
+	ret = ath12k_dp_tx_direct(arvif, skb);
+	if (unlikely(ret)) {
+		ath12k_dbg(ab, ATH12K_DBG_PPE,
+			   "failed to transmit frame %d\n", ret);
+		dev_kfree_skb_any(skb);
+		ab->soc_stats.bond_tx_ucast_dropped[ring_id]++;
+		return NETDEV_TX_OK;
+	}
+	return NETDEV_TX_OK;
+}
+
+void ieee80211_link_set_multicast_list(struct net_device *dev)
+{
+	return;
+}
+
+static int ieee80211_link_set_mtu(struct net_device *dev, int mtu)
+{
+	struct ath12k_link_vif_pvt *arvif_pvt = netdev_priv(dev);
+	struct ath12k_link_vif *arvif = arvif_pvt->arvif;
+
+	if (!arvif)
+		return -EINVAL;
+
+	if (!(IEEE80211_MTU_MIN < mtu && mtu < IEEE80211_MTU_MAX))
+		return -EINVAL;
+
+	if (!ath12k_ppe_vp_set_mtu(dev, arvif, mtu))
+		return -EINVAL;
+
+	dev->mtu = mtu;
+
+	return 0;
+}
+
+int ieee80211_link_change_mac(struct net_device *dev, void *addr)
+{
+	return 0;
+}
+
+#if LINUX_VERSION_IS_GEQ(5,2,0)
+u16 ieee80211_link_netdev_select_queue(struct net_device *dev,
+					 struct sk_buff *skb,
+					 struct net_device *sb_dev)
+#elif LINUX_VERSION_IS_GEQ(4,19,0)
+u16 ieee80211_link_netdev_select_queue(struct net_device *dev,
+					 struct sk_buff *skb,
+					 struct net_device *sb_dev,
+					 select_queue_fallback_t fallback)
+#else
+u16 ieee80211_link_netdev_select_queue(struct net_device *dev,
+					 struct sk_buff *skb,
+					 void *accel_priv,
+					 select_queue_fallback_t fallback)
+#endif
+{
+	return smp_processor_id();
+}
+
+void
+ieee80211_link_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)
+{
+	dev_fetch_sw_netstats(stats, dev->tstats);
+}
+static const struct net_device_ops ieee80211_link_dataif_8023_ops = {
+	.ndo_open		= ieee80211_link_open,
+	.ndo_stop		= ieee80211_link_stop,
+	.ndo_uninit		= ieee80211_link_uninit,
+	.ndo_start_xmit		= ieee80211_link_subif_start_xmit_8023,
+	.ndo_set_rx_mode	= ieee80211_link_set_multicast_list,
+	.ndo_change_mtu		= ieee80211_link_set_mtu,
+	.ndo_set_mac_address	= ieee80211_link_change_mac,
+	.ndo_select_queue	= ieee80211_link_netdev_select_queue,
+	.ndo_get_stats64	= ieee80211_link_get_stats64,
+};
+
+int ath12k_free_bonddev_for_sfe(struct wireless_dev *wdev, struct ieee80211_vif *vif, int link_num)
+{
+	struct ath12k_mld_dev *mldev = NULL;
+	struct wireless_dev *dummywdev = NULL;
+	struct wiphy *dummywiphy = NULL;
+	struct net_device *link_ndev = NULL;
+	int ret;
+
+	mutex_lock(&vif->bond_mutex);
+	link_ndev = vif->link_ndev[link_num];
+	if (link_ndev) {
+		ath12k_info(NULL, "Bond_release and Unregister link netdevice %s link ndev %px link_num %d\n", link_ndev->name, link_ndev, link_num);
+		bond_release(wdev->bond_netdev, link_ndev);
+		unregister_netdevice(link_ndev);
+		vif->link_ndev[link_num] = NULL;
+	} else {
+		ath12k_err(NULL, "ERR Free Bond dev for SFE. Unregister link netdevice %s link ndev %px link_num %d\n", link_ndev->name, link_ndev, link_num);
+	}
+	mutex_unlock(&vif->bond_mutex);
+	if (!wdev->bond_netdev) {
+		ath12k_info(NULL, "No bond device exists in the ath12k driver for device. SFE\n");
+		return 0;
+	}
+	mldev = bond_get_mlo_ctx(wdev->bond_netdev);
+	if (!test_bit(ATH12K_BOND_REGISTERED, &mldev->bond_state)) {
+		ath12k_err(NULL, "Bond interface destroyed already. Called for the second time.\n");
+		return 0;
+	}
+
+	dummywiphy = mldev->wdev->wiphy;
+	dummywdev = mldev->wdev;
+
+	/* Returns true on success */
+	ret  = bond_destroy_mlo(wdev->bond_netdev);
+	if (ret) {
+		wdev->bond_netdev = NULL;
+		ath12k_info(NULL,"Successfully destroyed bond device\n");
+	} else {
+		ath12k_err(NULL, "Not able destroy bond device %s ret %d\n", wdev->bond_netdev->name, ret);
+		return -EINVAL;
+	}
+	kfree(dummywdev);
+	wiphy_free(dummywiphy);
+	clear_bit(ATH12K_BOND_REGISTERED, &mldev->bond_state);
+	kfree(mldev);
+	return 0;
+}
+
+extern const struct cfg80211_ops mac80211_dummy_config_ops;
+int ath12k_bond_dev_cb(struct wireless_dev *wdev, struct net_device *dev, bool is_register)
+{
+	struct mlo_bond_info *mlo_info = NULL;
+	struct ath12k_mld_dev *mldev = NULL;
+	struct wireless_dev *dummywdev = NULL;
+	int priv_size = 100;
+	char name[20] = {0};
+	struct wiphy *dummywiphy = NULL;
+	bool ret;
+
+	if (!g_bonded_interface_model)
+		return 0;
+
+	if (is_register) {
+		if (wdev->bond_netdev && test_bit(ATH12K_BOND_REGISTERED, &mldev->bond_state)) {
+			ath12k_info(NULL, "Bond device already registered\n");
+			return 0;
+		}
+		mlo_info = kmalloc(sizeof(struct mlo_bond_info), GFP_KERNEL); //TODO: Free
+		if (!mlo_info) {
+			ath12k_err(NULL, "ERR: Couldn't allocate mlo_info\n");
+			return -ENOMEM;
+		}
+		memset(mlo_info, 0, sizeof(struct mlo_bond_info));
+		mldev = kmalloc(sizeof(struct ath12k_mld_dev), GFP_KERNEL);
+		if (!mldev) {
+			ath12k_err(NULL, "ERR: Couldn't allocate mld_dev\n");
+			kfree(mlo_info);
+			return -ENOMEM;
+		}
+		memset(mldev, 0, sizeof(struct ath12k_mld_dev));
+		dummywdev = kmalloc(sizeof(struct wireless_dev), GFP_KERNEL);
+		if (!mldev) {
+			ath12k_err(NULL, "ERR: Couldn't allocate mld_dev\n");
+			kfree(mlo_info);
+			kfree(mldev);
+			return -ENOMEM;
+		}
+		memset(dummywdev, 0, sizeof(struct wireless_dev));
+		dummywiphy = wiphy_new_nm(&mac80211_dummy_config_ops, priv_size, NULL);
+		if (!dummywiphy) {
+			kfree(mlo_info);
+			kfree(mldev);
+			kfree(dummywdev);
+			return -EINVAL;
+		}
+		dummywiphy->interface_modes = BIT(NL80211_IFTYPE_AP) | BIT(NL80211_IFTYPE_DUMMY);
+		mlo_info->wdev = dummywdev;
+		mldev->wdev = dummywdev;
+		mlo_info->wdev->wiphy = dummywiphy;
+		mlo_info->wdev->iftype = NL80211_IFTYPE_DUMMY;
+		mlo_info->bond_mlo_ctx = (void *)mldev;
+		mlo_info->bond_mlo_xmit_netdev = ath12k_dp_mlo_xmit_netdev;
+		mlo_info->bond_get_mlo_tx_netdev = ath12k_dp_get_mlo_tx_netdev ;
+		snprintf(name, sizeof(name), "%s_b", dev->name);
+		wdev->bond_netdev = bond_create_mlo(&init_net, name, mlo_info);
+
+		if (wdev->bond_netdev) {
+			wdev->bond_netdev->max_mtu = IEEE80211_MAX_DATA_LEN;
+			set_bit(ATH12K_BOND_REGISTERED, &mldev->bond_state);
+			ath12k_info(NULL, "Successfully registered bond_netdev %s for netdevice %s\n", wdev->bond_netdev->name, dev->name);
+		} else {
+			ath12k_err(NULL, "ERR: Unnable to register Bonded interface\n");
+		}
+		kfree(mlo_info);
+	} else {
+		//TODO: Cleanup all objects in the allocation path. dummy wdev, wiphy, mldev
+		if (!wdev->bond_netdev) {
+			ath12k_info(NULL, "No bond device exists in the ath12k driver for device %s\n", dev->name);
+			return 0;
+		}
+		mldev = bond_get_mlo_ctx(wdev->bond_netdev);
+		if (!test_bit(ATH12K_BOND_REGISTERED, &mldev->bond_state)) {
+			ath12k_err(NULL, "bond interface destroyed already. Called for the second time.\n");
+			return 0;
+		}
+
+		dummywiphy = mldev->wdev->wiphy;
+		dummywdev = mldev->wdev;
+
+		/* Returns true on success */
+		ret  = bond_destroy_mlo(wdev->bond_netdev);
+		if (ret) {
+			wdev->bond_netdev = NULL;
+			ath12k_info(NULL,"Successfully destroyed bond device\n");
+		} else {
+			ath12k_err(NULL, "Not able destroy bond device %s ret %d\n", wdev->bond_netdev->name, ret);
+			return -EINVAL;
+		}
+		//TODO: Free mlo_info
+		kfree(dummywdev);
+		wiphy_free(dummywiphy);
+		clear_bit(ATH12K_BOND_REGISTERED, &mldev->bond_state);
+		kfree(mldev);
+	}
+	return 0;
+}
--- /dev/null
+++ b/drivers/net/wireless/ath/ath12k/bondif.h
@@ -0,0 +1,44 @@
+// SPDX-License-Identifier: BSD-3-Clause-Clear
+/*
+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __BONDIF_H
+#define __BONDIF_H
+
+#define MAX_MLO_CHIPS 3
+#define MAX_PDEV_PER_SOC 3
+
+#define ATH12K_PPE_DS_2G_CORE_MASK		0x1
+#define ATH12K_PPE_DS_5G_CORE_MASK		0x2
+#define ATH12K_PPE_DS_6G_CORE_MASK		0x4
+#define ATH12K_PPE_DS_DEFAULT_CORE_MASK		0x7
+
+void ath12k_disable_ppe_for_link_netdev(struct ath12k_link_vif *arvif,
+				       struct net_device *link_dev);
+void ath12k_enable_ppe_for_link_netdev(struct ath12k_link_vif *arvif,
+				     struct net_device *link_dev);
+int ath12k_free_bonddev_for_sfe(struct wireless_dev *wdev,
+				struct ieee80211_vif *vif,
+				int link_num);
+int ath12k_bond_link_enslave(struct ath12k_link_vif *arvif, struct net_device *link_dev);
+void ath12k_bond_link_release(struct ath12k_link_vif *arvif);
+enum ath12k_bond_state {
+	ATH12K_BOND_SETUP_INPROGRESS,
+	ATH12K_BOND_REGISTERED,
+	ATH12K_BOND_LINK0_REGISTERED,
+	ATH12K_BOND_LINK1_REGISTERED,
+	ATH12K_BOND_LINK2_REGISTERED,
+
+};
+struct ath12k_mld_dev {
+	struct net_device *netdev;
+	struct ieee80211_vif *vif;
+	struct wireless_dev *wdev; //dummy one for bond registration. Optimize Bond MLO API.
+	struct net_device *link_dev[MAX_MLO_CHIPS][MAX_PDEV_PER_SOC];
+	u8 primary_chipid, primary_pdevid;
+	bool mcast_dev_set;
+	unsigned long bond_state;
+};
+
+#endif //__BONDIF_H
--- a/drivers/net/wireless/ath/ath12k/core.h
+++ b/drivers/net/wireless/ath/ath12k/core.h
@@ -335,6 +335,18 @@ struct ath12k_vif_tcl_desc_template {
 	u32 info4;
 };
 
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+struct ath12k_link_vif_pvt {
+        struct ath12k_link_vif *arvif;
+	struct net_device *link_ndev;
+	struct net_device *bond_dev;
+	struct ieee80211_hw *hw;
+	bool is_started;
+	int ppe_vp_profile_idx;
+	int vp_num;
+};
+#endif
+
 struct ath12k_link_vif {
 	struct ath12k_base *ab;
 	struct ath12k_dp *dp;
@@ -388,6 +400,12 @@ struct ath12k_link_vif {
 	u32 tx_vdev_id;
 	u8 link_id;
 	struct ath12k_vif *ahvif;
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+	struct ath12k_link_vif_pvt *ndev_pvt;
+	struct net_device *link_ndev;
+	int ppe_vp_type;
+	int ppe_vp_num;
+#endif
 
 	bool mvr_processing;
 	bool pending_csa_up;
@@ -1112,6 +1130,10 @@ struct ath12k_soc_dp_stats {
 	u32 fw_tx_status[MAX_FW_TX_STATUS];
 	u32 tx_enqueued[MAX_TCL_RING];
 	u32 tx_completed[MAX_TCL_RING];
+	u32 bond_tx_ucast_enqueued[MAX_TCL_RING];
+	u32 bond_tx_mcast_enqueued[MAX_TCL_RING];
+	u32 bond_tx_ucast_dropped[MAX_TCL_RING];
+	u32 bond_tx_mcast_dropped[MAX_TCL_RING];
 	u32 reo_rx[DP_REO_DST_RING_MAX] [ATH12K_MAX_SOCS];
 	u32 fast_rx[DP_REO_DST_RING_MAX] [ATH12K_MAX_SOCS];
 	u32 non_fast_rx[DP_REO_DST_RING_MAX] [ATH12K_MAX_SOCS];
--- a/drivers/net/wireless/ath/ath12k/dp.c
+++ b/drivers/net/wireless/ath/ath12k/dp.c
@@ -21,6 +21,10 @@
 #define ATH12K_DP_LMAC_PEER_ID_MLO	3
 #define ATH12K_DP_PEER_ROUTING_LMAC_ID_MASK	GENMASK(7,6)
 
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+extern int g_bonded_interface_model;
+#endif
+
 static void ath12k_dp_htt_htc_tx_complete(struct ath12k_base *ab,
 					  struct sk_buff *skb)
 {
@@ -62,6 +66,9 @@ int ath12k_dp_peer_default_route_setup(s
 	u32 reo_dest, param_value;
 	u32 lmac_peer_routing_id = ATH12K_DP_LMAC_PEER_ID_LEGACY;
 	int ret;
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+	struct ath12k_vif *ahvif = arvif->ahvif;
+#endif
 
 	sta = container_of((void *)arsta->ahsta, struct ieee80211_sta, drv_priv);
 
@@ -89,7 +96,8 @@ int ath12k_dp_peer_default_route_setup(s
 		   hweight16(sta->valid_links));
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 	/* keep last - override any PPE DS specific routing config */
-	ath12k_dp_peer_ppeds_route_setup(ar, arvif, arsta);
+	if ((ahvif->vdev_type == WMI_VDEV_TYPE_AP) && !((ahvif->vdev_type == WMI_VDEV_TYPE_AP) && (ahvif->vdev_subtype == WMI_VDEV_SUBTYPE_MESH_11S)))
+		ath12k_dp_peer_ppeds_route_setup(ar, arvif, arsta);
 #endif
 
 	return 0;
@@ -537,6 +545,9 @@ void ath12k_dp_tx_update_bank_profile(st
 	arvif->bank_id = ath12k_dp_tx_get_bank_profile(ab, arvif, dp);
 	arvif->desc.info0 = FIELD_PREP(HAL_TCL_DATA_CMD_INFO0_BANK_ID,
 				       arvif->bank_id);
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+	ath12k_dp_ppeds_update_vp_entry(arvif->ar, arvif);
+#endif
 }
 
 static void ath12k_dp_deinit_bank_profiles(struct ath12k_base *ab)
@@ -1174,11 +1185,15 @@ void ath12k_dp_pdev_pre_alloc(struct ath
 	}
 }
 
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
 static int ath12k_dp_ppe_rxole_rxdma_cfg(struct ath12k_base *ab)
 {
 	struct ath12k_dp_htt_rxdma_ppe_cfg_param param = {0};
 	int ret;
 
+	if (!g_bonded_interface_model)
+		return 0;
+
 	param.override = 1;
 	param.reo_dst_ind = HAL_REO2PPE_DST_IND;
 	param.multi_buffer_msdu_override_en = 0;
@@ -1195,6 +1210,7 @@ static int ath12k_dp_ppe_rxole_rxdma_cfg
 
 	return ret;
 }
+#endif
 
 int ath12k_dp_pdev_alloc(struct ath12k_base *ab)
 {
@@ -1202,12 +1218,14 @@ int ath12k_dp_pdev_alloc(struct ath12k_b
 	int ret;
 	int i;
 
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
 	ret = ath12k_dp_ppe_rxole_rxdma_cfg(ab);
 	if (ret) {
 		ath12k_err(ab, "Failed to send htt RxOLE and RxDMA messages to target :%d\n",
 			   ret);
 		goto out;
 	}
+#endif
 
 	ret = ath12k_dp_rx_htt_setup(ab);
 	if (ret)
@@ -1319,6 +1337,10 @@ void ath12k_dp_vdev_tx_attach(struct ath
 		ath12k_err(ar->ab, "Failed to initialize DP TX Banks");
 		return;
 	}
+
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+	ath12k_dp_ppeds_update_vp_entry(ar, arvif);
+#endif
 }
 
 static void ath12k_dp_cc_cleanup(struct ath12k_base *ab)
--- a/drivers/net/wireless/ath/ath12k/dp_rx.c
+++ b/drivers/net/wireless/ath/ath12k/dp_rx.c
@@ -2767,6 +2767,10 @@ static bool ath12k_dp_rx_check_fast_rx(s
 	if (is_multicast_ether_addr(ehdr->h_dest))
 	        return false;
 
+	/* TODO: make use of hw assisted intra-bss bit in msdu_end
+	 * to skip peer lookup and forward frames directly.
+	 */
+
 	/* check if the msdu needs to be bridged to our connected peer */
 	f_peer = ath12k_peer_find_by_addr(ar->ab, ehdr->h_dest);
 
@@ -2794,10 +2798,12 @@ static void ath12k_dp_rx_h_mpdu(struct a
 	struct ath12k_dp_rx_tid *rx_tid;
 	u32 err_bitmap;
 	u8 tid;
-#ifdef CPTCFG_MAC80211_PPE_SUPPORT
+#if defined(CPTCFG_MAC80211_PPE_SUPPORT) || defined(CPTCFG_ATH12K_BONDED_DS_SUPPORT)
 	int vp;
 #endif
 	struct wireless_dev *wdev = NULL;
+	struct ath12k_vif *ahvif;
+	struct ath12k_link_vif *arvif;
 
 	tid = ath12k_dp_rx_h_tid(ab, rx_desc);
 	/* PN for multicast packets will be checked in mac80211 */
@@ -2828,8 +2834,16 @@ static void ath12k_dp_rx_h_mpdu(struct a
 #endif
 				spin_unlock_bh(&ar->ab->base_lock);
 				ath12k_dp_rx_h_csum_offload(ar, msdu);
-				msdu->dev = wdev->netdev;
-#ifdef CPTCFG_MAC80211_PPE_SUPPORT
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+				ahvif = (struct ath12k_vif *)peer->vif->drv_priv;
+				arvif = ahvif->link[peer->link_id];
+				vp = arvif->ppe_vp_num;
+				if (wdev->bond_netdev)
+					msdu->dev = wdev->bond_netdev;
+				else
+#endif
+					msdu->dev = wdev->netdev;
+#if defined(CPTCFG_MAC80211_PPE_SUPPORT) || defined(CPTCFG_ATH12K_BONDED_DS_SUPPORT)
 				if (vp > 0) {
 					if (likely(ppe_vp_tx_to_ppe(vp, msdu)))
 						return;
@@ -2849,6 +2863,14 @@ static void ath12k_dp_rx_h_mpdu(struct a
 	}
 	spin_unlock_bh(&ar->ab->base_lock);
 
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+	if (peer) {
+		wdev = ieee80211_vif_to_wdev(peer->vif);
+		if (wdev && wdev->bond_netdev)
+			msdu->dev = wdev->bond_netdev;
+	}
+#endif
+
 	*fast_rx = false;
 
 	err_bitmap = ath12k_dp_rx_h_mpdu_err(ab, rx_desc);
@@ -3368,8 +3390,9 @@ int ath12k_dp_rx_pkt_type_filter(struct
 	struct ath12k_wmi_pkt_route_param param;
 	int ret;
 
-	/* Routing Eapol packets to CCE is only allowed now */
-	if (pkt_type != ATH12K_PKT_TYPE_EAP)
+	/* Routing Eapol/ARP packets to CCE is only allowed now */
+	if (pkt_type != ATH12K_PKT_TYPE_EAP &&
+	    pkt_type != ATH12K_PKT_TYPE_ARP_IPV4)
 		return -EINVAL;
 
 	param.opcode = ATH12K_WMI_PKTROUTE_ADD;
--- a/drivers/net/wireless/ath/ath12k/dp_tx.c
+++ b/drivers/net/wireless/ath/ath12k/dp_tx.c
@@ -273,6 +273,7 @@ int ath12k_dp_tx_direct(struct ath12k_li
 	u8 hal_ring_id, ring_id;
 	dma_addr_t paddr;
 	int ret;
+	int len = skb->fast_xmit ? 256 : skb->len;
 
 	ring_id = smp_processor_id();
 
@@ -284,8 +285,8 @@ int ath12k_dp_tx_direct(struct ath12k_li
 		return -ENOSPC;
 	}
 
-	dmac_clean_range_no_dsb(skb->data, skb->data + 256);
-	paddr = dma_map_single_attrs(dev, skb->data, 256,
+	dmac_clean_range_no_dsb(skb->data, skb->data + len);
+	paddr = dma_map_single_attrs(dev, skb->data, len,
 				     DMA_TO_DEVICE, DMA_ATTR_SKIP_CPU_SYNC);
 	if (unlikely(dma_mapping_error(dev, paddr))) {
 		atomic_inc(&ab->soc_stats.tx_err.misc_fail);
@@ -308,7 +309,7 @@ int ath12k_dp_tx_direct(struct ath12k_li
 
 	hal_ring_id = ring_id + HAL_SRNG_RING_ID_SW2TCL1;
 	tcl_ring = &ab->hal.srng_list[hal_ring_id];
-
+	spin_lock_bh(&tcl_ring->lock);
 	ath12k_hal_srng_access_src_ring_begin_nolock(tcl_ring);
 
 	hal_tcl_desc = (void *)ath12k_hal_srng_src_get_next_entry_nolock(ab, tcl_ring);
@@ -317,6 +318,7 @@ int ath12k_dp_tx_direct(struct ath12k_li
 		 * desc because the desc is directly enqueued onto hw queue.
 		 */
 		ath12k_hal_srng_access_umac_src_ring_end_nolock(tcl_ring);
+		spin_unlock_bh(&tcl_ring->lock);
 		ab->soc_stats.tx_err.desc_na[ring_id]++;
 		ret = -ENOMEM;
 		goto fail_unmap_dma;
@@ -352,6 +354,7 @@ int ath12k_dp_tx_direct(struct ath12k_li
 	memcpy(hal_tcl_desc, &tcl_desc, sizeof(tcl_desc));
 	dsb(st);
 	ath12k_hal_srng_access_umac_src_ring_end_nolock(tcl_ring);
+	spin_unlock_bh(&tcl_ring->lock);
 
 	atomic_inc(&ar->dp.num_tx_pending);
 
@@ -591,7 +594,7 @@ int ath12k_dp_tx(struct ath12k *ar, stru
 
 	hal_ring_id = tx_ring->tcl_data_ring.ring_id;
 	tcl_ring = &ab->hal.srng_list[hal_ring_id];
-
+	spin_lock_bh(&tcl_ring->lock);
 	ath12k_hal_srng_access_src_ring_begin_nolock(tcl_ring);
 	hal_tcl_desc = ath12k_hal_srng_src_get_next_entry(ab, tcl_ring);
 	if (unlikely(!hal_tcl_desc)) {
@@ -599,6 +602,7 @@ int ath12k_dp_tx(struct ath12k *ar, stru
 		 * desc because the desc is directly enqueued onto hw queue.
 		 */
 		ath12k_hal_srng_access_umac_src_ring_end_nolock(tcl_ring);
+		spin_unlock_bh(&tcl_ring->lock);
 		ab->soc_stats.tx_err.desc_na[ti.ring_id]++;
 		ret = -ENOMEM;
 
@@ -637,6 +641,7 @@ int ath12k_dp_tx(struct ath12k *ar, stru
 
 	dsb(st);
 	ath12k_hal_srng_access_umac_src_ring_end_nolock(tcl_ring);
+	spin_unlock_bh(&tcl_ring->lock);
 
 	ath12k_dbg_dump(ab, ATH12K_DBG_DP_TX, NULL, "dp tx msdu: ",
 			skb->data, skb->len);
@@ -1184,6 +1189,70 @@ void ath12k_dp_ppeds_tx_comp_get_desc(st
 	}
 }
 
+static void ath12k_ppeds_tx_update_stats(struct ath12k *ar, struct sk_buff *msdu,
+					 struct hal_wbm_release_ring *tx_status)
+{
+	struct ath12k_base *ab = ar->ab;
+	struct ieee80211_tx_info *info;
+	struct ath12k_peer *peer;
+	struct ath12k_link_sta *arsta;
+	struct hal_tx_status ts = { 0 };
+
+	info = IEEE80211_SKB_CB(msdu);
+	memset(&info->status, 0, sizeof(info->status));
+	info->status.rates[0].idx = -1;
+
+	ath12k_dp_tx_status_parse(ab, tx_status, &ts);
+	if (ts.status == HAL_WBM_TQM_REL_REASON_FRAME_ACKED &&
+	    !(info->flags & IEEE80211_TX_CTL_NO_ACK)) {
+		info->flags |= IEEE80211_TX_STAT_ACK;
+		info->status.ack_signal = ATH12K_DEFAULT_NOISE_FLOOR +
+					  ts.ack_rssi;
+		info->status.flags = IEEE80211_TX_STATUS_ACK_SIGNAL_VALID;
+	}
+
+	if (ts.status == HAL_WBM_TQM_REL_REASON_CMD_REMOVE_TX &&
+	    (info->flags & IEEE80211_TX_CTL_NO_ACK))
+		info->flags |= IEEE80211_TX_STAT_NOACK_TRANSMITTED;
+
+	if (ts.status != HAL_WBM_TQM_REL_REASON_FRAME_ACKED) {
+		switch (ts.status) {
+		case HAL_WBM_TQM_REL_REASON_CMD_REMOVE_MPDU:
+		case HAL_WBM_TQM_REL_REASON_DROP_THRESHOLD:
+		case HAL_WBM_TQM_REL_REASON_CMD_REMOVE_AGED_FRAMES:
+		case HAL_WBM_TQM_REL_REASON_CMD_REMOVE_TX:
+			return;
+		default:
+			//TODO: Remove this print and add as a stats
+			ath12k_dbg(ab, ATH12K_DBG_DP_TX, "tx frame is not acked status %d\n", ts.status);
+		}
+	}
+
+	spin_lock_bh(&ab->base_lock);
+
+	peer = ath12k_peer_find_by_id(ab, ts.peer_id);
+	if (unlikely(!peer || !peer->sta)) {
+		ath12k_dbg(ab, ATH12K_DBG_DATA,
+			   "dp_tx: failed to find the peer with peer_id %d\n",
+			   ts.peer_id);
+		spin_unlock_bh(&ab->base_lock);
+		return;
+	}
+
+	arsta = ath12k_peer_get_link_sta(ab, peer);
+	if (!arsta) {
+		ath12k_warn(ab, "link sta not found on peer %pM id %d\n",
+			    peer->addr, peer->peer_id);
+		spin_unlock_bh(&ab->base_lock);
+		return;
+	}
+
+	ieee80211_ppeds_tx_update_stats(ar->ah->hw, peer->sta, info, arsta->txrate,
+					peer->link_id, msdu->len);
+
+	spin_unlock_bh(&ab->base_lock);
+}
+
 int ath12k_ppeds_tx_completion_handler(struct ath12k_base *ab, int budget)
 {
 	struct ath12k_dp *dp = &ab->dp;
@@ -1253,6 +1322,10 @@ int ath12k_ppeds_tx_completion_handler(s
 
 		mac_id = tx_desc->mac_id;
 
+		if (unlikely(!ab->stats_disable))
+			ath12k_ppeds_tx_update_stats(ab->pdevs[mac_id].ar, tx_desc->skb,
+						     tx_status);
+
 		/* Release descriptor as soon as extracting necessary info
 		 * to reduce contention
 		 */
--- a/drivers/net/wireless/ath/ath12k/mac.c
+++ b/drivers/net/wireless/ath/ath12k/mac.c
@@ -23,7 +23,9 @@
 #include "testmode.h"
 #include "peer.h"
 #include "debugfs_sta.h"
-#include "ppe.h"
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+#include "bondif.h"
+#endif
 
 #define CHAN2G(_channel, _freq, _flags) { \
 	.band                   = NL80211_BAND_2GHZ, \
@@ -54,6 +56,14 @@
 
 static void ath12k_mac_remove_link_interface(struct ieee80211_hw *hw,
 					     struct ath12k_link_vif *arvif);
+
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+int ath12k_mac_op_change_vif_links(struct ieee80211_hw *hw,
+					  struct ieee80211_vif *vif,
+					  u16 old_links, u16 new_links,
+					  struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS]);
+extern int g_bonded_interface_model;
+#endif
 static const struct ieee80211_channel ath12k_2ghz_channels[] = {
 	CHAN2G(1, 2412, 0),
 	CHAN2G(2, 2417, 0),
@@ -4775,8 +4785,14 @@ static int ath12k_mac_vdev_delete(struct
 	arvif->is_created = false;
 
 clean_up:
-	arvif->ar = NULL;
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+	if (arvif->link_id != ATH12K_DEFAULT_SCAN_LINK && arvif->ndev_pvt) {
+		ath12k_bond_link_release(arvif);
+		ath12k_disable_ppe_for_link_netdev(arvif, arvif->ndev_pvt->link_ndev);
+	}
+#endif
 
+	arvif->ar = NULL;
 	spin_lock_bh(&ar->data_lock);
 	list_del(&arvif->list);
 	spin_unlock_bh(&ar->data_lock);
@@ -4824,7 +4840,7 @@ void ath12k_mac_unassign_link_vif(struct
 		kfree(arvif);
 }
 
-static struct ath12k_link_vif *
+struct ath12k_link_vif *
 ath12k_mac_assign_link_vif( struct ath12k_hw *ah, struct ieee80211_vif *vif, u8 link_id)
 {
 	struct ath12k_vif *ahvif = (void *)vif->drv_priv;
@@ -5165,8 +5181,10 @@ static int ath12k_mac_op_hw_scan(struct
 	 * delete-create vdev's for the same ar, in case the request is
 	 * always on the same band for the vif
 	 */
-	if (!arvif)
+	if (!arvif) {
+		mutex_unlock(&ah->conf_mutex);
 		return -ENOMEM;
+	}
 
 	if (arvif->is_created) {
 		if (ar != arvif->ar && arvif->is_started) {
@@ -6114,6 +6132,15 @@ static int ath12k_station_assoc(struct a
 		return ret;
 	}
 
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+	ret = ath12k_wmi_set_peer_intra_bss_cmd(ar, arvif->vdev_id, arsta->addr, 1);
+	if (ret) {
+		ath12k_warn(ar->ab, "failed to set vdev %i intra bss enable: %d\n",
+			    arvif->vdev_id, ret);
+		return ret;
+	}
+#endif
+
 	if (!sta->wme) {
 		arvif->num_legacy_stations++;
 		ret = ath12k_recalc_rtscts_prot(arvif);
@@ -8404,6 +8431,18 @@ static void ath12k_mgmt_over_wmi_tx_work
 			continue;
 		}
 
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+               if (arvif->ndev_pvt && arvif->ndev_pvt->link_ndev) {
+                       if (skb->dev->flags & IFF_SLAVE) {
+                               ath12k_warn(ar->ab, "invalid mgmt pkt rcvd for bonded slave iface %s\n",
+                                    skb->dev->name);
+                               ath12k_dbg_dump(ar->ab, ATH12K_DBG_PPE, NULL, "Invalid skb: ",
+                                       skb->data, skb->len);
+                               ath12k_mgmt_over_wmi_tx_drop(ar, skb);
+                               continue;
+                       }
+               }
+#endif
 		mutex_lock(&ar->conf_mutex);
 		if (ar->allocated_vdev_map & (1LL << arvif->vdev_id) &&
 		    arvif->is_started) {
@@ -8815,6 +8854,16 @@ static int ath12k_mac_config_mon_status_
 		tlv_filter = ath12k_mac_mon_status_filter_default;
 		if (ath12k_debugfs_rx_filter(ar))
 			tlv_filter.rx_filter = ath12k_debugfs_rx_filter(ar);
+
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+			if (g_bonded_interface_model &&
+			    test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ar->ab->dev_flags))
+				tlv_filter.rx_filter |= (HTT_RX_FILTER_TLV_FLAGS_PPDU_START |
+							 HTT_RX_FILTER_TLV_FLAGS_PPDU_END_USER_STATS |
+							 HTT_RX_FILTER_TLV_FLAGS_PPDU_END_USER_STATS_EXT |
+							 HTT_RX_FILTER_TLV_FLAGS_PPDU_START_USER_INFO);
+#endif /* CPTCFG_ATH12K_BONDED_DS_SUPPORT */
+
 	}
 
 	tlv_filter.offset_valid = false;
@@ -9054,15 +9103,24 @@ static int ath12k_mac_radio_start(struct
 		}
 	}
 
-	/* PPE DS requires eapol packets to be routed to wbm release ring */
-	if (test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ar->ab->dev_flags)) {
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+	/* program CCE rule for eapol packets to be routed to wbm release ring */
+	if (g_bonded_interface_model) {
 		ret = ath12k_dp_rx_pkt_type_filter(ar, ATH12K_PKT_TYPE_EAP,
 						   ATH12K_ROUTE_EAP_METADATA);
 		if (ret) {
 			ath12k_err(ar->ab, "failed to configure EAP pkt route: %d\n", ret);
 			goto err;
 		}
+
+		ret = ath12k_dp_rx_pkt_type_filter(ar, ATH12K_PKT_TYPE_ARP_IPV4,
+						   ATH12K_ROUTE_ARP_METADATA);
+		if (ret) {
+			ath12k_err(ar->ab, "failed to configure ARP pkt route: %d\n", ret);
+			goto err;
+		}
 	}
+#endif
 
 	__ath12k_set_antenna(ar, ar->cfg_tx_chainmask, ar->cfg_rx_chainmask);
 
@@ -9450,6 +9508,13 @@ static void ath12k_mac_update_vif_offloa
 		vif->offload_flags &= ~(IEEE80211_OFFLOAD_ENCAP_ENABLED |
 					IEEE80211_OFFLOAD_DECAP_ENABLED);
 
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+	if (vif->type == NL80211_IFTYPE_AP && arvif->ndev_pvt
+			&& (hweight16(vif->valid_links) > 1))
+		vif->offload_flags |= (IEEE80211_OFFLOAD_ENCAP_ENABLED |
+					IEEE80211_OFFLOAD_DECAP_ENABLED);
+#endif
+
 	if (vif->offload_flags & IEEE80211_OFFLOAD_ENCAP_ENABLED)
 		ahvif->tx_encap_type = ATH12K_HW_TXRX_ETHERNET;
 	else if (test_bit(ATH12K_FLAG_RAW_MODE, &ag->dev_flags))
@@ -9560,6 +9625,11 @@ static int ath12k_mac_vdev_create(struct
 	struct peer_create_params peer_param = {0};
 	struct ieee80211_bss_conf *link_conf;
 	u32 param_id, param_value;
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+	struct wireless_dev *wdev = ieee80211_vif_to_wdev(vif);
+	struct net_device *link_ndev = NULL;
+	struct ath12k_link_vif_pvt *link_ndev_pvt = NULL;
+#endif
 	u16 nss;
 	int i;
 	int ret, fbret, vdev_id;
@@ -9626,6 +9696,16 @@ static int ath12k_mac_vdev_create(struct
 	arvif->dp = &ab->dp;
 	arvif->dev = ab->dev;
 	arvif->pdev_idx = ar->pdev_idx;
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+	if (arvif->link_id != ATH12K_DEFAULT_SCAN_LINK) {
+		link_ndev = vif->link_ndev[link_id];
+		if (link_ndev) {
+			link_ndev_pvt = netdev_priv(link_ndev);
+			link_ndev_pvt->arvif = arvif;
+			arvif->ndev_pvt = link_ndev_pvt;
+		}
+	}
+#endif
 
 	switch (vif->type) {
 	case NL80211_IFTYPE_UNSPECIFIED:
@@ -9717,6 +9797,20 @@ static int ath12k_mac_vdev_create(struct
 				    arvif->vdev_id, ret);
 			goto err_peer_del;
 		}
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+		if (arvif->link_id != ATH12K_DEFAULT_SCAN_LINK) {
+			if (hweight16(vif->valid_links) <= 1) {
+				ath12k_free_bonddev_for_sfe(wdev, vif, link_id);
+				arvif->ndev_pvt = NULL;
+				arvif->ppe_vp_num = -1;
+			}
+			else if (link_ndev) {
+				ath12k_enable_ppe_for_link_netdev(arvif,
+								 arvif->ndev_pvt->link_ndev);
+				ath12k_bond_link_enslave(arvif, arvif->ndev_pvt->link_ndev);
+			}
+		}
+#endif
 		break;
 	case WMI_VDEV_TYPE_STA:
 		param_id = WMI_STA_PS_PARAM_RX_WAKE_POLICY;
@@ -9785,6 +9879,16 @@ static int ath12k_mac_vdev_create(struct
 	    test_bit(MONITOR_CONF_ENABLED, &ar->monitor_flags))
 		ath12k_mac_monitor_vdev_create(ar);
 
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+	ret = ath12k_wmi_send_vdev_set_intra_bss_cmd(ar, arvif->vdev_id,
+						     1);
+	if (ret) {
+		ath12k_warn(ab, "failed to set vdev %d intra bss enable :%d\n",
+			    arvif->vdev_id, ret);
+		goto err_peer_del;
+	}
+#endif
+
 	ret = ath12k_debugfs_add_interface(arvif);
 	if (ret)
 		goto err_peer_del;
@@ -10304,15 +10408,17 @@ static int ath12k_mac_op_ampdu_action(st
 	return ret;
 }
 
-static int ath12k_mac_op_change_vif_links(struct ieee80211_hw *hw,
-					  struct ieee80211_vif *vif,
-					  u16 old_links, u16 new_links,
-					  struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS])
+#ifndef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+int ath12k_mac_op_change_vif_links(struct ieee80211_hw *hw,
+				   struct ieee80211_vif *vif,
+				   u16 old_links, u16 new_links,
+				   struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS])
 {
 	ath12k_info(NULL,
 		    "link changed for MLD %pM old %d new %d\n", vif->addr, old_links, new_links);
 	return 0;
 }
+#endif
 
 static int ath12k_mac_op_add_chanctx(struct ieee80211_hw *hw,
 				     struct ieee80211_chanctx_conf *ctx)
@@ -12137,6 +12243,7 @@ ath12k_mac_op_assign_vif_chanctx(struct
 	arvif = ath12k_mac_assign_link_vif(ah, vif, link_id);
 	if (!arvif) {
 		ath12k_err(NULL, "unable to allocate link vif\n");
+		mutex_unlock(&ah->conf_mutex);
 		return -ENOMEM;
 	}
 
@@ -14133,10 +14240,6 @@ static const struct ieee80211_ops ath12k
 #endif
 	.get_txpower			= ath12k_mac_op_get_txpower,
 	.set_radar_background		= ath12k_mac_op_set_radar_background,
-#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
-	.ppeds_attach_vdev		= ath12k_mac_op_ppeds_attach_vdev,
-	.ppeds_detach_vdev		= ath12k_mac_op_ppeds_detach_vdev,
-#endif
 };
 
 static void ath12k_mac_update_ch_list(struct ath12k *ar,
@@ -15320,6 +15423,9 @@ int ath12k_mac_allocate(struct ath12k_hw
 			goto err_mac_destroy;
 		}
 
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+		ieee80211_enable_bond_dev(hw);
+#endif
 		ah = hw->priv;
 		ah->hw = hw;
 		ah->ops = ops;
--- a/drivers/net/wireless/ath/ath12k/pci.c
+++ b/drivers/net/wireless/ath/ath12k/pci.c
@@ -65,6 +65,15 @@ EXPORT_SYMBOL(ath12k_napi_poll_budget);
 module_param_named(napi_budget, ath12k_napi_poll_budget, uint, 0644);
 MODULE_PARM_DESC(napi_budget, "Napi budget processing per rx intr");
 
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+extern int ath12k_mlo_capable;
+extern int g_bonded_interface_model;
+extern unsigned int ath12k_ppe_ds_enabled;
+
+extern int ath12k_bond_dev_cb(struct wireless_dev *wdev, struct net_device *dev, bool is_register);
+extern int (*driver_bond_dev_cb)(struct wireless_dev *wdev, struct net_device *dev, bool is_register);
+#endif
+
 static const struct pci_device_id ath12k_pci_id_table[] = {
 	{ PCI_VDEVICE(QCOM, QCN9274_DEVICE_ID) },
 	{ PCI_VDEVICE(QCOM, WCN7850_DEVICE_ID) },
@@ -1369,7 +1378,24 @@ static int ath12k_pci_probe(struct pci_d
 	struct ath12k_pci *ab_pci;
 	u32 soc_hw_version_major, soc_hw_version_minor, addr;
 	int ret;
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+	if (ath12k_frame_mode == ATH12K_HW_TXRX_RAW ||
+	    ath12k_frame_mode == ATH12K_HW_TXRX_NATIVE_WIFI) {
+		ath12k_mlo_capable = 1;
+	}
+
+	if (ath12k_mlo_capable == 2) {
+		ath12k_mlo_capable = 1;
+		g_bonded_interface_model = ath12k_mlo_capable;
+		ath12k_ppe_ds_enabled = 1;
+		driver_bond_dev_cb = ath12k_bond_dev_cb;
+	} else if (ath12k_mlo_capable == 1 && g_bonded_interface_model != 1){
+ 		g_bonded_interface_model = 0;
+ 		driver_bond_dev_cb = NULL;
+ 	}
 
+	ath12k_info(NULL, "g_bonded_interface_model %d ath12k_mlo_capable %d \n", g_bonded_interface_model, ath12k_mlo_capable);
+#endif
 	ab = ath12k_core_alloc(&pdev->dev, sizeof(*ab_pci), ATH12K_BUS_PCI,
 			       &ath12k_pci_bus_params);
 	if (!ab) {
@@ -1588,4 +1614,8 @@ int ath12k_pci_init(void)
 void ath12k_pci_exit(void)
 {
 	pci_unregister_driver(&ath12k_pci_driver);
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+ 	g_bonded_interface_model = 0;
+ 	driver_bond_dev_cb = NULL;
+#endif
 }
--- a/drivers/net/wireless/ath/ath12k/ppe.c
+++ b/drivers/net/wireless/ath/ath12k/ppe.c
@@ -13,10 +13,15 @@
 #include <ppe_drv_sc.h>
 #include <linux/dma-mapping.h>
 #include <asm/cacheflush.h>
+#include <net/bonding.h>
 #include "hif.h"
 #include "ppe.h"
 
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+extern int g_bonded_interface_model;
+#endif
 static atomic_t num_ppeds_nodes;
+
 extern struct sk_buff *
 ath12k_dp_ppeds_tx_release_desc_nolock(struct ath12k_dp *dp,
 				struct ath12k_ppeds_tx_desc_info *tx_desc,
@@ -430,14 +435,49 @@ void ath12k_dp_peer_ppeds_route_setup(st
 				      struct ath12k_link_sta *arsta)
 {
 	struct ath12k_base *ab = ar->ab;
+	struct ath12k_link_vif *primary_link_arvif;
+	struct ath12k_vif *ahvif = arvif->ahvif;
 	u32 service_code = PPE_DRV_SC_SPF_BYPASS;
 	int ppe_routing_enable = 1;
-	u32 priority_valid = 0, src_info = arvif->vif->ppe_vp_num;
+	u32 priority_valid = 0, src_info = arvif->ppe_vp_num;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+
+	if (!g_bonded_interface_model)
+		return;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
 
-	if (!test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags) ||
-	    src_info == -1)
+	/* In SLO AP, DS is not supported */
+	if (hweight16(ahvif->vif->valid_links) <= 1)
 		return;
 
+	/* When SLO STA is associated to AP link vif which does not have DS rings,
+ 	 * do not enable DS.
+	 */
+	if (!sta->mlo && !test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags))
+		return;
+
+	/* If STA is MLO capable but primary link does not support DS,
+	 * disable DS routing on RX.
+	 */
+	if (sta->mlo) {
+		primary_link_arvif = arvif->ahvif->link[ahsta->assoc_link_id];
+
+		if (primary_link_arvif->ppe_vp_num == -1 ||
+		    primary_link_arvif->ppe_vp_type != PPE_VP_USER_TYPE_DS) {
+			ath12k_info(ab,
+				    "Primary link %d does not support DS "
+				    "Disabling DS routing on RX for peer %pM\n",
+				    ahsta->assoc_link_id, arsta->addr);
+			return;
+		}
+
+		if (arvif->ppe_vp_num == -1 ||
+		    arvif->ppe_vp_type != PPE_VP_USER_TYPE_DS)
+			src_info = primary_link_arvif->ppe_vp_num;
+	}
+
 	ath12k_wmi_config_peer_ppeds_routing(ar, arsta->addr, arvif->vdev_id,
 			service_code, priority_valid, src_info,
 			ppe_routing_enable);
@@ -455,8 +495,6 @@ static int ath12k_dp_ppeds_alloc_ppe_vp_
 		return -ENOSR;
 	}
 
-	ab->num_ppe_vp_profiles++;
-
 	for (i = 0; i < PPE_VP_ENTRIES_MAX; i++) {
 		if (!ab->dp.ppe_vp_profile[i].is_configured)
 			break;
@@ -464,8 +502,10 @@ static int ath12k_dp_ppeds_alloc_ppe_vp_
 
 	if (i == PPE_VP_ENTRIES_MAX) {
 		WARN_ONCE(1, "All ppe vp profile entries are in use!");
+		mutex_unlock(&ab->ppe_vp_tbl_lock);
 		return -ENOSR;
 	}
+	ab->num_ppe_vp_profiles++;
 
 	ab->dp.ppe_vp_profile[i].is_configured = true;
 	*vp_profile = &ab->dp.ppe_vp_profile[i];
@@ -507,8 +547,6 @@ static int ath12k_dp_ppeds_alloc_vp_tbl_
 		return -ENOSR;
 	}
 
-	ab->num_ppe_vp_entries++;
-
 	for (i = 0; i < PPE_VP_ENTRIES_MAX; i++) {
 		if (!ab->ppe_vp_tbl_registered[i])
 			break;
@@ -519,7 +557,8 @@ static int ath12k_dp_ppeds_alloc_vp_tbl_
 		return -ENOSR;
 	}
 
-	ab->ppe_vp_tbl_registered[i] = true;
+	ab->num_ppe_vp_entries++;
+	ab->ppe_vp_tbl_registered[i] = 1;
 	mutex_unlock(&ab->ppe_vp_tbl_lock);
 
 	return i;
@@ -544,7 +583,7 @@ static void ath12k_dp_ppeds_dealloc_vp_t
 		return;
 	}
 
-	ab->ppe_vp_tbl_registered[ppe_vp_num_idx] = false;
+	ab->ppe_vp_tbl_registered[ppe_vp_num_idx] = 0;
 	ab->num_ppe_vp_entries--;
 	mutex_unlock(&ab->ppe_vp_tbl_lock);
 }
@@ -560,7 +599,6 @@ static int ath12k_dp_ppeds_alloc_vp_sear
 		return -ENOSR;
 	}
 
-	ab->num_ppe_vp_search_idx_entries++;
 
 	for (i = 0; i < PPE_VP_ENTRIES_MAX; i++) {
 		if (!ab->ppe_vp_search_idx_tbl_set[i])
@@ -572,7 +610,8 @@ static int ath12k_dp_ppeds_alloc_vp_sear
 		return -ENOSR;
 	}
 
-	ab->ppe_vp_search_idx_tbl_set[i] = true;
+	ab->num_ppe_vp_search_idx_entries++;
+	ab->ppe_vp_search_idx_tbl_set[i] = 1;
 	mutex_unlock(&ab->ppe_vp_tbl_lock);
 
 	return i;
@@ -596,7 +635,7 @@ ath12k_dp_ppeds_dealloc_vp_search_idx_tb
 		return;
 	}
 
-	ab->ppe_vp_search_idx_tbl_set[ppe_vp_search_idx] = false;
+	ab->ppe_vp_search_idx_tbl_set[ppe_vp_search_idx] = 0;
 	ab->num_ppe_vp_search_idx_entries--;
 	mutex_unlock(&ab->ppe_vp_tbl_lock);
 
@@ -639,38 +678,65 @@ static void ath12k_dp_ppeds_setup_vp_ent
 	return;
 }
 
-int ath12k_mac_op_ppeds_attach_vdev(struct ieee80211_hw *hw,
-				struct ieee80211_vif *vif,
+void ath12k_dp_ppeds_update_vp_entry(struct ath12k *ar,
+				     struct ath12k_link_vif *arvif)
+{
+	struct ath12k_base *ab = ar->ab;
+	struct ath12k_link_vif_pvt *link_ndev_pvt = arvif->ndev_pvt;
+	struct ath12k_dp_ppe_vp_profile *vp_profile;
+	int ppe_vp_profile_idx;
+
+	if (!test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags))
+		return;
+
+	if (!ab->ppeds_handle) {
+		ath12k_dbg(ab, ATH12K_DBG_PPE, "DS not enabled on this chip\n");
+		return;
+	}
+
+	if (!link_ndev_pvt) {
+		ath12k_dbg(ab, ATH12K_DBG_PPE, "link netdevice not present for arvif\n");
+		return;
+	}
+
+	ppe_vp_profile_idx = link_ndev_pvt->ppe_vp_profile_idx;
+	vp_profile = &ab->dp.ppe_vp_profile[ppe_vp_profile_idx];
+	if (!vp_profile) {
+		ath12k_dbg(ab, ATH12K_DBG_PPE, "vp profile not present for arvif\n");
+		return;
+	}
+
+	ath12k_dp_ppeds_setup_vp_entry(ab, arvif->ar, arvif, vp_profile);
+}
+
+int ath12k_mac_op_ppeds_attach_vdev(struct ath12k_link_vif *arvif,
 				void *vp_arg, int *ppe_vp_num,
 				struct ieee80211_ppe_vp_ds_params *vp_params)
 {
-	struct ath12k_hw *ah = hw->priv;
-	struct ath12k_vif *ahvif = (void *)vif->drv_priv;
 	//TODO: handle MLO
-	struct ath12k_link_vif *arvif = &ahvif->link[0];
-	struct ath12k *ar = ah->radio;
+	struct ath12k *ar = arvif->ar;
 	//TODO: Handle split phy
 	struct ath12k_base *ab = ar->ab;
 	struct ath12k_dp_ppe_vp_profile *vp_profile = NULL;
-	int ppe_vp_profile_idx, ppe_vp_idx, vp_num;
+	struct ath12k_link_vif_pvt *link_ndev_pvt = NULL;
+	int ppe_vp_profile_idx, ppe_vp_tbl_idx, vp_num;
 	int ppe_vp_search_tbl_idx = -1;
 	int vdev_id = arvif->vdev_id;
 	int ret;
 
-	if (!test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags)) {
-		ppe_vp_num = -1;
+	if (!test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags))
 		return -ENOSR;
-	}
 
 	if (!ab->ppeds_handle) {
 		ath12k_err(ab, "DS not enabled on this chip\n");
 		return -EINVAL;
 	}
 
-	if (vif->type != NL80211_IFTYPE_AP) {
+	if (arvif->ahvif->vif->type != NL80211_IFTYPE_AP) {
 		return -EINVAL;
 	}
 
+	link_ndev_pvt = netdev_priv(vp_params->dev);
 	vp_num = ppe_ds_wlan_vp_alloc(ab->ppeds_handle, vp_params->dev, vp_arg);
 	if (vp_num < 0) {
 		ath12k_err(ab," vp alloc failed\n");
@@ -685,14 +751,14 @@ int ath12k_mac_op_ppeds_attach_vdev(stru
 		goto vp_free;
 	}
 
-	ppe_vp_idx = ath12k_dp_ppeds_alloc_vp_tbl_entry(ab);
-	if (ppe_vp_idx < 0) {
+	ppe_vp_tbl_idx = ath12k_dp_ppeds_alloc_vp_tbl_entry(ab);
+	if (ppe_vp_tbl_idx < 0) {
 		ath12k_err(ab, "Failed to allocate PPE VP idx for vdev_id:%d", vdev_id);
 		ret = -ENOSR;
 		goto dealloc_vp_profile;
 	}
 
-	if (vif->type == NL80211_IFTYPE_STATION) {
+	if (arvif->ahvif->vif->type == NL80211_IFTYPE_STATION) {
 		ppe_vp_search_tbl_idx = ath12k_dp_ppeds_alloc_vp_search_idx_tbl_entry(ab);
 		if (ppe_vp_search_tbl_idx < 0) {
 			ath12k_err(ab,
@@ -704,19 +770,23 @@ int ath12k_mac_op_ppeds_attach_vdev(stru
 	}
 
 	vp_profile->vp_num = vp_num;
-	vp_profile->ppe_vp_num_idx = ppe_vp_idx;
+	vp_profile->ppe_vp_num_idx = ppe_vp_tbl_idx;
 	vp_profile->to_fw = 0;
 	vp_profile->use_ppe_int_pri = 0;
 	vp_profile->drop_prec_enable = 0;
+	vp_profile->arvif = arvif;
 
 	/* For the sta mode fill up the index reg number */
 	ath12k_dp_ppeds_setup_vp_entry(ab, ar, arvif, vp_profile);
 
 	vp_params->ppe_vp_profile_idx = ppe_vp_profile_idx;
 	*ppe_vp_num = vp_num;
-	ath12k_dbg(ab, ATH12K_DBG_PPE,
-		   "PPEDS vdev attach success vpnum %d ppe_vp_idx %d ppe_vp_profile_idx %d\n",
-		   vp_num, ppe_vp_idx, ppe_vp_profile_idx);
+	ath12k_info(ab,
+		   "PPEDS vdev attach success chip_id %d vdev_id %d vpnum %d ppe_vp_profile_idx %d"
+		   "ppe_vp_tbl_idx %d to_fw %d int_pri %d prec_en %d search_idx_reg_num %d\n",
+		   ab->chip_id, vdev_id, vp_num, ppe_vp_profile_idx, ppe_vp_tbl_idx, vp_profile->to_fw,
+		   vp_profile->use_ppe_int_pri, vp_profile->drop_prec_enable,
+		   vp_profile->search_idx_reg_num);
 
 	return 0;
 
@@ -730,22 +800,17 @@ vp_free:
 	return ret;
 }
 
-void ath12k_mac_op_ppeds_detach_vdev(struct ieee80211_hw *hw,
-				     struct ieee80211_vif *vif,
+void ath12k_mac_op_ppeds_detach_vdev(struct ath12k_link_vif *arvif,
 				     struct ieee80211_ppe_vp_ds_params *vp_params)
 {
-	struct ath12k_hw *ah = hw->priv;
-	struct ath12k *ar = ah->radio;
+	struct ath12k *ar = arvif->ar;
 	struct ath12k_base *ab = ar->ab;
-	struct ath12k_vif *ahvif = (void *)vif->drv_priv;
-	struct ath12k_link_vif *arvif = &ahvif->link[0];
 	struct ath12k_dp_ppe_vp_profile *vp_profile;
 	int ppe_vp_profile_idx = -1;
 
 	if (!test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags))
 		return;
 
-	ath12k_dbg(ab, ATH12K_DBG_PPE, "PPEDS vdev detach\n");
 	ppe_vp_profile_idx = vp_params->ppe_vp_profile_idx;
 
 	vp_profile = &ab->dp.ppe_vp_profile[ppe_vp_profile_idx];
@@ -759,7 +824,7 @@ void ath12k_mac_op_ppeds_detach_vdev(str
 	ath12k_dbg(ab, ATH12K_DBG_PPE, "ppe_ds_wlan_vp_free\n");
 
 	/* For STA mode ast index table reg also needs to be cleaned */
-	if (vif->type == NL80211_IFTYPE_STATION)
+	if (arvif->ahvif->vif->type == NL80211_IFTYPE_STATION)
 		ath12k_dp_ppeds_dealloc_vp_search_idx_tbl_entry(ab, vp_profile->search_idx_reg_num);
 
 	ath12k_dp_ppeds_dealloc_vp_tbl_entry(ab, vp_profile->ppe_vp_num_idx);
--- a/drivers/net/wireless/ath/ath12k/ppe.h
+++ b/drivers/net/wireless/ath/ath12k/ppe.h
@@ -6,16 +6,6 @@
 #ifndef ATH12K_PPE_H
 #define ATH12K_PPE_H
 
-struct ath12k_dp_ppe_vp_profile {
-        bool is_configured;
-        u8 vp_num;
-        u8 ppe_vp_num_idx;
-        u8 search_idx_reg_num;
-        u8 drop_prec_enable;
-        u8 to_fw;
-        u8 use_ppe_int_pri;
-};
-
 #define ATH12K_PPEDS_DEFAULT_POOL_ID 0
 
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
@@ -26,18 +16,18 @@ void ath12k_dp_ppeds_stop(struct ath12k_
 int ath12k_dp_ppeds_start(struct ath12k_base *ab);
 int ath12k_ppeds_detach( struct ath12k_base *ab);
 int ath12k_ppeds_attach( struct ath12k_base *ab);
-int ath12k_mac_op_ppeds_attach_vdev(struct ieee80211_hw *hw,
-				       struct ieee80211_vif *vif,
-				       void *vp_arg, int *ppe_vp_num,
-				       struct ieee80211_ppe_vp_ds_params *vp_params);
-void ath12k_mac_op_ppeds_detach_vdev(struct ieee80211_hw *hw,
-				     struct ieee80211_vif *vif,
-				     struct ieee80211_ppe_vp_ds_params *vp_params);
+int ath12k_mac_op_ppeds_attach_vdev(struct ath12k_link_vif *arvif,
+                                void *vp_arg, int *ppe_vp_num,
+                                struct ieee80211_ppe_vp_ds_params *vp_params);
+void ath12k_mac_op_ppeds_detach_vdev(struct ath12k_link_vif *arvif,
+                                     struct ieee80211_ppe_vp_ds_params *vp_params);
 void ath12k_dp_peer_ppeds_route_setup(struct ath12k *ar, struct ath12k_link_vif *arvif,
 				      struct ath12k_link_sta *arsta);
 void *ath12k_dp_get_ppe_ds_ctxt(struct ath12k_base *ab);
 irqreturn_t ath12k_ds_ppe2tcl_irq_handler(int irq, void *ctxt);
 irqreturn_t ath12k_ds_reo2ppe_irq_handler(int irq, void *ctxt);
 irqreturn_t ath12k_dp_ppeds_handle_tx_comp(int irq, void *ctxt);
+void ath12k_dp_ppeds_update_vp_entry(struct ath12k *ar,
+				     struct ath12k_link_vif *arvif);
 #endif
 #endif
--- a/drivers/net/wireless/ath/ath6kl/cfg80211.c
+++ b/drivers/net/wireless/ath/ath6kl/cfg80211.c
@@ -3824,7 +3824,7 @@ struct wireless_dev *ath6kl_interface_ad
 
 	netdev_set_default_ethtool_ops(ndev, &ath6kl_ethtool_ops);
 
-	if (cfg80211_register_netdevice(ndev))
+	if (cfg80211_register_netdevice(ndev, 0))
 		goto err;
 
 	ar->avail_idx_map &= ~BIT(fw_vif_idx);
--- a/drivers/net/wireless/ath/wil6210/netdev.c
+++ b/drivers/net/wireless/ath/wil6210/netdev.c
@@ -432,7 +432,7 @@ int wil_vif_add(struct wil6210_priv *wil
 		if (rc)
 			return rc;
 	}
-	rc = cfg80211_register_netdevice(ndev);
+	rc = cfg80211_register_netdevice(ndev, 0);
 	if (rc < 0) {
 		dev_err(&ndev->dev, "Failed to register netdev: %d\n", rc);
 		if (any_active && vif->mid != 0)
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -6064,6 +6064,7 @@ struct wireless_dev {
 	/* the remainder of this struct should be private to cfg80211 */
 	struct list_head list;
 	struct net_device *netdev;
+	struct net_device *bond_netdev;
 
 	u32 identifier;
 
@@ -8748,7 +8749,7 @@ void cfg80211_unregister_wdev(struct wir
  *
  * Requires the RTNL and wiphy mutex to be held.
  */
-int cfg80211_register_netdevice(struct net_device *dev);
+int cfg80211_register_netdevice(struct net_device *dev, bool mlo_bond_dev);
 
 /**
  * cfg80211_unregister_netdevice - unregister the given netdev
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -1965,7 +1965,11 @@ struct ieee80211_vif {
 
 	bool txqs_stopped[IEEE80211_NUM_ACS];
 	bool noqueue_enable;
-
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	bool bond_init;
+	struct mutex bond_mutex;
+	struct net_device *link_ndev[IEEE80211_MLD_MAX_NUM_LINKS];
+#endif
 #ifdef CPTCFG_MAC80211_PPE_SUPPORT
 	int ppe_vp_num;
 	unsigned long ppe_vp_type;
@@ -4715,6 +4719,10 @@ struct ieee80211_hw *ieee80211_alloc_hw(
 	return ieee80211_alloc_hw_nm(priv_data_len, ops, NULL);
 }
 
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+void ieee80211_enable_bond_dev(struct ieee80211_hw *hw);
+#endif
+
 /**
  * ieee80211_register_hw - Register hardware device
  *
@@ -4936,6 +4944,11 @@ void ieee80211_rx_list(struct ieee80211_
 		       struct sk_buff *skb, struct sk_buff_head *list);
 #endif
 
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+void ieee80211_rx_update_stats(struct ieee80211_hw *hw, struct ieee80211_sta *pubsta,
+			       int link_id, u32 len, struct ieee80211_rx_status *status);
+#endif /* CPTCFG_MAC80211_BONDED_SUPPORT */
+
 /**
  * ieee80211_rx_napi - receive frame from NAPI context
  *
@@ -5314,6 +5327,32 @@ void ieee80211_tx_status_8023(struct iee
 			       struct ieee80211_vif *vif,
 			       struct sk_buff *skb);
 
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+/**
+ * ieee80211_ppeds_tx_update_stats - update tx stats for PPE DS path
+ *
+ * Call this function for all transmitted data frames after their transmit
+ * completion. This callback should only be called for data frames which
+ * are using driver's (or hardware's) offload capability of encap/decap
+ * 802.11 frames.
+ *
+ * This function may not be called in IRQ context. Calls to this function
+ * for a single hardware must be synchronized against each other and all
+ * calls in the same tx status family.
+ *
+ * @hw: the hardware the frame was transmitted by
+ * @pubsta: the station to update the tx rate for.
+ * @info: tx status information
+ * @rate: tx rate information
+ * @link_id: link id
+ * @len: length
+ */
+void ieee80211_ppeds_tx_update_stats(struct ieee80211_hw *hw,
+				     struct ieee80211_sta *pubsta,
+				     struct ieee80211_tx_info *info,
+				     struct rate_info rate, int link_id, u32 len);
+#endif /* CPTCFG_MAC80211_BONDED_SUPPORT */
+
 /**
  * ieee80211_report_low_ack - report non-responding station
  *
@@ -6294,6 +6333,15 @@ struct ieee80211_sta *ieee80211_find_sta
 					       const u8 *localaddr);
 
 /**
+ * ieee80211_sta_get_dvlan_iface - get dynamic vlan interface
+ *
+ * @pubsta: the station
+ *
+ * Return: The interface if found. %NULL otherwire.
+ */
+struct net_device *ieee80211_sta_get_dvlan_iface(struct ieee80211_sta *pubsta);
+
+/**
  * ieee80211_sta_block_awake - block station from waking up
  * @hw: the hardware
  * @pubsta: the station
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@ -3498,6 +3498,9 @@ enum nl80211_iftype {
 	NL80211_IFTYPE_P2P_DEVICE,
 	NL80211_IFTYPE_OCB,
 	NL80211_IFTYPE_NAN,
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	NL80211_IFTYPE_DUMMY,
+#endif
 
 	/* keep last */
 	NUM_NL80211_IFTYPES,
--- a/local-symbols
+++ b/local-symbols
@@ -67,6 +67,7 @@ MAC80211_DEBUG_COUNTERS=
 MAC80211_STA_HASH_MAX_SIZE=
 MAC80211_NSS_SUPPORT=
 MAC80211_PPE_SUPPORT=
+MAC80211_BONDED_SUPPORT=
 WLAN=
 PCMCIA_RAYCS=
 PCMCIA_WL3501=
@@ -144,3 +145,4 @@ ATH12K_TRACING=
 ATH12K_SPECTRAL=
 ATH12K_PKTLOG=
 ATH12K_PPE_DS_SUPPORT=
+ATH12K_BONDED_DS_SUPPORT=
--- a/net/mac80211/Kconfig
+++ b/net/mac80211/Kconfig
@@ -122,6 +122,24 @@ config MAC80211_PPE_SUPPORT
 
 	  If unsure, say N.
 
+config MAC80211_BONDED_SUPPORT
+	bool "QTI mac80211 bonded support"
+	depends on ATH12K
+	default n
+	---help---
+	  Enables Bonded support for ATH12K driver
+
+	  If unsure, say N.
+
+config MAC80211_BONDED_SUPPORT
+	bool "QTI mac80211 bonded support"
+	depends on ATH12K
+	default n
+	---help---
+	  Enables Bonded support for ATH12K driver
+
+	  If unsure, say N.
+
 config MAC80211_NOINLINE
 	bool "Do not inline TX/RX handlers"
 	depends on MAC80211_DEBUG_MENU
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -201,7 +201,11 @@ static struct wireless_dev *ieee80211_ad
 	struct ieee80211_sub_if_data *sdata;
 	int err;
 
-	err = ieee80211_if_add(local, name, name_assign_type, &wdev, type, params);
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	err = ieee80211_if_add(local, name, name_assign_type, &wdev, type, params, true);
+#else
+	err = ieee80211_if_add(local, name, name_assign_type, &wdev, type, params, false);
+#endif
 	if (err)
 		return ERR_PTR(err);
 
@@ -225,6 +229,26 @@ static int ieee80211_del_iface(struct wi
 	return 0;
 }
 
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+static struct wireless_dev *ieee80211_dummy_add_iface(struct wiphy *wiphy,
+                                                const char *name,
+                                                unsigned char name_assign_type,
+                                                enum nl80211_iftype type,
+                                                struct vif_params *params)
+{
+	return NULL;
+}
+static int ieee80211_dummy_del_iface(struct wiphy *wiphy, struct wireless_dev *wdev)
+{
+	return -EINVAL;
+}
+const struct cfg80211_ops mac80211_dummy_config_ops = {
+        .add_virtual_intf = ieee80211_dummy_add_iface,
+        .del_virtual_intf = ieee80211_dummy_del_iface,
+};
+EXPORT_SYMBOL(mac80211_dummy_config_ops);
+#endif
+
 static int ieee80211_change_iface(struct wiphy *wiphy,
 				  struct net_device *dev,
 				  enum nl80211_iftype type,
@@ -549,6 +573,10 @@ static int ieee80211_add_key(struct wiph
 	}
 
 	switch (sdata->vif.type) {
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	case NL80211_IFTYPE_DUMMY:
+		return 0;
+#endif
 	case NL80211_IFTYPE_STATION:
 		if (sdata->u.mgd.mfp != IEEE80211_MFP_DISABLED)
 			key->conf.flags |= IEEE80211_KEY_FLAG_RX_MGMT;
@@ -1759,9 +1787,23 @@ static int ieee80211_stop_ap(struct wiph
 
 	ieee80211_free_next_beacon(link);
 
+ #ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	if (sdata->wdev.bond_netdev && sdata->wdev.bond_netdev->flags & IFF_UP) {
+		netif_stop_queue(sdata->wdev.bond_netdev);
+		netif_carrier_off(sdata->wdev.bond_netdev);
+		sdata->wdev.bond_netdev->flags &= ~IFF_UP;
+	}
+
+	if (sdata->vif.link_ndev[link_id]) {
+		netif_stop_queue(sdata->vif.link_ndev[link_id]);
+		netif_carrier_off(sdata->vif.link_ndev[link_id]);
+	}
+#endif
+
 	/* turn off carrier for this interface and dependent VLANs */
 	list_for_each_entry(vlan, &sdata->u.ap.vlans, u.vlan.list)
 		netif_carrier_off(vlan->dev);
+
 	netif_carrier_off(dev);
 
 	/* remove beacon and probe response */
--- a/net/mac80211/chan.c
+++ b/net/mac80211/chan.c
@@ -294,6 +294,10 @@ ieee80211_get_chanctx_vif_max_required_b
 			continue;
 
 		switch (vif->type) {
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+		case NL80211_IFTYPE_DUMMY:
+			return 0;
+#endif
 		case NL80211_IFTYPE_AP:
 		case NL80211_IFTYPE_AP_VLAN:
 			width = ieee80211_get_max_required_bw(sdata, link_id);
@@ -1231,6 +1235,10 @@ ieee80211_link_chanctx_reservation_compl
 	struct ieee80211_sub_if_data *sdata = link->sdata;
 
 	switch (sdata->vif.type) {
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	case NL80211_IFTYPE_DUMMY:
+		return;
+#endif
 	case NL80211_IFTYPE_ADHOC:
 	case NL80211_IFTYPE_AP:
 	case NL80211_IFTYPE_MESH_POINT:
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -26,6 +26,9 @@
 #include <linux/idr.h>
 #include <linux/rhashtable.h>
 #include <linux/rbtree.h>
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+#include <net/bonding.h>
+#endif
 #include <net/ieee80211_radiotap.h>
 #include <net/cfg80211.h>
 #include <net/mac80211.h>
@@ -1982,7 +1985,7 @@ void ieee80211_iface_exit(void);
 int ieee80211_if_add(struct ieee80211_local *local, const char *name,
 		     unsigned char name_assign_type,
 		     struct wireless_dev **new_wdev, enum nl80211_iftype type,
-		     struct vif_params *params);
+		     struct vif_params *params, bool mlo_bond_dev);
 int ieee80211_if_change_type(struct ieee80211_sub_if_data *sdata,
 			     enum nl80211_iftype type);
 void ieee80211_if_remove(struct ieee80211_sub_if_data *sdata);
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@ -417,6 +417,16 @@ static void ieee80211_do_stop(struct iee
 	/*
 	 * Stop TX on this interface first.
 	 */
+ #ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	for_each_set_bit(link_id, &sdata->vif.valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		if (sdata->vif.link_ndev[link_id])
+			netif_tx_stop_all_queues(sdata->vif.link_ndev[link_id]);
+	}
+
+	if (sdata->wdev.bond_netdev)
+		netif_tx_stop_all_queues(sdata->wdev.bond_netdev);
+ #endif
+
 	if (sdata->dev)
 		netif_tx_stop_all_queues(sdata->dev);
 
@@ -769,10 +779,24 @@ static int ieee80211_stop(struct net_dev
 #ifdef CPTCFG_MAC80211_PPE_SUPPORT
 	struct ieee80211_ppe_vp_ds_params vp_params = {0};
 #endif
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	int link_id;
+#endif
 
 	/* close dependent VLAN interfaces before locking wiphy */
 	if (sdata->vif.type == NL80211_IFTYPE_AP) {
 		struct ieee80211_sub_if_data *vlan, *tmpsdata;
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+			for_each_set_bit(link_id, &sdata->vif.valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+				if (sdata->vif.link_ndev[link_id])
+					dev_close(sdata->vif.link_ndev[link_id]);
+			}
+
+			if (sdata->wdev.bond_netdev) {
+				if (sdata->wdev.bond_netdev)
+					dev_close(sdata->wdev.bond_netdev);
+		         }
+#endif
 
 		list_for_each_entry_safe(vlan, tmpsdata, &sdata->u.ap.vlans,
 					 u.vlan.list)
@@ -787,7 +811,7 @@ static int ieee80211_stop(struct net_dev
 #endif
 
 #ifdef CPTCFG_MAC80211_PPE_SUPPORT
-	if (sdata->vif.ppe_vp_num != -1) {
+	if (ppe_vp_accel && sdata->vif.ppe_vp_num != -1) {
 		drv_ppeds_detach_vdev(sdata, &sdata->vif, &vp_params);
 		if (sdata->vif.ppe_vp_type != PPE_VP_USER_TYPE_DS)
 			ppe_vp_free(sdata->vif.ppe_vp_num);
@@ -1448,6 +1472,11 @@ int ieee80211_do_open(struct wireless_de
 		/* cannot happen */
 		WARN_ON(1);
 		break;
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	case NL80211_IFTYPE_DUMMY:
+		return 0;
+		break;
+#endif
 	}
 
 	if (local->open_count == 0) {
@@ -1947,6 +1976,11 @@ static void ieee80211_setup_sdata(struct
 
 	/* and set some type-dependent values */
 	sdata->vif.type = type;
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	mutex_init(&sdata->vif.bond_mutex);
+	sdata->vif.bond_init = true;
+#endif
+
 	sdata->vif.p2p = false;
 #ifdef CPTCFG_MAC80211_PPE_SUPPORT
 	sdata->vif.ppe_vp_num = -1;
@@ -2025,6 +2059,10 @@ static void ieee80211_setup_sdata(struct
 	case NUM_NL80211_IFTYPES:
 		WARN_ON(1);
 		break;
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	case NL80211_IFTYPE_DUMMY:
+		return;
+#endif
 	}
 
 	/* need to do this after the switch so vif.type is correct */
@@ -2288,7 +2326,7 @@ static void ieee80211_assign_perm_addr(s
 int ieee80211_if_add(struct ieee80211_local *local, const char *name,
 		     unsigned char name_assign_type,
 		     struct wireless_dev **new_wdev, enum nl80211_iftype type,
-		     struct vif_params *params)
+		     struct vif_params *params, bool mlo_bond_dev)
 {
 	struct net_device *ndev = NULL;
 	struct ieee80211_sub_if_data *sdata = NULL;
@@ -2461,7 +2499,7 @@ int ieee80211_if_add(struct ieee80211_lo
 #endif
 		}
 
-		ret = cfg80211_register_netdevice(ndev);
+		ret = cfg80211_register_netdevice(ndev, mlo_bond_dev);
 		if (ret) {
 			free_netdev(ndev);
 			return ret;
@@ -2492,7 +2530,9 @@ void ieee80211_if_remove(struct ieee8021
 	synchronize_rcu();
 
 	cfg80211_unregister_wdev(&sdata->wdev);
-
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	mutex_destroy(&sdata->vif.bond_mutex);
+#endif
 	if (!sdata->dev) {
 		ieee80211_teardown_sdata(sdata);
 		kfree(sdata);
--- a/net/mac80211/main.c
+++ b/net/mac80211/main.c
@@ -630,6 +630,17 @@ static const struct ieee80211_vht_cap ma
 	},
 };
 
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+void cfg80211_enable_bond_dev(struct wiphy *wiphy);
+void ieee80211_enable_bond_dev(struct ieee80211_hw *hw)
+{
+	struct wiphy *wiphy = hw->wiphy;
+	cfg80211_enable_bond_dev(wiphy);
+
+}
+EXPORT_SYMBOL(ieee80211_enable_bond_dev);
+#endif
+
 struct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len,
 					   const struct ieee80211_ops *ops,
 					   const char *requested_name)
@@ -1494,8 +1505,14 @@ int ieee80211_register_hw(struct ieee802
 	    !ieee80211_hw_check(hw, NO_AUTO_VIF)) {
 		struct vif_params params = {0};
 
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+		result = ieee80211_if_add(local, "wlan%d", NET_NAME_ENUM, NULL,
+					  NL80211_IFTYPE_STATION, &params, true);
+#else
 		result = ieee80211_if_add(local, "wlan%d", NET_NAME_ENUM, NULL,
-					  NL80211_IFTYPE_STATION, &params);
+					  NL80211_IFTYPE_STATION, &params, false);
+#endif
+
 		if (result)
 			wiphy_warn(local->hw.wiphy,
 				   "Failed to add default virtual iface\n");
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@ -2354,7 +2354,7 @@ void ieee80211_dfs_cac_timer_work(struct
 			     dfs_cac_timer_work);
 	struct cfg80211_chan_def chandef = link->conf->chandef;
 	struct ieee80211_sub_if_data *sdata = link->sdata;
-
+	rtnl_lock();
 	mutex_lock(&sdata->local->mtx);
 
 	if (sdata->wdev.links[link->link_id].cac_started) {
@@ -2365,6 +2365,7 @@ void ieee80211_dfs_cac_timer_work(struct
 	}
 
 	mutex_unlock(&sdata->local->mtx);
+	rtnl_unlock();
 }
 
 static bool
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -2727,6 +2727,9 @@ static void ieee80211_netif_rx_ppe(struc
 out:
 	skb->protocol = eth_type_trans(skb, sdata->dev);
 	skb->dev = sdata->dev;
+	if (sdata->wdev.bond_netdev)
+		skb->dev = sdata->wdev.bond_netdev;
+
 	if (rx->napi)
 		napi_gro_receive(rx->napi, skb);
 	else
@@ -4793,6 +4796,59 @@ void ieee80211_check_fast_rx_iface(struc
 	mutex_unlock(&local->sta_mtx);
 }
 
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+void ieee80211_rx_update_stats(struct ieee80211_hw *hw, struct ieee80211_sta *pubsta,
+			       int link_id, u32 len, struct ieee80211_rx_status *status)
+{
+	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
+	struct link_sta_info *link_sta;
+	struct ieee80211_sta_rx_stats *stats;
+
+	rcu_read_lock();
+	if (link_id >= 0) {
+		link_sta = rcu_dereference(sta->link[link_id]);
+		if (WARN_ON_ONCE(!link_sta)) {
+			rcu_read_unlock();
+			return;
+		}
+	} else {
+		link_sta = &sta->deflink;
+	}
+
+	stats = &link_sta->rx_stats;
+
+	if (!(status->flag & RX_FLAG_NO_SIGNAL_VAL)) {
+		stats->last_signal = status->signal;
+	}
+
+	if (status->chains) {
+		int i;
+
+		stats->chains = status->chains;
+		for (i = 0; i < ARRAY_SIZE(status->chain_signal); i++) {
+			int signal = status->chain_signal[i];
+
+			if (!(status->chains & BIT(i)))
+				continue;
+
+			stats->chain_signal_last[i] = signal;
+		}
+	}
+
+	stats->last_rx = jiffies;
+	stats->last_rate = sta_stats_encode_rate(status);
+
+	stats->fragments++;
+	stats->packets++;
+
+	u64_stats_update_begin(&stats->syncp);
+	stats->bytes += len;
+	u64_stats_update_end(&stats->syncp);
+	rcu_read_unlock();
+}
+EXPORT_SYMBOL(ieee80211_rx_update_stats);
+#endif /* CPTCFG_MAC80211_BONDED_SUPPORT */
+
 static void ieee80211_rx_8023(struct ieee80211_rx_data *rx,
 			      struct ieee80211_fast_rx *fast_rx,
 			      int orig_len)
@@ -4802,6 +4858,9 @@ static void ieee80211_rx_8023(struct iee
 	struct sta_info *sta = rx->sta;
 	struct link_sta_info *link_sta;
 	struct sk_buff *skb = rx->skb;
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	struct wireless_dev *wdev = NULL;
+#endif
 	void *sa = skb->data + ETH_ALEN;
 	void *da = skb->data;
 
@@ -4852,6 +4911,12 @@ static void ieee80211_rx_8023(struct iee
 	stats->packets++;
 
 	skb->dev = fast_rx->dev;
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	wdev = (struct wireless_dev *)fast_rx->dev->ieee80211_ptr;
+	if (wdev && wdev->bond_netdev) {
+		skb->dev = wdev->bond_netdev;
+	}
+#endif
 
 	ieee80211_rx_stats(fast_rx->dev, skb->len);
 
@@ -4894,7 +4959,7 @@ static void ieee80211_rx_8023(struct iee
 	}
 
 #ifdef CPTCFG_MAC80211_PPE_SUPPORT
-	if (rx->sdata->vif.ppe_vp_num) {
+	if (rx->sdata->vif.ppe_vp_num != -1) {
 		ieee80211_netif_rx_ppe(rx, skb);
 		atomic_inc(&sta->rx_netif_pkts);
 		return;
@@ -4902,6 +4967,10 @@ static void ieee80211_rx_8023(struct iee
 #endif
 	/* deliver to local stack */
 	skb->protocol = eth_type_trans(skb, fast_rx->dev);
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	if (wdev->bond_netdev)
+		skb->dev = wdev->bond_netdev;
+#endif
 	ieee80211_deliver_skb_to_local_stack(skb, rx);
 }
 
--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@ -2415,6 +2415,10 @@ static int ieee80211_reconfig_link_bss(s
 		changed |= BSS_CHANGED_MU_GROUPS;
 
 	switch (sdata->vif.type) {
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	case NL80211_IFTYPE_DUMMY:
+		return 0;
+#endif
 	case NL80211_IFTYPE_STATION:
 		changed |= BSS_CHANGED_PS;
 		changed &= ~BSS_CHANGED_IDLE;
@@ -4410,9 +4414,11 @@ ieee80211_dfs_radar_detected_processing(
 	}
 	mutex_unlock(&local->chanctx_mtx);
 
+	rtnl_lock();
 	wiphy_lock(local->hw.wiphy);
 	ieee80211_dfs_cac_cancel(local);
 	wiphy_unlock(local->hw.wiphy);
+	rtnl_unlock();
 
 	if (radar_chandef)
 		radar_chandef->radar_bitmap = radar_bitmap;
--- a/net/wireless/chan.c
+++ b/net/wireless/chan.c
@@ -683,6 +683,10 @@ int cfg80211_chandef_dfs_required(struct
 		return -EINVAL;
 
 	switch (iftype) {
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	case NL80211_IFTYPE_DUMMY:
+		return 0;
+#endif
 	case NL80211_IFTYPE_ADHOC:
 	case NL80211_IFTYPE_AP:
 	case NL80211_IFTYPE_P2P_GO:
@@ -865,6 +869,10 @@ bool cfg80211_beaconing_iface_active(str
 	ASSERT_WDEV_LOCK(wdev);
 
 	switch (wdev->iftype) {
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	case NL80211_IFTYPE_DUMMY:
+		return true;
+#endif
 	case NL80211_IFTYPE_AP:
 	case NL80211_IFTYPE_P2P_GO:
 		for_each_valid_link(wdev, link) {
--- a/net/wireless/core.c
+++ b/net/wireless/core.c
@@ -22,6 +22,9 @@
 #include <linux/etherdevice.h>
 #include <linux/rtnetlink.h>
 #include <linux/sched.h>
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+#include <net/bonding.h>
+#endif
 #include <net/genetlink.h>
 #include <net/cfg80211.h>
 #include "nl80211.h"
@@ -54,6 +57,16 @@ module_param(cfg80211_disable_40mhz_24gh
 MODULE_PARM_DESC(cfg80211_disable_40mhz_24ghz,
 		 "Disable 40MHz support in the 2.4GHz band");
 
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+int g_bonded_interface_model = 0;
+module_param(g_bonded_interface_model, bool, 0644);
+MODULE_PARM_DESC(g_bonded_interface_model, "g_bonded_interface_model");
+EXPORT_SYMBOL(g_bonded_interface_model);
+
+int (*driver_bond_dev_cb)(struct wireless_dev *wdev, struct net_device *dev, bool is_register);
+EXPORT_SYMBOL(driver_bond_dev_cb);
+#endif
+
 struct cfg80211_registered_device *cfg80211_rdev_by_wiphy_idx(int wiphy_idx)
 {
 	struct cfg80211_registered_device *result = NULL, *rdev;
@@ -70,6 +83,15 @@ struct cfg80211_registered_device *cfg80
 	return result;
 }
 
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+void cfg80211_enable_bond_dev(struct wiphy *wiphy)
+{
+	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+	rdev->enable_bond_dev = 1;
+}
+EXPORT_SYMBOL(cfg80211_enable_bond_dev);
+#endif
+
 int get_wiphy_idx(struct wiphy *wiphy)
 {
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
@@ -1322,6 +1344,9 @@ static void _cfg80211_unregister_wdev(st
 {
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
 	unsigned int link_id;
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	bool skip_bond_netdev = false;
+#endif
 
 	ASSERT_RTNL();
 	lockdep_assert_held(&rdev->wiphy.mtx);
@@ -1336,6 +1361,19 @@ static void _cfg80211_unregister_wdev(st
 		sysfs_remove_link(&wdev->netdev->dev.kobj, "phy80211");
 		if (unregister_netdev)
 			unregister_netdevice(wdev->netdev);
+
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+		if (wdev->bond_netdev) {
+			if (wdev->iftype == NL80211_IFTYPE_MESH_POINT ||
+			    wdev->iftype == NL80211_IFTYPE_MONITOR ||
+				rdev->enable_bond_dev == 0 || wdev->iftype == NL80211_IFTYPE_STATION)
+				skip_bond_netdev = true;
+			if (!skip_bond_netdev &&
+			    g_bonded_interface_model && driver_bond_dev_cb) {
+				(*driver_bond_dev_cb)(wdev, wdev->netdev, false);
+			}
+		}
+#endif
 	}
 
 	list_del_rcu(&wdev->list);
@@ -1423,6 +1461,10 @@ void __cfg80211_leave(struct cfg80211_re
 	cfg80211_stop_background_radar_detection(wdev);
 
 	switch (wdev->iftype) {
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	case NL80211_IFTYPE_DUMMY:
+		return;
+#endif
 	case NL80211_IFTYPE_ADHOC:
 		__cfg80211_leave_ibss(rdev, dev, true);
 		break;
@@ -1556,22 +1598,29 @@ void cfg80211_register_wdev(struct cfg80
 	if (wdev->netdev &&
 	    sysfs_create_link(&wdev->netdev->dev.kobj, &rdev->wiphy.dev.kobj,
 			      "phy80211"))
-		pr_err("failed to add phy80211 symlink to netdev!\n");
+		pr_err("failed to add phy80211 symlink to netdev! name %s\n", wdev->netdev->name);
 
 	nl80211_notify_iface(rdev, wdev, NL80211_CMD_NEW_INTERFACE);
 }
 
-int cfg80211_register_netdevice(struct net_device *dev)
+int cfg80211_register_netdevice(struct net_device *dev, bool create_bond_dev)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	struct cfg80211_registered_device *rdev;
 	int ret;
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	bool skip_bond_netdev = false;
+#endif
 
 	ASSERT_RTNL();
 
 	if (WARN_ON(!wdev))
 		return -EINVAL;
 
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	if (wdev->iftype == NL80211_IFTYPE_DUMMY && !wdev->wiphy)
+		return 0;
+#endif
 	rdev = wiphy_to_rdev(wdev->wiphy);
 
 	lockdep_assert_held(&rdev->wiphy.mtx);
@@ -1584,6 +1633,18 @@ int cfg80211_register_netdevice(struct n
 		goto out;
 
 	cfg80211_register_wdev(rdev, wdev);
+
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	if (wdev->iftype == NL80211_IFTYPE_MESH_POINT ||
+	     wdev->iftype == NL80211_IFTYPE_MONITOR ||
+		 rdev->enable_bond_dev == 0 || wdev->iftype == NL80211_IFTYPE_STATION)
+		skip_bond_netdev = true;
+
+	if (!skip_bond_netdev && g_bonded_interface_model &&
+	    create_bond_dev && driver_bond_dev_cb) {
+		(*driver_bond_dev_cb)(wdev, dev, true);
+	}
+#endif
 	ret = 0;
 out:
 	wdev->registering = false;
@@ -1604,6 +1665,11 @@ static int cfg80211_netdev_notifier_call
 	if (!wdev)
 		return NOTIFY_DONE;
 
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	if (wdev->iftype == NL80211_IFTYPE_DUMMY && !wdev->wiphy)
+		return 0;
+#endif
+
 	rdev = wiphy_to_rdev(wdev->wiphy);
 
 	WARN_ON(wdev->iftype == NL80211_IFTYPE_UNSPECIFIED);
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -1608,6 +1608,10 @@ static int nl80211_key_allowed(struct wi
 	ASSERT_WDEV_LOCK(wdev);
 
 	switch (wdev->iftype) {
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	case NL80211_IFTYPE_DUMMY:
+		return 0;
+#endif
 	case NL80211_IFTYPE_AP:
 	case NL80211_IFTYPE_AP_VLAN:
 	case NL80211_IFTYPE_P2P_GO:
@@ -10528,6 +10532,7 @@ static int nl80211_start_radar_detection
 
 	flush_delayed_work(&rdev->dfs_update_channels_wk);
 
+	rtnl_lock();
 	wiphy_lock(wiphy);
 	wdev_lock(wdev);
 
@@ -10614,6 +10619,7 @@ static int nl80211_start_radar_detection
 unlock:
 	wdev_unlock(wdev);
 	wiphy_unlock(wiphy);
+	rtnl_unlock();
 
 	return err;
 }
@@ -16972,9 +16978,16 @@ nl80211_remove_link_station(struct sk_bu
 		 NL80211_FLAG_NEED_RTNL)		\
 	SELECTOR(__sel, NETDEV_UP,			\
 		 NL80211_FLAG_NEED_NETDEV_UP)		\
+	SELECTOR(__sel, NETDEV_UP_RTNL,			\
+		 NL80211_FLAG_NEED_RTNL |		\
+		 NL80211_FLAG_NEED_NETDEV_UP)		\
 	SELECTOR(__sel, NETDEV_UP_LINK,			\
 		 NL80211_FLAG_NEED_NETDEV_UP |		\
 		 NL80211_FLAG_MLO_VALID_LINK_ID)	\
+	SELECTOR(__sel, NETDEV_UP_LINK_RTNL,			\
+		 NL80211_FLAG_NEED_NETDEV_UP |		\
+		 NL80211_FLAG_NEED_RTNL |		\
+		 NL80211_FLAG_MLO_VALID_LINK_ID)	\
 	SELECTOR(__sel, NETDEV_UP_LINK_NOMTX,		\
 		 NL80211_FLAG_NEED_NETDEV_UP |		\
 		 NL80211_FLAG_NO_WIPHY_MTX |		\
@@ -17006,7 +17019,13 @@ nl80211_remove_link_station(struct sk_bu
 		 NL80211_FLAG_NEED_RTNL)		\
 	SELECTOR(__sel, WIPHY_CLEAR,			\
 		 NL80211_FLAG_NEED_WIPHY |		\
-		 NL80211_FLAG_CLEAR_SKB)
+		 NL80211_FLAG_CLEAR_SKB)		\
+	SELECTOR(__sel, NETDEV_UP_LINK_NOMTX_RTNL,	\
+		 NL80211_FLAG_NEED_NETDEV_UP |		\
+		 NL80211_FLAG_NEED_RTNL	|		\
+		 NL80211_FLAG_NO_WIPHY_MTX |		\
+		 NL80211_FLAG_MLO_VALID_LINK_ID)
+
 
 enum nl80211_internal_flags_selector {
 #define SELECTOR(_, name, value)	NL80211_IFL_SEL_##name,
@@ -17369,6 +17388,7 @@ static const struct genl_small_ops nl802
 		.flags = GENL_UNS_ADMIN_PERM,
 		.doit = nl80211_start_ap,
 		.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |
+					 NL80211_FLAG_NEED_RTNL |
 					 NL80211_FLAG_MLO_VALID_LINK_ID),
 	},
 	{
@@ -17377,6 +17397,7 @@ static const struct genl_small_ops nl802
 		.flags = GENL_UNS_ADMIN_PERM,
 		.doit = nl80211_stop_ap,
 		.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |
+					 NL80211_FLAG_NEED_RTNL |
 					 NL80211_FLAG_MLO_VALID_LINK_ID),
 	},
 	{
@@ -17498,7 +17519,7 @@ static const struct genl_small_ops nl802
 		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
 		.doit = nl80211_trigger_scan,
 		.flags = GENL_UNS_ADMIN_PERM,
-		.internal_flags = IFLAGS(NL80211_FLAG_NEED_WDEV_UP),
+		.internal_flags = IFLAGS(NL80211_FLAG_NEED_WDEV_UP | NL80211_FLAG_NEED_RTNL),
 	},
 	{
 		.cmd = NL80211_CMD_ABORT_SCAN,
@@ -18077,13 +18098,15 @@ static const struct genl_small_ops nl802
 		.cmd = NL80211_CMD_ADD_LINK,
 		.doit = nl80211_add_link,
 		.flags = GENL_UNS_ADMIN_PERM,
-		.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),
+		.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |
+					 NL80211_FLAG_NEED_RTNL),
 	},
 	{
 		.cmd = NL80211_CMD_REMOVE_LINK,
 		.doit = nl80211_remove_link,
 		.flags = GENL_UNS_ADMIN_PERM,
 		.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |
+					 NL80211_FLAG_NEED_RTNL |
 					 NL80211_FLAG_MLO_VALID_LINK_ID),
 	},
 	{
@@ -18091,6 +18114,7 @@ static const struct genl_small_ops nl802
 		.doit = nl80211_add_link_station,
 		.flags = GENL_UNS_ADMIN_PERM,
 		.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |
+					 NL80211_FLAG_NEED_RTNL |
 					 NL80211_FLAG_MLO_VALID_LINK_ID),
 	},
 	{
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -1113,6 +1113,10 @@ int cfg80211_change_iface(struct cfg8021
 	if (!err) {
 		dev->priv_flags &= ~IFF_DONT_BRIDGE;
 		switch (ntype) {
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+		case NL80211_IFTYPE_DUMMY:
+			return 0;
+#endif
 		case NL80211_IFTYPE_STATION:
 			if (dev->ieee80211_ptr->use_4addr)
 				break;
--- a/drivers/net/wireless/ath/ath12k/dp.h
+++ b/drivers/net/wireless/ath/ath12k/dp.h
@@ -369,7 +369,7 @@ struct host_link_stats {
 #define PPE_VP_ENTRIES_MAX 32
 #define MAX_PPEDS_IRQ_NAME_LEN 20
 #define MAX_PPEDS_IRQS 3
-struct dp_ppe_vp_profile {
+struct ath12k_dp_ppe_vp_profile {
 	bool is_configured;
 	u8 vp_num;
 	u8 ppe_vp_num_idx;
@@ -377,6 +377,7 @@ struct dp_ppe_vp_profile {
 	u8 drop_prec_enable;
 	u8 to_fw;
 	u8 use_ppe_int_pri;
+	struct ath12k_link_vif *arvif;
 };
 #endif
 
@@ -449,7 +450,7 @@ struct ath12k_dp {
 	/* protects the free and used desc lists */
 	spinlock_t ppeds_tx_desc_lock[ATH12K_HW_MAX_QUEUES_PPEDS];
 
-	struct dp_ppe_vp_profile ppe_vp_profile[PPE_VP_ENTRIES_MAX];
+	struct ath12k_dp_ppe_vp_profile ppe_vp_profile[PPE_VP_ENTRIES_MAX];
 	char ppeds_irq_name[MAX_PPEDS_IRQS][MAX_PPEDS_IRQ_NAME_LEN];
 	int ppeds_irq[MAX_PPEDS_IRQS];
 #endif
--- a/drivers/net/wireless/ath/ath12k/dp_rx.h
+++ b/drivers/net/wireless/ath/ath12k/dp_rx.h
@@ -40,6 +40,7 @@ enum ath12k_routing_pkt_type {
 #define ATH12K_RX_PROTOCOL_TAG_START_OFFSET  128
 #define ATH12K_ROUTE_WBM_RELEASE        3
 #define ATH12K_ROUTE_EAP_METADATA       (ATH12K_RX_PROTOCOL_TAG_START_OFFSET + ATH12K_PKT_TYPE_EAP)
+#define ATH12K_ROUTE_ARP_METADATA       (ATH12K_RX_PROTOCOL_TAG_START_OFFSET + ATH12K_PKT_TYPE_ARP_IPV4)
 
 struct ath12k_dp_rx_tid {
 	u8 tid;
--- a/drivers/net/wireless/ath/ath12k/hal.c
+++ b/drivers/net/wireless/ath/ath12k/hal.c
@@ -358,6 +358,13 @@ static u8 ath12k_hw_qcn9274_rx_desc_get_
 			    RX_MSDU_END_INFO5_TID);
 }
 
+static u8 ath12k_hw_qcn9274_rx_desc_get_msdu_intra_bss_bit(struct hal_rx_desc *desc)
+{
+	/* TODO - msdu_end info9 */
+	return 0;
+}
+
+
 static u16 ath12k_hw_qcn9274_rx_desc_get_mpdu_peer_id(struct hal_rx_desc *desc)
 {
 	return le16_get_bits(desc->u.qcn9274.mpdu_start.sw_peer_id,
@@ -696,6 +703,7 @@ const struct hal_ops hal_qcn9274_ops = {
 	.rx_desc_get_msdu_payload = ath12k_hw_qcn9274_rx_desc_get_msdu_payload,
 	.rx_desc_get_mpdu_start_offset = ath12k_hw_qcn9274_rx_desc_get_mpdu_start_offset,
 	.rx_desc_get_msdu_end_offset = ath12k_hw_qcn9274_rx_desc_get_msdu_end_offset,
+	.rx_desc_get_msdu_intra_bss_bit = ath12k_hw_qcn9274_rx_desc_get_msdu_intra_bss_bit,
 	.rx_desc_mac_addr2_valid = ath12k_hw_qcn9274_rx_desc_mac_addr2_valid,
 	.rx_desc_mpdu_start_addr2 = ath12k_hw_qcn9274_rx_desc_mpdu_start_addr2,
 	.rx_desc_is_mcbc = ath12k_hw_qcn9274_rx_desc_is_mcbc,
--- a/drivers/net/wireless/ath/ath12k/hal.h
+++ b/drivers/net/wireless/ath/ath12k/hal.h
@@ -1127,6 +1127,7 @@ struct hal_ops {
 	u8 *(*rx_desc_get_msdu_payload)(struct hal_rx_desc *desc);
 	u32 (*rx_desc_get_mpdu_start_offset)(void);
 	u32 (*rx_desc_get_msdu_end_offset)(void);
+	u8 (*rx_desc_get_msdu_intra_bss_bit)(struct hal_rx_desc *desc);
 	bool (*rx_desc_mac_addr2_valid)(struct hal_rx_desc *desc);
 	u8* (*rx_desc_mpdu_start_addr2)(struct hal_rx_desc *desc);
 	bool (*rx_desc_is_mcbc)(struct hal_rx_desc *desc);
--- a/drivers/net/wireless/ath/ath12k/rx_desc.h
+++ b/drivers/net/wireless/ath/ath12k/rx_desc.h
@@ -691,7 +691,7 @@ enum rx_msdu_start_reception_type {
 
 #define RX_MSDU_END_INFO9_SERVICE_CODE		GENMASK(14, 6)
 #define RX_MSDU_END_INFO9_PRIORITY_VALID	BIT(15)
-#define RX_MSDU_END_INFO9_INRA_BSS		BIT(16)
+#define RX_MSDU_END_INFO9_INTRA_BSS		BIT(16)
 #define RX_MSDU_END_INFO9_DEST_CHIP_ID		GENMASK(18, 17)
 #define RX_MSDU_END_INFO9_MCAST_ECHO		BIT(19)
 #define RX_MSDU_END_INFO9_WDS_LEARN_EVENT	BIT(20)
--- a/drivers/net/wireless/ath/ath12k/wmi.c
+++ b/drivers/net/wireless/ath/ath12k/wmi.c
@@ -1455,7 +1455,72 @@ int ath12k_wmi_config_peer_ppeds_routing
 
 	return ret;
 }
-#endif
+
+int
+ath12k_wmi_send_vdev_set_intra_bss_cmd(struct ath12k *ar,
+				       u32 vdev_id, u32 enable)
+{
+	struct ath12k_pdev_wmi *wmi = ar->wmi;
+	struct ath12k_vdev_set_intra_bss_cmd *cmd;
+	struct sk_buff *skb;
+	int ret;
+
+	skb = ath12k_wmi_alloc_skb(wmi->wmi_ab, sizeof(struct ath12k_vdev_set_intra_bss_cmd));
+	if (!skb)
+		return -ENOMEM;
+
+	cmd = (struct ath12k_vdev_set_intra_bss_cmd *)skb->data;
+	cmd->tlv_header = ath12k_wmi_tlv_cmd_hdr(WMI_TAG_VDEV_SET_INTRA_BSS_PARAMS,
+						 sizeof(*cmd));
+	cmd->vdev_id = vdev_id;
+	cmd->enable = enable;
+
+	ret = ath12k_wmi_cmd_send(wmi, skb, WMI_VDEV_SET_INTRA_BSS_CMDID);
+	if (ret) {
+		ath12k_warn(ar->ab,
+			    "failed to send WMI_VDEV_SET_INTRA_BSS_CMDID\n");
+		dev_kfree_skb(skb);
+	}
+
+	ath12k_dbg(ar->ab, ATH12K_DBG_WMI,
+		   "WMI vdev id 0x%x set inra bss %s\n",
+		   vdev_id, enable?"enable":"disable");
+
+	return ret;
+}
+
+int ath12k_wmi_set_peer_intra_bss_cmd(struct ath12k *ar, u32 vdev_id, const u8 *peer_addr,
+				      u32 enable)
+{
+	struct ath12k_pdev_wmi *wmi = ar->wmi;
+	struct wmi_peer_set_intra_bss_cmd *cmd;
+	struct sk_buff *skb;
+	int ret;
+
+	skb = ath12k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));
+	if (!skb)
+		return -ENOMEM;
+
+	cmd = (struct wmi_peer_set_intra_bss_param_cmd *)skb->data;
+	cmd->tlv_header = ath12k_wmi_tlv_cmd_hdr(WMI_TAG_PEER_SET_INTRA_BSS_PARAMS,
+						 sizeof(*cmd));
+	ether_addr_copy(cmd->peer_macaddr.addr, peer_addr);
+	cmd->vdev_id = cpu_to_le32(vdev_id);
+	cmd->enable = cpu_to_le32(enable);
+
+	ret = ath12k_wmi_cmd_send(wmi, skb, WMI_PEER_SET_INTRA_BSS_CMDID);
+	if (ret) {
+		ath12k_warn(ar->ab, "failed to send WMI_PEER_SET_INTRA_BSS_CMD\n");
+		dev_kfree_skb(skb);
+	}
+
+	ath12k_dbg(ar->ab, ATH12K_DBG_WMI,
+		   "WMI vdev %d peer 0x%pM set intra_bss %s\n",
+		   vdev_id, peer_addr, enable ? "enable" : "disable");
+
+	return ret;
+}
+#endif /* CPTCFG_ATH12K_PPE_DS_SUPPORT */
 
 int ath12k_wmi_send_pdev_pkt_route(struct ath12k *ar,
 				   struct ath12k_wmi_pkt_route_param *param)
--- a/drivers/net/wireless/ath/ath12k/wmi.h
+++ b/drivers/net/wireless/ath/ath12k/wmi.h
@@ -395,6 +395,8 @@ enum wmi_tlv_cmd_id {
         WMI_VDEV_GET_BIG_DATA_P2_CMDID,
         /** set TPC PSD/non-PSD power */
         WMI_VDEV_SET_TPC_POWER_CMDID,
+	WMI_VDEV_IGMP_OFFLOAD_CMDID,
+	WMI_VDEV_SET_INTRA_BSS_CMDID,
 	WMI_PEER_CREATE_CMDID = WMI_TLV_CMD(WMI_GRP_PEER),
 	WMI_PEER_DELETE_CMDID,
 	WMI_PEER_FLUSH_TIDS_CMDID,
@@ -426,6 +428,7 @@ enum wmi_tlv_cmd_id {
 	WMI_PEER_UNMAP_RESPONSE_CMDID,
 	WMI_PEER_CONFIG_VLAN_CMDID,
 	WMI_PEER_CONFIG_PPE_DS_CMDID,
+	WMI_PEER_SET_INTRA_BSS_CMDID,
 	WMI_BCN_TX_CMDID = WMI_TLV_CMD(WMI_GRP_MGMT),
 	WMI_PDEV_SEND_BCN_CMDID,
 	WMI_BCN_TMPL_CMDID,
@@ -2044,6 +2047,8 @@ enum wmi_tlv_tag {
 	WMI_TAG_MLO_PEER_CREATE_PARAMS = 0x3D5,
 	WMI_TAG_MLO_VDEV_START_PARAMS = 0x3D6,
 	WMI_TAG_MLO_VDEV_CREATE_PARAMS = 0x3D7,
+	WMI_TAG_VDEV_SET_INTRA_BSS_PARAMS = 0x3EE,
+	WMI_TAG_PEER_SET_INTRA_BSS_PARAMS,
 	WMI_TAG_PDEV_PKTLOG_DECODE_INFO = 0x414,
 	WMI_TAG_SPECTRAL_SCAN_BW_CAPABILITIES,
 	WMI_TAG_SPECTRAL_FFT_SIZE_CAPABILITIES,
@@ -3672,6 +3677,21 @@ struct wmi_peer_set_param_cmd {
 	__le32 param_value;
 } __packed;
 
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+struct wmi_peer_set_intra_bss_cmd {
+	__le32 tlv_header;
+	struct wmi_mac_addr peer_macaddr;
+	__le32 vdev_id;
+	__le32 enable;
+} __packed;
+
+struct ath12k_vdev_set_intra_bss_cmd {
+    u32 tlv_header;
+    u32 vdev_id;
+    u32 enable;
+} __packed;
+#endif
+
 struct wmi_peer_flush_tids_cmd {
 	__le32 tlv_header;
 	__le32 vdev_id;
@@ -8417,6 +8437,13 @@ int
 ath12k_mgmt_rx_reo_init_context(struct ath12k_base *ab);
 int
 ath12k_mgmt_rx_reo_deinit_context(struct ath12k_base *ab);
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+int
+ath12k_wmi_send_vdev_set_intra_bss_cmd(struct ath12k *ar,
+				       u32 vdev_id, u32 enable);
+int ath12k_wmi_set_peer_intra_bss_cmd(struct ath12k *ar,  u32 vdev_id, const u8 *peer_addr,
+				      u32 enable);
+#endif
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 int ath12k_wmi_config_peer_ppeds_routing(struct ath12k *ar,
 					 const u8 *peer_addr, u8 vdev_id,
--- a/drivers/net/wireless/ath/ath12k/debugfs.c
+++ b/drivers/net/wireless/ath/ath12k/debugfs.c
@@ -1581,12 +1581,14 @@ static ssize_t ath12k_debugfs_dump_soc_r
 	return len;
 }
 
+extern struct ath12k *ath12k_mac_get_ar_by_pdev_id(struct ath12k_base *ab, u32 pdev_id);
 static ssize_t ath12k_debugfs_dump_soc_dp_stats(struct file *file,
 						char __user *user_buf,
 						size_t count, loff_t *ppos)
 {
 	struct ath12k_base *ab = file->private_data;
 	struct ath12k_soc_dp_stats *soc_stats = &ab->soc_stats;
+	struct ath12k *ar;
 	int len = 0, i, retval;
 	const int size = 4096;
 	static const char *rxdma_err[HAL_REO_ENTR_RING_RXDMA_ECODE_MAX] = {
@@ -1723,6 +1725,17 @@ static ssize_t ath12k_debugfs_dump_soc_d
 			soc_stats->tx_completed[2],
 			soc_stats->tx_completed[3]);
 
+	for (i = 0; i < 3; i++) {
+
+		ar = ath12k_mac_get_ar_by_pdev_id(ab, i);
+		if (ar) {
+			len += scnprintf(buf + len, size - len,
+					"\ntx_pending [%d]: 0:%d\n",
+					i,
+					atomic_read(&ar->dp.num_tx_pending));
+		}
+	}
+
 	len += scnprintf(buf + len, size - len, "\nREO Rx Received:\n");
 	for (i = 0; i < DP_REO_DST_RING_MAX; i++)
 		len += scnprintf(buf + len, size - len,
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -108,6 +108,9 @@ struct cfg80211_registered_device {
 	/* lock for all wdev lists */
 	spinlock_t mgmt_registrations_lock;
 
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+	bool enable_bond_dev;
+#endif
 	/* must be last because of the way we do wiphy_priv(),
 	 * and it should at least be aligned to NETDEV_ALIGN */
 	struct wiphy wiphy __aligned(NETDEV_ALIGN);
--- a/drivers/net/wireless/ath/ath12k/dp_mon.c
+++ b/drivers/net/wireless/ath/ath12k/dp_mon.c
@@ -10,6 +10,10 @@
 #include "dp_tx.h"
 #include "peer.h"
 
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+extern int g_bonded_interface_model;
+#endif
+
 static void ath12k_dp_mon_rx_handle_ofdma_info(void *rx_tlv,
 					       struct hal_rx_user_status *rx_user_status)
 {
@@ -3323,6 +3327,78 @@ ath12k_dp_mon_rx_update_peer_rate_table_
 		rx_stats->byte_stats.rx_rate[bw_idx][gi_idx][nss_idx][mcs_idx] += ppdu_info->mpdu_len;
 }
 
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+static void ath12k_dp_mon_rx_update_peer_stats_bonded(struct ath12k *ar,
+						      struct ath12k_link_sta *arsta,
+						      struct hal_rx_mon_ppdu_info *ppdu_info,
+						      struct ieee80211_rx_status *rx_status)
+{
+	struct ieee80211_rx_status status;
+	struct ieee80211_sta *sta;
+	u32 uid;
+
+	if (ar->ab->stats_disable || !g_bonded_interface_model ||
+	    !test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ar->ab->dev_flags))
+		return;
+
+	memset(&status, 0 , sizeof(status));
+	if (arsta) { // SU stats
+		if (arsta->arvif && (arsta->arvif->ppe_vp_num == -1 ||
+		    (arsta->arvif->ahvif &&
+		     hweight16(arsta->arvif->ahvif->links_map) <= 1)))
+			return;
+
+		if (!rx_status) {
+			ath12k_dp_mon_fill_rx_stats(ar, ppdu_info, &status);
+			rx_status = &status;
+		}
+
+		sta = container_of((void *)arsta->ahsta, struct ieee80211_sta, drv_priv);
+		ieee80211_rx_update_stats(ar->ah->hw, sta, arsta->link_id,
+					  ppdu_info->mpdu_len, rx_status);
+		return;
+	}
+
+	for (uid = 0; uid < ppdu_info->num_users; uid++) { // MU stats
+		struct ath12k_peer *peer;
+
+		if (uid == HAL_MAX_UL_MU_USERS)
+			break;
+
+		if (ppdu_info->peer_id == HAL_INVALID_PEERID)
+			return;
+		peer = ath12k_peer_find_by_id(ar->ab, ppdu_info->peer_id);
+
+		if (!peer) {
+			ath12k_warn(ar->ab, "peer with peer id %d can't be found\n",
+				    ppdu_info->peer_id);
+			continue;
+		}
+
+		arsta = ath12k_peer_get_link_sta(ar->ab, peer);
+		if (!arsta) {
+			ath12k_warn(ar->ab, "link sta not found on peer %pM id %d\n",
+				    peer->addr, peer->peer_id);
+			continue;
+		}
+
+		if (arsta->arvif && (arsta->arvif->ppe_vp_num == -1 ||
+		    (arsta->arvif->ahvif &&
+		     hweight16(arsta->arvif->ahvif->links_map) <= 1)))
+			continue;
+
+		if (!rx_status) {
+			ath12k_dp_mon_fill_rx_stats(ar, ppdu_info, &status);
+			rx_status = &status;
+		}
+
+		sta = container_of((void *)arsta->ahsta, struct ieee80211_sta, drv_priv);
+		ieee80211_rx_update_stats(ar->ah->hw, sta, arsta->link_id,
+					  ppdu_info->mpdu_len, rx_status);
+	}
+}
+#endif /* CPTCFG_ATH12K_BONDED_DS_SUPPORT */
+
 static void ath12k_dp_mon_rx_update_peer_su_stats(struct ath12k *ar,
 						  struct ath12k_link_sta *arsta,
 						  struct hal_rx_mon_ppdu_info *ppdu_info)
@@ -3775,10 +3851,18 @@ move_next:
 
 			ath12k_dp_mon_rx_update_peer_su_stats(ar, arsta,
 							      ppdu_info);
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+			ath12k_dp_mon_rx_update_peer_stats_bonded(ar, arsta, ppdu_info,
+								  &ar->dp.rx_status);
+#endif /* CPTCFG_ATH12K_BONDED_DS_SUPPORT */
 		} else if ((ppdu_info->fc_valid) &&
 			   (ppdu_info->ast_index != HAL_AST_IDX_INVALID)) {
 			ath12k_dp_mon_rx_process_ulofdma(ppdu_info);
 			ath12k_dp_mon_rx_update_peer_mu_stats(ar, ppdu_info);
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+			ath12k_dp_mon_rx_update_peer_stats_bonded(ar, NULL, ppdu_info,
+								  &ar->dp.rx_status);
+#endif /* CPTCFG_ATH12K_BONDED_DS_SUPPORT */
 		}
 
 next_skb:
@@ -3952,10 +4036,18 @@ move_next:
 
 			ath12k_dp_mon_rx_update_peer_su_stats(ar, arsta,
 							      ppdu_info);
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+			ath12k_dp_mon_rx_update_peer_stats_bonded(ar, arsta, ppdu_info,
+								  NULL);
+#endif /* CPTCFG_ATH12K_BONDED_DS_SUPPORT */
 		} else if ((ppdu_info->fc_valid) &&
 			   (ppdu_info->ast_index != HAL_AST_IDX_INVALID)) {
 			ath12k_dp_mon_rx_process_ulofdma(ppdu_info);
 			ath12k_dp_mon_rx_update_peer_mu_stats(ar, ppdu_info);
+#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+			ath12k_dp_mon_rx_update_peer_stats_bonded(ar, NULL, ppdu_info,
+								  NULL);
+#endif /* CPTCFG_ATH12K_BONDED_DS_SUPPORT */
  		}
 
 		if (ath12k_debugfs_is_pktlog_peer_valid(ar, peer->addr)) {
--- a/net/mac80211/status.c
+++ b/net/mac80211/status.c
@@ -1279,6 +1279,39 @@ void ieee80211_tx_status_8023(struct iee
 }
 EXPORT_SYMBOL(ieee80211_tx_status_8023);
 
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+void ieee80211_ppeds_tx_update_stats(struct ieee80211_hw *hw,
+				     struct ieee80211_sta *pubsta,
+				     struct ieee80211_tx_info *info,
+				     struct rate_info rate, int link_id, u32 len)
+{
+	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
+	struct link_sta_info *link_sta;
+	int rates_idx, retry_count;
+
+	rcu_read_lock();
+	if (link_id >= 0) {
+		link_sta = rcu_dereference(sta->link[link_id]);
+		if (WARN_ON_ONCE(!link_sta)) {
+			rcu_read_unlock();
+			return;
+		}
+	} else {
+		link_sta = &sta->deflink;
+	}
+
+	link_sta->tx_stats.packets[0]++;
+	link_sta->tx_stats.bytes[0] += len;
+	rates_idx = ieee80211_tx_get_rates(hw, info, &retry_count);
+	link_sta->tx_stats.last_rate = info->status.rates[rates_idx];
+	link_sta->tx_stats.last_rate_info = rate;
+
+	rcu_read_unlock();
+}
+EXPORT_SYMBOL(ieee80211_ppeds_tx_update_stats);
+#endif /* CPTCFG_MAC80211_BONDED_SUPPORT */
+
+
 void ieee80211_report_low_ack(struct ieee80211_sta *pubsta, u32 num_packets)
 {
 	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
--- a/include/linux/ieee80211.h
+++ b/include/linux/ieee80211.h
@@ -216,6 +216,17 @@ static inline u16 ieee80211_sn_sub(u16 s
 #define IEEE80211_MAX_AID_S1G		8191
 #define IEEE80211_MAX_TIM_LEN		251
 #define IEEE80211_MAX_MESH_PEERINGS	63
+
+/*
+ * Maximum acceptable MTU is:
+ *  IEEE80211_MAX_LEN - WEP overhead - CRC -
+ *      QoS overhead - RSN/WPA overhead
+ * Min is arbitrarily chosen > IEEE80211_MIN_LEN.  The default
+ * mtu is Ethernet-compatible; it's set by ether_ifattach.
+ */
+#define IEEE80211_MTU_MAX       2290
+#define IEEE80211_MTU_MIN       32
+
 /* Maximum size for the MA-UNITDATA primitive, 802.11 standard section
    6.2.1.1.2.
 
--- a/net/mac80211/sta_info.c
+++ b/net/mac80211/sta_info.c
@@ -217,6 +217,20 @@ struct sta_info *sta_info_get(struct iee
 	return NULL;
 }
 
+struct net_device *ieee80211_sta_get_dvlan_iface(struct ieee80211_sta *pubsta)
+{
+	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
+
+	if (!sta)
+		return NULL;
+
+	if (sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
+		return  sta->sdata->dev;
+	else
+		return NULL;
+}
+EXPORT_SYMBOL(ieee80211_sta_get_dvlan_iface);
+
 /*
  * Get sta info either from the specified interface
  * or from one of its vlans
