From ae5e678c404d727c9dba7a687bacd3b098e85f82 Mon Sep 17 00:00:00 2001
From: Manish Dharanenthiran <quic_mdharane@quicinc.com>
Date: Mon, 10 Jul 2023 23:51:46 +0530
Subject: [PATCH] wifi: ath12k: Add support for Mode 1 recovery cache

This patchset adds support for Mode 1 recovery
mechanism where only asserted chip will be recovered
bypassing the mac80211 recovery mechanism.

Client connected to asserted chip will be disconnected/traffic
will be impacted. For clients in non-asserted chips
will be differentiated between MLO and legacy clients.
All MLO clients will be disconnected and legacy client
will be in connection but there will be minimal ping
drop during umac reset.

Signed-off-by: Manish Dharanenthiran <quic_mdharane@quicinc.com>
---
 drivers/net/wireless/ath/ath12k/core.c  | 857 +++++++++++++++++++++++-
 drivers/net/wireless/ath/ath12k/core.h  |  13 +-
 drivers/net/wireless/ath/ath12k/debug.h |   1 +
 drivers/net/wireless/ath/ath12k/mac.c   | 411 ++++++++----
 drivers/net/wireless/ath/ath12k/mac.h   |  40 ++
 drivers/net/wireless/ath/ath12k/peer.c  |   2 +-
 drivers/net/wireless/ath/ath12k/peer.h  |   1 +
 drivers/net/wireless/ath/ath12k/wmi.c   |  13 +-
 drivers/net/wireless/ath/ath12k/wmi.h   |   4 +
 9 files changed, 1204 insertions(+), 138 deletions(-)

--- a/drivers/net/wireless/ath/ath12k/core.c
+++ b/drivers/net/wireless/ath/ath12k/core.c
@@ -11,6 +11,7 @@
 #include <linux/of.h>
 #include <linux/of_platform.h>
 
+#include "peer.h"
 #include "core.h"
 #include "coredump.h"
 #include "dp_tx.h"
@@ -59,8 +60,7 @@ unsigned int ath12k_ppe_ds_enabled = fal
 module_param_named(ppe_ds_enable, ath12k_ppe_ds_enabled, uint, 0644);
 MODULE_PARM_DESC(ppe_ds_enable, "ppe_ds_enable: 0-disable, 1-enable");
 
-static unsigned int ath12k_recovery_mode = ATH12K_MLO_RECOVERY_MODE0;
-unsigned int ath12k_ssr_failsafe_mode = false;
+unsigned int ath12k_ssr_failsafe_mode = true;
 module_param_named(ssr_failsafe_mode, ath12k_ssr_failsafe_mode, uint, 0644);
 MODULE_PARM_DESC(ssr_failsafe_mode, "ssr failsafe mode: 0-disable, 1-enable");
 
@@ -162,6 +162,7 @@ ath12k_core_hw_group_alloc(u8 id, u8 max
 	mutex_init(&ag->mutex_lock);
 	mutex_init(&ag->mlomem_arena.mutex_lock);
 	ag->hw_queues_stopped = false;
+	ag->recovery_mode = ATH12K_MLO_RECOVERY_MODE0;
 
 	return ag;
 }
@@ -1432,6 +1433,12 @@ static int ath12k_core_hw_group_start(st
 	for (i = 0; i < ag->num_chip; i++) {
 		ab = ag->ab[i];
 
+		/* pdev create needs to be done only for recovered
+		 * ab during Mode1 scenario
+		 */
+		if (ag->recovery_mode == ATH12K_MLO_RECOVERY_MODE1 && !ab->recovery_start)
+			continue;
+
 		mutex_lock(&ab->core_lock);
 		ret = ath12k_core_pdev_create(ab);
 		if (ret) {
@@ -1460,6 +1467,12 @@ static int ath12k_core_hw_group_start(st
 	for (i = 0; i < ag->num_chip; i++) {
 		ab = ag->ab[i];
 
+		/* pdev init needs to be done only for recovered
+		 * ab during Mode1 scenario
+		 */
+		if (ag->recovery_mode == ATH12K_MLO_RECOVERY_MODE1 && !ab->recovery_start)
+			continue;
+
 		mutex_lock(&ab->core_lock);
 
 		ret = ath12k_core_pdev_init(ab);
@@ -1575,7 +1588,7 @@ static void ath12k_core_trigger_partner(
 				ab->qmi.num_radios, ag->num_chip);
 
 		if (found) {
-			if (ath12k_recovery_mode == ATH12K_MLO_RECOVERY_MODE0 &&
+			if (ag->recovery_mode == ATH12K_MLO_RECOVERY_MODE0 &&
 			    !test_bit(ATH12K_FLAG_QMI_HOST_CAP_SENT, &partner_ab->dev_flags)) {
 				ath12k_qmi_trigger_host_cap(partner_ab);
 			}
@@ -1846,6 +1859,7 @@ static int ath12k_core_reconfigure_on_cr
 
 	ath12k_dp_free(ab);
 	ath12k_hal_srng_deinit(ab);
+	ath12k_dp_umac_reset_deinit(ab);
 	ath12k_umac_reset_completion(ab);
 
 	ab->free_vdev_map = (1LL << (ab->num_radios * TARGET_NUM_VDEVS)) - 1;
@@ -1866,7 +1880,8 @@ err_hal_srng_deinit:
 	return ret;
 }
 
-static void ath12k_core_mlo_hw_queues_stop(struct ath12k_hw_group *ag)
+static void ath12k_core_mlo_hw_queues_stop(struct ath12k_hw_group *ag,
+					   struct ath12k_base *block_ab)
 {
 	struct ath12k_base *ab;
 	struct ath12k_hw *ah;
@@ -1883,6 +1898,12 @@ static void ath12k_core_mlo_hw_queues_st
 	}
 	ag->hw_queues_stopped = true;
 
+	if (ag->recovery_mode == ATH12K_MLO_RECOVERY_MODE1) {
+		block_ab->qmi.num_radios = ATH12K_QMI_INVALID_RADIO;
+		clear_bit(ATH12K_FLAG_QMI_HOST_CAP_SENT, &block_ab->dev_flags);
+		return;
+	}
+
 	for (i = 0; i < ag->num_chip; i++) {
 		ab = ag->ab[i];
 
@@ -1890,7 +1911,7 @@ static void ath12k_core_mlo_hw_queues_st
 		* In Mode0, partner chips are expected to be asserted, hence reset
 		* qmi.num_radios count to ensure avoiding duplicate host cap triggers.
 		*/
-		if (ath12k_recovery_mode == ATH12K_MLO_RECOVERY_MODE0) {
+		if (ag->recovery_mode == ATH12K_MLO_RECOVERY_MODE0) {
 			ab->qmi.num_radios = ATH12K_QMI_INVALID_RADIO;
 			clear_bit(ATH12K_FLAG_QMI_HOST_CAP_SENT, &ab->dev_flags);
 		}
@@ -2004,6 +2025,7 @@ static void ath12k_core_post_reconfigure
 void ath12k_core_halt(struct ath12k *ar)
 {
 	struct ath12k_base *ab = ar->ab;
+	struct ath12k_hw_group *ag = ab->ag;
 
 	lockdep_assert_held(&ar->conf_mutex);
 
@@ -2014,16 +2036,730 @@ void ath12k_core_halt(struct ath12k *ar)
 	cancel_work_sync(&ar->regd_update_work);
 	rcu_assign_pointer(ab->pdevs_active[ar->pdev_idx], NULL);
 	synchronize_rcu();
-	INIT_LIST_HEAD(&ar->arvifs);
+
+	if (ag->recovery_mode == ATH12K_MLO_RECOVERY_MODE0)
+		INIT_LIST_HEAD(&ar->arvifs);
+
 	idr_init(&ar->txmgmt_idr);
 }
 
+static int ath12k_core_mode1_recovery_sta_list(void *data,
+					       struct ieee80211_sta *sta)
+{
+	struct ath12k_link_sta *arsta;
+	struct ath12k_sta *ahsta = (struct ath12k_sta *)sta->drv_priv;
+	struct ath12k_link_vif *arvif = (struct ath12k_link_vif *)data;
+	struct ath12k_vif *ahvif = arvif->ahvif;
+	struct ieee80211_vif *vif = ahvif->vif;
+	struct ath12k *ar = arvif->ar;
+	struct ath12k_base *ab = arvif->ab;
+	struct ath12k_key_conf *key_conf = NULL;
+	struct ath12k_peer *peer;
+	struct ieee80211_key_conf *key;
+	int ret = -1, key_idx;
+	u8 link_id = arvif->link_id;
+	enum ieee80211_sta_state state, prev_state;
+	bool sta_added = false;
+
+	if (ahsta->ahvif != arvif->ahvif)
+		return -1;
+
+	/* Check if there is a link sta in the vif link */
+	if (!(BIT(link_id) & ahsta->links_map))
+		return -1;
+
+	/* From iterator, rcu_read_lock is acquired. Will be revisited
+	 * later to use local list
+	 */
+	arsta = ahsta->link[link_id];
+
+	key_conf = container_of((void *)sta, struct ath12k_key_conf, sta);
+
+	if (vif->type != NL80211_IFTYPE_AP &&
+	    vif->type != NL80211_IFTYPE_AP_VLAN)
+		return 0;
+
+	peer = ath12k_peer_find(ar->ab, arvif->vdev_id, arsta->addr);
+	if (peer) {
+		sta_added = true;
+		goto key_add;
+	}
+
+	prev_state = arsta->state;
+	for (state = IEEE80211_STA_NOTEXIST;
+	     state < prev_state; state++) {
+		/* all station set case */
+		/* TODO: Iterator API is called with rcu lock
+		 * hence need for this unlock/lock statement.
+		 * Need to revisit in next version
+		 */
+		rcu_read_unlock();
+		ath12k_mac_update_sta_state(ar->ah->hw, arvif->ahvif->vif, sta,
+					    state, (state + 1));
+		rcu_read_lock();
+		sta_added = true;
+	}
+
+key_add:
+	if (sta_added)
+	for (key_idx = 0; key_idx < WMI_MAX_KEY_INDEX; key_idx++) {
+		key = arsta->keys[key_idx];
+
+		if (key) {
+			/* BIP needs to be done in software */
+			if (key->cipher == WLAN_CIPHER_SUITE_AES_CMAC ||
+			    key->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_128 ||
+			    key->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_256 ||
+			    key->cipher == WLAN_CIPHER_SUITE_BIP_CMAC_256) {
+				ret = 1;
+				goto out;
+			}
+
+			if (test_bit(ATH12K_FLAG_HW_CRYPTO_DISABLED, &ab->ag->dev_flags)) {
+				ret = 1;
+				goto out;
+			}
+
+			if (!arvif->is_created) {
+				key_conf = kzalloc(sizeof(*key_conf), GFP_ATOMIC);
+
+				if (!key_conf) {
+					ath12k_info(NULL, "failed to alloc cache key config\n");
+					goto out;
+				}
+
+				key_conf->cmd = SET_KEY;
+				key_conf->sta = sta;
+				key_conf->key = key;
+
+				list_add_tail(&key_conf->list,
+					      &ahvif->cache[link_id].key_conf.list);
+
+				ath12k_info(NULL, "set key param cached since vif not assign to radio\n");
+				goto out;
+			}
+
+			if (sta->mlo) {
+				for_each_set_bit(link_id, &sta->valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+					arvif = ahvif->link[link_id];
+					arsta = ahsta->link[link_id];
+					if (WARN_ON(!arvif || !arsta))
+						continue;
+
+					/* TODO: Iterator API is called with rcu lock
+					 * hence need for this unlock/lock statement.
+					 * Need to revisit in next version
+					 */
+					rcu_read_unlock();
+					ret = ath12k_mac_set_key(arvif->ar, SET_KEY, arvif, arsta, key);
+					rcu_read_lock();
+					if (ret)
+						break;
+					arsta->keys[key->keyidx] = key;
+				}
+			} else {
+				arsta = &ahsta->deflink;
+				arvif = arsta->arvif;
+				if (WARN_ON(!arvif))
+					goto out;
+
+				/* TODO: Iterator API is called with rcu lock
+				 * hence need for this unlock/lock statement.
+				 * Need to revisit in next version
+				 */
+				rcu_read_unlock();
+				ret = ath12k_mac_set_key(arvif->ar, SET_KEY, arvif, arsta, key);
+				rcu_read_lock();
+				arsta->keys[key->keyidx] = key;
+			}
+		}
+	}
+
+	ath12k_dbg(ab, ATH12K_DBG_MODE1_RECOVERY,
+		"Recovered sta:%pM link_id:%d, num_sta:%d\n",
+		arsta->addr, arsta->link_id, arvif->ar->num_stations);
+
+	ret = 0;
+out:
+	return ret;
+}
+
+static int ath12k_mlo_recovery_link_vif_reconfig(struct ath12k *ar,
+					    struct ath12k_vif *ahvif,
+					    struct ath12k_link_vif *arvif,
+					    struct ieee80211_vif *vif,
+					    struct ieee80211_bss_conf *link_conf)
+{
+	int i;
+	int link_id = arvif->link_id;
+	struct ath12k_hw *ah = ar->ah;
+	struct ieee80211_tx_queue_params params;
+	struct wmi_wmm_params_arg *p = NULL;
+	u64 changed = 0;
+
+	mutex_lock(&ah->conf_mutex);
+
+	switch (vif->type) {
+	case NL80211_IFTYPE_AP_VLAN:
+	case NL80211_IFTYPE_MONITOR:
+		break;
+	case NL80211_IFTYPE_ADHOC:
+		fallthrough;
+	default:
+		ieee80211_iterate_stations_atomic(ar->ah->hw,
+						  ath12k_core_mode1_recovery_sta_list,
+						  arvif);
+		fallthrough;
+	case NL80211_IFTYPE_AP: /* AP stations are handled later */
+		for (i = 0; i < IEEE80211_NUM_ACS; i++) {
+
+			if ((vif->active_links &&
+			    !(vif->active_links & BIT(link_id))) ||
+			    (link_id >= IEEE80211_MLD_MAX_NUM_LINKS))
+				break;
+
+			switch (i) {
+			case IEEE80211_AC_VO:
+				p = &arvif->wmm_params.ac_vo;
+				break;
+			case IEEE80211_AC_VI:
+				p = &arvif->wmm_params.ac_vi;
+				break;
+			case IEEE80211_AC_BE:
+				p = &arvif->wmm_params.ac_be;
+				break;
+			case IEEE80211_AC_BK:
+				p = &arvif->wmm_params.ac_bk;
+				break;
+			}
+
+			params.cw_min = p->cwmin;
+			params.cw_max = p->cwmax;
+			params.aifs = p->aifs;
+			params.txop = p->txop;
+
+			mutex_lock(&ar->conf_mutex);
+			ath12k_mac_conf_tx(ar, arvif, i, &params);
+			mutex_unlock(&ar->conf_mutex);
+		}
+		break;
+	}
+
+	/* common change flags for all interface types */
+	changed = BSS_CHANGED_ERP_CTS_PROT |
+		  BSS_CHANGED_ERP_PREAMBLE |
+		  BSS_CHANGED_ERP_SLOT |
+		  BSS_CHANGED_HT |
+		  BSS_CHANGED_BASIC_RATES |
+		  BSS_CHANGED_BEACON_INT |
+		  BSS_CHANGED_BSSID |
+		  BSS_CHANGED_CQM |
+		  BSS_CHANGED_QOS |
+		  BSS_CHANGED_IDLE |
+		  BSS_CHANGED_TXPOWER |
+		  BSS_CHANGED_MCAST_RATE;
+
+	if (link_conf->mu_mimo_owner)
+		changed |= BSS_CHANGED_MU_GROUPS;
+
+	switch (vif->type) {
+#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+	case NL80211_IFTYPE_DUMMY:
+		mutex_unlock(&ah->conf_mutex);
+		return 0;
+#endif
+	case NL80211_IFTYPE_STATION:
+		changed |= BSS_CHANGED_ASSOC |
+			   BSS_CHANGED_ARP_FILTER |
+			   BSS_CHANGED_PS;
+
+		/* Assume re-send beacon info report to the driver */
+		changed |= BSS_CHANGED_BEACON_INFO;
+
+		if (link_conf->max_idle_period ||
+			link_conf->protected_keep_alive)
+			changed |= BSS_CHANGED_KEEP_ALIVE;
+
+		if (!arvif->is_created) {
+			ath12k_info(NULL,
+				    "bss info parameter changes %llx cached to apply after vdev create on channel assign\n",
+				    changed);
+
+			ahvif->cache[link_id].bss_conf_changed |= changed;
+			mutex_unlock(&ah->conf_mutex);
+			return 0;
+		}
+
+		mutex_lock(&ar->conf_mutex);
+		ath12k_mac_bss_info_changed(ar, arvif, link_conf, changed);
+		mutex_unlock(&ar->conf_mutex);
+		break;
+	case NL80211_IFTYPE_OCB:
+		changed |= BSS_CHANGED_OCB;
+
+		mutex_lock(&ar->conf_mutex);
+		ath12k_mac_bss_info_changed(ar, arvif, link_conf, changed);
+		mutex_unlock(&ar->conf_mutex);
+		break;
+	case NL80211_IFTYPE_ADHOC:
+		changed |= BSS_CHANGED_IBSS;
+		fallthrough;
+	case NL80211_IFTYPE_AP:
+		changed |= BSS_CHANGED_P2P_PS;
+
+		if (vif->type == NL80211_IFTYPE_AP) {
+			changed |= BSS_CHANGED_AP_PROBE_RESP;
+			ahvif->u.ap.ssid_len = vif->cfg.ssid_len;
+			if (vif->cfg.ssid_len)
+				memcpy(ahvif->u.ap.ssid, vif->cfg.ssid, vif->cfg.ssid_len);
+		}
+		fallthrough;
+	case NL80211_IFTYPE_MESH_POINT:
+		if (link_conf->enable_beacon) {
+			changed |= BSS_CHANGED_BEACON |
+				   BSS_CHANGED_BEACON_ENABLED;
+
+			mutex_lock(&ar->conf_mutex);
+			ath12k_mac_bss_info_changed(ar, arvif, link_conf,
+					changed &~ BSS_CHANGED_IDLE);
+			mutex_unlock(&ar->conf_mutex);
+
+		}
+		break;
+	case NL80211_IFTYPE_NAN:
+	case NL80211_IFTYPE_AP_VLAN:
+	case NL80211_IFTYPE_MONITOR:
+	case NL80211_IFTYPE_P2P_DEVICE:
+		/* nothing to do */
+		break;
+	case NL80211_IFTYPE_UNSPECIFIED:
+	case NUM_NL80211_IFTYPES:
+	case NL80211_IFTYPE_P2P_CLIENT:
+	case NL80211_IFTYPE_P2P_GO:
+	case NL80211_IFTYPE_WDS:
+		WARN_ON(1);
+		break;
+	}
+
+	mutex_unlock(&ah->conf_mutex);
+	ath12k_dbg(ar->ab, ATH12K_DBG_MODE1_RECOVERY, "Reconfig link vif done:type:%d\n", vif->type);
+	return 0;
+}
+
+static int ath12k_mlo_core_recovery_reconfig_link_bss(struct ath12k *ar,
+						      struct ieee80211_bss_conf *link_conf,
+						      struct ath12k_vif *ahvif,
+						      struct ath12k_link_vif *arvif)
+{
+	struct ieee80211_vif *vif = arvif->ahvif->vif;
+	struct ath12k_base *ab = ar->ab;
+	struct ath12k_hw *ah = ar->ah;
+	enum ieee80211_ap_reg_power power_type;
+	struct peer_create_params param;
+	struct ieee80211_chanctx_conf *ctx = &arvif->chanctx;
+	int ret = -1;
+	u8 link_id = link_conf->link_id;
+
+
+	ath12k_dbg(ab, ATH12K_DBG_MODE1_RECOVERY,
+		"Recovering: link_id:%d [vif->link_id:%d] type:%d\n",
+		link_id, arvif->link_id, vif->type);
+
+	mutex_lock(&ah->conf_mutex);
+
+	if (vif->type == NL80211_IFTYPE_AP &&
+	    ar->num_peers > (ar->max_num_peers - 1)) {
+		ath12k_err(ab, "Error in peers:%d\n",
+				ar->num_peers);
+		goto exit;
+	}
+
+	if (ar->num_created_vdevs > (TARGET_NUM_VDEVS - 1)) {
+		ath12k_err(ab, "failed to create vdev, reached max vdev limit %d[%d]\n",
+				ar->num_created_vdevs,
+				TARGET_NUM_VDEVS);
+		goto exit;
+	}
+
+	mutex_lock(&ar->conf_mutex);
+
+	ret = ath12k_mac_vdev_create(ar, arvif);
+	if (!ret)
+		ath12k_mac_vif_cache_flush(ar, vif, arvif->link_id);
+
+	if (ar->supports_6ghz && ctx->def.chan->band == NL80211_BAND_6GHZ &&
+            (ahvif->vdev_type == WMI_VDEV_TYPE_STA ||
+             ahvif->vdev_type == WMI_VDEV_TYPE_AP)) {
+                power_type = link_conf->power_type;
+                ath12k_dbg(ab, ATH12K_DBG_MAC, "mac chanctx power type %d\n",
+                           power_type);
+                if (power_type == IEEE80211_REG_UNSET_AP)
+                        power_type = IEEE80211_REG_LPI_AP;
+
+		/* TODO: Transmit Power Envelope specification for 320 is not
+                 * available yet. Need to add TPE 320 support when spec is ready
+                 */
+                if (ahvif->vdev_type == WMI_VDEV_TYPE_STA &&
+		    ctx->def.width != NL80211_CHAN_WIDTH_320) {
+                        ath12k_mac_parse_tx_pwr_env(ar, arvif, ctx);
+		}
+        }
+
+	/* for some targets bss peer must be created before vdev_start */
+	if (ab->hw_params->vdev_start_delay &&
+	    ahvif->vdev_type != WMI_VDEV_TYPE_AP &&
+	    ahvif->vdev_type != WMI_VDEV_TYPE_MONITOR &&
+	    !ath12k_peer_find_by_vdev_id(ab, arvif->vdev_id)) {
+		ret = 0;
+		goto exit;
+	}
+
+	if (ab->hw_params->vdev_start_delay &&
+	    (ahvif->vdev_type == WMI_VDEV_TYPE_AP ||
+	     ahvif->vdev_type == WMI_VDEV_TYPE_MONITOR)) {
+		param.vdev_id = arvif->vdev_id;
+		param.peer_type = WMI_PEER_TYPE_DEFAULT;
+		param.peer_addr = ar->mac_addr;
+
+		ret = ath12k_peer_create(ar, arvif, NULL, &param);
+		if (ret) {
+			ath12k_warn(ab, "failed to create peer after vdev start delay: %d",
+				    ret);
+			goto exit;
+		}
+	}
+
+	if (ahvif->vdev_type == WMI_VDEV_TYPE_MONITOR) {
+		ret = ath12k_mac_monitor_start(ar);
+		if (ret)
+			goto exit;
+		arvif->is_started = true;
+		goto exit;
+	}
+
+	if (ath12k_mac_is_ml_arvif(arvif) &&
+	    ahvif->vdev_type == WMI_VDEV_TYPE_AP) {
+		mutex_unlock(&ar->conf_mutex);
+		ret = ath12k_mac_mlo_vdev_start(arvif, false);
+		mutex_lock(&ar->conf_mutex);
+		goto exit;
+	}
+
+	ret = ath12k_mac_vdev_start(arvif, &ctx->def, ctx->radar_enabled);
+	if (ret) {
+		ath12k_err(ab, "vdev start failed during recovery\n");
+		goto exit;
+	}
+
+	if (ahvif->vdev_type != WMI_VDEV_TYPE_MONITOR &&
+	    test_bit(MONITOR_VDEV_CREATED, &ar->monitor_flags))
+		ath12k_mac_monitor_start(ar);
+
+	arvif->is_started = true;
+	arvif->is_created = true;
+
+	ret = 0;
+exit:
+	ath12k_dbg(ab, ATH12K_DBG_MODE1_RECOVERY,
+		   "ret:%d No. of vdev created:%d, links_map:%d, flag:%d\n",
+		   ret,
+		   ahvif->num_vdev_created,
+		   ahvif->links_map,
+		   arvif->is_created);
+
+	mutex_unlock(&ar->conf_mutex);
+	mutex_unlock(&ah->conf_mutex);
+
+	return ret;
+}
+
+/* Wrapper function for recovery after crash */
+int ath12k_mode1_recovery_reconfig(struct ath12k_base *ab, const char *fun)
+{
+	struct ath12k *ar = NULL;
+	struct ath12k_pdev *pdev;
+	struct ath12k_link_vif *arvif, *tmp;
+	struct ath12k_vif *ahvif ;
+	struct ieee80211_bss_conf *link;
+	struct ath12k_hw_group *ag = ab->ag;
+	struct ath12k_base *partner_ab;
+	struct ath12k_hw *ah;
+	struct ieee80211_key_conf *key;
+	int i, j, key_idx;
+	u32 changed = 0;
+	int ret = -EINVAL;
+	bool started = false;
+
+	for (j = 0; j < ab->num_radios; j++) {
+		pdev = &ab->pdevs[j];
+		ar = pdev->ar;
+
+		if (WARN_ON(!ar))
+			continue;
+
+		if (!ath12k_ftm_mode) {
+			if (ath12k_mac_radio_start(ar)) {
+				ath12k_err(ab, "mac radio start failed\n");
+				return ret;
+			}
+			ar->ah->in_recovery = true;
+			started = true;
+		}
+
+		if (list_empty(&ar->arvifs))
+			continue;
+
+		/* Decrement number of vdev created for all the arvif
+		 * under a ar
+		 */
+		list_for_each_entry_safe_reverse(arvif, tmp, &ar->arvifs, list) {
+			arvif->ahvif->num_vdev_created--;
+		}
+	}
+
+	/* add chanctx/hw_config/filter part */
+	for (j = 0; j < ab->num_radios; j++) {
+		pdev = &ab->pdevs[j];
+		ar = pdev->ar;
+
+		if (!ar)
+			continue;
+
+		mutex_lock(&ar->conf_mutex);
+
+		list_for_each_entry_safe_reverse(arvif, tmp, &ar->arvifs, list) {
+			ahvif = arvif->ahvif;
+
+			if (!ahvif)
+				continue;
+
+			arvif->is_started = false;
+			arvif->is_created = false;
+
+			rcu_read_lock();
+			link = rcu_dereference(ahvif->vif->link_conf[arvif->link_id]);
+
+			/* Not expected */
+			if (WARN_ON(!link)) {
+				rcu_read_unlock();
+				continue;
+			}
+			rcu_read_unlock();
+			spin_lock_bh(&ar->data_lock);
+
+			ar->rx_channel = link->chandef.chan;
+			spin_unlock_bh(&ar->data_lock);
+
+			/* hw_config */
+			changed &= ~(IEEE80211_CONF_CHANGE_CHANNEL |
+				IEEE80211_CONF_CHANGE_POWER |
+				IEEE80211_CONF_CHANGE_SMPS);
+
+			if (ar->ah->hw->conf.flags & IEEE80211_CONF_MONITOR) {
+				set_bit(MONITOR_CONF_ENABLED, &ar->monitor_flags);
+
+				if (test_bit(MONITOR_VDEV_CREATED,
+				    &ar->monitor_flags)) {
+					ret = ath12k_mac_monitor_vdev_create(ar);
+					if (!ret && ath12k_mac_monitor_start(ar)) {
+						ath12k_err(ab, "unable to start monitor vdev\n");
+						ath12k_mac_monitor_vdev_delete(ar);
+					} else {
+						ath12k_err(ab, "unable to create monitor vdev\n");
+					}
+				}
+			} else {
+				clear_bit(MONITOR_CONF_ENABLED, &ar->monitor_flags);
+				if (test_bit(MONITOR_VDEV_CREATED,
+					      &ar->monitor_flags)) {
+					ret = ath12k_mac_monitor_stop(ar);
+					if (!ret && ath12k_mac_monitor_vdev_delete(ar))
+						ath12k_err(ab, "monitor vdev delete failed\n");
+					else
+						ath12k_err(ab, "failed to stop monitor stop\n");
+				}
+			}
+
+			/* configure filter - we can use the same flag*/
+		}
+		mutex_unlock(&ar->conf_mutex);
+	}
+
+	/* assign chanctx part */
+	for (j = 0; j < ab->num_radios; j++) {
+		pdev = &ab->pdevs[j];
+		ar = pdev->ar;
+
+		if (!ar)
+			continue;
+
+		mutex_lock(&ar->conf_mutex);
+
+		list_for_each_entry_safe_reverse(arvif, tmp, &ar->arvifs, list) {
+			ahvif = arvif->ahvif;
+
+			if (!ahvif)
+				continue;
+
+			rcu_read_lock();
+			link = rcu_dereference(ahvif->vif->link_conf[arvif->link_id]);
+
+			/* Not expected */
+			if (WARN_ON(!link)) {
+				rcu_read_unlock();
+				continue;
+			}
+			rcu_read_unlock();
+
+			/* unlock ar mutex here since we will take ah mutex in
+			 * the reconfig link API thus maintaining same order
+			 * as we use in other places.
+			 */
+			mutex_unlock(&ar->conf_mutex);
+			ret = ath12k_mlo_core_recovery_reconfig_link_bss(ar, link, ahvif, arvif);
+			if (ret) {
+				ath12k_err(ab, "ERROR in reconfig link:%d\n",
+						ret);
+				return ret;
+			}
+			ath12k_dbg(ab, ATH12K_DBG_MODE1_RECOVERY,
+					"vdev_created getting incremented:%d\n",
+					ahvif->num_vdev_created);
+			mutex_lock(&ar->conf_mutex);
+		}
+		mutex_unlock(&ar->conf_mutex);
+		ath12k_dbg(ab, ATH12K_DBG_MODE1_RECOVERY, "Reconfig link bss completed\n");
+	}
+
+	/* reconfig_link_bss */
+	for (j = 0; j < ab->num_radios; j++) {
+		pdev = &ab->pdevs[j];
+		ar = pdev->ar;
+
+		if (!ar)
+			continue;
+
+		mutex_lock(&ar->conf_mutex);
+
+		list_for_each_entry_safe_reverse(arvif, tmp, &ar->arvifs, list) {
+			ahvif = arvif->ahvif;
+
+			if (!ahvif)
+				continue;
+
+			rcu_read_lock();
+			ath12k_dbg(ab, ATH12K_DBG_MODE1_RECOVERY,
+					"vdev reconfig rcu_lock_acquired:\n") ;
+
+			link = rcu_dereference(ahvif->vif->link_conf[arvif->link_id]);
+
+			/* Not expected */
+			if (WARN_ON(!link)) {
+				rcu_read_unlock();
+				continue;
+			}
+			rcu_read_unlock();
+
+			/* unlock ar mutex here since we will take ah mutex in
+			 * the reconfig link API thus maintaining same order
+			 * as we use in other places.
+			 */
+			mutex_unlock(&ar->conf_mutex);
+			ret = ath12k_mlo_recovery_link_vif_reconfig(ar, ahvif,
+				       arvif,
+				       arvif->ahvif->vif,
+				       link);
+			if (ret) {
+				ath12k_err(ab, "Failed to update reconfig_bss\n");
+				return ret;
+			}
+			mutex_lock(&ar->conf_mutex);
+		}
+		mutex_unlock(&ar->conf_mutex);
+		ath12k_dbg(ab, ATH12K_DBG_MODE1_RECOVERY, "Recovery link vif completed\n");
+	}
+
+	for (i = 0; i < ag->num_chip; i++) {
+		partner_ab = ag->ab[i];
+		if (ab == partner_ab)
+			continue;
+
+		clear_bit(ATH12K_FLAG_UMAC_RECOVERY_START, &partner_ab->dev_flags);
+	}
+
+	/* sta state part */
+	for (j = 0; j < ab->num_radios; j++) {
+		pdev = &ab->pdevs[j];
+		ar = pdev->ar;
+
+		if (!ar)
+			continue;
+
+		mutex_lock(&ar->conf_mutex);
+
+		if (list_empty(&ar->arvifs)) {
+			mutex_unlock(&ar->conf_mutex);
+			continue;
+		}
+
+		list_for_each_entry_safe_reverse(arvif, tmp, &ar->arvifs, list) {
+			ahvif = arvif->ahvif;
+
+			if (!ahvif)
+				continue;
+
+			/* unlock ar mutex here as the iterator will be called
+			 * within rcu lock.
+			 */
+			mutex_unlock(&ar->conf_mutex);
+			ieee80211_iterate_stations_atomic(ar->ah->hw,
+							  ath12k_core_mode1_recovery_sta_list,
+							  arvif);
+			mutex_lock(&ar->conf_mutex);
+			for (key_idx = 0; key_idx < WMI_MAX_KEY_INDEX; key_idx++) {
+				key = arvif->keys[key_idx];
+				if (key) {
+					ath12k_dbg(ab, ATH12K_DBG_MODE1_RECOVERY,
+						"key:%p cipher:%d idx:%d flags:%d\n",
+						key, key->cipher, key->keyidx, key->flags);
+					ret = ath12k_mac_set_key(arvif->ar, SET_KEY, arvif, NULL, key);
+				}
+			}
+		}
+		mutex_unlock(&ar->conf_mutex);
+		ar->ah->in_recovery = false;
+	}
+
+	for (i = 0; i < ag->num_hw; i++) {
+		ah = ag->ah[i];
+		if (!ah)
+			continue;
+
+		for (j = 0; j < ab->num_radios; j++) {
+			pdev = &ab->pdevs[j];
+			ar = pdev->ar;
+
+			if (!ar)
+				continue;
+
+			ath12k_mac_reconfig_complete(ah->hw,
+						     IEEE80211_RECONFIG_TYPE_RESTART,
+						     ar);
+		}
+	}
+
+	ab->recovery_start = false;
+	ag->recovery_mode = ATH12K_MLO_RECOVERY_MODE0;
+	return ret;
+}
+
 static void ath12k_core_restart(struct work_struct *work)
 {
 	struct ath12k_base *ab = container_of(work, struct ath12k_base, restart_work);
 	struct ath12k_hw_group *ag = ab->ag;
 	int ret;
 	struct ath12k_hw *ah;
+	struct ath12k *ar;
 	int i;
 
 	if (!ab->is_reset)
@@ -2036,16 +2772,20 @@ static void ath12k_core_restart(struct w
 		 * If for any reason, reconfiguration fails, issue bug on for
 		 * Mode 0
 		 */
-		if (ath12k_ssr_failsafe_mode && ath12k_recovery_mode == ATH12K_MLO_RECOVERY_MODE0)
+		if (ath12k_ssr_failsafe_mode && ag->recovery_mode == ATH12K_MLO_RECOVERY_MODE0)
 			BUG_ON(1);
 		return;
 	}
 
+	ath12k_dbg(ab, ATH12K_DBG_MODE1_RECOVERY,
+			"ab->is_reset[%d]\n", ab->is_reset);
+	ar = ab->pdevs[0].ar;
+
 	if (!ab->is_reset)
 		ath12k_core_post_reconfigure_recovery(ab);
 
 	if (ath12k_core_hw_group_start_ready(ag) &&
-	    ath12k_recovery_mode == ATH12K_MLO_RECOVERY_MODE0) {
+	    ag->recovery_mode == ATH12K_MLO_RECOVERY_MODE0) {
 		for (i = 0; i < ag->num_hw; i++) {
 			ah = ag->ah[i];
 			if (!ah)
@@ -2060,6 +2800,19 @@ static void ath12k_core_restart(struct w
 	if (ath12k_sawf_reconfigure_on_crash(ab))
 		ath12k_warn(ab, "SAWF SLA reconfiguring failed\n");
 #endif /* CPTCFG_ATH12K_SAWF */
+
+	if (ath12k_core_hw_group_start_ready(ag) &&
+	    ag->recovery_mode == ATH12K_MLO_RECOVERY_MODE1) {
+		queue_work(ab->workqueue_aux, &ab->recovery_work);
+	}
+}
+
+static void ath12k_core_mode1_recovery_work(struct work_struct *work)
+{
+	struct ath12k_base *ab = container_of(work, struct ath12k_base, recovery_work);
+	ath12k_dbg(ab, ATH12K_DBG_MODE1_RECOVERY,
+			"queued recovery work\n");
+	ath12k_mode1_recovery_reconfig(ab, __func__);
 }
 
 static void ath12k_rproc_recovery_do_coredump(struct rproc *rproc)
@@ -2163,26 +2916,26 @@ static int ath12k_rproc_recovery_power_u
  * is identified by waiting for MLO Teardown complete for all
  * chipsets
  */
-int ath12k_core_trigger_umac_reset(struct ath12k_base *ab)
+static int ath12k_core_trigger_umac_reset(struct ath12k_base *ab)
 {
 	struct ath12k_hw_group *ag = ab->ag;
 	long time_left;
-	unsigned long timeout;
+	int ret = 0;
 
 	reinit_completion(&ag->umac_reset_complete);
 
 	ath12k_mac_mlo_teardown_with_umac_reset(ab);
 
-	timeout = jiffies + msecs_to_jiffies(ATH12K_UMAC_RESET_TIMEOUT_IN_MS);
-
 	time_left = wait_for_completion_timeout(&ag->umac_reset_complete,
-						timeout);
+						msecs_to_jiffies(ATH12K_UMAC_RESET_TIMEOUT_IN_MS));
 
 	if (!time_left) {
 		ath12k_warn(ab, "UMAC reset didn't get completed within 200 ms\n");
-		return -ETIMEDOUT;
+		ret = -ETIMEDOUT;
 	}
-	return 0;
+
+	ag->trigger_umac_reset = false;
+	return ret;
 }
 
 #ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
@@ -2230,9 +2983,11 @@ static void ath12k_core_reset(struct wor
 {
 	struct ath12k_base *ab = container_of(work, struct ath12k_base, reset_work);
 	struct ath12k_hw_group *ag = ab->ag;
+	struct ath12k_hw *ah;
 	struct ath12k_base *partner_ab;
 	int reset_count, fail_cont_count, i;
 	long time_left;
+	bool teardown = false;
 
 #ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
 	if (!ab->is_reset) {
@@ -2243,9 +2998,21 @@ static void ath12k_core_reset(struct wor
 	}
 #endif
 
-	ag->recovery_mode = ATH12K_MLO_RECOVERY_MODE0;
 	if (ab->recovery_mode_address) {
-		ag->recovery_mode = *ab->recovery_mode_address;
+		switch (*ab->recovery_mode_address) {
+			case ATH12K_MLO_RECOVERY_MODE1:
+				ag->recovery_mode = ATH12K_MLO_RECOVERY_MODE1;
+				break;
+			case ATH12K_MLO_RECOVERY_MODE0:
+				fallthrough;
+			default:
+				ag->recovery_mode = ATH12K_MLO_RECOVERY_MODE0;
+		}
+		ath12k_dbg(ab, ATH12K_DBG_MODE1_RECOVERY,
+			"mode:%d\n", ag->recovery_mode);
+	}
+	else {
+		ag->recovery_mode = ATH12K_MLO_RECOVERY_MODE0;
 	}
 
 	/* Sometimes the recovery will fail and then the next all recovery fail,
@@ -2277,7 +3044,7 @@ static void ath12k_core_reset(struct wor
 		 */
 		ath12k_warn(ab, "already resetting count %d\n", reset_count);
 
-		if (ath12k_ssr_failsafe_mode && ath12k_recovery_mode == ATH12K_MLO_RECOVERY_MODE0)
+		if (ath12k_ssr_failsafe_mode && ag->recovery_mode == ATH12K_MLO_RECOVERY_MODE0)
 			BUG_ON(1);
 
 		reinit_completion(&ab->reset_complete);
@@ -2305,6 +3072,70 @@ static void ath12k_core_reset(struct wor
 	ab->is_reset = true;
 	atomic_set(&ab->recovery_count, 0);
 
+	/* Incase recovery fails and FW asserts again, this is to prevent invalid operation. */
+	if (ag->num_started && ab->fw_recovery_support)
+		ag->num_started--;
+
+	if (!ag->hw_queues_stopped)
+		ath12k_core_mlo_hw_queues_stop(ag, ab);
+
+	for (i = 0; i < ag->num_chip; i++) {
+		partner_ab = ag->ab[i];
+		if (ab == partner_ab)
+			continue;
+
+		teardown = false;
+		/* Need to check partner_ab and keep recovery mode
+		 * in ab struct?
+		 */
+		if (ag->recovery_mode == ATH12K_MLO_RECOVERY_MODE1) {
+			if (test_bit(ATH12K_FLAG_UMAC_RECOVERY_START, &partner_ab->dev_flags) ||
+			    test_bit(ATH12K_FLAG_RECOVERY, &partner_ab->dev_flags)) {
+				/* On receiving MHI Interrupt for pdev which is
+				 * already in UMAC Recovery, then fallback to
+				 * MODE0
+				 */
+				ag->recovery_mode = ATH12K_MLO_RECOVERY_MODE0;
+			} else if ((!test_bit(ATH12K_FLAG_RECOVERY, &partner_ab->dev_flags)) &&
+			    (!(test_bit(ATH12K_FLAG_UMAC_RECOVERY_START, &partner_ab->dev_flags)))) {
+				/* Set dev flags to UMAC recovery START
+				 * and set flag to send teardown later
+				 */
+				ath12k_dbg(ab, ATH12K_DBG_MODE1_RECOVERY,
+						"setting teardown to true\n");
+				set_bit(ATH12K_FLAG_UMAC_RECOVERY_START, &partner_ab->dev_flags);
+				teardown = true;
+				continue;
+			} else {
+				/* if one of the ab is already in recovery, or
+				 * in UMAC recovery start phase
+				 * then fall back to MODE0
+				 */
+				ag->recovery_mode = ATH12K_MLO_RECOVERY_MODE0;
+			}
+		}
+	}
+
+	if (teardown) {
+		if (ath12k_core_trigger_umac_reset(ab) ||
+		    ath12k_mac_partner_peer_cleanup(ab)) {
+			/* Fallback to Mode0 if umac reset/peer_cleanup is
+			 * failed */
+			ag->recovery_mode = ATH12K_MLO_RECOVERY_MODE0;
+		} else {
+			/* wake queues here as ping should continue for
+			 * legacy clients in non-asserted chipsets
+			 */
+			for (i = 0; i < ag->num_hw; i++) {
+				ah = ag->ah[i];
+				if (!ah)
+					continue;
+
+				ieee80211_wake_queues(ah->hw);
+			}
+		}
+	}
+
 	for (i = 0; i < ag->num_chip; i++) {
 		partner_ab = ag->ab[i];
 		if (ab == partner_ab)
@@ -2314,16 +3145,17 @@ static void ath12k_core_reset(struct wor
 		 * method to ensure recovery of all partner chips in MODE0 instead of
 		 * relying on firmware to crash partner chips
 		 */
-		if (ath12k_recovery_mode == ATH12K_MLO_RECOVERY_MODE0 &&
-		    !test_bit(ATH12K_FLAG_RECOVERY, &partner_ab->dev_flags))
+		if (ag->recovery_mode == ATH12K_MLO_RECOVERY_MODE0 &&
+		    !test_bit(ATH12K_FLAG_RECOVERY, &partner_ab->dev_flags)) {
+			ath12k_dbg(ab, ATH12K_DBG_MODE1_RECOVERY,
+				"sending fw_hang cmd ar:%p\n",
+				partner_ab->pdevs[0].ar);
 			ath12k_wmi_force_fw_hang_cmd(partner_ab->pdevs[0].ar,
 						     ATH12K_WMI_FW_HANG_ASSERT_TYPE,
 						     ATH12K_WMI_FW_HANG_DELAY, true);
+		}
 	}
 
-	if (!ag->hw_queues_stopped)
-		ath12k_core_mlo_hw_queues_stop(ag);
-
 	ath12k_core_pre_reconfigure_recovery(ab);
 
 	ath12k_core_post_reconfigure_recovery(ab);
@@ -2342,10 +3174,6 @@ static void ath12k_core_reset(struct wor
 	if (ab->is_qdss_tracing)
 		ab->is_qdss_tracing = false;
 
-	/* Incase recovery fails and FW asserts again, this is to prevent invalid operation. */
-	if (ag->num_started && ab->fw_recovery_support)
-		ag->num_started--;
-
 	if (ab->fw_recovery_support) {
 		if (ab->hif.bus == ATH12K_BUS_PCI) {
 			ath12k_hif_power_down(ab);
@@ -2358,6 +3186,12 @@ static void ath12k_core_reset(struct wor
 		}
 		ath12k_dbg(ab, ATH12K_DBG_BOOT, "reset started\n");
 	}
+	if (ag->recovery_mode == ATH12K_MLO_RECOVERY_MODE1)
+		ab->recovery_start = true;
+
+	ab->recovery_mode_address = NULL;
+	ab->crash_info_address = NULL;
+
 	mutex_unlock(&ag->mutex_lock);
 }
 
@@ -2674,6 +3508,7 @@ struct ath12k_base *ath12k_core_alloc(st
 	init_waitqueue_head(&ab->ssr_dump_wq);
 	INIT_WORK(&ab->restart_work, ath12k_core_restart);
 	INIT_WORK(&ab->reset_work, ath12k_core_reset);
+	INIT_WORK(&ab->recovery_work, ath12k_core_mode1_recovery_work);
 	timer_setup(&ab->rx_replenish_retry, ath12k_ce_rx_replenish_retry, 0);
 	init_completion(&ab->htc_suspend);
 	init_completion(&ab->wow.wakeup_completed);
--- a/drivers/net/wireless/ath/ath12k/core.h
+++ b/drivers/net/wireless/ath/ath12k/core.h
@@ -255,6 +255,7 @@ enum ath12k_dev_flags {
 	ATH12K_FLAG_WMI_INIT_DONE,
 	ATH12K_FLAG_UMAC_PRERESET_START,
 	ATH12K_FLAG_UMAC_RESET_COMPLETE,
+	ATH12K_FLAG_UMAC_RECOVERY_START,
 };
 
 enum ath12k_monitor_flags {
@@ -339,6 +340,7 @@ struct ath12k_key_conf {
 struct ath12k_recovery_cache {
 	struct ath12k_tx_conf tx_conf;
 	struct ath12k_key_conf key_conf;
+	struct list_head recovery_sta_list;
 	u64 bss_conf_changed;
 };
 
@@ -441,6 +443,7 @@ struct ath12k_link_vif {
 	struct completion peer_ch_width_switch_send;
 	struct work_struct peer_ch_width_switch_work;
 	struct ath12k_peer_ch_width_switch_data *peer_ch_width_switch_data;
+	struct ieee80211_key_conf *keys[WMI_MAX_KEY_INDEX + 1];
 };
 
 struct ath12k_vif {
@@ -680,6 +683,9 @@ struct ath12k_link_sta {
 
 	/* For check disable fixed rate check for peer */
 	bool disable_fixed_rate;
+	/* will be saved to use during recovery */
+	struct ieee80211_key_conf *keys[WMI_MAX_KEY_INDEX + 1];
+	enum ieee80211_sta_state state;
 };
 
 struct ath12k_sta {
@@ -1250,6 +1256,7 @@ struct ath12k_hw {
 
 	/* protected by ah->data_lock */
 	struct list_head ml_peers;
+	bool in_recovery;
 	struct ath12k radio[0] __aligned(sizeof(void *));
 };
 
@@ -1261,7 +1268,8 @@ struct ath12k_mlo_memory {
 };
 
 enum ath12k_mlo_recovery_mode {
-	ATH12K_MLO_RECOVERY_MODE0,
+	ATH12K_MLO_RECOVERY_MODE0 = 1,
+	ATH12K_MLO_RECOVERY_MODE1 = 2,
 };
 
 struct ath12k_mlo_dp_umac_reset {
@@ -1417,6 +1425,7 @@ struct ath12k_base {
 	struct work_struct restart_work;
 	struct workqueue_struct *workqueue_aux;
 	struct work_struct reset_work;
+	struct work_struct recovery_work;
 	atomic_t recovery_count;
 	atomic_t reset_count;
 	bool is_reset;
@@ -1489,6 +1498,8 @@ struct ath12k_base {
 	u32 *recovery_mode_address;
 
 	bool mlo_complete_event;
+	/* Mode1 specific flag to identify recovering pdev */
+	bool recovery_start;
 	/* must be last */
 	u8 drv_priv[0] __aligned(sizeof(void *));
 };
--- a/drivers/net/wireless/ath/ath12k/debug.h
+++ b/drivers/net/wireless/ath/ath12k/debug.h
@@ -34,6 +34,7 @@ enum ath12k_debug_mask {
 	ATH12K_DBG_SAWF		= 0x00040000,
 	ATH12K_DBG_PPE          = 0x00080000,
 	ATH12K_DBG_DP_UMAC_RESET= 0x00100000,
+	ATH12K_DBG_MODE1_RECOVERY= 0x00200000,
 	ATH12K_DBG_ANY		= 0xffffffff,
 };
 
--- a/drivers/net/wireless/ath/ath12k/mac.c
+++ b/drivers/net/wireless/ath/ath12k/mac.c
@@ -265,12 +265,8 @@ static const u32 ath12k_smps_map[] = {
 	[WLAN_HT_CAP_SM_PS_DISABLED] = WMI_PEER_SMPS_PS_NONE,
 };
 
-static int ath12k_mac_vdev_create(struct ath12k *ar, struct ath12k_link_vif *arvif);
 static int ath12k_start_vdev_delay(struct ath12k *ar,
 				   struct ieee80211_vif *vif);
-static void ath12k_mac_parse_tx_pwr_env(struct ath12k *ar,
-                                        struct ath12k_link_vif *arvif,
-                                        struct ieee80211_chanctx_conf *ctx);
 static void ath12k_update_bcn_template_work(struct work_struct *work);
 static void ath12k_update_obss_color_notify_work(struct work_struct *work);
 static void ath12k_mac_remove_link_interface(struct ieee80211_hw *hw,
@@ -1026,10 +1022,106 @@ static int ath12k_mac_set_kickout(struct
 	return 0;
 }
 
+static void ath12k_mac_dec_num_stations(struct ath12k_link_vif *arvif,
+				        struct ath12k_link_sta *arsta)
+{
+	struct ath12k_vif *ahvif = arvif->ahvif;
+	struct ath12k *ar = arvif->ar;
+	struct ath12k_sta *ahsta = arsta->ahsta;
+	struct ieee80211_sta *sta;
+
+	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
+
+	lockdep_assert_held(&ar->conf_mutex);
+
+	if (!ar->num_stations)
+		return;
+
+	if (ahvif->vdev_type == WMI_VDEV_TYPE_STA && !sta->tdls)
+		return;
+
+	ar->num_stations--;
+}
+
+int ath12k_mac_partner_peer_cleanup(struct ath12k_base *ab)
+{
+
+	struct ath12k_base *partner_ab;
+	struct ath12k *ar;
+	struct ath12k_pdev *pdev;
+	struct ath12k_hw_group *ag;
+	struct ath12k_link_vif *arvif;
+	struct ath12k_vif *ahvif;
+	struct ieee80211_sta *sta;
+	struct ieee80211_vif *vif;
+	struct ath12k_sta *ahsta;
+	struct ath12k_link_sta *arsta;
+	struct ath12k_peer *peer, *tmp;
+	int idx, rad_idx, count=0, ret = 0;
+	u8 link_id;
+
+	ag = ab->ag;
+
+	for (idx = 0; idx < ag->num_chip; idx++) {
+		partner_ab = ag->ab[idx];
+
+		if (ab == partner_ab)
+			continue;
+
+		for (rad_idx = 0; rad_idx < partner_ab->num_radios; rad_idx++) {
+			pdev = &partner_ab->pdevs[rad_idx];
+			ar = pdev->ar;
+
+			/* TODO: Need to see if ab peers list is suffice for
+			 * split phy case also
+			 */
+			list_for_each_entry_safe(peer, tmp, &partner_ab->peers, list) {
+				count++;
+				if (!peer->sta || !peer->mlo || !peer->vif)
+					continue;
+
+				link_id = peer->link_id;
+				/* get arsta */
+				sta = peer->sta;
+				ahsta = (struct ath12k_sta *)sta->drv_priv;
+				arsta = ahsta->link[link_id];
+
+				/* get arvif */
+				vif = peer->vif;
+				ahvif = (struct ath12k_vif *)vif->drv_priv;
+				arvif = ahvif->link[link_id];
+				cancel_work_sync(&arsta->update_wk);
+
+				mutex_lock(&ar->conf_mutex);
+				ret = ath12k_peer_delete_send(ar, arvif->vdev_id, arsta->addr);
+				if (ret) {
+					mutex_unlock(&ar->conf_mutex);
+					ath12k_warn(ar->ab,
+						    "failed to delete peer vdev_id %d addr %pM ret %d\n",
+						    arvif->vdev_id, arsta->addr, ret);
+					continue;
+				}
+				ret = ath12k_wait_for_peer_delete_done(ar, arvif->vdev_id, arsta->addr);
+				if (ret) {
+					mutex_unlock(&ar->conf_mutex);
+					continue;
+				}
+				ar->num_peers--;
+				arvif->num_stations--;
+				ath12k_mac_dec_num_stations(arvif, arsta);
+				mutex_unlock(&ar->conf_mutex);
+			}
+		}
+	}
+	return ret;
+}
+
 void ath12k_mac_peer_cleanup_all(struct ath12k *ar)
 {
 	struct ath12k_peer *peer, *tmp;
 	struct ath12k_base *ab = ar->ab;
+	struct ath12k_hw_group *ag = ab->ag;
+	struct ath12k_link_vif *arvif, *tmp_vif;
 
 	lockdep_assert_held(&ar->conf_mutex);
 
@@ -1054,6 +1146,10 @@ void ath12k_mac_peer_cleanup_all(struct
 	ar->num_peers = 0;
 	ar->num_stations = 0;
 
+	if (ag->recovery_mode == ATH12K_MLO_RECOVERY_MODE1) {
+		list_for_each_entry_safe_reverse(arvif, tmp_vif, &ar->arvifs, list)
+			arvif->num_stations = 0;
+	}
 	ath12k_dbg(ar->ab, ATH12K_DBG_MAC, "ath12k mac peer cleanup done\n");
 }
 
@@ -1191,7 +1287,7 @@ static int ath12k_mac_monitor_vdev_stop(
 	return ret;
 }
 
-static int ath12k_mac_monitor_vdev_create(struct ath12k *ar)
+int ath12k_mac_monitor_vdev_create(struct ath12k *ar)
 {
 	struct ath12k_pdev *pdev = ar->pdev;
 	struct vdev_create_params param;
@@ -1267,7 +1363,7 @@ static int ath12k_mac_monitor_vdev_creat
 	return 0;
 }
 
-static int ath12k_mac_monitor_vdev_delete(struct ath12k *ar)
+int ath12k_mac_monitor_vdev_delete(struct ath12k *ar)
 {
 	int ret = 0;
 	unsigned long time_left = 0;
@@ -1320,7 +1416,7 @@ ath12k_mac_get_any_chandef_iter(struct i
 		arg->def = &conf->def;
 }
 
-static int ath12k_mac_monitor_start(struct ath12k *ar)
+int ath12k_mac_monitor_start(struct ath12k *ar)
 {
 	struct cfg80211_chan_def *chandef;
 	struct ath12k_mac_any_chandef_arg arg = { .ar = ar, .def = NULL};
@@ -1364,7 +1460,7 @@ static int ath12k_mac_monitor_start(stru
 	return ret;
 }
 
-static int ath12k_mac_monitor_stop(struct ath12k *ar)
+int ath12k_mac_monitor_stop(struct ath12k *ar)
 {
 	int ret;
 
@@ -4284,10 +4380,10 @@ static int ath12k_mac_config_obss_pd(str
 	return 0;
 }
 
-static void ath12k_mac_bss_info_changed(struct ath12k *ar,
-					struct ath12k_link_vif *arvif,
-					struct ieee80211_bss_conf *info,
-					u64 changed)
+void ath12k_mac_bss_info_changed(struct ath12k *ar,
+				 struct ath12k_link_vif *arvif,
+				 struct ieee80211_bss_conf *info,
+				 u64 changed)
 {
 	struct ath12k_vif *ahvif = arvif->ahvif, *tx_ahvif;
 	struct ath12k_link_vif *tx_arvif;
@@ -4454,7 +4550,8 @@ skip_pending_cs_up:
 	if (changed & BSS_CHANGED_BSSID && info->bssid && !is_zero_ether_addr(info->bssid))
 		ether_addr_copy(arvif->bssid, info->bssid);
 
-	if (changed & BSS_CHANGED_BEACON_ENABLED && !arvif->is_started)
+	/* pending_up is not needed for recovered ab during Mode1 scenario */
+	if (changed & BSS_CHANGED_BEACON_ENABLED && !arvif->is_started && !ar->ab->recovery_start)
 		arvif->pending_up = true;
 
 	if (changed & BSS_CHANGED_BEACON_ENABLED && arvif->is_started) {
@@ -5518,10 +5615,10 @@ static int ath12k_clear_peer_keys(struct
 	return first_errno;
 }
 
-static int ath12k_mac_set_key(struct ath12k *ar, enum set_key_cmd cmd,
-			      struct ath12k_link_vif *arvif,
-			      struct ath12k_link_sta *arsta,
-			      struct ieee80211_key_conf *key)
+int ath12k_mac_set_key(struct ath12k *ar, enum set_key_cmd cmd,
+		       struct ath12k_link_vif *arvif,
+		       struct ath12k_link_sta *arsta,
+		       struct ieee80211_key_conf *key)
 {
 	struct ath12k_base *ab;
 	struct ath12k_peer *peer;
@@ -5540,6 +5637,10 @@ static int ath12k_mac_set_key(struct ath
 		sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
 	}
 
+	if (sta && sta->mlo &&
+	   (test_bit(ATH12K_FLAG_UMAC_RECOVERY_START, &ar->ab->dev_flags)))
+		return 0;
+
 	lockdep_assert_held(&ar->ah->conf_mutex);
 
 	rcu_read_lock();
@@ -5718,8 +5819,10 @@ static int ath12k_mac_op_set_key(struct
 	}
 
 	if (test_bit(ATH12K_FLAG_CRASH_FLUSH, &arvif->ar->ab->dev_flags)) {
+		ath12k_dbg(arvif->ar->ab, ATH12K_DBG_MODE1_RECOVERY,
+				"cmd:%d called for crash flush set ab\n", cmd);
 		mutex_unlock(&ah->conf_mutex);
-		return -ESHUTDOWN;
+		return 0;
 	}
 
 	if (sta) {
@@ -5735,6 +5838,7 @@ static int ath12k_mac_op_set_key(struct
 				mutex_unlock(&arvif->ar->conf_mutex);
 				if (ret)
 					break;
+				arsta->keys[key->keyidx] = key;
 			}
 		} else {
 			arsta = &ahsta->deflink;
@@ -5744,10 +5848,13 @@ static int ath12k_mac_op_set_key(struct
 			mutex_lock(&arvif->ar->conf_mutex);
 			ret = ath12k_mac_set_key(arvif->ar, cmd, arvif, arsta, key);
 			mutex_unlock(&arvif->ar->conf_mutex);
+			arsta->keys[key->keyidx] = key;
 		}
 	} else {
 		mutex_lock(&arvif->ar->conf_mutex);
 		ret = ath12k_mac_set_key(arvif->ar, cmd, arvif, arsta, key);
+		/* if sta is null, consider it has self peer */
+		arvif->keys[key->keyidx] = key;
 		mutex_unlock(&arvif->ar->conf_mutex);
 	}
 out:
@@ -6229,7 +6336,7 @@ static int ath12k_station_assoc(struct a
 
 	arsta->bw = bandwidth;
 	arvif->num_stations++;
-	ath12k_dbg(ar->ab, ATH12K_DBG_MAC,
+	ath12k_dbg(ar->ab, ATH12K_DBG_MODE1_RECOVERY,
 		   "mac station %pM connected to vdev %u. num_stations=%u\n",
 		   arsta->addr,  arvif->vdev_id, arvif->num_stations);
 
@@ -6651,33 +6758,10 @@ static int ath12k_mac_inc_num_stations(s
 
 	ar->num_stations++;
 
+	ath12k_dbg(ar->ab, ATH12K_DBG_MODE1_RECOVERY,"num_stat incremented:%d\n", ar->num_stations);
 	return 0;
 }
 
-static void ath12k_mac_dec_num_stations(struct ath12k_link_vif *arvif,
-				        struct ath12k_link_sta *arsta)
-{
-	struct ath12k_vif *ahvif = arvif->ahvif;
-	struct ath12k *ar = arvif->ar;
-	struct ath12k_sta *ahsta = arsta->ahsta;
-	struct ieee80211_sta *sta;
-
-	if (ar && !ar->num_stations &&
-			test_bit(ATH12K_FLAG_RECOVERY, &ar->ab->dev_flags))
-		return;
-
-	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
-
-	lockdep_assert_held(&ar->conf_mutex);
-
-	if (ahvif->vdev_type == WMI_VDEV_TYPE_STA && !sta->tdls)
-		return;
-
-	WARN_ON(ar->num_stations == 0);
-	if (ar->num_stations)
-		ar->num_stations--;
-}
-
 static void ath12k_mac_station_post_remove(struct ath12k *ar,
 					   struct ath12k_link_vif *arvif,
 					   struct ath12k_link_sta *arsta)
@@ -6947,6 +7031,7 @@ static int ath12k_mac_assign_link_sta(st
 	arsta->arvif = ahvif->link[link_id];
 	arsta->ahsta = ahsta;
 	arsta->link_id = link_id;
+	arsta->state = IEEE80211_STA_NONE;
 
 	return 0;
 }
@@ -7075,6 +7160,11 @@ static int ath12k_mac_handle_link_sta_st
 
 	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
 
+	if (sta->mlo &&
+	   (test_bit(ATH12K_FLAG_UMAC_RECOVERY_START, &ar->ab->dev_flags)))
+		/* Shouldn't allow MLO STA assoc until UMAC_RECOVERY bit is cleared */
+		return 0;
+
 	/* cancel must be done outside the ar mutex to avoid deadlock */
 	if ((old_state == IEEE80211_STA_NONE &&
 	     new_state == IEEE80211_STA_NOTEXIST)) {
@@ -7132,6 +7222,7 @@ static int ath12k_mac_handle_link_sta_st
 				    arsta->addr);
 	}
 
+	arsta->state = new_state;
 	mutex_unlock(&ar->conf_mutex);
 
 	ath12k_dbg(ar->ab, ATH12K_DBG_PEER, "mac sta %pM old state %d new state :%d\n",
@@ -7206,11 +7297,11 @@ out:
 	return ret;
 }
 
-static int ath12k_mac_op_sta_state(struct ieee80211_hw *hw,
-				   struct ieee80211_vif *vif,
-				   struct ieee80211_sta *sta,
-				   enum ieee80211_sta_state old_state,
-				   enum ieee80211_sta_state new_state)
+int ath12k_mac_update_sta_state(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif,
+				struct ieee80211_sta *sta,
+				enum ieee80211_sta_state old_state,
+				enum ieee80211_sta_state new_state)
 {
 	struct ath12k_hw *ah = hw->priv;
 	struct ath12k_link_vif *arvif;
@@ -7269,7 +7360,7 @@ static int ath12k_mac_op_sta_state(struc
 		goto exit;
 	}
 
-	if (!sta->valid_links)
+	if (!sta->valid_links && !vif->valid_links)
 		WARN_ON(1);
 
 	/* assign default link to the first link sta */
@@ -7294,6 +7385,27 @@ static int ath12k_mac_op_sta_state(struc
 		goto exit;
  	}
 
+	/* Reconfig links of arsta during recovery */
+	if (ahsta->link[ahsta->assoc_link_id]->state != IEEE80211_STA_NONE &&
+	    old_state == IEEE80211_STA_NOTEXIST &&
+	    new_state == IEEE80211_STA_NONE) {
+		ahsta->num_peer = 0;
+
+		for_each_set_bit(link_id, &ahsta->links_map,
+				 IEEE80211_MLD_MAX_NUM_LINKS) {
+			arsta = ahsta->link[link_id];
+			arvif = ahvif->link[link_id];
+
+			ath12k_mac_assign_link_sta(ah, ahsta, arsta,
+						   ahvif, link_id);
+		}
+		ahsta->deflink.is_assoc_link = true;
+		ahsta->assoc_link_id = ahvif->deflink.link_id;
+
+		if (ahsta->use_4addr_set)
+			ieee80211_queue_work(ah->hw, &ahsta->set_4addr_wk);
+	}
+
 	for_each_set_bit(link_id, &sta->valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
 		arvif = ahvif->link[link_id];
 		arsta = ahsta->link[link_id];
@@ -7320,7 +7432,8 @@ static int ath12k_mac_op_sta_state(struc
 					ret = 0;
 			}
 
-			if (old_state == IEEE80211_STA_NOTEXIST && new_state == IEEE80211_STA_NONE) {
+			if (old_state == IEEE80211_STA_NOTEXIST && new_state == IEEE80211_STA_NONE &&
+			    !test_bit(ATH12K_FLAG_RECOVERY, &arvif->ar->ab->dev_flags)) {
 
 				/* Unassign this link sta which couldnt be added to FW and
 				 * cleanup the other link stations added earlier
@@ -7346,6 +7459,16 @@ exit:
 	return ret;
 }
 
+static int ath12k_mac_op_sta_state(struct ieee80211_hw *hw,
+				   struct ieee80211_vif *vif,
+				   struct ieee80211_sta *sta,
+				   enum ieee80211_sta_state old_state,
+				   enum ieee80211_sta_state new_state)
+{
+	return ath12k_mac_update_sta_state(hw, vif, sta, old_state,
+					   new_state);
+}
+
 static int ath12k_mac_op_change_sta_links(struct ieee80211_hw *hw,
 					    struct ieee80211_vif *vif,
 					    struct ieee80211_sta *sta,
@@ -7613,9 +7736,9 @@ exit:
 	return ret;
 }
 
-static int ath12k_mac_conf_tx(struct ath12k *ar,
-			      struct ath12k_link_vif *arvif, u16 ac,
-			      const struct ieee80211_tx_queue_params *params)
+int ath12k_mac_conf_tx(struct ath12k *ar,
+		       struct ath12k_link_vif *arvif, u16 ac,
+		       const struct ieee80211_tx_queue_params *params)
 {
 	struct wmi_wmm_params_arg *p = NULL;
 	int ret;
@@ -9116,6 +9239,13 @@ static void ath12k_mac_op_tx(struct ieee
 
 	ar = arvif->ar;
 
+	ah = ar->ah;
+
+	if (unlikely(test_bit(ATH12K_FLAG_CRASH_FLUSH, &ar->ab->dev_flags))) {
+		ieee80211_free_txskb(ah->hw, skb);
+		return;
+	}
+
 #ifdef CPTCFG_MAC80211_SFE_SUPPORT
 	if (skb->fast_xmit) {
 		ret = ath12k_mac_tx_check_max_limit(ar, skb);
@@ -9137,13 +9267,6 @@ static void ath12k_mac_op_tx(struct ieee
 	}
 #endif
 
-	ah = ar->ah;
-
-	if (unlikely(test_bit(ATH12K_FLAG_CRASH_FLUSH, &ar->ab->dev_flags))) {
-		ieee80211_free_txskb(ah->hw, skb);
-		return;
-	}
-
 	if (key) {
 		skb_cb->cipher = key->cipher;
 		skb_cb->flags |= ATH12K_SKB_CIPHER_SET;
@@ -9231,6 +9354,9 @@ static void ath12k_mac_op_tx(struct ieee
 
 			tmp_ar = tmp_arvif->ar;
 
+			if (unlikely(test_bit(ATH12K_FLAG_CRASH_FLUSH, &tmp_ar->ab->dev_flags)))
+				continue;
+
 			ret = ath12k_mac_tx_check_max_limit(tmp_ar, skb);
 			if (ret) {
 				ath12k_dbg(tmp_ar->ab, ATH12K_DBG_MAC,
@@ -9448,6 +9574,10 @@ static int __ath12k_mac_mlo_teardown(str
 	struct ath12k_base *ab = ar->ab;
 	int ret;
 
+       // If we receive teardown during ab is down, then exit silently
+       if (test_bit(ATH12K_FLAG_RECOVERY, &ab->dev_flags))
+	       return 0;
+
 	ret = ath12k_wmi_mlo_teardown(ar, umac_reset);
 	if (ret) {
 		ath12k_err(ab, "failed to teardown MLO for pdev_idx %d: %d\n",
@@ -9455,8 +9585,8 @@ static int __ath12k_mac_mlo_teardown(str
 		return ret;
 	}
 
-	ath12k_dbg(ab, ATH12K_DBG_MAC, "MLO teardown for pdev_idx %d\n",
-		   ar->pdev_idx);
+	ath12k_dbg(ab, ATH12K_DBG_MAC, "MLO teardown for pdev_idx %d:%d\n",
+		   ar->pdev_idx, umac_reset);
 	return 0;
 }
 
@@ -9492,12 +9622,45 @@ err_setup:
 	return ret;
 }
 
-static int ath12k_mac_radio_start(struct ath12k *ar)
+static void ath12k_mac_drain_tx(struct ath12k_hw *ah,
+				struct ath12k *asserted_ar)
+{
+	struct ath12k *ar;
+	int i;
+
+	if (asserted_ar) {
+		/* if asserted ar is NOT NULL, consider it
+		 * is during Mode1 recovery and drain only
+		 * asserted pdev
+		 */
+		ath12k_mac_radio_drain_tx(asserted_ar);
+		return;
+	}
+
+	ar = ah->radio;
+
+	for (i = 0; i < ah->num_radio; i++) {
+		ath12k_mac_radio_drain_tx(ar);
+		ar++;
+	}
+}
+
+int ath12k_mac_radio_start(struct ath12k *ar)
 {
 	struct ath12k_base *ab = ar->ab;
 	struct ath12k_pdev *pdev = ar->pdev;
+	struct ath12k_hw_group *ag = ab->ag;
+	struct ath12k_hw *ah = ar->ah;
 	int ret;
 
+	/* reo init/drain tx only needed for recovered
+	 * ab during Mode1 scenario
+	 */
+	if (ab->recovery_start) {
+		ath12k_mgmt_rx_reo_init_timer(ag);
+		ath12k_mac_drain_tx(ah, ar);
+	}
+
 	mutex_lock(&ar->conf_mutex);
 
 	switch (ar->state) {
@@ -9768,7 +9931,7 @@ static void ath12k_mac_radio_stop(struct
         spin_unlock_bh(&ar->data_lock);
 }
 
-static void ath12k_mgmt_rx_reo_init_timer(struct ath12k_hw_group *ag)
+void ath12k_mgmt_rx_reo_init_timer(struct ath12k_hw_group *ag)
 {
 	struct ath12k_mgmt_rx_reo_context *reo_context = &ag->rx_reo;
 
@@ -9803,19 +9966,6 @@ static void ath12k_mgmt_rx_reo_deinit_ti
 	reo_context->timer_init_done = false;
 }
 
-static void ath12k_mac_drain_tx(struct ath12k_hw *ah)
-{
-	struct ath12k *ar;
-	int i;
-
-	ar = ah->radio;
-
-	for (i = 0; i < ah->num_radio; i++) {
-		ath12k_mac_radio_drain_tx(ar);
-		ar++;
-	}
-}
-
 static int ath12k_mac_op_start(struct ieee80211_hw *hw)
 {
 	struct ath12k_hw *ah = hw->priv;
@@ -9827,7 +9977,7 @@ static int ath12k_mac_op_start(struct ie
 
 	ath12k_mgmt_rx_reo_init_timer(ag);
 
-	ath12k_mac_drain_tx(ah);
+	ath12k_mac_drain_tx(ah, NULL);
 
 	mutex_lock(&ah->conf_mutex);
 	ar = ah->radio;
@@ -9874,7 +10024,7 @@ static void ath12k_mac_op_stop(struct ie
 
 	ath12k_mgmt_rx_reo_deinit_timer(ag);
 
-	ath12k_mac_drain_tx(ah);
+	ath12k_mac_drain_tx(ah, NULL);
 
 	mutex_lock(&ah->conf_mutex);
 	ar = ah->radio;
@@ -10165,7 +10315,7 @@ static void ath12k_update_obss_color_not
 	mutex_unlock(&ar->conf_mutex);
 }
 
-static int ath12k_mac_vdev_create(struct ath12k *ar, struct ath12k_link_vif *arvif)
+ int ath12k_mac_vdev_create(struct ath12k *ar, struct ath12k_link_vif *arvif)
 {
 	struct ieee80211_vif *vif = arvif->ahvif->vif;
 	struct ath12k_base *ab = ar->ab;
@@ -10315,7 +10465,14 @@ static int ath12k_mac_vdev_create(struct
 	ar->allocated_vdev_map |= 1LL << arvif->vdev_id;
 
 	spin_lock_bh(&ar->data_lock);
-	list_add(&arvif->list, &ar->arvifs);
+
+	/* list added is not needed during mode1 recovery
+	 * as the arvif(s) updated are from the existing
+	 * list
+	 */
+	if (!ab->recovery_start)
+		list_add(&arvif->list, &ar->arvifs);
+
 	spin_unlock_bh(&ar->data_lock);
 
 	ath12k_mac_update_vif_offload(ar, arvif);
@@ -10474,8 +10631,8 @@ err:
 	return ret;
 }
 
-static void ath12k_mac_vif_cache_flush(struct ath12k *ar,  struct ieee80211_vif *vif,
-				       u8 link_id)
+void ath12k_mac_vif_cache_flush(struct ath12k *ar,  struct ieee80211_vif *vif,
+				u8 link_id)
 {
 	struct ath12k_hw *ah = ar->ah;
 	struct ath12k_vif *ahvif = (void *)vif->drv_priv;
@@ -10921,6 +11078,10 @@ static int ath12k_mac_ampdu_action(struc
 	if (unlikely(test_bit(ATH12K_FLAG_CRASH_FLUSH, &ar->ab->dev_flags)))
 		return -ESHUTDOWN;
 
+	if (params->sta->mlo &&
+	   (test_bit(ATH12K_FLAG_UMAC_RECOVERY_START, &ar->ab->dev_flags)))
+		return 0;
+
 	mutex_lock(&ar->conf_mutex);
 
 	switch (params->action) {
@@ -11363,7 +11524,7 @@ err:
 	return ret;
 }
 
-static int ath12k_mac_vdev_start(struct ath12k_link_vif *arvif,
+int ath12k_mac_vdev_start(struct ath12k_link_vif *arvif,
 				 const struct cfg80211_chan_def *chandef,
 				 bool radar_enabled)
 {
@@ -11477,7 +11638,7 @@ beacon_tmpl_setup:
 	return ret;
 }
 
-static int ath12k_mac_mlo_vdev_start(struct ath12k_link_vif *arvif)
+int ath12k_mac_mlo_vdev_start(struct ath12k_link_vif *arvif, bool flag)
 {
 	struct ath12k_vif *ahvif = arvif->ahvif;
 	struct ath12k *ar = arvif->ar;
@@ -11539,7 +11700,12 @@ static int ath12k_mac_mlo_vdev_start(str
 
 		arvif->is_started = true;
 		mutex_unlock(&ar->conf_mutex);
-		ahvif->num_vdev_started++;
+		/* num vdev started is not needed during mode1 recovery
+		 * as the arvif(s) updated are from the existing
+		 * list
+		 */
+		if (!ar->ab->recovery_start)
+			ahvif->num_vdev_started++;
 		/* Beaconing not required in DFS channel assignment for CAC */
 		return ret;
 	}
@@ -11563,6 +11729,9 @@ static int ath12k_mac_mlo_vdev_start(str
 
 		ar = arvif_p->ar;
 
+		if (!ar->ab->is_reset && !flag)
+			continue;
+
 		/* TODO cant hold rcu lock due to call of ath12k_mac_bss_info_changed
 		 * option is to take a backup if link info, anyways this function would
 		 * change after FW support for dynamic add
@@ -11594,7 +11763,12 @@ static int ath12k_mac_mlo_vdev_start(str
 			arvif_p->pending_up = false;
 		}
 		mutex_unlock(&ar->conf_mutex);
-		ahvif->num_vdev_started++;
+		/* num vdev started is not needed during mode1 recovery
+		 * as the arvif(s) updated are from the existing
+		 * list
+		 */
+		if (!ar->ab->recovery_start)
+			ahvif->num_vdev_started++;
 	}
 out:
 	return ret;
@@ -12650,9 +12824,9 @@ void ath12k_mac_fill_reg_tpc_info(struct
                 ath12k_ieee80211_ap_pwr_type_convert(reg_6g_power_mode);
 }
 
-static void ath12k_mac_parse_tx_pwr_env(struct ath12k *ar,
-                                        struct ath12k_link_vif *arvif,
-                                        struct ieee80211_chanctx_conf *ctx)
+void ath12k_mac_parse_tx_pwr_env(struct ath12k *ar,
+				 struct ath12k_link_vif *arvif,
+				 struct ieee80211_chanctx_conf *ctx)
 {
         struct ath12k_base *ab = ar->ab;
 	struct ath12k_vif *ahvif = arvif->ahvif;
@@ -12932,11 +13106,11 @@ ath12k_mac_op_assign_vif_chanctx(struct
 		goto out;
 	}
 
+	memcpy(&arvif->chanctx, ctx, sizeof(*ctx));
 	if (ath12k_mac_is_ml_arvif(arvif) &&
 	    ahvif->vdev_type == WMI_VDEV_TYPE_AP) {
 		mutex_unlock(&ar->conf_mutex);
-		memcpy(&arvif->chanctx, ctx, sizeof(*ctx));
-		ret = ath12k_mac_mlo_vdev_start(arvif);
+		ret = ath12k_mac_mlo_vdev_start(arvif, true);
 		mutex_unlock(&ah->conf_mutex);
 		return ret;
 	}
@@ -13130,7 +13304,7 @@ ath12k_mac_op_switch_vif_chanctx(struct
 	return 0;
 }
 
-static int
+int
 ath12k_set_vdev_param_to_all_vifs(struct ath12k *ar, int param, u32 value)
 {
 	struct ath12k_link_vif *arvif;
@@ -14233,14 +14407,68 @@ out:
 	mutex_unlock(&ah->conf_mutex);
 	return ret;
 }
+static void ath12k_mac_sta_hw_restart_disconnect(struct ath12k *ar)
+{
+	struct ath12k_vif *ahvif;
+	struct ath12k_link_vif *arvif;
 
-static void
-ath12k_mac_op_reconfig_complete(struct ieee80211_hw *hw,
-				enum ieee80211_reconfig_type reconfig_type)
+	list_for_each_entry(arvif, &ar->arvifs, list) {
+		ahvif = arvif->ahvif;
+		if (ahvif->vdev_type == WMI_VDEV_TYPE_STA)
+			ieee80211_hw_restart_disconnect(ahvif->vif);
+	}
+}
+
+static void ath12k_mac_reconfig_completion(struct ath12k *ar,
+					   u8 *restart_count)
+{
+	u8 recovery_count;
+
+	mutex_lock(&ar->conf_mutex);
+
+	if (ar->state == ATH12K_STATE_RESTARTED) {
+		if (ar->ab->ag->recovery_mode == ATH12K_MLO_RECOVERY_MODE0)
+			ath12k_mac_sta_hw_restart_disconnect(ar);
+		ath12k_warn(ar->ab, "pdev %d successfully recovered\n",
+			    ar->pdev->pdev_id);
+		ar->state = ATH12K_STATE_ON;
+		*restart_count += 1;
+	}
+
+	if (ar->ab->is_reset) {
+		recovery_count = atomic_inc_return(&ar->ab->recovery_count);
+		ath12k_dbg(ar->ab, ATH12K_DBG_BOOT,
+			   "recovery count %d\n", recovery_count);
+		/* When there are multiple radios in an SOC,
+		 * the recovery has to be done for each radio
+		 */
+		if (recovery_count == ar->ab->num_radios) {
+			atomic_dec(&ar->ab->reset_count);
+			complete(&ar->ab->reset_complete);
+			ar->ab->is_reset = false;
+			ar->ab->recovery_start = false;
+			atomic_set(&ar->ab->fail_cont_count, 0);
+			clear_bit(ATH12K_FLAG_RECOVERY, &ar->ab->dev_flags);
+			spin_lock_bh(&ar->ab->base_lock);
+			ar->ab->stats.last_recovery_time =
+				jiffies_to_msecs(jiffies -
+						ar->ab->recovery_start_time);
+			spin_unlock_bh(&ar->ab->base_lock);
+			ath12k_dbg(ar->ab, ATH12K_DBG_BOOT, "reset success\n");
+		}
+	}
+
+	mutex_unlock(&ar->conf_mutex);
+}
+
+void
+ath12k_mac_reconfig_complete(struct ieee80211_hw *hw,
+				enum ieee80211_reconfig_type reconfig_type,
+				struct ath12k *asserted_radio)
 {
 	struct ath12k_hw *ah = hw->priv;
 	struct ath12k *ar;
-	u8 restart_count = 0, recovery_count;
+	u8 restart_count = 0;
 	int i;
 
 	if (reconfig_type != IEEE80211_RECONFIG_TYPE_RESTART)
@@ -14250,42 +14478,21 @@ ath12k_mac_op_reconfig_complete(struct i
 
 	ar = ah->radio;
 
-	for (i = 0; i < ah->num_radio; i++) {
-		mutex_lock(&ar->conf_mutex);
-
-		if (ar->state == ATH12K_STATE_RESTARTED) {
-			ath12k_warn(ar->ab, "pdev %d successfully recovered\n",
-				    ar->pdev->pdev_id);
-			ar->state = ATH12K_STATE_ON;
-			restart_count++;
-		}
-
-		if (ar->ab->is_reset) {
-			recovery_count = atomic_inc_return(&ar->ab->recovery_count);
-			ath12k_dbg(ar->ab, ATH12K_DBG_BOOT,
-				   "recovery count %d\n", recovery_count);
-			/* When there are multiple radios in an SOC,
-			 * the recovery has to be done for each radio
-			 */
-			if (recovery_count == ar->ab->num_radios) {
-				atomic_dec(&ar->ab->reset_count);
-				complete(&ar->ab->reset_complete);
-				ar->ab->is_reset = false;
-				atomic_set(&ar->ab->fail_cont_count, 0);
-				clear_bit(ATH12K_FLAG_RECOVERY, &ar->ab->dev_flags);
-				spin_lock_bh(&ar->ab->base_lock);
-				ar->ab->stats.last_recovery_time =
-					jiffies_to_msecs(jiffies -
-							ar->ab->recovery_start_time);
-				spin_unlock_bh(&ar->ab->base_lock);
-				ath12k_dbg(ar->ab, ATH12K_DBG_BOOT, "reset success\n");
-			}
-		}
+	if (asserted_radio) {
+		ath12k_mac_reconfig_completion(asserted_radio, &restart_count);
+		goto out;
+	}
 
-		mutex_unlock(&ar->conf_mutex);
+	for (i = 0; i < ah->num_radio; i++) {
+		ath12k_mac_reconfig_completion(ar, &restart_count);
 		ar++;
 	}
 
+out:
+	/* If is_one_radio flag is set, then assume other radios
+	 * are up and running and wake queues once the reconfig is
+	 * done
+	 */
 	if (restart_count == ah->num_radio)
 		ieee80211_wake_queues(ah->hw);
 
@@ -14293,6 +14500,12 @@ ath12k_mac_op_reconfig_complete(struct i
 	ah->ag->hw_queues_stopped = false;
 }
 
+static void ath12k_mac_op_reconfig_complete(struct ieee80211_hw *hw,
+				  enum ieee80211_reconfig_type reconfig_type)
+{
+	ath12k_mac_reconfig_complete(hw, reconfig_type, NULL);
+}
+
 static void
 ath12k_mac_update_bss_chan_survey(struct ath12k *ar,
 				  struct ieee80211_channel *channel)
--- a/drivers/net/wireless/ath/ath12k/mac.h
+++ b/drivers/net/wireless/ath/ath12k/mac.h
@@ -14,6 +14,7 @@ struct ath12k;
 struct ath12k_base;
 struct ath12k_hw;
 struct ath12k_hw_group;
+struct ath12k_link_sta;
 
 struct ath12k_generic_iter {
 	struct ath12k *ar;
@@ -242,4 +243,43 @@ void ath12k_mac_background_dfs_event(str
 				     enum ath12k_background_dfs_events ev);
 bool ath12k_mac_tx_check_max_limit(struct ath12k *ar, struct sk_buff *skb);
 int ath12k_mac_mlo_teardown_with_umac_reset(struct ath12k_base *ab);
+void ath12k_mac_bss_info_changed(struct ath12k *ar,
+				 struct ath12k_link_vif *arvif,
+				 struct ieee80211_bss_conf *info,
+				 u64 changed);
+int ath12k_mac_radio_start(struct ath12k *ar);
+int ath12k_mac_conf_tx(struct ath12k *ar,
+		       struct ath12k_link_vif *arvif, u16 ac,
+		       const struct ieee80211_tx_queue_params *params);
+int ath12k_mac_set_key(struct ath12k *ar,
+		       enum set_key_cmd cmd,
+		       struct ath12k_link_vif *arvif,
+		       struct ath12k_link_sta *arsta,
+		       struct ieee80211_key_conf *key);
+
+int ath12k_mac_update_sta_state(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif,
+				struct ieee80211_sta *sta,
+				enum ieee80211_sta_state old_state,
+				enum ieee80211_sta_state new_state);
+void ath12k_mgmt_rx_reo_init_timer(struct ath12k_hw_group *ag);
+int ath12k_mac_vdev_create(struct ath12k *ar, struct ath12k_link_vif *arvif);
+void ath12k_mac_vif_cache_flush(struct ath12k *ar,  struct ieee80211_vif *vif,
+				u8 link_id);
+void ath12k_mac_parse_tx_pwr_env(struct ath12k *ar,
+				 struct ath12k_link_vif *arvif,
+				 struct ieee80211_chanctx_conf *ctx);
+int ath12k_mac_monitor_start(struct ath12k *ar);
+int ath12k_mac_mlo_vdev_start(struct ath12k_link_vif *arvif, bool flag);
+int ath12k_mac_vdev_start(struct ath12k_link_vif *arvif,
+			  const struct cfg80211_chan_def *chandef,
+			  bool radar_enabled);
+int ath12k_mac_monitor_vdev_create(struct ath12k *ar);
+int ath12k_mac_monitor_vdev_delete(struct ath12k *ar);
+int ath12k_mac_monitor_stop(struct ath12k *ar);
+int ath12k_set_vdev_param_to_all_vifs(struct ath12k *ar, int param, u32 value);
+void ath12k_mac_reconfig_complete(struct ieee80211_hw *hw,
+				  enum ieee80211_reconfig_type reconfig_type,
+				  struct ath12k *asserted_radio);
+int ath12k_mac_partner_peer_cleanup(struct ath12k_base *ab);
 #endif
--- a/drivers/net/wireless/ath/ath12k/peer.c
+++ b/drivers/net/wireless/ath/ath12k/peer.c
@@ -406,7 +406,7 @@ int ath12k_wait_for_peer_delete_done(str
 	return 0;
 }
 
-static int ath12k_peer_delete_send(struct ath12k *ar, u32 vdev_id, u8 *addr)
+int ath12k_peer_delete_send(struct ath12k *ar, u32 vdev_id, u8 *addr)
 {
 	struct ath12k_peer *peer;
 	struct ath12k_base *ab = ar->ab;
--- a/drivers/net/wireless/ath/ath12k/peer.h
+++ b/drivers/net/wireless/ath/ath12k/peer.h
@@ -118,6 +118,7 @@ void ath12k_peer_rhash_tbl_destroy(struc
 int ath12k_peer_rhash_delete(struct ath12k_base *ab, struct ath12k_peer *peer);
 void ath12k_peer_mlo_map_event(struct ath12k_base *ab, struct sk_buff *skb);
 void ath12k_peer_mlo_unmap_event(struct ath12k_base *ab, struct sk_buff *skb);
+int ath12k_peer_delete_send(struct ath12k *ar, u32 vdev_id, u8 *addr);
 
 static inline
 struct ath12k_link_sta *ath12k_peer_get_link_sta(struct ath12k_base *ab,
--- a/drivers/net/wireless/ath/ath12k/wmi.c
+++ b/drivers/net/wireless/ath/ath12k/wmi.c
@@ -8499,6 +8499,14 @@ static const char *ath12k_wmi_vdev_resp_
 		return "dfs violation";
 	case WMI_VDEV_START_RESPONSE_INVALID_REGDOMAIN:
 		return "invalid regdomain";
+	case WMI_VDEV_START_RESPONSE_INVALID_BAND:
+		return "invalid band";
+	case WMI_VDEV_START_RESPONSE_INVALID_PREFERRED_TX_RX_STREAMS:
+		/** Invalid preferred tx/rx streams */
+		return "invalid TX/RX streams";
+	case WMI_VDEV_START_RESPONSE_INVALID_TX_VAP_CONFIG:
+		/** Invalid tx_vap config in VDEV start */
+		return "invalid tx vap config";
 	default:
 		return "unknown";
 	}
@@ -13188,10 +13196,8 @@ static void ath12k_wmi_event_teardown_co
 			complete_flag = false;
 	}
 
-	if (complete_flag) {
+	if (complete_flag && ag->recovery_mode == ATH12K_MLO_RECOVERY_MODE1)
 		complete(&ag->umac_reset_complete);
-		ag->trigger_umac_reset = false;
-	}
 }
 
 static void ath12k_wmi_process_mvr_event(struct ath12k *ab, u32 *vdev_id_bm,
@@ -14133,7 +14139,6 @@ int ath12k_wmi_mlo_setup(struct ath12k *
 		dev_kfree_skb(skb);
 	}
 
-	ar->ab->mlo_complete_event = false;
 	return ret;
 }
 
@@ -14161,7 +14166,6 @@ int ath12k_wmi_mlo_ready(struct ath12k *
 		dev_kfree_skb(skb);
 	}
 
-	ar->ab->mlo_complete_event = false;
 	return ret;
 }
 
@@ -14191,6 +14195,7 @@ int ath12k_wmi_mlo_teardown(struct ath12
 		dev_kfree_skb(skb);
 	}
 
+	ar->ab->mlo_complete_event = false;
 	return ret;
 }
 
--- a/drivers/net/wireless/ath/ath12k/wmi.h
+++ b/drivers/net/wireless/ath/ath12k/wmi.h
@@ -4816,6 +4816,10 @@ enum wmi_vdev_start_resp_status_code {
 	WMI_VDEV_START_RESPONSE_NOT_SUPPORTED = 2,
 	WMI_VDEV_START_RESPONSE_DFS_VIOLATION = 3,
 	WMI_VDEV_START_RESPONSE_INVALID_REGDOMAIN = 4,
+	/** Band unsupported by current hw mode in VDEV start */
+	WMI_VDEV_START_RESPONSE_INVALID_BAND = 5,
+	WMI_VDEV_START_RESPONSE_INVALID_PREFERRED_TX_RX_STREAMS = 6, /** Invalid preferred tx/rx streams */
+	WMI_VDEV_START_RESPONSE_INVALID_TX_VAP_CONFIG = 7, /** Invalid tx_vap config in VDEV start */
 };
 
 ;
