diff -upr linux-6.6.89/drivers/net/mdio/of_mdio.c /home/build9/seb_working/linux-6.6.89/drivers/net/mdio/of_mdio.c
--- a/drivers/net/mdio/of_mdio.c	2025-08-22 14:44:34.467093772 +0800
+++ b/drivers/net/mdio/of_mdio.c	2025-08-22 14:39:10.212748831 +0800
@@ -145,7 +145,10 @@ static int __of_mdiobus_parse_phys(struc
 	int addr, rc = 0;
 
 	/* Loop over the child nodes and register a phy_device for each phy */
+	int an8801=0;
 	for_each_available_child_of_node(np, child) {
+		if(an8801==1)break;
+
 		if (of_node_name_eq(child, "ethernet-phy-package")) {
 			/* Ignore invalid ethernet-phy-package node */
 			if (!of_find_property(child, "reg", NULL))
@@ -166,8 +169,25 @@ static int __of_mdiobus_parse_phys(struc
 			continue;
 		}
 
-		if (of_mdiobus_child_is_phy(child))
+		if (of_mdiobus_child_is_phy(child)) {
+			if(addr==30)
+			{
+				int phy_id ;
+
+				phy_id = mdiobus_read(mdio, addr, MII_PHYSID1) << 16 ;
+				phy_id = phy_id + mdiobus_read(mdio, addr, MII_PHYSID2);
+				dev_info(&mdio->dev, "[of_mdio] %s %d  addr:%d phy_id:0x%x  \n",__func__, __LINE__, addr, phy_id);
+
+				if (phy_id==0 || phy_id==0x1a750000)
+				{
+					dev_info(&mdio->dev, "[of_mdio] %s %d  continue  \n",__func__, __LINE__);
+					continue;
+				}
+				else
+					an8801=1;
+			}
 			rc = of_mdiobus_register_phy(mdio, child, addr);
+		}
 		else
 			rc = of_mdiobus_register_device(mdio, child, addr);
 
diff -upr linux-6.6.89/drivers/net/phy/Kconfig /home/build9/seb_working/linux-6.6.89/drivers/net/phy/Kconfig
--- a/drivers/net/phy/Kconfig	2025-08-08 17:02:38.023751484 +0800
+++ b/drivers/net/phy/Kconfig	2025-08-22 15:01:27.708103066 +0800
@@ -142,6 +142,11 @@ endif # RTL8366_SMI
 
 comment "MII PHY device drivers"
 
+config AIROHA_AN8801_PHY
+	tristate "Drivers for Airoha AN8801 Gigabit PHYs"
+	help
+	  Currently supports the Airoha AN8801 PHY.
+
 config AIROHA_EN8801SC_PHY
 	tristate "Airoha EN8801SC Gigabit PHY"
 	help
diff -upr linux-6.6.89/drivers/net/phy/Makefile /home/build9/seb_working/linux-6.6.89/drivers/net/phy/Makefile
--- a/drivers/net/phy/Makefile	2025-08-08 17:02:38.023751484 +0800
+++ b/drivers/net/phy/Makefile	2025-08-22 15:02:07.464601732 +0800
@@ -49,6 +49,7 @@ obj-y				+= $(sfp-obj-y) $(sfp-obj-m)
 
 obj-$(CONFIG_ADIN_PHY)		+= adin.o
 obj-$(CONFIG_ADIN1100_PHY)	+= adin1100.o
+obj-$(CONFIG_AIROHA_AN8801_PHY)   += an8801.o
 obj-$(CONFIG_AIROHA_EN8801SC_PHY)   += en8801sc.o
 obj-$(CONFIG_AIR_AN8855_PHY)		+= air_an8855.o
 obj-$(CONFIG_AIR_EN8811H_PHY)   += air_en8811h.o
diff -upr linux-6.6.89/drivers/net/phy/phylink.c /home/build9/seb_working/linux-6.6.89/drivers/net/phy/phylink.c
--- a/drivers/net/phy/phylink.c	2025-08-22 14:43:00.994406615 +0800
+++ b/drivers/net/phy/phylink.c	2025-08-22 14:39:10.280749309 +0800
@@ -2290,7 +2290,20 @@ int phylink_fwnode_phy_connect(struct ph
 	/* We're done with the phy_node handle */
 	fwnode_handle_put(phy_fwnode);
 	if (!phy_dev)
-		return -ENODEV;
+	{
+		phylink_info(pl, "[phylink] reload phy-handle2. %s %d\n",__func__, __LINE__);
+		phy_fwnode = fwnode_find_reference(fwnode, "phy-handle2", 0);
+		if (IS_ERR(phy_fwnode)) {
+			if (pl->cfg_link_an_mode == MLO_AN_PHY)
+				return -ENODEV;
+			return 0;
+		}
+		phy_dev = fwnode_phy_find_device(phy_fwnode);
+		fwnode_handle_put(phy_fwnode);
+
+		if (!phy_dev)
+			return -ENODEV;
+ 	}
 
 	/* Use PHY device/driver interface */
	if (pl->link_interface == PHY_INTERFACE_MODE_NA) {
