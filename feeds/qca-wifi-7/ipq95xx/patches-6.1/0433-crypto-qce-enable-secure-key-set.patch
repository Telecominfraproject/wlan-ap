From ed031eed5ef831e25dd1b91c4a81cbe9c6c2c51f Mon Sep 17 00:00:00 2001
From: Sivaprakash Murugesan <sivaprak@codeaurora.org>
Date: Thu, 7 May 2020 20:19:27 +0530
Subject: [PATCH] crypto: qce: enable secure key set

enable setting encryption/decryption keys through TZ securely
when this feature enabled the key passed from crypto manager to
qce skcipher will be ignored and a key will be generated from TZ.

TZ will also lock the legacy key registers upon enabling this feature,
and unlock will be done upon disabling this feature.

there are two possible ways to enable this

1. Through dts, upon setting qce,use_fixed_hw_key flag in crypto device
   node.
2. Through sysfs entry echo 1 > sys/kernel/crypto/qce/fixed_sec_key

Signed-off-by: Sivaprakash Murugesan <sivaprak@codeaurora.org>
Change-Id: Ic353401c6b38f82fdc277dec859e154664242eb1
---
 drivers/crypto/qce/cipher.h   |  4 ++
 drivers/crypto/qce/common.c   |  4 +-
 drivers/crypto/qce/core.c     | 82 +++++++++++++++++++++++++++++++++++
 drivers/crypto/qce/core.h     |  6 +++
 drivers/crypto/qce/skcipher.c | 16 +++++++
 5 files changed, 111 insertions(+), 1 deletion(-)

diff --git a/drivers/crypto/qce/cipher.h b/drivers/crypto/qce/cipher.h
index 850f257d00f3..3e9c6a1cd373 100644
--- a/drivers/crypto/qce/cipher.h
+++ b/drivers/crypto/qce/cipher.h
@@ -17,6 +17,10 @@ struct qce_cipher_ctx {
 	struct crypto_skcipher *fallback;
 };
 
+struct qce_config_key_sec {
+	uint32_t keylen;
+}__attribute__((packed));
+
 /**
  * struct qce_cipher_reqctx - holds private cipher objects per request
  * @flags: operation flags
diff --git a/drivers/crypto/qce/common.c b/drivers/crypto/qce/common.c
index 7c612ba5068f..63cbf42a643b 100644
--- a/drivers/crypto/qce/common.c
+++ b/drivers/crypto/qce/common.c
@@ -354,7 +354,9 @@ static int qce_setup_regs_skcipher(struct crypto_async_request *async_req)
 		return -EINVAL;
 	}
 
-	qce_write_array(qce, REG_ENCR_KEY0, (u32 *)enckey, enckey_words);
+	if (!qce->use_fixed_key)
+		qce_write_array(qce, REG_ENCR_KEY0, (u32 *)enckey,
+				enckey_words);
 
 	if (!IS_ECB(flags)) {
 		if (IS_XTS(flags))
diff --git a/drivers/crypto/qce/core.c b/drivers/crypto/qce/core.c
index 8edfef08b791..ef80b0b19222 100644
--- a/drivers/crypto/qce/core.c
+++ b/drivers/crypto/qce/core.c
@@ -7,6 +7,8 @@
 #include <linux/dma-mapping.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/of.h>
+#include <linux/qcom_scm.h>
 #include <linux/mod_devicetable.h>
 #include <linux/platform_device.h>
 #include <linux/spinlock.h>
@@ -239,6 +241,76 @@ static void qce_unregister_algs(struct qce_device *qce)
 	}
 }
 
+#define to_qcedev(k) container_of(k, struct qce_device, kobj)
+
+/* Expose fixed key field so that qce can request key from TZ */
+static ssize_t fixed_sec_key_show(struct kobject *kobj,
+			struct attribute *attr, char *buf)
+{
+	struct qce_device *qce = to_qcedev(kobj);
+
+	return scnprintf(buf, sizeof(int), "%d\n", qce->use_fixed_key);
+}
+
+/* Store fixed key field from sysfs */
+static ssize_t fixed_sec_key_store(struct kobject *kobj,
+		struct attribute *attr, const char *buf, size_t count)
+{
+	int use_fixed_key;
+	struct qce_device *qce = to_qcedev(kobj);
+
+	sscanf(buf, "%du", &use_fixed_key);
+	if (use_fixed_key == 1) {
+		qce->use_fixed_key = true;
+	} else {
+		qti_qcekey_release_xpu_prot();
+		qce->use_fixed_key = false;
+	}
+	return count;
+}
+
+static struct attribute qce_fixed_key_attribute = {
+	.name = "fixed_sec_key",
+	.mode = 0660,
+};
+
+static struct attribute *qce_attrs[] = {
+	&qce_fixed_key_attribute,
+	NULL
+};
+
+static struct sysfs_ops qce_sysfs_ops = {
+	.show = fixed_sec_key_show,
+	.store = fixed_sec_key_store,
+};
+
+static struct kobj_type qce_ktype = {
+	.sysfs_ops = &qce_sysfs_ops,
+	.default_attrs = qce_attrs,
+};
+
+static int qce_sysfs_init(struct qce_device *qce)
+{
+	int ret;
+
+	qce->kobj_parent = kobject_create_and_add("crypto", kernel_kobj);
+	if (!qce->kobj_parent)
+		return -ENOMEM;
+
+	ret = kobject_init_and_add(&qce->kobj, &qce_ktype, qce->kobj_parent,
+			"%s", "qce");
+	if (ret)
+		kobject_del(qce->kobj_parent);
+
+	return ret;
+}
+
+static void qce_sysfs_deinit(struct qce_device *qce)
+{
+	kobject_del(&qce->kobj);
+	kobject_del(qce->kobj_parent);
+}
+
 static int qce_register_algs(struct qce_device *qce)
 {
 	const struct qce_algo_ops *ops;
@@ -451,6 +523,9 @@ static int qce_crypto_probe(struct platform_device *pdev)
 	if (ret < 0)
 		return ret;
 
+	if (device_property_read_bool(dev, "qce,use_fixed_hw_key"))
+		qce->use_fixed_key = true;
+
 	qce->core = devm_clk_get(qce->dev, "core");
 	if (IS_ERR(qce->core))
 		return PTR_ERR(qce->core);
@@ -499,8 +574,14 @@ static int qce_crypto_probe(struct platform_device *pdev)
 	if (ret)
 		goto unregister_algs;
 
+	ret = qce_sysfs_init(qce);
+	if (ret)
+		goto remove_debugfs;
+
 	return 0;
 
+remove_debugfs:
+	debugfs_remove_recursive(qce->qce_debug_dent);
 unregister_algs:
 	qce_unregister_algs(qce);
 err_dma:
@@ -525,6 +606,7 @@ static int qce_crypto_remove(struct platform_device *pdev)
 	clk_disable_unprepare(qce->iface);
 	clk_disable_unprepare(qce->core);
 	debugfs_remove_recursive(qce->qce_debug_dent);
+	qce_sysfs_deinit(qce);
 	return 0;
 }
 
diff --git a/drivers/crypto/qce/core.h b/drivers/crypto/qce/core.h
index 77c701657711..81ec5d40f49e 100644
--- a/drivers/crypto/qce/core.h
+++ b/drivers/crypto/qce/core.h
@@ -70,6 +70,9 @@ struct qce_stat {
  * @qce_debug_read_buf: buffer to store the qce stats
  * @async_req_enqueue: invoked by every algorithm to enqueue a request
  * @async_req_done: invoked by every algorithm to finish its request
+ * @use_fixed_key: bool variable to generate key from TZ
+ * @kobj pointer to sysfs entry
+ * @kobj_parent partent sysfs entry
  */
 struct qce_device {
 	struct crypto_queue queue;
@@ -89,6 +92,9 @@ struct qce_device {
 	int (*async_req_enqueue)(struct qce_device *qce,
 				 struct crypto_async_request *req);
 	void (*async_req_done)(struct qce_device *qce, int ret);
+	bool use_fixed_key;
+	struct kobject kobj;
+	struct kobject *kobj_parent;
 };
 
 /**
diff --git a/drivers/crypto/qce/skcipher.c b/drivers/crypto/qce/skcipher.c
index 5b493fdc1e74..c733413ab8aa 100644
--- a/drivers/crypto/qce/skcipher.c
+++ b/drivers/crypto/qce/skcipher.c
@@ -12,6 +12,7 @@
 #include <crypto/aes.h>
 #include <crypto/internal/des.h>
 #include <crypto/internal/skcipher.h>
+#include <linux/qcom_scm.h>
 
 #include "cipher.h"
 
@@ -24,6 +25,14 @@ MODULE_PARM_DESC(aes_sw_max_len,
 
 static LIST_HEAD(skcipher_algs);
 
+static int qce_setkey_sec(struct qce_device *qce, unsigned int keylen)
+{
+	struct qce_config_key_sec key;
+
+	key.keylen = keylen;
+	return qti_set_qcekey_sec(&key, sizeof(struct qce_config_key_sec));
+}
+
 static void qce_skcipher_done(void *data)
 {
 	struct crypto_async_request *async_req = data;
@@ -174,11 +183,18 @@ static int qce_skcipher_setkey(struct crypto_skcipher *ablk, const u8 *key,
 	struct qce_cipher_ctx *ctx = crypto_tfm_ctx(tfm);
 	unsigned long flags = to_cipher_tmpl(ablk)->alg_flags;
 	unsigned int __keylen;
+	struct qce_alg_template *tmpl = to_cipher_tmpl(ablk);
+	struct qce_device *qce = tmpl->qce;
 	int ret;
 
 	if (!key || !keylen)
 		return -EINVAL;
 
+	if (qce->use_fixed_key) {
+		ret = qce_setkey_sec(qce, keylen);
+		if (ret)
+			return ret;
+	}
 	/*
 	 * AES XTS key1 = key2 not supported by crypto engine.
 	 * Revisit to request a fallback cipher in this case.
-- 
2.34.1

