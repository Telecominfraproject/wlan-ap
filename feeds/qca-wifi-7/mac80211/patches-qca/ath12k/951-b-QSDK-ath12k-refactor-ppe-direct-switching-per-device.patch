From 92f86ab690d0f9a0be5a2c6071efcb6aa847d976 Mon Sep 17 00:00:00 2001
From: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
Date: Fri, 26 Apr 2024 13:15:00 -0700
Subject: QSDK: ath12k: refactor ppe direct switching per device
 initializations

- Move per device (ab) ppe related info to a structure
- make ath12k_ppeds_attach() out of ath12k_dp_cc_init() and issue
  from ath12k_dp_alloc()
- As only one queue is utilized for PPE DS TX descriptors, cleanup
  framework added to support multiple hardware queues for ppeds
  tx descriptors.

Patch-depdendency: 763-b-wifi-ath12k-add-framework-to-support-PPE-DS.patch

Signed-off-by: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
Signed-off-by: Aishwarya R <quic_aisr@quicinc.com>
---
 drivers/net/wireless/ath/ath12k/core.c       |   2 +-
 drivers/net/wireless/ath/ath12k/core.h       |  41 +--
 drivers/net/wireless/ath/ath12k/debugfs.c    |   4 +-
 drivers/net/wireless/ath/ath12k/dp.c         | 229 ++++++++---------
 drivers/net/wireless/ath/ath12k/dp.h         |  14 +-
 drivers/net/wireless/ath/ath12k/dp_tx.c      |  43 ++--
 drivers/net/wireless/ath/ath12k/dp_tx.h      |   3 +-
 drivers/net/wireless/ath/ath12k/hw.h         |   1 -
 drivers/net/wireless/ath/ath12k/pci.c        |   8 +-
 drivers/net/wireless/ath/ath12k/pcic.c       |   8 +-
 drivers/net/wireless/ath/ath12k/ppe.c        | 253 ++++++++++---------
 drivers/net/wireless/ath/ath12k/ppe.h        |  51 +++-
 drivers/net/wireless/ath/ath12k/umac_reset.c |   4 +-
 13 files changed, 322 insertions(+), 339 deletions(-)

Index: b/drivers/net/wireless/ath/ath12k/core.c
===================================================================
--- a/drivers/net/wireless/ath/ath12k/core.c
+++ b/drivers/net/wireless/ath/ath12k/core.c
@@ -4037,7 +4037,7 @@ struct ath12k_base *ath12k_core_alloc(st
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 	/* Used for tracking the order of per ab's DS node in bringup sequence
 	 * for the purposes of affinity settings */
-	ab->ppeds_soc_idx = -1;
+	ab->ppe.ppeds_soc_idx = -1;
 #endif
 	return ab;
 
Index: b/drivers/net/wireless/ath/ath12k/core.h
===================================================================
--- a/drivers/net/wireless/ath/ath12k/core.h
+++ b/drivers/net/wireless/ath/ath12k/core.h
@@ -32,6 +32,7 @@
 #include "telemetry_agent_if.h"
 #include "cfr.h"
 #include "hal_rx.h"
+#include "ppe.h"
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 #include <ppe_ds_wlan.h>
 #include <ppe_vp_public.h>
@@ -1307,30 +1308,6 @@ struct ath12k_soc_dp_stats {
 	u32 reo_excep_msdu_buf_type;
 };
 
-#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
-struct ath12k_ppeds_stats {
-	u32 tcl_prod_cnt;
-	u32 tcl_cons_cnt;
-	u32 reo_prod_cnt;
-	u32 reo_cons_cnt;
-	u32 get_tx_desc_cnt;
-	u32 tx_desc_allocated;
-	u32 tx_desc_freed;
-	u32 fw2wbm_pkt_drops;
-	u32 enable_intr_cnt;
-	u32 disable_intr_cnt;
-	u32 release_tx_single_cnt;
-	u32 release_rx_desc_cnt;
-	u32 num_rx_desc_freed;
-	u32 num_rx_desc_realloc;
-};
-
-struct ath12k_ppeds_napi {
-	struct napi_struct napi;
-	struct net_device ndev;
-};
-#endif
-
 struct ath12k_reg_freq {
          u32 start_freq;
          u32 end_freq;
@@ -1595,21 +1572,7 @@ struct ath12k_base {
 	enum wide_band_cap wide_band;
 
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
-	ppe_ds_wlan_handle_t *ppeds_handle;
-	/* used for per node enumeration*/
-	int ppeds_soc_idx;
-	int ppe_vp_tbl_registered[PPE_VP_ENTRIES_MAX];
-	int ppe_vp_search_idx_tbl_set[PPE_VP_ENTRIES_MAX];
-	struct ath12k_ppeds_napi ppeds_napi_ctxt;
-	struct mutex ppe_vp_tbl_lock;
-	u8 num_ppe_vp_profiles;
-	u8 num_ppe_vp_search_idx_entries;
-	u8 num_ppe_vp_entries;
-    u8 ppeds_int_mode_enabled;
-	u8 ppeds_stopped;
-	struct ath12k_ppeds_stats ppeds_stats;
-	u16 *ppeds_rx_idx[ATH12K_MAX_SOCS];
-	u16 ppeds_rx_num_elem;
+	struct ath12k_ppe ppe;
 #endif
 
 	int userpd_id;
Index: b/drivers/net/wireless/ath/ath12k/debugfs.c
===================================================================
--- a/drivers/net/wireless/ath/ath12k/debugfs.c
+++ b/drivers/net/wireless/ath/ath12k/debugfs.c
@@ -2786,7 +2786,7 @@ static ssize_t ath12k_debugfs_dump_ppeds
 						size_t count, loff_t *ppos)
 {
 	struct ath12k_base *ab = file->private_data;
-	struct ath12k_ppeds_stats *ppeds_stats = &ab->ppeds_stats;
+	struct ath12k_ppeds_stats *ppeds_stats = &ab->ppe.ppeds_stats;
 	int len = 0,  retval;
 	const int size = 4096;
 	char *buf;
@@ -2841,7 +2841,7 @@ ath12k_debugfs_write_ppeds_stats(struct
 				  size_t count, loff_t *ppos)
 {
 	struct ath12k_base *ab = file->private_data;
-	struct ath12k_ppeds_stats *ppeds_stats = &ab->ppeds_stats;
+	struct ath12k_ppeds_stats *ppeds_stats = &ab->ppe.ppeds_stats;
 	char buf[20] = {0};
 	int ret;
 
Index: b/drivers/net/wireless/ath/ath12k/dp.c
===================================================================
--- a/drivers/net/wireless/ath/ath12k/dp.c
+++ b/drivers/net/wireless/ath/ath12k/dp.c
@@ -1761,11 +1761,6 @@ static void ath12k_dp_cc_cleanup(struct
 		spin_unlock_bh(&dp->tx_desc_lock[pool_id]);
 	}
 
-#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
-	if (test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags))
-		ath12k_ppeds_detach(ab);
-#endif
-
 	/* unmap SPT pages */
 	for (i = 0; i < dp->num_spt_pages; i++) {
 		if (!dp->spt_info[i].vaddr)
@@ -1809,6 +1804,7 @@ void ath12k_dp_free(struct ath12k_base *
 	ath12k_dp_link_desc_cleanup(ab, dp->link_desc_banks,
 				    HAL_WBM_IDLE_LINK, &dp->wbm_idle_ring);
 
+	ath12k_ppeds_detach(ab);
 	ath12k_dp_cc_cleanup(ab);
 	ath12k_dp_reoq_lut_cleanup(ab);
 	ath12k_dp_deinit_bank_profiles(ab);
@@ -2020,51 +2016,45 @@ static void ath12k_dp_ppeds_tx_desc_clea
 	struct ath12k_ppeds_tx_desc_info *ppeds_tx_desc_info, *tmp2;
 	struct ath12k_dp *dp = &ab->dp;
 	struct sk_buff *skb;
-	int i;
 
 	/* PPEDS TX Descriptor cleanup */
-	for (i = 0; i < ATH12K_HW_MAX_QUEUES_PPEDS; i++) {
-		spin_lock_bh(&dp->ppeds_tx_desc_lock[i]);
+	spin_lock_bh(&dp->ppeds_tx_desc_lock);
 
-		/* clean up used desc list */
-		list_for_each_entry_safe(ppeds_tx_desc_info, tmp2,
-					 &dp->ppeds_tx_desc_used_list[i],
-					 list) {
-			list_move_tail(&ppeds_tx_desc_info->list,
-				       &dp->ppeds_tx_desc_free_list[i]);
-			skb = ppeds_tx_desc_info->skb;
-			ppeds_tx_desc_info->skb = NULL;
-			if (!skb) {
-				WARN_ON_ONCE(1);
-				continue;
-			}
-			dma_unmap_single_attrs(ab->dev, ATH12K_SKB_CB(skb)->paddr,
-					       skb->len, DMA_TO_DEVICE,
-					       DMA_ATTR_SKIP_CPU_SYNC);
-			dev_kfree_skb_any(skb);
+	/* clean up used desc list */
+	list_for_each_entry_safe(ppeds_tx_desc_info, tmp2,
+				 &dp->ppeds_tx_desc_used_list, list) {
+		list_move_tail(&ppeds_tx_desc_info->list, &dp->ppeds_tx_desc_free_list);
+		skb = ppeds_tx_desc_info->skb;
+		ppeds_tx_desc_info->skb = NULL;
+		if (!skb) {
+			WARN_ON_ONCE(1);
+			continue;
 		}
+		dma_unmap_single_attrs(ab->dev, ATH12K_SKB_CB(skb)->paddr,
+				       skb->len, DMA_TO_DEVICE,
+				       DMA_ATTR_SKIP_CPU_SYNC);
+		dev_kfree_skb_any(skb);
+	}
 
-		/* clean up descriptors and skbs from reuse list */
-		list_for_each_entry_safe(ppeds_tx_desc_info, tmp2,
-					 &dp->ppeds_tx_desc_reuse_list[i],
-					 list) {
-			list_move_tail(&ppeds_tx_desc_info->list,
-				       &dp->ppeds_tx_desc_free_list[i]);
-			skb = ppeds_tx_desc_info->skb;
-			ppeds_tx_desc_info->skb = NULL;
-			if (!skb) {
-				WARN_ON_ONCE(1);
-				continue;
-			}
-			dma_unmap_single_attrs(ab->dev, ppeds_tx_desc_info->paddr,
-					       skb->len, DMA_TO_DEVICE,
-					       DMA_ATTR_SKIP_CPU_SYNC);
-			dev_kfree_skb_any(skb);
+	/* clean up descriptors and skbs from reuse list */
+	list_for_each_entry_safe(ppeds_tx_desc_info, tmp2,
+				 &dp->ppeds_tx_desc_reuse_list, list) {
+		list_move_tail(&ppeds_tx_desc_info->list, &dp->ppeds_tx_desc_free_list);
+		skb = ppeds_tx_desc_info->skb;
+		ppeds_tx_desc_info->skb = NULL;
+		if (!skb) {
+			WARN_ON_ONCE(1);
+			continue;
 		}
-		dp->ppeds_tx_desc_reuse_list_len[i] = 0;
-
-		spin_unlock_bh(&dp->ppeds_tx_desc_lock[i]);
+		dma_unmap_single_attrs(ab->dev, ppeds_tx_desc_info->paddr,
+				       skb->len, DMA_TO_DEVICE,
+				       DMA_ATTR_SKIP_CPU_SYNC);
+		dev_kfree_skb_any(skb);
 	}
+
+	dp->ppeds_tx_desc_reuse_list_len = 0;
+
+	spin_unlock_bh(&dp->ppeds_tx_desc_lock);
 }
 
 int ath12k_dp_cc_ppeds_desc_cleanup(struct ath12k_base *ab)
@@ -2073,7 +2063,6 @@ int ath12k_dp_cc_ppeds_desc_cleanup(stru
 	struct ath12k_dp *dp = &ab->dp;
 	struct sk_buff *skb;
 	int i;
-	u32  pool_id, ppeds_tx_spt_page;
 
 	if (!dp->spt_info) {
 		ath12k_err(ab,"ath12k_dp_cc_ppeds_desc_cleanup failed");
@@ -2081,53 +2070,43 @@ int ath12k_dp_cc_ppeds_desc_cleanup(stru
 	}
 
 	/* PPEDS TX Descriptor cleanup */
-	for (i = 0; i < ATH12K_HW_MAX_QUEUES_PPEDS; i++) {
-		spin_lock_bh(&dp->ppeds_tx_desc_lock[i]);
-
-		/* clean up used desc list */
-		list_for_each_entry_safe(ppeds_tx_desc_info, tmp2,
-					 &dp->ppeds_tx_desc_used_list[i],
-					 list) {
-			list_del(&ppeds_tx_desc_info->list);
-			skb = ppeds_tx_desc_info->skb;
-			if (!skb)
-				continue;
-
-			dma_unmap_single(ab->dev, ATH12K_SKB_CB(skb)->paddr,
-					 skb->len, DMA_TO_DEVICE);
-			dev_kfree_skb_any(skb);
-		}
+	spin_lock_bh(&dp->ppeds_tx_desc_lock);
 
-		/* clean up descriptors and skbs from reuse list */
-		list_for_each_entry_safe(ppeds_tx_desc_info, tmp2,
-					 &dp->ppeds_tx_desc_reuse_list[i],
-					 list) {
-			list_del(&ppeds_tx_desc_info->list);
-			skb = ppeds_tx_desc_info->skb;
-			if (!skb)
-				continue;
-
-			dma_unmap_single(ab->dev, ppeds_tx_desc_info->paddr,
-					 skb->len, DMA_TO_DEVICE);
-			dev_kfree_skb_any(skb);
-		}
+	/* clean up used desc list */
+	list_for_each_entry_safe(ppeds_tx_desc_info, tmp2,
+				 &dp->ppeds_tx_desc_used_list, list) {
+		list_del(&ppeds_tx_desc_info->list);
+		skb = ppeds_tx_desc_info->skb;
+		if (!skb)
+			continue;
 
-		spin_unlock_bh(&dp->ppeds_tx_desc_lock[i]);
+		dma_unmap_single(ab->dev, ATH12K_SKB_CB(skb)->paddr,
+				 skb->len, DMA_TO_DEVICE);
+		dev_kfree_skb_any(skb);
 	}
 
-	for (pool_id = 0; pool_id < ATH12K_HW_MAX_QUEUES_PPEDS; pool_id++) {
-		spin_lock_bh(&dp->ppeds_tx_desc_lock[pool_id]);
+	/* clean up descriptors and skbs from reuse list */
+	list_for_each_entry_safe(ppeds_tx_desc_info, tmp2,
+				 &dp->ppeds_tx_desc_reuse_list, list) {
+		list_del(&ppeds_tx_desc_info->list);
+		skb = ppeds_tx_desc_info->skb;
+		if (!skb)
+			continue;
 
-		for (i = 0; i < ATH12K_PPEDS_TX_SPT_PAGES_PER_POOL; i++) {
-			ppeds_tx_spt_page = i + pool_id * ATH12K_PPEDS_TX_SPT_PAGES_PER_POOL;
-			if (!dp->spt_info->ppedstxbaddr[ppeds_tx_spt_page])
-				continue;
+		dma_unmap_single(ab->dev, ppeds_tx_desc_info->paddr,
+				 skb->len, DMA_TO_DEVICE);
+		dev_kfree_skb_any(skb);
+	}
 
-			kfree(dp->spt_info->ppedstxbaddr[ppeds_tx_spt_page]);
-		}
+	for (i = 0; i < ATH12K_NUM_PPEDS_TX_SPT_PAGES; i++) {
+		if (!dp->spt_info->ppedstxbaddr[i])
+			continue;
 
-		spin_unlock_bh(&dp->ppeds_tx_desc_lock[pool_id]);
+		kfree(dp->spt_info->ppedstxbaddr[i]);
 	}
+
+	spin_unlock_bh(&dp->ppeds_tx_desc_lock);
+
 	ath12k_dbg(ab, ATH12K_DBG_PPE, "ath12k_dp_cc_ppeds_desc_cleanup success\n");
 
 	return 0;
@@ -2138,42 +2117,44 @@ int ath12k_dp_cc_ppeds_desc_init(struct
 	struct ath12k_dp *dp = &ab->dp;
 	struct ath12k_ppeds_tx_desc_info *ppeds_tx_descs;
 	struct ath12k_spt_info *ppeds_tx_spt_pages;
-	u32 i, j, pool_id, ppeds_tx_spt_page;
+	u32 i, j;
 	u32 ppt_idx;
 
+	INIT_LIST_HEAD(&dp->ppeds_tx_desc_free_list);
+	INIT_LIST_HEAD(&dp->ppeds_tx_desc_reuse_list);
+	INIT_LIST_HEAD(&dp->ppeds_tx_desc_used_list);
+	spin_lock_init(&dp->ppeds_tx_desc_lock);
+	dp->ppeds_tx_desc_reuse_list_len = 0;
+
 	/* pointer to start of TX pages */
 	ppeds_tx_spt_pages = &dp->spt_info[ATH12K_PPEDS_TX_SPT_PAGE_OFFSET];
 
-	for (pool_id = 0; pool_id < ATH12K_HW_MAX_QUEUES_PPEDS; pool_id++) {
-		spin_lock_bh(&dp->ppeds_tx_desc_lock[pool_id]);
-		for (i = 0; i < ATH12K_PPEDS_TX_SPT_PAGES_PER_POOL; i++) {
-			ppeds_tx_descs = kcalloc(ATH12K_MAX_SPT_ENTRIES, sizeof(*ppeds_tx_descs),
-					   GFP_ATOMIC);
+	spin_lock_bh(&dp->ppeds_tx_desc_lock);
+	for (i = 0; i < ATH12K_NUM_PPEDS_TX_SPT_PAGES; i++) {
+		ppeds_tx_descs = kcalloc(ATH12K_MAX_SPT_ENTRIES, sizeof(*ppeds_tx_descs),
+				   GFP_ATOMIC);
 
-			if (!ppeds_tx_descs) {
-				spin_unlock_bh(&dp->ppeds_tx_desc_lock[pool_id]);
-				ath12k_dp_cc_ppeds_desc_cleanup(ab);
-				return -ENOMEM;
-			}
+		if (!ppeds_tx_descs) {
+			spin_unlock_bh(&dp->ppeds_tx_desc_lock);
+			ath12k_dp_cc_ppeds_desc_cleanup(ab);
+			return -ENOMEM;
+		}
 
-			ppeds_tx_spt_page = i + pool_id * ATH12K_PPEDS_TX_SPT_PAGES_PER_POOL;
-			dp->spt_info->ppedstxbaddr[ppeds_tx_spt_page] = &ppeds_tx_descs[0];
+		dp->spt_info->ppedstxbaddr[i] = &ppeds_tx_descs[0];
 
-			for (j = 0; j < ATH12K_MAX_SPT_ENTRIES; j++) {
-				ppt_idx = ATH12K_PPEDS_TX_SPT_PAGE_OFFSET + ppeds_tx_spt_page;
-				ppeds_tx_descs[j].desc_id = ath12k_dp_cc_cookie_gen(ppt_idx, j);
-				ppeds_tx_descs[j].pool_id = pool_id;
-				list_add_tail(&ppeds_tx_descs[j].list,
-					      &dp->ppeds_tx_desc_free_list[pool_id]);
+		for (j = 0; j < ATH12K_MAX_SPT_ENTRIES; j++) {
+			ppt_idx = ATH12K_PPEDS_TX_SPT_PAGE_OFFSET + i;
+			ppeds_tx_descs[j].desc_id = ath12k_dp_cc_cookie_gen(ppt_idx, j);
+			list_add_tail(&ppeds_tx_descs[j].list,
+				      &dp->ppeds_tx_desc_free_list);
 
-				/* Update descriptor VA in SPT */
-				*(struct ath12k_ppeds_tx_desc_info **)
-					((u8 *)ppeds_tx_spt_pages[ppeds_tx_spt_page].vaddr +
-					 (j * sizeof(u64))) = &ppeds_tx_descs[j];
-			}
+			/* Update descriptor VA in SPT */
+			*(struct ath12k_ppeds_tx_desc_info **)
+				((u8 *)ppeds_tx_spt_pages[i].vaddr +
+				 (j * sizeof(u64))) = &ppeds_tx_descs[j];
 		}
-		spin_unlock_bh(&dp->ppeds_tx_desc_lock[pool_id]);
 	}
+	spin_unlock_bh(&dp->ppeds_tx_desc_lock);
 	ath12k_dbg(ab, ATH12K_DBG_PPE, "ath12k_dp_cc_ppeds_desc_init success\n");
 
 	return 0;
@@ -2331,19 +2312,6 @@ static int ath12k_dp_cc_init(struct ath1
 		goto free;
 	}
 
-#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
-	if (test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags)) {
-		for (i = 0; i < ATH12K_HW_MAX_QUEUES_PPEDS; i++) {
-			INIT_LIST_HEAD(&dp->ppeds_tx_desc_free_list[i]);
-			INIT_LIST_HEAD(&dp->ppeds_tx_desc_reuse_list[i]);
-			INIT_LIST_HEAD(&dp->ppeds_tx_desc_used_list[i]);
-			spin_lock_init(&dp->ppeds_tx_desc_lock[i]);
-			dp->ppeds_tx_desc_reuse_list_len[i] = 0;
-		}
-		ath12k_ppeds_attach(ab);
-	}
-#endif
-
 	return 0;
 free:
 	ath12k_dp_cc_cleanup(ab);
@@ -2440,20 +2408,26 @@ int ath12k_dp_alloc(struct ath12k_base *
 	}
 
 	ret = ath12k_dp_cc_init(ab);
-
 	if (ret) {
 		ath12k_warn(ab, "failed to setup cookie converter %d\n", ret);
 		goto fail_link_desc_cleanup;
 	}
+
 	ret = ath12k_dp_init_bank_profiles(ab);
 	if (ret) {
 		ath12k_warn(ab, "failed to setup bank profiles %d\n", ret);
 		goto fail_hw_cc_cleanup;
 	}
 
+	ret = ath12k_ppeds_attach(ab);
+	if (ret) {
+		ath12k_warn(ab, "failed to attach PPE DS %d\n", ret);
+		goto fail_ppeds_detach;
+	}
+
 	ret = ath12k_dp_srng_common_setup(ab);
 	if (ret)
-		goto fail_dp_bank_profiles_cleanup;
+		goto fail_ppeds_detach;
 
 	size = sizeof(struct hal_wbm_release_ring_tx) * DP_TX_COMP_RING_SIZE;
 
@@ -2485,7 +2459,8 @@ fail_dp_rx_free:
 fail_cmn_srng_cleanup:
 	ath12k_dp_srng_common_cleanup(ab);
 
-fail_dp_bank_profiles_cleanup:
+fail_ppeds_detach:
+	ath12k_ppeds_detach(ab);
 	ath12k_dp_deinit_bank_profiles(ab);
 
 fail_hw_cc_cleanup:
@@ -2553,7 +2528,7 @@ void ath12k_umac_reset_handle_post_reset
 	ath12k_dp_umac_txrx_desc_cleanup(ab);
 
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
-	if (ab->ppeds_handle)
+	if (ab->ppe.ppeds_handle)
 		ath12k_dp_ppeds_tx_desc_cleanup(ab);
 #endif
 	ath12k_dp_rxdma_ring_setup(ab);
Index: b/drivers/net/wireless/ath/ath12k/dp.h
===================================================================
--- a/drivers/net/wireless/ath/ath12k/dp.h
+++ b/drivers/net/wireless/ath/ath12k/dp.h
@@ -253,10 +253,8 @@ struct ath12k_pdev_dp {
 #define ATH12K_RX_SPT_PAGE_OFFSET ATH12K_NUM_PPEDS_TX_SPT_PAGES + ATH12K_NUM_TX_SPT_PAGES
 
 
-#define ATH12K_PPEDS_TX_SPT_PAGES_PER_POOL (ATH12K_NUM_POOL_PPEDS_TX_DESC / \
+#define ATH12K_NUM_PPEDS_TX_SPT_PAGES (ATH12K_NUM_POOL_PPEDS_TX_DESC / \
 					    ATH12K_MAX_SPT_ENTRIES)
-#define ATH12K_NUM_PPEDS_TX_SPT_PAGES (ATH12K_PPEDS_TX_SPT_PAGES_PER_POOL *\
-				       ATH12K_HW_MAX_QUEUES_PPEDS)
 
 #define ATH12K_NUM_SPT_PAGES	(ATH12K_NUM_TX_SPT_PAGES + ATH12K_NUM_RX_SPT_PAGES + \
 				 ATH12K_NUM_PPEDS_TX_SPT_PAGES)
@@ -471,12 +469,12 @@ struct ath12k_dp {
 	spinlock_t tx_desc_lock[ATH12K_HW_MAX_QUEUES];
 
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
-	struct list_head ppeds_tx_desc_free_list[ATH12K_HW_MAX_QUEUES_PPEDS];
-	struct list_head ppeds_tx_desc_reuse_list[ATH12K_HW_MAX_QUEUES_PPEDS];
-	struct list_head ppeds_tx_desc_used_list[ATH12K_HW_MAX_QUEUES_PPEDS];
-	int ppeds_tx_desc_reuse_list_len[ATH12K_HW_MAX_QUEUES_PPEDS];
+	struct list_head ppeds_tx_desc_free_list;
+	struct list_head ppeds_tx_desc_reuse_list;
+	struct list_head ppeds_tx_desc_used_list;
+	int ppeds_tx_desc_reuse_list_len;
 	/* protects the free and used desc lists */
-	spinlock_t ppeds_tx_desc_lock[ATH12K_HW_MAX_QUEUES_PPEDS];
+	spinlock_t ppeds_tx_desc_lock;
 
 	struct ath12k_dp_ppe_vp_profile ppe_vp_profile[PPE_VP_ENTRIES_MAX];
 	char ppeds_irq_name[MAX_PPEDS_IRQS][MAX_PPEDS_IRQ_NAME_LEN];
Index: b/drivers/net/wireless/ath/ath12k/dp_tx.c
===================================================================
--- a/drivers/net/wireless/ath/ath12k/dp_tx.c
+++ b/drivers/net/wireless/ath/ath12k/dp_tx.c
@@ -104,46 +104,44 @@ enum hal_encrypt_type ath12k_dp_tx_get_e
 #define ATH12K_PPEDS_HOTLIST_LEN_MAX 1024
 struct sk_buff *
 ath12k_dp_ppeds_tx_release_desc_nolock(struct ath12k_dp *dp,
-				struct ath12k_ppeds_tx_desc_info *tx_desc,
-				u8 ring_id)
+				struct ath12k_ppeds_tx_desc_info *tx_desc)
 {
 	struct sk_buff *skb = NULL;
 
-	lockdep_assert_held(&dp->ppeds_tx_desc_lock[ATH12K_PPEDS_DEFAULT_POOL_ID]);
-	if (dp->ppeds_tx_desc_reuse_list_len[ring_id] < ATH12K_PPEDS_HOTLIST_LEN_MAX &&
+	lockdep_assert_held(&dp->ppeds_tx_desc_lock);
+	if (dp->ppeds_tx_desc_reuse_list_len < ATH12K_PPEDS_HOTLIST_LEN_MAX &&
 	    tx_desc->skb) {
-		list_move_tail(&tx_desc->list, &dp->ppeds_tx_desc_reuse_list[ring_id]);
-		dp->ppeds_tx_desc_reuse_list_len[ring_id]++;
+		list_move_tail(&tx_desc->list, &dp->ppeds_tx_desc_reuse_list);
+		dp->ppeds_tx_desc_reuse_list_len++;
 	} else {
 		skb = tx_desc->skb;
 		tx_desc->skb = NULL;
-		list_move_tail(&tx_desc->list, &dp->ppeds_tx_desc_free_list[ring_id]);
+		list_move_tail(&tx_desc->list, &dp->ppeds_tx_desc_free_list);
 	}
 
 	return skb;
 }
 
 struct ath12k_ppeds_tx_desc_info *
-ath12k_dp_ppeds_tx_assign_desc_nolock(struct ath12k_dp *dp,
-				      u8 ring_id)
+ath12k_dp_ppeds_tx_assign_desc_nolock(struct ath12k_dp *dp)
 {
 	struct ath12k_ppeds_tx_desc_info *desc, *next;
 
-	lockdep_assert_held(&dp->ppeds_tx_desc_lock[ATH12K_PPEDS_DEFAULT_POOL_ID]);
+	lockdep_assert_held(&dp->ppeds_tx_desc_lock);
 	/* first try to fetch descriptor from hotlist if not use free list */
-	desc = list_first_entry_or_null(&dp->ppeds_tx_desc_reuse_list[ring_id],
+	desc = list_first_entry_or_null(&dp->ppeds_tx_desc_reuse_list,
 					struct ath12k_ppeds_tx_desc_info,
 					list);
 	if (desc) {
-		list_move_tail(&desc->list, &dp->ppeds_tx_desc_used_list[ring_id]);
-		dp->ppeds_tx_desc_reuse_list_len[ring_id]--;
+		list_move_tail(&desc->list, &dp->ppeds_tx_desc_used_list);
+		dp->ppeds_tx_desc_reuse_list_len--;
 		/* Prefetch next hotlist descriptor */
-		if (dp->ppeds_tx_desc_reuse_list_len[ring_id])
-			next = list_first_entry_or_null(&dp->ppeds_tx_desc_reuse_list[ring_id],
+		if (dp->ppeds_tx_desc_reuse_list_len)
+			next = list_first_entry_or_null(&dp->ppeds_tx_desc_reuse_list,
 							struct ath12k_ppeds_tx_desc_info,
 							list);
 		else
-			next = list_first_entry_or_null(&dp->ppeds_tx_desc_free_list[ring_id],
+			next = list_first_entry_or_null(&dp->ppeds_tx_desc_free_list,
 							struct ath12k_ppeds_tx_desc_info,
 							list);
 		prefetch(next);
@@ -152,7 +150,7 @@ ath12k_dp_ppeds_tx_assign_desc_nolock(st
 	}
 
 	/* Fetch desc from Freelist if hotlist is empty */
-	desc = list_first_entry_or_null(&dp->ppeds_tx_desc_free_list[ring_id],
+	desc = list_first_entry_or_null(&dp->ppeds_tx_desc_free_list,
 					struct ath12k_ppeds_tx_desc_info,
 					list);
 	if (unlikely(!desc)) {
@@ -160,7 +158,7 @@ ath12k_dp_ppeds_tx_assign_desc_nolock(st
 		return NULL;
 	}
 
-	list_move_tail(&desc->list, &dp->ppeds_tx_desc_used_list[ring_id]);
+	list_move_tail(&desc->list, &dp->ppeds_tx_desc_used_list);
 
 	return desc;
 }
@@ -1471,7 +1469,7 @@ int ath12k_ppeds_tx_completion_handler(s
 
 	ath12k_hal_srng_access_dst_ring_end_nolock(status_ring);
 
-	spin_lock_bh(&dp->ppeds_tx_desc_lock[ATH12K_PPEDS_DEFAULT_POOL_ID]);
+	spin_lock_bh(&dp->ppeds_tx_desc_lock);
 	spin_unlock_bh(&status_ring->lock);
 
 	while (count--) {
@@ -1492,8 +1490,7 @@ int ath12k_ppeds_tx_completion_handler(s
 		/* Release descriptor as soon as extracting necessary info
 		 * to reduce contention
 		 */
-		msdu = ath12k_dp_ppeds_tx_release_desc_nolock(dp, tx_desc,
-							      ATH12K_PPEDS_DEFAULT_POOL_ID);
+		msdu = ath12k_dp_ppeds_tx_release_desc_nolock(dp, tx_desc);
 		buf_rel_source = FIELD_GET(HAL_WBM_RELEASE_INFO0_REL_SRC_MODULE,
 					   tx_status->info0);
 		if (unlikely(buf_rel_source == HAL_WBM_REL_SRC_MODULE_FW)) {
@@ -1502,7 +1499,7 @@ int ath12k_ppeds_tx_completion_handler(s
 						  HTT_TX_WBM_COMP_INFO0_STATUS);
 			if (htt_status != HAL_WBM_REL_HTT_TX_COMP_STATUS_OK &&
 			    !ab->stats_disable) {
-				ab->ppeds_stats.fw2wbm_pkt_drops++;
+				ab->ppe.ppeds_stats.fw2wbm_pkt_drops++;
 			}
 			dev_kfree_skb_any(msdu);
 			ath12k_warn(ab, "ath12k: Frame received from unexpected source %d status %d!\n",
@@ -1531,7 +1528,7 @@ int ath12k_ppeds_tx_completion_handler(s
 
 		work_done++;
 	}
-	spin_unlock_bh(&dp->ppeds_tx_desc_lock[ATH12K_PPEDS_DEFAULT_POOL_ID]);
+	spin_unlock_bh(&dp->ppeds_tx_desc_lock);
 	dev_kfree_skb_list_fast(&free_list_head);
 
 	return work_done;
Index: b/drivers/net/wireless/ath/ath12k/dp_tx.h
===================================================================
--- a/drivers/net/wireless/ath/ath12k/dp_tx.h
+++ b/drivers/net/wireless/ath/ath12k/dp_tx.h
@@ -218,8 +218,7 @@ int ath12k_dp_tx_completion_handler(stru
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 int ath12k_ppeds_tx_completion_handler(struct ath12k_base *ab, int ring_id);
 struct ath12k_ppeds_tx_desc_info *
-ath12k_dp_ppeds_tx_assign_desc_nolock(struct ath12k_dp *dp,
-				      u8 ring_id);
+ath12k_dp_ppeds_tx_assign_desc_nolock(struct ath12k_dp *dp);
 #endif
 int ath12k_dp_tx_htt_h2t_ppdu_stats_req(struct ath12k *ar, u32 mask);
 int
Index: b/drivers/net/wireless/ath/ath12k/hw.h
===================================================================
--- a/drivers/net/wireless/ath/ath12k/hw.h
+++ b/drivers/net/wireless/ath/ath12k/hw.h
@@ -83,7 +83,6 @@ struct ath12k_cfr_peer_tx_param;
 #define ATH12K_HW_DEFAULT_QUEUE		0
 
 #define ATH12K_HW_MAX_QUEUES		4
-#define ATH12K_HW_MAX_QUEUES_PPEDS	1
 #define ATH12K_QUEUE_LEN		4096
 
 #define ATH12K_HW_RATECODE_CCK_SHORT_PREAM_MASK  0x4
Index: b/drivers/net/wireless/ath/ath12k/pci.c
===================================================================
--- a/drivers/net/wireless/ath/ath12k/pci.c
+++ b/drivers/net/wireless/ath/ath12k/pci.c
@@ -250,7 +250,7 @@ int ath12k_pci_ppeds_register_interrupts
 	u8 bus_id = pci_domain_nr(ar_pci->pdev->bus);
 	int ret;
 
-	if (ab->ppeds_soc_idx == -1) {
+	if (ab->ppe.ppeds_soc_idx == -1) {
 		ath12k_err(ab, "invalid ppeds_soc_idx in ppeds_register_interrupts\n");
 		return -EINVAL;
 	}
@@ -260,35 +260,36 @@ int ath12k_pci_ppeds_register_interrupts
 	irq_set_status_flags(irq, IRQ_DISABLE_UNLAZY);
 	if (type == HAL_PPE2TCL) {
 		snprintf(&ab->dp.ppeds_irq_name[PPEDS_IRQ_PPE2TCL], sizeof(ab->dp.ppeds_irq_name),
-			 "pci%d_ppe2tcl_%d", bus_id, ab->ppeds_soc_idx);
+			 "pci%d_ppe2tcl_%d", bus_id, ab->ppe.ppeds_soc_idx);
 		ret = request_irq(irq,  ath12k_ds_ppe2tcl_irq_handler,
-				  IRQF_SHARED,
+				  IRQF_NO_AUTOEN | IRQF_NO_SUSPEND,
 			    ab->dp.ppeds_irq_name[PPEDS_IRQ_PPE2TCL], (void *)ath12k_dp_get_ppe_ds_ctxt(ab));
 		if (ret)
 			goto irq_fail;
 		ab->dp.ppeds_irq[PPEDS_IRQ_PPE2TCL] = irq;
 	} else if (type == HAL_REO2PPE) {
 		snprintf(&ab->dp.ppeds_irq_name[PPEDS_IRQ_REO2PPE], sizeof(ab->dp.ppeds_irq_name),
-			 "pci%d_reo2ppe_%d", bus_id, ab->ppeds_soc_idx);
+			 "pci%d_reo2ppe_%d", bus_id, ab->ppe.ppeds_soc_idx);
 		ret = request_irq(irq,  ath12k_ds_reo2ppe_irq_handler,
 				  IRQF_SHARED,
 				  ab->dp.ppeds_irq_name[PPEDS_IRQ_REO2PPE], (void *)ath12k_dp_get_ppe_ds_ctxt(ab));
 		if (ret)
 			goto irq_fail;
 		ab->dp.ppeds_irq[PPEDS_IRQ_REO2PPE] = irq;
+		disable_irq_nosync(irq);
 	} else if (type == HAL_WBM2SW_RELEASE && ring_num == HAL_WBM2SW_PPEDS_TX_CMPLN_RING_NUM) {
 		snprintf(&ab->dp.ppeds_irq_name[PPEDS_IRQ_PPE_WBM2SW_REL], sizeof(ab->dp.ppeds_irq_name),
-			 "pci%d_ppe_wbm_rel_%d", bus_id, ab->ppeds_soc_idx);
+			 "pci%d_ppe_wbm_rel_%d", bus_id, ab->ppe.ppeds_soc_idx);
 		ret = request_irq(irq,  ath12k_dp_ppeds_handle_tx_comp,
 				  IRQF_SHARED,
 				  ab->dp.ppeds_irq_name[PPEDS_IRQ_PPE_WBM2SW_REL],(void *)ab);
 		if (ret)
 			goto irq_fail;
 		ab->dp.ppeds_irq[PPEDS_IRQ_PPE_WBM2SW_REL] = irq;
+		disable_irq_nosync(irq);
 	} else {
 		return 0;
 	}
-	disable_irq_nosync(irq);
 
 	return 0;
 
Index: b/drivers/net/wireless/ath/ath12k/pcic.c
===================================================================
--- a/drivers/net/wireless/ath/ath12k/pcic.c
+++ b/drivers/net/wireless/ath/ath12k/pcic.c
@@ -606,7 +606,7 @@ int ath12k_pcic_ppeds_register_interrupt
 	u8 bus_id = ab->userpd_id;
 	struct platform_device *pdev = ab->pdev;
 
-	if (ab->ppeds_soc_idx == -1) {
+	if (ab->ppe.ppeds_soc_idx == -1) {
 		ath12k_err(ab, "invalid ppeds_soc_idx in ppeds_register_interrupts\n");
 		return -EINVAL;
 	}
@@ -617,9 +617,9 @@ int ath12k_pcic_ppeds_register_interrupt
 			goto irq_fail;
 		irq_set_status_flags(irq, IRQ_DISABLE_UNLAZY);
 		snprintf(&ab->dp.ppeds_irq_name[PPEDS_IRQ_PPE2TCL], sizeof(ab->dp.ppeds_irq_name),
-			 "pcic%d_ppe2tcl_%d", bus_id, ab->ppeds_soc_idx);
+			 "pcic%d_ppe2tcl_%d", bus_id, ab->ppe.ppeds_soc_idx);
 		ret = devm_request_irq(&pdev->dev, irq,  ath12k_ds_ppe2tcl_irq_handler,
-				  IRQF_SHARED,
+				  IRQF_NO_AUTOEN | IRQF_NO_SUSPEND,
 			    ab->dp.ppeds_irq_name[PPEDS_IRQ_PPE2TCL], (void *)ath12k_dp_get_ppe_ds_ctxt(ab));
 		if (ret)
 			goto irq_fail;
@@ -630,30 +630,32 @@ int ath12k_pcic_ppeds_register_interrupt
 			goto irq_fail;
 		irq_set_status_flags(irq, IRQ_DISABLE_UNLAZY);
 		snprintf(&ab->dp.ppeds_irq_name[PPEDS_IRQ_REO2PPE], sizeof(ab->dp.ppeds_irq_name),
-			 "pcic%d_reo2ppe_%d", bus_id, ab->ppeds_soc_idx);
+			 "pcic%d_reo2ppe_%d", bus_id, ab->ppe.ppeds_soc_idx);
 		ret = devm_request_irq(&pdev->dev, irq,  ath12k_ds_reo2ppe_irq_handler,
 				  IRQF_SHARED,
 				  ab->dp.ppeds_irq_name[PPEDS_IRQ_REO2PPE], (void *)ath12k_dp_get_ppe_ds_ctxt(ab));
 		if (ret)
 			goto irq_fail;
 		ab->dp.ppeds_irq[PPEDS_IRQ_REO2PPE] = irq;
+		disable_irq_nosync(irq);
+
 	} else if (type == HAL_WBM2SW_RELEASE && ring_num == HAL_WBM2SW_PPEDS_TX_CMPLN_RING_NUM) {
 		irq = ab->dp.ppeds_irq[PPEDS_IRQ_PPE_WBM2SW_REL];
 		if (!irq)
 			goto irq_fail;
 		irq_set_status_flags(irq, IRQ_DISABLE_UNLAZY);
 		snprintf(&ab->dp.ppeds_irq_name[PPEDS_IRQ_PPE_WBM2SW_REL], sizeof(ab->dp.ppeds_irq_name),
-			 "pcic%d_ppe_wbm_rel_%d", bus_id, ab->ppeds_soc_idx);
+			 "pcic%d_ppe_wbm_rel_%d", bus_id, ab->ppe.ppeds_soc_idx);
 		ret = devm_request_irq(&pdev->dev, irq,  ath12k_dp_ppeds_handle_tx_comp,
 				  IRQF_SHARED,
 				  ab->dp.ppeds_irq_name[PPEDS_IRQ_PPE_WBM2SW_REL],(void *)ab);
 		if (ret)
 			goto irq_fail;
 		ab->dp.ppeds_irq[PPEDS_IRQ_PPE_WBM2SW_REL] = irq;
+		disable_irq_nosync(irq);
 	} else {
 		return 0;
 	}
-	disable_irq_nosync(irq);
 
 	return 0;
 
Index: b/drivers/net/wireless/ath/ath12k/ppe.c
===================================================================
--- a/drivers/net/wireless/ath/ath12k/ppe.c
+++ b/drivers/net/wireless/ath/ath12k/ppe.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
  */
+
 #include "core.h"
 #include "dp.h"
 #include "dp_tx.h"
@@ -9,10 +10,6 @@
 #include "debugfs_sta.h"
 #include "hw.h"
 #include "peer.h"
-#include <ppe_ds_wlan.h>
-#include <ppe_vp_public.h>
-#include <ppe_drv_sc.h>
-#include <ppe_drv.h>
 #include <linux/dma-mapping.h>
 #include <asm/cacheflush.h>
 #include "hif.h"
@@ -25,8 +22,7 @@ static atomic_t num_ppeds_nodes;
 
 extern struct sk_buff *
 ath12k_dp_ppeds_tx_release_desc_nolock(struct ath12k_dp *dp,
-				struct ath12k_ppeds_tx_desc_info *tx_desc,
-				u8 ring_id);
+				struct ath12k_ppeds_tx_desc_info *tx_desc);
 
 irqreturn_t ath12k_ds_ppe2tcl_irq_handler(int irq, void *ctxt)
 {
@@ -44,10 +40,10 @@ irqreturn_t ath12k_ds_reo2ppe_irq_handle
 
 void *ath12k_dp_get_ppe_ds_ctxt(struct ath12k_base *ab)
 {
-	if (!ab || !ab->ppeds_handle)
+	if (!ab || !ab->ppe.ppeds_handle)
 		return NULL;
 
-	return ppe_ds_wlan_get_intr_ctxt(ab->ppeds_handle);
+	return ppe_ds_wlan_get_intr_ctxt(ab->ppe.ppeds_handle);
 }
 
 static void ath12k_ppeds_set_tcl_prod_idx(ppe_ds_wlan_handle_t *ppeds_handle, u16 tcl_prod_idx)
@@ -58,7 +54,7 @@ static void ath12k_ppeds_set_tcl_prod_id
 
 	srng = &ab->hal.srng_list[dp->ppe2tcl_ring.ring_id];
 	if (!ab->stats_disable)
-		ab->ppeds_stats.tcl_prod_cnt++;
+		ab->ppe.ppeds_stats.tcl_prod_cnt++;
 
 	srng->u.src_ring.hp = tcl_prod_idx * srng->entry_size;
 	ath12k_hal_srng_access_end(ab, srng);
@@ -72,7 +68,7 @@ static u16 ath12k_ppeds_get_tcl_cons_idx
 	u32 tp;
 
 	if (!ab->stats_disable)
-		ab->ppeds_stats.tcl_cons_cnt++;
+		ab->ppe.ppeds_stats.tcl_cons_cnt++;
 
 	srng = &ab->hal.srng_list[dp->ppe2tcl_ring.ring_id];
 	tp = *(volatile u32 *)(srng->u.src_ring.tp_addr);
@@ -89,7 +85,7 @@ static void ath12k_ppeds_set_reo_cons_id
 
 	srng = &ab->hal.srng_list[dp->reo2ppe_ring.ring_id];
 	if (!ab->stats_disable)
-		ab->ppeds_stats.reo_cons_cnt++;
+		ab->ppe.ppeds_stats.reo_cons_cnt++;
 
 	srng->u.dst_ring.tp = reo_cons_idx * srng->entry_size;
 	ath12k_hal_srng_access_end(ab, srng);
@@ -105,7 +101,7 @@ static u16 ath12k_ppeds_get_reo_prod_idx
 	srng = &ab->hal.srng_list[dp->reo2ppe_ring.ring_id];
 	hp = *(volatile u32 *)(srng->u.dst_ring.hp_addr);
  	if (!ab->stats_disable)
-		ab->ppeds_stats.reo_prod_cnt++;
+		ab->ppe.ppeds_stats.reo_prod_cnt++;
 	return hp / srng->entry_size;
 }
 
@@ -116,13 +112,13 @@ static inline void ath12k_ppeds_enable_s
 
 	if (enable) {
 		if (!ab->stats_disable)
-			ab->ppeds_stats.enable_intr_cnt++;
+			ab->ppe.ppeds_stats.enable_intr_cnt++;
 
 		ath12k_hif_ppeds_irq_enable(ab, PPEDS_IRQ_PPE2TCL);
 	}
 	else {
 		if (!ab->stats_disable)
-			ab->ppeds_stats.disable_intr_cnt++;
+			ab->ppe.ppeds_stats.disable_intr_cnt++;
 
 		ath12k_hif_ppeds_irq_disable(ab, PPEDS_IRQ_PPE2TCL);
 	}
@@ -218,7 +214,7 @@ int ath12k_dp_rx_bufs_replenish_ppeds(st
 		count += ath12k_ppeds_free_rx_desc(arr, ab, i, idx_of_ab);
 
 	if (!ab->stats_disable)
-		ab->ppeds_stats.num_rx_desc_freed += count;
+		ab->ppe.ppeds_stats.num_rx_desc_freed += count;
 
 	return 0;
 }
@@ -241,23 +237,23 @@ static void ath12k_ppeds_release_rx_desc
 	u16 *tmp;
 
 	if (!ab->stats_disable)
-		ab->ppeds_stats.release_rx_desc_cnt += count;
+		ab->ppe.ppeds_stats.release_rx_desc_cnt += count;
 
-	if (unlikely(count > ab->ppeds_rx_num_elem)) {
+	if (unlikely(count > ab->ppe.ppeds_rx_num_elem)) {
 		new_size = sizeof(u16) * count;
 		for (chip_id = 0; chip_id < ag->num_chip; chip_id++) {
-			tmp = krealloc(*ab->ppeds_rx_idx[chip_id], new_size, GFP_ATOMIC);
+			tmp = krealloc(*ab->ppe.ppeds_rx_idx[chip_id], new_size, GFP_ATOMIC);
 			if (!tmp) {
 		        	ath12k_err(ab, "ppeds: rx desc realloc failed for size %u\n",
 					   count);
 				goto err_h_alloc_failure;
 			}
 
-			*ab->ppeds_rx_idx[chip_id] = tmp;
+			*ab->ppe.ppeds_rx_idx[chip_id] = tmp;
 		}
 
-		ab->ppeds_rx_num_elem = count;
-		ab->ppeds_stats.num_rx_desc_realloc =+ chip_id;
+		ab->ppe.ppeds_rx_num_elem = count;
+		ab->ppe.ppeds_stats.num_rx_desc_realloc =+ chip_id;
 	}
 
 	for (i = 0; i < count; i++) {
@@ -273,7 +269,7 @@ static void ath12k_ppeds_release_rx_desc
 		/* Maintain indexes of arr per ab seperately, which can accessed easily
 	 	 * during per ab's rxdma srng replenish
 	 	 */
-		ab->ppeds_rx_idx[chip_id][rx_bufs_reaped[chip_id]] = i;
+		ab->ppe.ppeds_rx_idx[chip_id][rx_bufs_reaped[chip_id]] = i;
 		rx_bufs_reaped[chip_id]++;
 	}
 
@@ -283,7 +279,7 @@ static void ath12k_ppeds_release_rx_desc
 
 		src_ab = ag->ab[chip_id];
 		ath12k_dp_rx_bufs_replenish_ppeds(src_ab, rx_bufs_reaped[chip_id],
-						  &ab->ppeds_rx_idx[chip_id][0], arr);
+						  &ab->ppe.ppeds_rx_idx[chip_id][0], arr);
 	}
 
 	return;
@@ -295,9 +291,9 @@ err_h_alloc_failure:
 		for (i = 0; i < count; i++)
 		        num_free_desc +=
 				ath12k_ppeds_free_rx_desc(arr, src_ab, i,
-							  &src_ab->ppeds_rx_idx[chip_id][0]);
+							  &src_ab->ppe.ppeds_rx_idx[chip_id][0]);
 		if (!src_ab->stats_disable)
-			src_ab->ppeds_stats.num_rx_desc_freed += num_free_desc;
+			src_ab->ppe.ppeds_stats.num_rx_desc_freed += num_free_desc;
 	}
 }
 
@@ -308,7 +304,7 @@ void ath12k_ppeds_release_tx_desc_single
 	struct ath12k_base *ab = *(struct ath12k_base **)ppe_ds_wlan_priv(ppeds_handle);
 
 	if (!ab->stats_disable)
-		ab->ppeds_stats.release_tx_single_cnt++;
+		ab->ppe.ppeds_stats.release_tx_single_cnt++;
 
         return;
 }
@@ -332,9 +328,9 @@ static u32 ath12k_ppeds_get_batched_tx_d
 	flags = flags & ~__GFP_KSWAPD_RECLAIM;
 #endif
 
-	spin_lock_bh(&dp->ppeds_tx_desc_lock[ATH12K_PPEDS_DEFAULT_POOL_ID]);
+	spin_lock_bh(&dp->ppeds_tx_desc_lock);
 	for (i = 0; i < num_buff_req; i++) {
-		tx_desc = ath12k_dp_ppeds_tx_assign_desc_nolock(dp, ATH12K_PPEDS_DEFAULT_POOL_ID);
+		tx_desc = ath12k_dp_ppeds_tx_assign_desc_nolock(dp);
 		if (unlikely(!tx_desc)) {
 			ath12k_err(ab, "ran out of ppeds tx desc!\n");
 			dsb(st);
@@ -350,8 +346,7 @@ static u32 ath12k_ppeds_get_batched_tx_d
 			 */
 			skb = __netdev_alloc_skb_no_skb_reset(NULL, buff_size, flags);
 			if (unlikely(!skb)) {
-				ath12k_dp_ppeds_tx_release_desc_nolock(dp, tx_desc,
-								ATH12K_PPEDS_DEFAULT_POOL_ID);
+				ath12k_dp_ppeds_tx_release_desc_nolock(dp, tx_desc);
 				break;
 			}
 
@@ -373,13 +368,13 @@ static u32 ath12k_ppeds_get_batched_tx_d
 		arr[i].buff_addr = tx_desc->paddr;
 		allocated++;
 	}
-	spin_unlock_bh(&dp->ppeds_tx_desc_lock[ATH12K_PPEDS_DEFAULT_POOL_ID]);
+	spin_unlock_bh(&dp->ppeds_tx_desc_lock);
 
 	dsb(st);
 
 	if (!ab->stats_disable) {
-		ab->ppeds_stats.get_tx_desc_cnt++;
-		ab->ppeds_stats.tx_desc_allocated += allocated;
+		ab->ppe.ppeds_stats.get_tx_desc_cnt++;
+		ab->ppe.ppeds_stats.tx_desc_allocated += allocated;
 	}
 
 	return allocated;
@@ -387,7 +382,7 @@ static u32 ath12k_ppeds_get_batched_tx_d
 
 static int ath12k_dp_ppeds_tx_comp_poll(struct napi_struct *napi, int budget)
 {
-	struct ath12k_base *ab = container_of(napi, struct ath12k_base, ppeds_napi_ctxt.napi);
+	struct ath12k_base *ab = container_of(napi, struct ath12k_base, ppe.ppeds_napi_ctxt.napi);
 	int total_budget = (budget << 2) - 1;
 	struct ath12k_dp *dp = &ab->dp;
 	int work_done;
@@ -395,7 +390,7 @@ static int ath12k_dp_ppeds_tx_comp_poll(
 	set_bit(ATH12K_DP_PPEDS_TX_COMP_NAPI_BIT, &dp->ppeds_service_running);
 	work_done = ath12k_ppeds_tx_completion_handler(ab, total_budget);
 	if (!ab->stats_disable)
-		ab->ppeds_stats.tx_desc_freed += work_done;
+		ab->ppe.ppeds_stats.tx_desc_freed += work_done;
 
 	work_done = (work_done + 1) >> 2;
 	clear_bit(ATH12K_DP_PPEDS_TX_COMP_NAPI_BIT, &dp->ppeds_service_running);
@@ -418,7 +413,7 @@ static int ath12k_dp_ppeds_tx_comp_poll(
 irqreturn_t ath12k_dp_ppeds_handle_tx_comp(int irq, void *ctxt)
 {
 	struct ath12k_base *ab = (struct ath12k_base *)ctxt;
-	struct ath12k_ppeds_napi *napi_ctxt = &ab->ppeds_napi_ctxt;
+	struct ath12k_ppeds_napi *napi_ctxt = &ab->ppe.ppeds_napi_ctxt;
 
 	ath12k_hif_ppeds_irq_disable(ab, PPEDS_IRQ_PPE_WBM2SW_REL);
 	napi_schedule(&napi_ctxt->napi);
@@ -428,7 +423,7 @@ irqreturn_t ath12k_dp_ppeds_handle_tx_co
 int ath12k_ppe_napi_budget = NAPI_POLL_WEIGHT;
 static int ath12k_dp_ppeds_add_napi_ctxt(struct ath12k_base *ab)
 {
-	struct ath12k_ppeds_napi *napi_ctxt = &ab->ppeds_napi_ctxt;
+	struct ath12k_ppeds_napi *napi_ctxt = &ab->ppe.ppeds_napi_ctxt;
 	int ret;
 
 	ret = init_dummy_netdev((struct net_device *)&napi_ctxt->ndev);
@@ -438,11 +433,11 @@ static int ath12k_dp_ppeds_add_napi_ctxt
 	}
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0))
-		netif_napi_add(&napi_ctxt->ndev, &napi_ctxt->napi,
-			       ath12k_dp_ppeds_tx_comp_poll);
+	netif_napi_add(&napi_ctxt->ndev, &napi_ctxt->napi,
+		       ath12k_dp_ppeds_tx_comp_poll);
 #else
-		netif_napi_add_weight(&napi_ctxt->ndev, &napi_ctxt->napi,
-				      ath12k_dp_ppeds_tx_comp_poll, ath12k_ppe_napi_budget);
+	netif_napi_add_weight(&napi_ctxt->ndev, &napi_ctxt->napi,
+			      ath12k_dp_ppeds_tx_comp_poll, ath12k_ppe_napi_budget);
 #endif
 
 	return 0;
@@ -456,7 +451,7 @@ void ath12k_dp_ppeds_service_enable_disa
 	if (enable)
 		set_bit(ATH12K_DP_PPEDS_NAPI_DONE_BIT, &dp->ppeds_service_running);
 
-	ppe_ds_wlan_service_status_update(ab->ppeds_handle, enable);
+	ppe_ds_wlan_service_status_update(ab->ppe.ppeds_handle, enable);
 }
 
 void ath12k_dp_ppeds_interrupt_stop(struct ath12k_base *ab)
@@ -473,7 +468,7 @@ void ath12k_dp_ppeds_interrupt_start(str
 
 static void ath12k_dp_ppeds_del_napi_ctxt(struct ath12k_base *ab)
 {
-	struct ath12k_ppeds_napi *napi_ctxt = &ab->ppeds_napi_ctxt;
+	struct ath12k_ppeds_napi *napi_ctxt = &ab->ppe.ppeds_napi_ctxt;
 
 	netif_napi_del(&napi_ctxt->napi);
 	ath12k_dbg(ab, ATH12K_DBG_PPE, " ath12k_dp_ppeds_del_napi_ctxt success\n");
@@ -548,7 +543,7 @@ void ath12k_dp_peer_ppeds_route_setup(st
 		primary_link_arvif = arvif->ahvif->link[ahsta->primary_link_id];
 
 		if (!test_bit(ATH12K_FLAG_PPE_DS_ENABLED,
-		    primary_link_arvif->ab->dev_flags)) {
+		    &primary_link_arvif->ab->dev_flags)) {
 			ath12k_info(ab,
 				    "Primary link %d does not support DS "
 				    "Disabling DS routing on RX for peer %pM\n",
@@ -567,9 +562,9 @@ static int ath12k_dp_ppeds_alloc_ppe_vp_
 {
 	int i;
 
-	mutex_lock(&ab->ppe_vp_tbl_lock);
-	if (ab->num_ppe_vp_profiles == PPE_VP_ENTRIES_MAX) {
-		mutex_unlock(&ab->ppe_vp_tbl_lock);
+	mutex_lock(&ab->ppe.ppe_vp_tbl_lock);
+	if (ab->ppe.num_ppe_vp_profiles == PPE_VP_ENTRIES_MAX) {
+		mutex_unlock(&ab->ppe.ppe_vp_tbl_lock);
 		ath12k_err(ab, "Maximum ppe_vp count reached for soc\n");
 		return -ENOSR;
 	}
@@ -581,14 +576,14 @@ static int ath12k_dp_ppeds_alloc_ppe_vp_
 
 	if (i == PPE_VP_ENTRIES_MAX) {
 		WARN_ONCE(1, "All ppe vp profile entries are in use!");
-		mutex_unlock(&ab->ppe_vp_tbl_lock);
+		mutex_unlock(&ab->ppe.ppe_vp_tbl_lock);
 		return -ENOSR;
 	}
-	ab->num_ppe_vp_profiles++;
+	ab->ppe.num_ppe_vp_profiles++;
 
 	ab->dp.ppe_vp_profile[i].is_configured = true;
 	*vp_profile = &ab->dp.ppe_vp_profile[i];
-	mutex_unlock(&ab->ppe_vp_tbl_lock);
+	mutex_unlock(&ab->ppe.ppe_vp_tbl_lock);
 
 	return i;
 }
@@ -602,16 +597,16 @@ ath12k_dp_ppeds_dealloc_ppe_vp_profile(s
 		return;
 	}
 
-	mutex_lock(&ab->ppe_vp_tbl_lock);
+	mutex_lock(&ab->ppe.ppe_vp_tbl_lock);
 	if (!ab->dp.ppe_vp_profile[ppe_vp_profile_idx].is_configured) {
-		mutex_unlock(&ab->ppe_vp_tbl_lock);
+		mutex_unlock(&ab->ppe.ppe_vp_tbl_lock);
 		ath12k_err(ab, "PPE VP profile is not configured at idx:%d", ppe_vp_profile_idx);
 		return;
 	}
 
 	ab->dp.ppe_vp_profile[ppe_vp_profile_idx].is_configured = false;
-	ab->num_ppe_vp_profiles--;
-	mutex_unlock(&ab->ppe_vp_tbl_lock);
+	ab->ppe.num_ppe_vp_profiles--;
+	mutex_unlock(&ab->ppe.ppe_vp_tbl_lock);
 	ath12k_dbg(ab, ATH12K_DBG_PPE, "ath12k_dp_ppeds_dealloc_ppe_vp_profile success\n");
 }
 
@@ -619,26 +614,27 @@ static int ath12k_dp_ppeds_alloc_vp_tbl_
 {
 	int i;
 
-	mutex_lock(&ab->ppe_vp_tbl_lock);
-	if (ab->num_ppe_vp_profiles == PPE_VP_ENTRIES_MAX) {
-		mutex_unlock(&ab->ppe_vp_tbl_lock);
+	mutex_lock(&ab->ppe.ppe_vp_tbl_lock);
+	if (ab->ppe.num_ppe_vp_profiles == PPE_VP_ENTRIES_MAX) {
+		mutex_unlock(&ab->ppe.ppe_vp_tbl_lock);
 		ath12k_err(ab, "Maximum ppe_vp count reached for soc\n");
 		return -ENOSR;
 	}
 
 	for (i = 0; i < PPE_VP_ENTRIES_MAX; i++) {
-		if (!ab->ppe_vp_tbl_registered[i])
+		if (!ab->ppe.ppe_vp_tbl_registered[i])
 			break;
 	}
 
 	if (i == PPE_VP_ENTRIES_MAX) {
+		mutex_unlock(&ab->ppe.ppe_vp_tbl_lock);
 		WARN_ONCE(1, "All ppe vp table entries are in use!");
 		return -ENOSR;
 	}
 
-	ab->num_ppe_vp_entries++;
-	ab->ppe_vp_tbl_registered[i] = 1;
-	mutex_unlock(&ab->ppe_vp_tbl_lock);
+	ab->ppe.num_ppe_vp_entries++;
+	ab->ppe.ppe_vp_tbl_registered[i] = 1;
+	mutex_unlock(&ab->ppe.ppe_vp_tbl_lock);
 
 	return i;
 }
@@ -655,43 +651,44 @@ static void ath12k_dp_ppeds_dealloc_vp_t
 
 	ath12k_hal_tx_set_ppe_vp_entry(ab, vp_cfg, ppe_vp_num_idx);
 
-	mutex_lock(&ab->ppe_vp_tbl_lock);
-	if (!ab->ppe_vp_tbl_registered[ppe_vp_num_idx]) {
-		mutex_unlock(&ab->ppe_vp_tbl_lock);
+	mutex_lock(&ab->ppe.ppe_vp_tbl_lock);
+	if (!ab->ppe.ppe_vp_tbl_registered[ppe_vp_num_idx]) {
+		mutex_unlock(&ab->ppe.ppe_vp_tbl_lock);
 		ath12k_err(ab, "PPE VP is not configured at idx:%d", ppe_vp_num_idx);
 		return;
 	}
 
-	ab->ppe_vp_tbl_registered[ppe_vp_num_idx] = 0;
-	ab->num_ppe_vp_entries--;
-	mutex_unlock(&ab->ppe_vp_tbl_lock);
+	ab->ppe.ppe_vp_tbl_registered[ppe_vp_num_idx] = 0;
+	ab->ppe.num_ppe_vp_entries--;
+	mutex_unlock(&ab->ppe.ppe_vp_tbl_lock);
 }
 
 static int ath12k_dp_ppeds_alloc_vp_search_idx_tbl_entry(struct ath12k_base *ab)
 {
 	int i;
 
-	mutex_lock(&ab->ppe_vp_tbl_lock);
-	if (ab->num_ppe_vp_profiles == PPE_VP_ENTRIES_MAX) {
-		mutex_unlock(&ab->ppe_vp_tbl_lock);
+	mutex_lock(&ab->ppe.ppe_vp_tbl_lock);
+	if (ab->ppe.num_ppe_vp_profiles == PPE_VP_ENTRIES_MAX) {
+		mutex_unlock(&ab->ppe.ppe_vp_tbl_lock);
 		ath12k_err(ab, "Maximum ppe_vp count reached for soc\n");
 		return -ENOSR;
 	}
 
 
 	for (i = 0; i < PPE_VP_ENTRIES_MAX; i++) {
-		if (!ab->ppe_vp_search_idx_tbl_set[i])
+		if (!ab->ppe.ppe_vp_search_idx_tbl_set[i])
 			break;
 	}
 
 	if (i == PPE_VP_ENTRIES_MAX) {
+		mutex_unlock(&ab->ppe.ppe_vp_tbl_lock);
 		WARN_ONCE(1, "All ppe vp table entries are in use!");
 		return -ENOSR;
 	}
 
-	ab->num_ppe_vp_search_idx_entries++;
-	ab->ppe_vp_search_idx_tbl_set[i] = 1;
-	mutex_unlock(&ab->ppe_vp_tbl_lock);
+	ab->ppe.num_ppe_vp_search_idx_entries++;
+	ab->ppe.ppe_vp_search_idx_tbl_set[i] = 1;
+	mutex_unlock(&ab->ppe.ppe_vp_tbl_lock);
 
 	return i;
 }
@@ -707,16 +704,16 @@ ath12k_dp_ppeds_dealloc_vp_search_idx_tb
 
 	ath12k_dbg(ab, ATH12K_DBG_PPE, "dealloc ppe_vp_search_idx %d\n", ppe_vp_search_idx);
 
-	mutex_lock(&ab->ppe_vp_tbl_lock);
-	if (!ab->ppe_vp_search_idx_tbl_set[ppe_vp_search_idx]) {
-		mutex_unlock(&ab->ppe_vp_tbl_lock);
+	mutex_lock(&ab->ppe.ppe_vp_tbl_lock);
+	if (!ab->ppe.ppe_vp_search_idx_tbl_set[ppe_vp_search_idx]) {
+		mutex_unlock(&ab->ppe.ppe_vp_tbl_lock);
 		ath12k_err(ab,"PPE VP search idx table is not configured at idx:%d", ppe_vp_search_idx);
 		return;
 	}
 
-	ab->ppe_vp_search_idx_tbl_set[ppe_vp_search_idx] = 0;
-	ab->num_ppe_vp_search_idx_entries--;
-	mutex_unlock(&ab->ppe_vp_tbl_lock);
+	ab->ppe.ppe_vp_search_idx_tbl_set[ppe_vp_search_idx] = 0;
+	ab->ppe.num_ppe_vp_search_idx_entries--;
+	mutex_unlock(&ab->ppe.ppe_vp_tbl_lock);
 
 	return;
 }
@@ -768,7 +765,7 @@ void ath12k_dp_ppeds_update_vp_entry(str
 	if (!test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags))
 		return;
 
-	if (!ab->ppeds_handle) {
+	if (!ab->ppe.ppeds_handle) {
 		ath12k_dbg(ab, ATH12K_DBG_PPE, "DS not enabled on this chip\n");
 		return;
 	}
@@ -800,7 +797,7 @@ int ath12k_ppeds_attach_vdev(struct ath1
 	if (!test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags))
 		return -ENOSR;
 
-	if (!ab->ppeds_handle) {
+	if (!ab->ppe.ppeds_handle) {
 		ath12k_err(ab, "DS not enabled on this chip\n");
 		return -EINVAL;
 	}
@@ -865,7 +862,7 @@ dealloc_vp_tbl_entry:
 dealloc_vp_profile:
 	ath12k_dp_ppeds_dealloc_ppe_vp_profile(ab, ppe_vp_profile_idx);
 vp_free:
-	ppe_ds_wlan_vp_free(ab->ppeds_handle, vp_num);
+	ppe_ds_wlan_vp_free(ab->ppe.ppeds_handle, vp_num);
 
 	return ret;
 }
@@ -890,7 +887,7 @@ void ath12k_ppeds_detach_vdev(struct ath
 		return;
 	}
 
-	ppe_ds_wlan_vp_free(ab->ppeds_handle, vp_profile->vp_num);
+	ppe_ds_wlan_vp_free(ab->ppe.ppeds_handle, vp_profile->vp_num);
 	ath12k_dbg(ab, ATH12K_DBG_PPE, "ppe_ds_wlan_vp_free\n");
 
 	/* For STA mode ast index table reg also needs to be cleaned */
@@ -909,13 +906,13 @@ int ath12k_ppeds_get_handle(struct ath12
 	if (!test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags))
 		return 0;
 
-	ab->ppeds_handle = ppe_ds_wlan_inst_alloc(&ppeds_ops, sizeof(struct ath12k_base *));
-	if (!ab->ppeds_handle) {
+	ab->ppe.ppeds_handle = ppe_ds_wlan_inst_alloc(&ppeds_ops, sizeof(struct ath12k_base *));
+	if (!ab->ppe.ppeds_handle) {
 		ath12k_err(ab, "Failed to allocate ppeds soc instance\n");
 		ath12k_ppeds_detach(ab);
 		return -ENOSR;
 	}
-	ath12k_dbg(ab, ATH12K_DBG_PPE, "PPEDS handle obtained for ab %px ppeds_handle %px\n", ab, ab->ppeds_handle);
+	ath12k_dbg(ab, ATH12K_DBG_PPE, "PPEDS handle obtained for ab %px ppeds_handle %px\n", ab, ab->ppe.ppeds_handle);
 	return 0;
 }
 
@@ -938,12 +935,9 @@ int ath12k_ppeds_attach(struct ath12k_ba
 		if (ab->ag->recovery_mode == ATH12K_MLO_RECOVERY_MODE1 &&
 		    ab->dp.ppe_vp_profile[i].is_configured)
 			goto skip_vp_reset;
-		else
-			ath12k_dbg(ab, ATH12K_DBG_PPE,
-				   "PPEDS attach reset PPE VP table");
 
-		ab->ppe_vp_tbl_registered[i] = 0;
-		ab->ppe_vp_search_idx_tbl_set[i] = 0;
+		ab->ppe.ppe_vp_tbl_registered[i] = 0;
+		ab->ppe.ppe_vp_search_idx_tbl_set[i] = 0;
 		ab->dp.ppe_vp_profile[i].is_configured = false;
 	}
 
@@ -952,39 +946,39 @@ skip_vp_reset:
 	if (ret)
 		return ret;
 
-	WARN_ON(ab->ppeds_soc_idx != -1);
+	WARN_ON(ab->ppe.ppeds_soc_idx != -1);
 	/* dec ppeds_soc_idx to start from 0 */
-	ab->ppeds_soc_idx = atomic_inc_return(&num_ppeds_nodes) - 1;
+	ab->ppe.ppeds_soc_idx = atomic_inc_return(&num_ppeds_nodes) - 1;
 
 	ath12k_dbg(ab, ATH12K_DBG_PPE,
 		   "PPEDS attach ab %px ppeds_handle %px ppeds_soc_idx %d num_ppeds_nodes %d\n",
-		   ab, ab->ppeds_handle, ab->ppeds_soc_idx, atomic_read(&num_ppeds_nodes));
+		   ab, ab->ppe.ppeds_handle, ab->ppe.ppeds_soc_idx, atomic_read(&num_ppeds_nodes));
 	ret = ath12k_dp_ppeds_add_napi_ctxt(ab);
 	if (ret)
 		return -ENOSR;
 
-	abptr = (struct ath12k_base **)ppe_ds_wlan_priv(ab->ppeds_handle);
+	abptr = (struct ath12k_base **)ppe_ds_wlan_priv(ab->ppe.ppeds_handle);
 	*abptr = ab;
 	ath12k_dbg(ab, ATH12K_DBG_PPE, "PPEDS attach success\n");
 
 	for (i = 0; i < ab->ag->num_chip; i++) {
-		ab->ppeds_rx_idx[i] = kzalloc((sizeof(u16) * PPE_DS_TXCMPL_DEF_BUDGET),
+		ab->ppe.ppeds_rx_idx[i] = kzalloc((sizeof(u16) * PPE_DS_TXCMPL_DEF_BUDGET),
 					      GFP_ATOMIC);
-		if (!ab->ppeds_rx_idx[i]) {
+		if (!ab->ppe.ppeds_rx_idx[i]) {
 		        ath12k_err(ab, "Failed to alloc mem ppeds_rx_desc\n");
 			goto err_ppeds_attach;
 		}
 	}
 
-	ab->ppeds_rx_num_elem = PPE_DS_TXCMPL_DEF_BUDGET;
+	ab->ppe.ppeds_rx_num_elem = PPE_DS_TXCMPL_DEF_BUDGET;
 
 	return 0;
 
 err_ppeds_attach:
-	ab->ppeds_rx_num_elem = 0;
+	ab->ppe.ppeds_rx_num_elem = 0;
 	for (i = i - 1; i >= 0; i--) {
-		kfree(ab->ppeds_rx_idx[i]);
-		ab->ppeds_rx_idx[i] = NULL;
+		kfree(ab->ppe.ppeds_rx_idx[i]);
+		ab->ppe.ppeds_rx_idx[i] = NULL;
 	}
 
 	return -ENOMEM;
@@ -997,7 +991,7 @@ int ath12k_ppeds_detach(struct ath12k_ba
 	if (!test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags))
 		return 0;
 
-	if (!ab->ppeds_handle)
+	if (!ab->ppe.ppeds_handle)
 		return 0;
 
 	ath12k_dp_ppeds_del_napi_ctxt(ab);
@@ -1005,9 +999,9 @@ int ath12k_ppeds_detach(struct ath12k_ba
 
 	/* free ppe-ds interrupts before freeing the instance */
 	ath12k_hif_ppeds_free_interrupts(ab);
-	ppe_ds_wlan_inst_free(ab->ppeds_handle);
-	ab->ppeds_handle = NULL;
-	ab->ppeds_soc_idx = -1;
+	ppe_ds_wlan_inst_free(ab->ppe.ppeds_handle);
+	ab->ppe.ppeds_handle = NULL;
+	ab->ppe.ppeds_soc_idx = -1;
 	atomic_dec(&num_ppeds_nodes);
 
 	for (i = 0; i < PPE_VP_ENTRIES_MAX; i++) {
@@ -1017,19 +1011,19 @@ int ath12k_ppeds_detach(struct ath12k_ba
 		else
 			ath12k_dbg(ab, ATH12K_DBG_PPE,
 				   "PPEDS deatch reset VP table");
-		ab->ppe_vp_tbl_registered[i] = 0;
-		ab->ppe_vp_search_idx_tbl_set[i] = 0;
+		ab->ppe.ppe_vp_tbl_registered[i] = 0;
+		ab->ppe.ppe_vp_search_idx_tbl_set[i] = 0;
 		ab->dp.ppe_vp_profile[i].is_configured = false;
 	}
 
 skip_vp_reset:
 	ath12k_dbg(ab, ATH12K_DBG_PPE, "PPEDS detach success\n");
 
-	if (ab->ppeds_rx_num_elem) {
-		ab->ppeds_rx_num_elem = 0;
+	if (ab->ppe.ppeds_rx_num_elem) {
+		ab->ppe.ppeds_rx_num_elem = 0;
 		for (i = 0; i < ab->ag->num_chip; i++) {
-			kfree(ab->ppeds_rx_idx[i]);
-			ab->ppeds_rx_idx[i] = NULL;
+			kfree(ab->ppe.ppeds_rx_idx[i]);
+			ab->ppe.ppeds_rx_idx[i] = NULL;
 		}
 	}
 
@@ -1038,16 +1032,17 @@ skip_vp_reset:
 
 int ath12k_dp_ppeds_start(struct ath12k_base *ab)
 {
-	struct ath12k_ppeds_napi *napi_ctxt = &ab->ppeds_napi_ctxt;
+	struct ath12k_ppeds_napi *napi_ctxt = &ab->ppe.ppeds_napi_ctxt;
 	struct ppe_ds_wlan_ctx_info_handle wlan_info_hdl;
 	bool umac_reset_inprogress;
+	int ds_node_id;
 
 	if (!test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags))
 		return 0;
 
 	umac_reset_inprogress = ath12k_dp_umac_reset_in_progress(ab);
 
-	if (!ab->ppeds_handle) {
+	if (!ab->ppe.ppeds_handle) {
 		ath12k_err(ab, "ppeds_handle is null");
 		return -EINVAL;
 	}
@@ -1055,21 +1050,29 @@ int ath12k_dp_ppeds_start(struct ath12k_
 	if (!umac_reset_inprogress)
 		napi_enable(&napi_ctxt->napi);
 
-	ab->ppeds_stopped = 0;
+	ab->ppe.ppeds_stopped = 0;
 
 	wlan_info_hdl.umac_reset_inprogress = 0;
 
-	if (ppe_ds_wlan_instance_start(ab->ppeds_handle,
+	if (ppe_ds_wlan_instance_start(ab->ppe.ppeds_handle,
 				       &wlan_info_hdl) != 0)
 		return -EINVAL;
 
-	ath12k_dbg(ab, ATH12K_DBG_PPE, "PPEDS start success\n");
+	ds_node_id = ppe_ds_wlan_get_node_id(ab->ppe.ppeds_handle);
+	if (ds_node_id == PPE_VP_DS_INVALID_NODE_ID) {
+		ath12k_err(ab, "Failed to get DS node id for chip_id %d\n",
+			   ab->chip_id);
+		return -ENOSR;
+	}
+	ab->ppe.ds_node_id = ds_node_id;
+
+	ath12k_dbg(ab, ATH12K_DBG_PPE, "PPEDS start success chip_id %d ds_node_id %d ppeds_soc_idx %d", ab->chip_id, ab->ppe.ds_node_id, ab->ppe.ppeds_soc_idx);
 	return 0;
 }
 
 void ath12k_dp_ppeds_stop(struct ath12k_base *ab)
 {
-	struct ath12k_ppeds_napi *napi_ctxt = &ab->ppeds_napi_ctxt;
+	struct ath12k_ppeds_napi *napi_ctxt = &ab->ppe.ppeds_napi_ctxt;
 	struct ppe_ds_wlan_ctx_info_handle wlan_info_hdl;
 	bool umac_reset_in_progress;
 
@@ -1078,19 +1081,19 @@ void ath12k_dp_ppeds_stop(struct ath12k_
 
 	umac_reset_in_progress = ath12k_dp_umac_reset_in_progress(ab);
 
-	if (!ab->ppeds_handle || ab->ppeds_stopped) {
+	if (!ab->ppe.ppeds_handle || ab->ppe.ppeds_stopped) {
 		ath12k_warn(ab, "PPE DS aleady stopped!\n");
 		return;
 	}
 
-	ab->ppeds_stopped = 1;
+	ab->ppe.ppeds_stopped = 1;
 
 	if (!umac_reset_in_progress)
 		napi_disable(&napi_ctxt->napi);
 
 	wlan_info_hdl.umac_reset_inprogress = umac_reset_in_progress;
 
-	ppe_ds_wlan_instance_stop(ab->ppeds_handle,
+	ppe_ds_wlan_instance_stop(ab->ppe.ppeds_handle,
 				  &wlan_info_hdl);
 
 	ath12k_dbg(ab, ATH12K_DBG_PPE, "PPEDS stop success\n");
@@ -1106,7 +1109,7 @@ int ath12k_dp_ppeds_register_soc(struct
 	if (!test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags))
 		return 0;
 
-	if (!ab->ppeds_handle) {
+	if (!ab->ppe.ppeds_handle) {
 		ath12k_err(ab, "ppeds not attached");
 		return -EINVAL;
 	}
@@ -1119,16 +1122,16 @@ int ath12k_dp_ppeds_register_soc(struct
 	reg_info.ppe2tcl_num_desc = DP_PPE2TCL_RING_SIZE;
 	reg_info.reo2ppe_num_desc = DP_REO2PPE_RING_SIZE;
 
-	if (ppe_ds_wlan_inst_register(ab->ppeds_handle, &reg_info) != true) {
+	if (ppe_ds_wlan_inst_register(ab->ppe.ppeds_handle, &reg_info) != true) {
 	        ath12k_err(ab, "ppeds not attached");
 		return -EINVAL;
 	}
 
 	idx->ppe2tcl_start_idx = reg_info.ppe2tcl_start_idx;
 	idx->reo2ppe_start_idx = reg_info.reo2ppe_start_idx;
-	ab->ppeds_int_mode_enabled = reg_info.ppe_ds_int_mode_enabled;
+	ab->ppe.ppeds_int_mode_enabled = reg_info.ppe_ds_int_mode_enabled;
 
-	ath12k_dbg(ab, ATH12K_DBG_PPE, "PPEDS register soc-success");
+	ath12k_dbg(ab, ATH12K_DBG_PPE, "PPEDS register soc-success chip_id %d", ab->chip_id);
 
         return 0;
 }
Index: b/drivers/net/wireless/ath/ath12k/ppe.h
===================================================================
--- a/drivers/net/wireless/ath/ath12k/ppe.h
+++ b/drivers/net/wireless/ath/ath12k/ppe.h
@@ -6,7 +6,15 @@
 #ifndef ATH12K_PPE_H
 #define ATH12K_PPE_H
 
-#define ATH12K_PPEDS_DEFAULT_POOL_ID 0
+#include <ppe_ds_wlan.h>
+#include <ppe_vp_public.h>
+#include <ppe_drv_sc.h>
+#include <ppe_drv.h>
+
+struct ath12k_base;
+struct ath12k_vif;
+
+#define ATH12K_MAX_SOCS             3
 
 #define ATH12K_PPE_DEFAULT_CORE_MASK		ath12k_rfs_core_mask[0]
 #define ATH12K_PPE_RFS_2GHZ_CORE_MASK		ath12k_rfs_core_mask[1]
@@ -27,6 +35,47 @@ int ath12k_vif_alloc_vp(struct ath12k_vi
 void ath12k_vif_free_vp(struct ath12k_vif *ahvif);
 
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+struct ath12k_ppeds_stats {
+	u32 tcl_prod_cnt;
+	u32 tcl_cons_cnt;
+	u32 reo_prod_cnt;
+	u32 reo_cons_cnt;
+	u32 get_tx_desc_cnt;
+	u32 tx_desc_allocated;
+	u32 tx_desc_freed;
+	u32 fw2wbm_pkt_drops;
+	u32 enable_intr_cnt;
+	u32 disable_intr_cnt;
+	u32 release_tx_single_cnt;
+	u32 release_rx_desc_cnt;
+	u32 num_rx_desc_freed;
+	u32 num_rx_desc_realloc;
+};
+
+struct ath12k_ppeds_napi {
+	struct napi_struct napi;
+	struct net_device ndev;
+};
+
+struct ath12k_ppe {
+	ppe_ds_wlan_handle_t *ppeds_handle;
+	/* used for per node enumeration*/
+	int ppeds_soc_idx;
+	int ppe_vp_tbl_registered[PPE_VP_ENTRIES_MAX];
+	int ppe_vp_search_idx_tbl_set[PPE_VP_ENTRIES_MAX];
+	struct ath12k_ppeds_napi ppeds_napi_ctxt;
+	struct mutex ppe_vp_tbl_lock;
+	u8 num_ppe_vp_profiles;
+	u8 num_ppe_vp_search_idx_entries;
+	u8 num_ppe_vp_entries;
+	u8 ppeds_int_mode_enabled;
+	u8 ppeds_stopped;
+	struct ath12k_ppeds_stats ppeds_stats;
+	u16 *ppeds_rx_idx[ATH12K_MAX_SOCS];
+	u16 ppeds_rx_num_elem;
+	/* ds_node_id */
+	int ds_node_id;
+};
 
 #define ATH12K_DP_PPEDS_NAPI_DONE_BIT	1
 #define ATH12K_DP_PPEDS_TX_COMP_NAPI_BIT	2
Index: b/drivers/net/wireless/ath/ath12k/umac_reset.c
===================================================================
--- a/drivers/net/wireless/ath/ath12k/umac_reset.c
+++ b/drivers/net/wireless/ath/ath12k/umac_reset.c
@@ -353,7 +353,7 @@ void ath12k_umac_reset_handle_pre_reset(
 	atomic_inc(&mlo_umac_reset->response_chip);
 
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
-	if (ab->ppeds_handle) {
+	if (ab->ppe.ppeds_handle) {
 		ath12k_dp_ppeds_service_enable_disable(ab, true);
 		ab->dp_umac_reset.umac_pre_reset_in_prog = true;
 		ath12k_dp_ppeds_interrupt_stop(ab);
@@ -377,7 +377,7 @@ void ath12k_umac_reset_handle_post_reset
 	atomic_inc(&mlo_umac_reset->response_chip);
 	ath12k_hif_irq_enable(ab);
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
-	if (ab->ppeds_handle) {
+	if (ab->ppe.ppeds_handle) {
 		ath12k_dp_ppeds_start(ab);
 		ath12k_dp_ppeds_interrupt_start(ab);
 	}
diff --git a/drivers/net/wireless/ath/ath12k/core.c b/drivers/net/wireless/ath/ath12k/core.c
index 2bb0cdb228fe..2dcf3f9dea52 100644
--- a/drivers/net/wireless/ath/ath12k/core.c
+++ b/drivers/net/wireless/ath/ath12k/core.c
@@ -1717,7 +1717,6 @@ static int ath12k_core_hw_group_start(struct ath12k_hw_group *ag)
 			goto pdev_cleanup;
 		}
 		ath12k_hif_irq_enable(ab);
-		ath12k_hif_ppeds_irq_enable(ab, PPEDS_IRQ_PPE2TCL);
 		ath12k_hif_ppeds_irq_enable(ab, PPEDS_IRQ_REO2PPE);
 		ath12k_hif_ppeds_irq_enable(ab, PPEDS_IRQ_PPE_WBM2SW_REL);
 
diff --git a/drivers/net/wireless/ath/ath12k/pci.c b/drivers/net/wireless/ath/ath12k/pci.c
index 64bccf40a135..854592e6dee9 100644
--- a/drivers/net/wireless/ath/ath12k/pci.c
+++ b/drivers/net/wireless/ath/ath12k/pci.c
@@ -262,7 +262,7 @@ int ath12k_pci_ppeds_register_interrupts(struct ath12k_base *ab, int type, int v
 		snprintf(&ab->dp.ppeds_irq_name[PPEDS_IRQ_PPE2TCL], sizeof(ab->dp.ppeds_irq_name[PPEDS_IRQ_PPE2TCL]),
 			 "pci%d_ppe2tcl_%d", bus_id, ab->ppe.ppeds_soc_idx);
 		ret = request_irq(irq,  ath12k_ds_ppe2tcl_irq_handler,
-				  IRQF_NO_AUTOEN | IRQF_NO_SUSPEND,
+				  IRQF_NO_SUSPEND,
 			    ab->dp.ppeds_irq_name[PPEDS_IRQ_PPE2TCL], (void *)ath12k_dp_get_ppe_ds_ctxt(ab));
 		if (ret)
 			goto irq_fail;
@@ -276,7 +276,6 @@ int ath12k_pci_ppeds_register_interrupts(struct ath12k_base *ab, int type, int v
 		if (ret)
 			goto irq_fail;
 		ab->dp.ppeds_irq[PPEDS_IRQ_REO2PPE] = irq;
-		disable_irq_nosync(irq);
 	} else if (type == HAL_WBM2SW_RELEASE && ring_num == HAL_WBM2SW_PPEDS_TX_CMPLN_RING_NUM) {
 		snprintf(&ab->dp.ppeds_irq_name[PPEDS_IRQ_PPE_WBM2SW_REL], sizeof(ab->dp.ppeds_irq_name[PPEDS_IRQ_PPE_WBM2SW_REL]),
 			 "pci%d_ppe_wbm_rel_%d", bus_id, ab->ppe.ppeds_soc_idx);
@@ -286,11 +285,12 @@ int ath12k_pci_ppeds_register_interrupts(struct ath12k_base *ab, int type, int v
 		if (ret)
 			goto irq_fail;
 		ab->dp.ppeds_irq[PPEDS_IRQ_PPE_WBM2SW_REL] = irq;
-		disable_irq_nosync(irq);
 	} else {
 		return 0;
 	}
 
+	disable_irq_nosync(irq);
+
 	return 0;
 
 irq_fail:
diff --git a/drivers/net/wireless/ath/ath12k/pcic.c b/drivers/net/wireless/ath/ath12k/pcic.c
index 4ba17095fcf1..e6dd9ab56d5c 100644
--- a/drivers/net/wireless/ath/ath12k/pcic.c
+++ b/drivers/net/wireless/ath/ath12k/pcic.c
@@ -624,7 +624,7 @@ int ath12k_pcic_ppeds_register_interrupts(struct ath12k_base *ab, int type, int
 		snprintf(&ab->dp.ppeds_irq_name[PPEDS_IRQ_PPE2TCL], sizeof(ab->dp.ppeds_irq_name[PPEDS_IRQ_PPE2TCL]),
 			 "pcic%d_ppe2tcl_%d", bus_id, ab->ppe.ppeds_soc_idx);
 		ret = devm_request_irq(&pdev->dev, irq,  ath12k_ds_ppe2tcl_irq_handler,
-				  IRQF_NO_AUTOEN | IRQF_NO_SUSPEND,
+				  IRQF_NO_SUSPEND,
 			    ab->dp.ppeds_irq_name[PPEDS_IRQ_PPE2TCL], (void *)ath12k_dp_get_ppe_ds_ctxt(ab));
 		if (ret)
 			goto irq_fail;
@@ -642,7 +642,6 @@ int ath12k_pcic_ppeds_register_interrupts(struct ath12k_base *ab, int type, int
 		if (ret)
 			goto irq_fail;
 		ab->dp.ppeds_irq[PPEDS_IRQ_REO2PPE] = irq;
-		disable_irq_nosync(irq);
 
 	} else if (type == HAL_WBM2SW_RELEASE && ring_num == HAL_WBM2SW_PPEDS_TX_CMPLN_RING_NUM) {
 		irq = ab->dp.ppeds_irq[PPEDS_IRQ_PPE_WBM2SW_REL];
@@ -657,11 +656,12 @@ int ath12k_pcic_ppeds_register_interrupts(struct ath12k_base *ab, int type, int
 		if (ret)
 			goto irq_fail;
 		ab->dp.ppeds_irq[PPEDS_IRQ_PPE_WBM2SW_REL] = irq;
-		disable_irq_nosync(irq);
 	} else {
 		return 0;
 	}
 
+	disable_irq_nosync(irq);
+
 	return 0;
 
 irq_fail:
