From 89db6feadce880099794725e9a3a6415e28c683f Mon Sep 17 00:00:00 2001
From: Mahendran P <quic_mahep@quicinc.com>
Date: Thu, 1 Jun 2023 14:55:39 +0530
Subject: [PATCH] ath12k: sawf: Add telemetry agent interface and configuration

Add the telemetry agent interfaces which interacts with telemetry agent
module. These interfaces helps to configure and update the required
stats to the telemetry agent which will be processed by telemetry agent
and detect the breach and notifies the driver.

Signed-off-by: Mahendran P <quic_mahep@quicinc.com>
Signed-off-by: Nagarajan Maran <quic_nmaran@quicinc.com>
---
 drivers/net/wireless/ath/ath12k/Makefile      |   3 +-
 drivers/net/wireless/ath/ath12k/sawf.c        |  12 +
 drivers/net/wireless/ath/ath12k/telemetry.c   |  27 +-
 .../wireless/ath/ath12k/telemetry_agent_if.c  | 308 ++++++++++++++++++
 .../wireless/ath/ath12k/telemetry_agent_if.h  |  76 +++++
 7 files changed, 825 insertions(+), 2 deletions(-)
 create mode 100644 drivers/net/wireless/ath/ath12k/telemetry_agent_if.c
 create mode 100644 drivers/net/wireless/ath/ath12k/telemetry_agent_if.h

--- a/drivers/net/wireless/ath/ath12k/sawf.c
+++ b/drivers/net/wireless/ath/ath12k/sawf.c
@@ -12,6 +12,8 @@
 #include "vendor.h"
 #include <linux/module.h>
 #include <qca-nss-ecm/ecm_classifier_emesh_public.h>
+#include "telemetry.h"
+#include "telemetry_agent_if.h"
 
 #define SVC_INDEX(svc_id) svc_id - 1
 #define DRV_TO_FW_SVC_ID(svc_id) (svc_id - 1)
@@ -133,6 +135,15 @@ void ath12k_update_svc_class(struct ath1
 	new_param->ul_max_latency = sawf_params->ul_max_latency;
 	new_param->ul_ofdma_disable = sawf_params->ul_ofdma_disable;
 	new_param->ul_mu_mimo_disable = sawf_params->ul_mu_mimo_disable;
+
+	ath12k_telemetry_set_svclass_cfg(true, new_param->svc_id,
+					 new_param->min_throughput_rate,
+					 new_param->max_throughput_rate,
+					 new_param->burst_size,
+					 new_param->service_interval,
+					 new_param->delay_bound,
+					 new_param->msdu_ttl,
+					 new_param->msdu_rate_loss);
 }
 
 bool ath12k_validate_sawf_param(struct ath12k_sawf_svc_params *params)
@@ -272,6 +283,15 @@ bool ath12k_disable_svc_class(u8 svc_id)
 	sawf_svc_class = &sawf_ctx->svc_classes[SVC_INDEX(svc_id)];
 	memset(sawf_svc_class, 0, sizeof(*sawf_svc_class));
 
+	ath12k_telemetry_set_svclass_cfg(false, svc_id,
+					 sawf_svc_class->min_throughput_rate,
+					 sawf_svc_class->max_throughput_rate,
+					 sawf_svc_class->burst_size,
+					 sawf_svc_class->service_interval,
+					 sawf_svc_class->delay_bound,
+					 sawf_svc_class->msdu_ttl,
+					 sawf_svc_class->msdu_rate_loss);
+
 	return true;
 }
 
@@ -519,8 +539,8 @@ u8 ath12k_sawf_get_msduq_of_tid(struct a
 {
 	struct ath12k_sawf_peer_ctx *peer_ctx = NULL;
 	struct ath12k_sawf_ctx *sawf_ctx;
-	u8 max_usr_def_q_sawf, def_msduq_max, q;
-	u8 msduq_id = SAWF_MSDUQ_ID_INVALID;
+	void *telemetry_peer_ctx = NULL;
+	u8 max_usr_def_q_sawf, def_msduq_max, q, msduq_id = SAWF_MSDUQ_ID_INVALID;
 
 	sawf_ctx = ath12k_get_sawf_context();
 	if (!sawf_ctx)
@@ -559,6 +579,22 @@ u8 ath12k_sawf_get_msduq_of_tid(struct a
 				ath12k_dbg(ab, ATH12K_DBG_SAWF,
 					   "New:msduq_id 0x%x:tid %u usrdefq %u\n",
 					   msduq_id, tid, q);
+
+				if (!peer_ctx->telemetry_peer_ctx) {
+					telemetry_peer_ctx =
+							ath12k_telemetry_peer_ctx_alloc(ab,
+											&peer->sawf_stats,
+											peer->addr,
+											svc_id,
+											(msduq_id - def_msduq_max));
+					if (telemetry_peer_ctx) {
+						peer_ctx->telemetry_peer_ctx = telemetry_peer_ctx;
+						ath12k_dbg(ab, ATH12K_DBG_SAWF,
+							   "telemetry peer ctx allocation"
+							   "with msduq_id:0x%x\n",
+							   msduq_id - def_msduq_max);
+					}
+				}
 				break;
 			}
 		}
@@ -571,11 +607,10 @@ u16 ath12k_sawf_alloc_msduq(struct ath12
 			    u8 svc_id,
 			    u16 peer_id)
 {
-	u8 msduq_id;
-	u8 svc_tid;
-	u16 ret_peer_msduq = SAWF_PEER_MSDUQ_INVALID;
 	struct ath12k_sawf_ctx *sawf_ctx;
 	struct ath12k_peer *peer;
+	u16 ret_peer_msduq = SAWF_PEER_MSDUQ_INVALID;
+	u8 svc_tid, msduq_id;
 
 	sawf_ctx = ath12k_get_sawf_context();
 	if (!sawf_ctx)
@@ -1463,8 +1498,9 @@ void ath12k_sawf_stats_update(struct ath
 	u64 entry_ts, enqueue_timestamp;
 	struct ath12k_base *ab = ar->ab;
 	struct sawf_tx_stats *tx_stats;
-	u32 msduq_id, len, q_id, tid;
-	u8 svc_id;
+	void *telemetry_peer_ctx;
+	u32 msduq_id, len, q_id, tid, num_pkts;
+	u8 svc_id, hostq_id;
 
 	if (!ts || !peer_ctx)
 		return;
@@ -1486,6 +1522,10 @@ void ath12k_sawf_stats_update(struct ath
 	tid = u32_get_bits(msduq_id, MSDUQID_TID_MASK);
 	q_id = u32_get_bits(msduq_id, MSDUQID_Q_MASK) - ab->default_msduq_per_tid;
 
+	hostq_id = msduq_id - (ab->default_msduq_per_tid * ATH12K_SAWF_MAX_TID_SUPPORT);
+	ath12k_telemetry_get_sla_num_pkts(&num_pkts);
+	telemetry_peer_ctx = peer->sawf_ctx_peer.telemetry_peer_ctx;
+
 	if (!(ath12k_debugfs_is_sawf_stats_enabled(ar) & ATH12K_SAWF_STATS_BASIC))
 		goto latency_stats_update;
 
@@ -1532,6 +1572,13 @@ void ath12k_sawf_stats_update(struct ath
 
 	tx_stats->queue_depth--;
 
+	if ((!((tx_stats->tx_success.num_pkts + tx_stats->tx_failed) % num_pkts)) &&
+	    telemetry_peer_ctx)
+		ath12k_telemetry_update_msdu_drop(telemetry_peer_ctx, tid, hostq_id,
+						  tx_stats->tx_success.num_pkts,
+						  tx_stats->tx_failed,
+						  tx_stats->dropped.age_out);
+
 latency_stats_update:
 
 	tx_delay_stats = &sawf_stats->tx_delay_stats[tid][q_id];
@@ -1555,6 +1602,11 @@ latency_stats_update:
 		sw_delay = (u32) (enqueue_timestamp - entry_ts);
 	tx_delay_stats->swdelay_win_total += sw_delay;
 
+	ath12k_telemetry_get_sla_mov_avg_num_pkt(&pkt_win);
+
+	if (!pkt_win)
+		pkt_win = ATH12K_MOV_AVG_PKT_WIN;
+
 	if (!(tx_delay_stats->num_pkt % pkt_win)) {
 		tx_delay_stats->nwdelay_avg = div_u64(tx_delay_stats->nwdelay_win_total,
 					  pkt_win);
@@ -1563,6 +1615,12 @@ latency_stats_update:
 		tx_delay_stats->hwdelay_avg = div_u64(tx_delay_stats->hwdelay_win_total,
 					  pkt_win);
 
+		if (telemetry_peer_ctx)
+			ath12k_telemetry_update_delay_mvng(telemetry_peer_ctx,
+							   tid, hostq_id,
+							   tx_delay_stats->nwdelay_avg,
+							   tx_delay_stats->swdelay_avg,
+							   tx_delay_stats->hwdelay_avg);
 		tx_delay_stats->nwdelay_win_total = 0;
 		tx_delay_stats->swdelay_win_total = 0;
 		tx_delay_stats->hwdelay_win_total = 0;
@@ -1577,6 +1635,12 @@ latency_stats_update:
 			tx_delay_stats->failure++;
 		else
 			tx_delay_stats->success++;
+
+		if (!(tx_delay_stats->num_pkt % num_pkts) && telemetry_peer_ctx)
+			ath12k_telemetry_update_delay(telemetry_peer_ctx,
+						      tid, hostq_id,
+						      tx_delay_stats->success,
+						      tx_delay_stats->failure);
 	}
 	return;
 }
@@ -1646,19 +1710,21 @@ static void ath12k_copy_tx_stats(struct
 	dst->tx_failed = src->tx_failed;
 	dst->queue_depth = src->queue_depth;
 
-	dst->throughput = src->throughput = 0;
-	dst->ingress_rate = src->ingress_rate = 0;
+	dst->throughput = src->throughput;
+	dst->ingress_rate = src->ingress_rate;
 }
 
 static int ath12k_telemetry_get_txstats(struct telemetry_sawftx_stats *tx_stats,
 					struct ath12k_base *ab,
 					u8 *peer_mac, u8 svc_id)
 {
-	struct ath12k_sawf_stats *sawf_stats;
+	struct ath12k_sawf_stats *sawf_stats = NULL;
 	struct sawf_tx_stats *stats;
 	struct telemetry_sawf_tx_stat *tx;
 	struct ath12k_peer *peer = NULL;
+	struct ath12k_sawf_peer_ctx *peer_ctx = NULL;
 	int ret = 0;
+	u32 throughput = 0, ingress_rate = 0, msduq = 0;
 	u8 sawf_max_user_queues;
 
 	sawf_max_user_queues = sawf_ctx->max_msduq_per_tid - sawf_ctx->default_msduq_per_tid;
@@ -1669,6 +1735,12 @@ static int ath12k_telemetry_get_txstats(
 		goto end_stats;
 	}
 
+	peer_ctx = &peer->sawf_ctx_peer;
+	if (!peer_ctx) {
+		ret = -ENODATA;
+		goto end_stats;
+	}
+
 	sawf_stats = &peer->sawf_stats;
 	if(!sawf_stats) {
 		ret = -ENODATA;
@@ -1681,6 +1753,17 @@ static int ath12k_telemetry_get_txstats(
 			for (q_idx = 0; q_idx < sawf_max_user_queues; q_idx++) {
 				stats = &sawf_stats->tx_stats[tid][q_idx];
 				tx = &tx_stats->tx[tid][q_idx];
+				if (peer_ctx->telemetry_peer_ctx) {
+					msduq = u16_encode_bits(q_idx, MSDUQID_Q_MASK) |
+						u16_encode_bits(tid, MSDUQID_TID_MASK);
+					ath12k_telemetry_get_rate(peer_ctx->telemetry_peer_ctx,
+								  tid, msduq,
+								  &throughput,
+								  &ingress_rate);
+					msduq = 0;
+				}
+				stats->throughput = throughput;
+				stats->ingress_rate = ingress_rate;
 				ath12k_copy_tx_stats(stats, tx);
 			}
 		}
@@ -1692,6 +1775,14 @@ static int ath12k_telemetry_get_txstats(
 		}
 		stats = &sawf_stats->tx_stats[tid][q_id];
 		tx = &tx_stats->tx[0][0];
+		if (peer_ctx->telemetry_peer_ctx) {
+			msduq = u16_encode_bits(q_id, MSDUQID_Q_MASK) |
+				u16_encode_bits(tid, MSDUQID_TID_MASK);
+			ath12k_telemetry_get_rate(peer_ctx->telemetry_peer_ctx, tid, msduq,
+						  &throughput, &ingress_rate);
+		}
+		stats->throughput = throughput;
+		stats->ingress_rate = ingress_rate;
 		ath12k_copy_tx_stats(stats, tx);
 		tx_stats->tid = tid;
 		tx_stats->msduq = q_id;
@@ -1715,9 +1806,9 @@ static void ath12k_copy_delay_stats(stru
 	dst_hist_stats->max = src_hist_stats->max;
 	dst_hist_stats->avg = src_hist_stats->avg;
 
-	dst->nwdelay_avg = src->nwdelay_avg = 0;
-	dst->swdelay_avg = src->swdelay_avg = 0;
-	dst->hwdelay_avg = src->hwdelay_avg = 0;
+	dst->nwdelay_avg = src->nwdelay_avg;
+	dst->swdelay_avg = src->swdelay_avg;
+	dst->hwdelay_avg = src->hwdelay_avg;
 	dst->delay_bound_success = src->success;
 	dst->delay_bound_failure = src->failure;
 }
@@ -1730,7 +1821,9 @@ static int ath12k_telemetry_get_delaysta
 	struct sawf_tx_delay_stats *stats;
 	struct telemetry_sawf_delay_stat *delay;
 	struct ath12k_peer *peer;
+	struct ath12k_sawf_peer_ctx *peer_ctx = NULL;
 	int ret = 0;
+	u32 nwdelay_avg = 0, swdelay_avg = 0, hwdelay_avg = 0, msduq = 0;
 	u8 sawf_max_user_queues;
 
 	sawf_max_user_queues = sawf_ctx->max_msduq_per_tid - sawf_ctx->default_msduq_per_tid;
@@ -1747,12 +1840,29 @@ static int ath12k_telemetry_get_delaysta
 		goto end_stats;
 	}
 
+	peer_ctx = &peer->sawf_ctx_peer;
+	if (!peer_ctx) {
+		ret = -ENODATA;
+		goto end_stats;
+	}
+
 	if (svc_id == 0) {
 		int tid, q_idx;
 		for (tid = 0; tid < ATH12K_SAWF_MAX_TID_SUPPORT; tid++) {
 			for (q_idx = 0; q_idx < sawf_max_user_queues; q_idx++) {
 				stats = &sawf_stats->tx_delay_stats[tid][q_idx];
 				delay = &delay_stats->delay[tid][q_idx];
+				if (peer_ctx->telemetry_peer_ctx) {
+					msduq = u16_encode_bits(q_idx, MSDUQID_Q_MASK) |
+						u16_encode_bits(tid, MSDUQID_TID_MASK);
+					ath12k_telemetry_get_mov_avg(peer_ctx->telemetry_peer_ctx,
+								     tid, msduq, &nwdelay_avg,
+								     &swdelay_avg, &hwdelay_avg);
+					msduq = 0;
+				}
+				stats->nwdelay_avg = nwdelay_avg;
+				stats->swdelay_avg = swdelay_avg;
+				stats->hwdelay_avg = hwdelay_avg;
 				ath12k_copy_delay_stats(stats, delay);
 			}
 		}
@@ -1766,6 +1876,16 @@ static int ath12k_telemetry_get_delaysta
 
 		stats = &sawf_stats->tx_delay_stats[tid][q_id];
 		delay = &delay_stats->delay[0][0];
+		if (peer_ctx->telemetry_peer_ctx) {
+			msduq = u16_encode_bits(q_id, MSDUQID_Q_MASK) |
+				u16_encode_bits(tid, MSDUQID_TID_MASK);
+			ath12k_telemetry_get_mov_avg(peer_ctx->telemetry_peer_ctx,
+						     tid, msduq, &nwdelay_avg,
+						     &swdelay_avg, &hwdelay_avg);
+		}
+		stats->nwdelay_avg = nwdelay_avg;
+		stats->swdelay_avg = swdelay_avg;
+		stats->hwdelay_avg = hwdelay_avg;
 		ath12k_copy_delay_stats(stats, delay);
 		delay_stats->tid = tid;
 		delay_stats->msduq = q_id;
@@ -1812,3 +1932,215 @@ int telemetry_extract_data(struct stats_
 
 	return ret;
 }
+
+int ath12k_telemetry_sla_reset_stats(u8 svc_id, u8 *peer_mac, u8 *mld_mac_addr,
+				     u8 set_clear)
+{
+	return ath12k_telemetry_reset_peer_stats(peer_mac);
+}
+
+int ath12k_telemetry_get_sawf_tx_stats_tput(void *ptr, void *stats, u64 *in_bytes,
+					    u64 *in_cnt, u64 *tx_bytes,
+					    u64 *tx_cnt, u8 tid_v, u8 msduq_id)
+{
+	struct ath12k_base *ab = (struct ath12k_base *)ptr;
+	struct ath12k_sawf_stats *sawf_stats = (struct ath12k_sawf_stats *)stats;
+	struct sawf_tx_stats *tx_stats = NULL;
+	int ret = 0;
+	u8 tid, q_id, sawf_max_q_per_tid;
+
+	if (!ab || !sawf_stats)
+		return -ENODATA;
+
+	spin_lock_bh(&ab->base_lock);
+
+	tid = u8_get_bits(msduq_id, MSDUQID_TID_MASK);
+	q_id = u8_get_bits(msduq_id, MSDUQID_Q_MASK);
+
+	sawf_max_q_per_tid = ab->max_msduq_per_tid - ab->default_msduq_per_tid;
+
+	if (q_id > sawf_max_q_per_tid) {
+		ret = -EINVAL;
+		goto end;
+	}
+
+	tx_stats = &sawf_stats->tx_stats[tid][q_id];
+	if (!tx_stats) {
+		ret = -ENOENT;
+		goto end;
+	}
+
+	*in_bytes = tx_stats->tx_ingress.bytes;
+	*in_cnt = tx_stats->tx_ingress.num_pkts;
+	*tx_bytes = tx_stats->tx_success.bytes;
+	*tx_cnt = tx_stats->tx_success.num_pkts;
+end:
+	spin_unlock_bh(&ab->base_lock);
+	return ret;
+}
+
+int ath12k_telemetry_get_sawf_tx_stats_mpdu(void *ptr, void *stats, u64 *svc_int_pass,
+					    u64 *svc_int_fail, u64 *burst_pass,
+					    u64 *burst_fail, u8 tid_v, u8 msduq_id)
+{
+	struct ath12k_base *ab = (struct ath12k_base *)ptr;
+	struct ath12k_sawf_stats *sawf_stats = (struct ath12k_sawf_stats *)stats;
+	struct sawf_tx_stats *tx_stats = NULL;
+	int ret = 0;
+	u8 tid, q_id, sawf_max_q_per_tid;
+
+	if (!ab || !sawf_stats)
+		return -ENODATA;
+
+	spin_lock_bh(&ab->base_lock);
+
+	tid = u8_get_bits(msduq_id, MSDUQID_TID_MASK);
+	q_id = u8_get_bits(msduq_id, MSDUQID_Q_MASK);
+
+	sawf_max_q_per_tid = ab->max_msduq_per_tid - ab->default_msduq_per_tid;
+
+	if (q_id > sawf_max_q_per_tid) {
+		ret = -EINVAL;
+		goto end;
+	}
+
+	tx_stats = &sawf_stats->tx_stats[tid][q_id];
+	if (!tx_stats) {
+		ret = -ENOENT;
+		goto end;
+	}
+
+	*svc_int_pass = tx_stats->svc_intval_stats.success_cnt;
+	*svc_int_fail = tx_stats->svc_intval_stats.failure_cnt;
+	*burst_pass = tx_stats->burst_size_stats.success_cnt;
+	*burst_fail = tx_stats->burst_size_stats.failure_cnt;
+end:
+	spin_unlock_bh(&ab->base_lock);
+	return ret;
+}
+
+int ath12k_telemetry_get_sawf_tx_stats_drop(void *ptr, void *stats, u64 *pass,
+					    u64 *drop, u64 *drop_ttl,
+					    u8 tid_v, u8 msduq_id)
+{
+	struct ath12k_base *ab = (struct ath12k_base *)ptr;
+	struct ath12k_sawf_stats *sawf_stats = (struct ath12k_sawf_stats *)stats;
+	struct sawf_tx_stats *tx_stats = NULL;
+	int ret = 0;
+	u8 tid, q_id, sawf_max_q_per_tid;
+
+	if (!ab || !sawf_stats)
+		return -ENODATA;
+
+	spin_lock_bh(&ab->base_lock);
+
+	tid = u8_get_bits(msduq_id, MSDUQID_TID_MASK);
+	q_id = u8_get_bits(msduq_id, MSDUQID_Q_MASK);
+
+	sawf_max_q_per_tid = ab->max_msduq_per_tid - ab->default_msduq_per_tid;
+
+	if (q_id > sawf_max_q_per_tid) {
+		ret = -EINVAL;
+		goto end;
+	}
+
+	tx_stats = &sawf_stats->tx_stats[tid][q_id];
+	if (!tx_stats) {
+		ret = -ENOENT;
+		goto end;
+	}
+
+	*pass = tx_stats->tx_success.num_pkts;
+	*drop = tx_stats->tx_failed;
+	*drop_ttl = tx_stats->dropped.age_out;
+end:
+	spin_unlock_bh(&ab->base_lock);
+	return ret;
+}
+
+void ath12k_send_breach_indication(struct work_struct *work)
+{
+	struct ath12k_telemetry_ctx *telemetry_ctx = container_of(work, struct ath12k_telemetry_ctx, indicate_breach);
+	struct ath12k_tele_breach_params *breach_params, *tmp;
+
+	if (!telemetry_ctx) {
+		ath12k_err(NULL, "Telemetry ctx is unavailable\n");
+		return;
+	}
+
+	spin_lock_bh(&telemetry_ctx->breach_ind_lock);
+	list_for_each_entry_safe(breach_params, tmp, &telemetry_ctx->list, list) {
+		list_del(&breach_params->list);
+		spin_unlock_bh(&telemetry_ctx->breach_ind_lock);
+		ath12k_telemetry_notify_breach(breach_params->mac_addr,
+					       breach_params->svc_id,
+					       breach_params->param,
+					       breach_params->set_clear,
+					       breach_params->tid);
+		kfree(breach_params);
+		spin_lock_bh(&telemetry_ctx->breach_ind_lock);
+	}
+	spin_unlock_bh(&telemetry_ctx->breach_ind_lock);
+	return;
+}
+
+void ath12k_telemetry_breach_indication(u8 *mac_addr, u8 svc_id, u8 param, bool set_clear, u8 tid)
+{
+	struct ath12k_tele_breach_params *breach_params;
+	struct ath12k_telemetry_ctx *telemetry_ctx = NULL;
+
+	if (!mac_addr)
+		return;
+
+	telemetry_ctx = get_telemetry_context();
+	if (!telemetry_ctx) {
+		ath12k_err(NULL, "Breach detection received when telemetry ctx is unavailable\n");
+		return;
+	}
+
+	breach_params = kzalloc(sizeof(*breach_params), GFP_NOWAIT);
+	if (!breach_params) {
+		ath12k_err(NULL, "Failed to allocate memory to indicate breach detection\n");
+		return;
+	}
+
+	ether_addr_copy(breach_params->mac_addr, mac_addr);
+	breach_params->svc_id = svc_id;
+	breach_params->param = param;
+	breach_params->set_clear = set_clear;
+	breach_params->tid = tid;
+
+	spin_lock_bh(&telemetry_ctx->breach_ind_lock);
+	list_add_tail(&breach_params->list, &telemetry_ctx->list);
+	spin_unlock_bh(&telemetry_ctx->breach_ind_lock);
+
+	queue_work(telemetry_ctx->workqueue, &telemetry_ctx->indicate_breach);
+}
+
+void ath12k_telemetry_notify_breach(u8 *mac_addr, u8 svc_id, u8 param,
+				    bool set_clear, u8 tid)
+{
+	struct ieee80211_vif *vif = NULL;
+	struct ath12k_base *ab = NULL;
+	struct ath12k_peer *peer = NULL;
+	u8 *mld_addr = NULL;
+
+	if (!mac_addr)
+		return;
+
+	peer = (struct ath12k_peer *)ath12k_get_ab_nd_peer_from_peer_mac(mac_addr, &ab);
+	if (peer && ab) {
+		spin_lock_bh(&ab->base_lock);
+		vif = peer->vif;
+		if (peer->peer_id & ATH12K_ML_PEER_ID_VALID)
+			mld_addr = peer->ml_addr;
+		spin_unlock_bh(&ab->base_lock);
+		ath12k_vendor_telemetry_notify_breach(vif, mac_addr, svc_id, param,
+						      set_clear, tid, mld_addr);
+	} else {
+		ath12k_dbg(NULL, ATH12K_DBG_SAWF, "Peer(%pM) not found for notifying breach",
+			   mac_addr);
+	}
+
+	return;
+}
--- a/drivers/net/wireless/ath/ath12k/telemetry.c
+++ b/drivers/net/wireless/ath/ath12k/telemetry.c
@@ -9,7 +9,8 @@
 #include "vendor.h"
 #include "telemetry.h"
 #include <linux/module.h>
-
+#include "telemetry_agent_if.h"
+#include "telemetry_agent_wifi_driver_if.h"
 
 #define MIN_THERSHOLD_PERCENTAGE 0
 #define MAX_THERSHOLD_PERCENTAGE 100
@@ -29,6 +30,10 @@ void ath12k_telemetry_init(struct ath12k
 		ath12k_err(NULL, "telemetry context failed to initialize\n");
 		return;
 	}
+	spin_lock_init(&telemetry_ctx->breach_ind_lock);
+	telemetry_ctx->workqueue = create_singlethread_workqueue("breach_ind_wq");
+	INIT_WORK(&telemetry_ctx->indicate_breach, ath12k_send_breach_indication);
+	INIT_LIST_HEAD(&telemetry_ctx->list);
 	ath12k_info(NULL, "telemetry context initialized\n");
 	return;
 }
@@ -41,6 +46,14 @@ void ath12k_telemetry_deinit(struct ath1
 	if (!telemetry_ctx)
 		return;
 
+	if (test_bit(ATH12K_FLAG_CRASH_FLUSH, &ab->dev_flags)) {
+		cancel_work_sync(&telemetry_ctx->indicate_breach);
+		return;
+	}
+
+	cancel_work_sync(&telemetry_ctx->indicate_breach);
+	destroy_workqueue(telemetry_ctx->workqueue);
+
 	kfree(telemetry_ctx);
 	telemetry_ctx = NULL;
 	ath12k_info(NULL, "telemetry context freed\n");
@@ -73,6 +86,12 @@ int ath12k_telemetry_sawf_sla_samples_co
 	telemetry_param->sla_num_pkt = param.sla_num_pkt;
 	telemetry_param->sla_time_sec = param.sla_time_sec;
 
+	ath12k_telemetry_set_mov_avg_params(telemetry_param->moving_avg_pkt,
+					    telemetry_param->moving_avg_win);
+
+	ath12k_telemetry_set_sla_params(telemetry_param->sla_num_pkt,
+					telemetry_param->sla_time_sec);
+
 	ath12k_info(NULL, "telemetry sla samples configuration done, "
 		    "movavgpkt:%d movavgwin:%d slanumpkt:%d slatimesec:%d \n",
 		    telemetry_param->moving_avg_pkt,telemetry_param->moving_avg_win,
@@ -114,6 +133,15 @@ int ath12k_telemetry_sawf_sla_thershold_
 	sla_thershold_param->msdu_ttl = param.msdu_ttl;
 	sla_thershold_param->msdu_rate_loss = param.msdu_rate_loss;
 
+	ath12k_telemetry_set_sla_cfg(sla_thershold_param->svc_id,
+				     sla_thershold_param->min_throughput_rate,
+				     sla_thershold_param->max_throughput_rate,
+				     sla_thershold_param->burst_size,
+				     sla_thershold_param->service_interval,
+				     sla_thershold_param->delay_bound,
+				     sla_thershold_param->msdu_ttl,
+				     sla_thershold_param->msdu_rate_loss);
+
 	ath12k_info(NULL, "telemetry sla thershold configuration done, "
 		    "svcid: %d MinThrRate:%d MaxThrRate:%d BurstSize:%d "
 		    "serviceInt:%d \n DelayBound: %d MsduTtl:%d "
@@ -172,6 +200,15 @@ int ath12k_telemetry_sawf_sla_detection_
 	telemetry_param->msdu_ttl = param.msdu_ttl;
 	telemetry_param->msdu_rate_loss = param.msdu_rate_loss;
 
+	ath12k_telemetry_set_sla_detect_cfg(telemetry_param->sla_detect,
+					    telemetry_param->min_throughput_rate,
+					    telemetry_param->max_throughput_rate,
+					    telemetry_param->burst_size,
+					    telemetry_param->service_interval,
+					    telemetry_param->delay_bound,
+					    telemetry_param->msdu_ttl,
+					    telemetry_param->msdu_rate_loss);
+
 	ath12k_info(NULL, "telemetry sla detection configuration done, detect option: %d "
 		   "MinThrRate:%d MaxThrRate:%d BurstSize:%d ServiceInt:%d \n DelayBound: %d "
 		   "MsduTtl:%d MsduRateLoss:%d \n", telemetry_param->sla_detect,
@@ -182,3 +219,25 @@ int ath12k_telemetry_sawf_sla_detection_
 
 	return ret;
 }
+
+bool ath12k_telemetry_get_sla_mov_avg_num_pkt(u32 *mov_avg)
+{
+	if (!telemetry_ctx) {
+		mov_avg = 1;
+		return false;
+	}
+
+	*mov_avg = telemetry_ctx->sla_samples_params.moving_avg_pkt;
+	return true;
+}
+
+bool ath12k_telemetry_get_sla_num_pkts(u32 *pkt_num)
+{
+	if (!telemetry_ctx) {
+		pkt_num = 1;
+		return false;
+	}
+
+	*pkt_num = telemetry_ctx->sla_samples_params.sla_num_pkt;
+	return true;
+}
--- /dev/null
+++ b/drivers/net/wireless/ath/ath12k/telemetry_agent_if.c
@@ -0,0 +1,348 @@
+// SPDX-License-Identifier: BSD-3-Clause-Clear
+/*
+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#include "core.h"
+#include "debug.h"
+#include "sawf.h"
+#include <linux/export.h>
+#include "telemetry.h"
+#include "telemetry_agent_if.h"
+#include "telemetry_agent_wifi_driver_if.h"
+#include <linux/module.h>
+
+int ath12k_get_pdev_stats(void *obj, struct agent_link_iface_stats_obj *stats);
+int ath12k_get_peer_info(void *obj, struct agent_peer_iface_init_obj *stats);
+int ath12k_get_pdev_info(void *obj, struct agent_pdev_iface_init_obj *stats);
+int ath12k_get_peer_stats(void *obj, struct agent_peer_iface_stats_obj *stats);
+int ath12k_get_psoc_info(void *obj, struct agent_psoc_iface_init_obj *stats);
+
+struct telemetry_agent_ops *g_agent_ops;
+EXPORT_SYMBOL(g_agent_ops);
+
+int register_telemetry_agent_ops(struct telemetry_agent_ops *agent_ops);
+int unregister_telemetry_agent_ops(struct telemetry_agent_ops *agent_ops);
+
+int register_telemetry_agent_ops(struct telemetry_agent_ops *agent_ops)
+{
+	g_agent_ops = agent_ops;
+	g_agent_ops->agent_get_psoc_info = ath12k_get_psoc_info;
+	g_agent_ops->agent_get_pdev_info = ath12k_get_pdev_info;
+	g_agent_ops->agent_get_peer_info = ath12k_get_peer_info;
+	g_agent_ops->agent_get_pdev_stats = ath12k_get_pdev_stats;
+	g_agent_ops->agent_get_peer_stats = ath12k_get_peer_stats;
+	g_agent_ops->agent_get_emesh_pdev_stats = NULL;
+	g_agent_ops->agent_get_emesh_peer_stats = NULL;
+
+	/* SAWF ops */
+	g_agent_ops->sawf_get_tput_stats = ath12k_sawf_get_tput_stats;
+	g_agent_ops->sawf_get_mpdu_stats = ath12k_sawf_get_mpdu_stats;
+	g_agent_ops->sawf_get_drop_stats = ath12k_sawf_get_drop_stats;
+	g_agent_ops->sawf_notify_breach = ath12k_sawf_notify_breach;
+
+	ath12k_info(NULL, "registered telemetry agent ops: %p", g_agent_ops);
+	return 0;
+}
+EXPORT_SYMBOL(register_telemetry_agent_ops);
+
+int unregister_telemetry_agent_ops(struct telemetry_agent_ops *agent_ops)
+{
+	g_agent_ops = NULL;
+	ath12k_info(NULL, "unregistered telemetry agent ops: %p", g_agent_ops);
+	return 0;
+}
+EXPORT_SYMBOL(unregister_telemetry_agent_ops);
+
+u32 ath12k_telemetry_agent_init(void)
+{
+	int status = 0;
+	/* TODO */
+	ath12k_info(NULL, "telemetry agent init Done\n");
+	return status;
+}
+
+u32 ath12k_telemetry_agent_deinit(void)
+{
+	int status = 0;
+	/* TODO */
+	ath12k_info(NULL, "telemetry agent deinit\n");
+	return status;
+}
+
+int ath12k_get_pdev_stats(void *obj, struct agent_link_iface_stats_obj *stats)
+{
+	ath12k_warn(NULL, "ath12k_get_pdev_stats - not implemented \n");
+	return -1;
+}
+
+int ath12k_get_peer_info(void *obj, struct agent_peer_iface_init_obj *stats)
+{
+	ath12k_warn(NULL, "ath12k_get_peer_info - not implemented \n");
+	return -1;
+}
+
+int ath12k_get_pdev_info(void *obj, struct agent_pdev_iface_init_obj *stats)
+{
+	ath12k_warn(NULL, "ath12k_get_pdev_info - not implemented \n");
+	return -1;
+}
+
+int ath12k_get_peer_stats(void *obj, struct agent_peer_iface_stats_obj *stats)
+{
+	ath12k_warn(NULL, "ath12k_get_peer_stats - not implemented \n");
+	return -1;
+}
+
+int ath12k_get_psoc_info(void *obj, struct agent_psoc_iface_init_obj *stats)
+{
+	ath12k_warn(NULL, "ath12k_get_peer_stats - not implemented \n");
+	return -1;
+}
+
+void *ath12k_telemetry_peer_ctx_alloc(void *peer, void *sawf_stats,
+				      u8 *mac_addr,
+				      u8 svc_id, u8 hostq_id)
+{
+	if (g_agent_ops)
+		return g_agent_ops->sawf_alloc_peer(peer, sawf_stats,
+						    mac_addr,
+						    svc_id,
+						    hostq_id);
+	return NULL;
+}
+
+void ath12k_telemetry_peer_ctx_free(void *telemetry_peer_ctx)
+{
+	if (g_agent_ops)
+		g_agent_ops->sawf_free_peer(telemetry_peer_ctx);
+}
+
+bool ath12k_telemetry_update_tid_msduq(void *telemetry_peer_ctx,
+				       u8 hostq_id, u8 tid, u8 msduq_idx)
+{
+	if (g_agent_ops) {
+		if (g_agent_ops->sawf_updt_queue_info(telemetry_peer_ctx,
+						      hostq_id, tid,
+						      msduq_idx))
+			return false;
+	}
+
+	return true;
+}
+
+bool ath12k_telemetry_set_mov_avg_params(u32 num_pkt,
+					 u32 num_win)
+{
+	if (g_agent_ops) {
+		if (g_agent_ops->sawf_updt_delay_mvng(num_pkt, num_win))
+			return false;
+	}
+
+	return true;
+}
+
+bool ath12k_telemetry_set_sla_params(u32 num_pkt,
+				     u32 time_sec)
+{
+	if (g_agent_ops) {
+		if (g_agent_ops->sawf_updt_sla_params(num_pkt, time_sec))
+			return false;
+	}
+
+	return true;
+}
+
+bool ath12k_telemetry_set_sla_cfg(u8 svc_id,
+				  u8 min_tput_rate,
+				  u8 max_tput_rate,
+				  u8 burst_size,
+				  u8 svc_interval,
+				  u8 delay_bound,
+				  u8 msdu_ttl,
+				  u8 msdu_rate_loss)
+{
+	if (g_agent_ops) {
+		if (g_agent_ops->sawf_set_sla_cfg(svc_id,
+					          min_tput_rate,
+						  max_tput_rate,
+						  burst_size,
+						  svc_interval,
+						  delay_bound,
+						  msdu_ttl,
+						  msdu_rate_loss))
+			return false;
+	}
+
+	return true;
+}
+
+bool ath12k_telemetry_set_svclass_cfg(bool enable, u8 svc_id,
+				      u32 min_tput_rate,
+				      u32 max_tput_rate,
+				      u32 burst_size,
+				      u32 svc_interval,
+				      u32 delay_bound,
+				      u32 msdu_ttl,
+				      u32 msdu_rate_loss)
+{
+	if (g_agent_ops) {
+		if (g_agent_ops->sawf_set_svclass_cfg(enable, svc_id,
+						      min_tput_rate,
+						      max_tput_rate,
+						      burst_size,
+						      svc_interval,
+						      delay_bound,
+						      msdu_ttl,
+				                      msdu_rate_loss))
+			return false;
+	}
+
+	return true;
+}
+
+bool ath12k_telemetry_set_sla_detect_cfg(u8 detect_type,
+					 u8 min_tput_rate,
+					 u8 max_tput_rate,
+					 u8 burst_size,
+					 u8 svc_interval,
+					 u8 delay_bound,
+					 u8 msdu_ttl,
+					 u8 msdu_rate_loss)
+{
+	if (g_agent_ops) {
+		if (g_agent_ops->sawf_set_sla_dtct_cfg(detect_type,
+						       min_tput_rate,
+						       max_tput_rate,
+						       burst_size,
+						       svc_interval,
+						       delay_bound,
+						       msdu_ttl,
+						       msdu_rate_loss))
+			return false;
+	}
+
+	return true;
+}
+
+bool ath12k_telemetry_update_delay(void *telemetry_ctx, u8 tid,
+				   u8 queue, u64 pass,
+				   u64 fail)
+{
+	if (g_agent_ops) {
+		if (g_agent_ops->sawf_push_delay(telemetry_ctx, tid,
+						 queue, pass, fail))
+			return false;
+	}
+
+	return true;
+}
+
+bool ath12k_telemetry_update_delay_mvng(void *telemetry_ctx,
+					u8 tid, u8 queue,
+					u64 nwdelay_winavg,
+					u64 swdelay_winavg,
+					u64 hwdelay_winavg)
+{
+	if (g_agent_ops) {
+		if (g_agent_ops->sawf_push_delay_mvng(telemetry_ctx,
+						      tid, queue,
+						      nwdelay_winavg,
+						      swdelay_winavg,
+						      hwdelay_winavg))
+			return false;
+	}
+
+	return true;
+}
+
+bool ath12k_telemetry_update_msdu_drop(void *telemetry_ctx,
+				       u8 tid, u8 queue,
+				       u64 success,
+				       u64 failure_drop,
+				       u64 failure_ttl)
+{
+	if (g_agent_ops) {
+		if (g_agent_ops->sawf_push_msdu_drop(telemetry_ctx, tid,
+						  queue, success,
+						  failure_drop,
+						  failure_ttl))
+			return false;
+	}
+
+	return true;
+}
+
+bool ath12k_telemetry_get_rate(void *telemetry_ctx, u8 tid,
+			       u8 queue, u32 *egress_rate,
+			       u32 *ingress_rate)
+{
+	if (g_agent_ops) {
+		if (g_agent_ops->sawf_pull_rate(telemetry_ctx, tid, queue,
+						egress_rate, ingress_rate))
+			return false;
+	}
+
+	return true;
+}
+
+bool ath12k_telemetry_get_mov_avg(void *telemetry_ctx, u8 tid,
+				  u8 queue, u32 *nwdelay_avg,
+				  u32 *swdelay_avg,
+				  u32 *hwdelay_avg)
+{
+	if (g_agent_ops) {
+		if (g_agent_ops->sawf_pull_mov_avg(telemetry_ctx, tid,
+						   queue, nwdelay_avg,
+						   swdelay_avg, hwdelay_avg))
+			return false;
+	}
+
+	return true;
+}
+
+int ath12k_telemetry_reset_peer_stats(u8 *peer_mac)
+{
+	int ret = -EOPNOTSUPP;
+
+	if (g_agent_ops)
+		ret = g_agent_ops->sawf_reset_peer_stats(peer_mac);
+
+	return ret;
+}
+
+int ath12k_sawf_get_tput_stats(void *soc, void *arg, u64 *in_bytes,
+			       u64 *in_cnt, u64 *tx_bytes,
+			       u64 *tx_cnt, u8 tid, u8 msduq)
+{
+	return ath12k_telemetry_get_sawf_tx_stats_tput(soc, arg,
+						       in_bytes, in_cnt,
+						       tx_bytes, tx_cnt,
+						       tid, msduq);
+}
+
+int ath12k_sawf_get_mpdu_stats(void *soc, void *arg, u64 *svc_int_pass,
+			       u64 *svc_int_fail, u64 *burst_pass,
+			       u64 *burst_fail, u8 tid, u8 msduq)
+{
+	return ath12k_telemetry_get_sawf_tx_stats_mpdu(soc, arg, svc_int_pass,
+						       svc_int_fail, burst_pass,
+						       burst_fail, tid, msduq);
+}
+
+int ath12k_sawf_get_drop_stats(void *soc, void *arg, u64 *pass,
+			       u64 *drop, u64 *drop_ttl,
+			       u8 tid, u8 msduq)
+{
+	return ath12k_telemetry_get_sawf_tx_stats_drop(soc, arg, pass, drop,
+						       drop_ttl, tid, msduq);
+}
+
+void ath12k_sawf_notify_breach(u8 *mac_addr,
+			       u8 svc_id,
+			       u8 param,
+			       bool set_clear,
+			       u8 tid)
+{
+	ath12k_telemetry_breach_indication(mac_addr, svc_id, param, set_clear, tid);
+}
--- /dev/null
+++ b/drivers/net/wireless/ath/ath12k/telemetry_agent_if.h
@@ -0,0 +1,67 @@
+// SPDX-License-Identifier: BSD-3-Clause-Clear
+/*
+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef ATH12K_TELEMETRY_AGENT_IF_H
+#define ATH12K_TELEMETRY_AGENT_IF_H
+
+u32 ath12k_telemetry_agent_init(void);
+u32 ath12k_telemetry_agent_deinit(void);
+
+int ath12k_sawf_get_tput_stats(void *soc, void *arg, u64 *in_bytes,
+			       u64 *in_cnt, u64 *tx_bytes,
+			       u64 *tx_cnt, u8 tid, u8 msduq);
+int ath12k_sawf_get_mpdu_stats(void *soc, void *arg, u64 *svc_int_pass,
+			       u64 *svc_int_fail, u64 *burst_pass,
+			       u64 *burst_fail, u8 tid, u8 msduq);
+int ath12k_sawf_get_drop_stats(void *soc, void *arg, u64 *pass,
+			       u64 *drop, u64 *drop_ttl,
+			       u8 tid, u8 msduq);
+void ath12k_sawf_notify_breach(u8 *mac_addr, u8 svc_id, u8 param,
+			       bool set_clear, u8 tid);
+void *ath12k_telemetry_peer_ctx_alloc(void *peer, void *sawf_stats,
+				      u8 *mac_addr,
+				      u8 svc_id, u8 hostq_id);
+void ath12k_telemetry_peer_ctx_free(void *telemetry_peer_ctx);
+bool ath12k_telemetry_update_tid_msduq(void *telemetry_peer_ctx,
+				       u8 hostq_id, u8 tid, u8 msduq_idx);
+bool ath12k_telemetry_set_mov_avg_params(u32 num_pkt, u32 num_win);
+bool ath12k_telemetry_set_sla_params(u32 num_pkt, u32 time_sec);
+bool ath12k_telemetry_set_sla_cfg(u8 svc_id, u8 min_tput_rate, u8 max_tput_rate,
+				  u8 burst_size, u8 svc_interval, u8 delay_bound,
+				  u8 msdu_ttl, u8 msdu_rate_loss);
+bool ath12k_telemetry_set_svclass_cfg(bool enable, u8 svc_id,
+				      u32 min_tput_rate,
+				      u32 max_tput_rate,
+				      u32 burst_size,
+				      u32 svc_interval,
+				      u32 delay_bound,
+				      u32 msdu_ttl,
+				      u32 msdu_rate_loss);
+bool ath12k_telemetry_set_sla_detect_cfg(u8 detect_type,
+					 u8 min_tput_rate,
+					 u8 max_tput_rate,
+					 u8 burst_size,
+					 u8 svc_interval,
+					 u8 delay_bound,
+					 u8 msdu_ttl,
+					 u8 msdu_rate_loss);
+bool ath12k_telemetry_update_delay(void *telemetry_ctx, u8 tid,
+				   u8 queue, u64 pass, u64 fail);
+bool ath12k_telemetry_update_delay_mvng(void *telemetry_ctx,
+					u8 tid, u8 queue,
+					u64 nwdelay_winavg,
+					u64 swdelay_winavg,
+					u64 hwdelay_winavg);
+bool ath12k_telemetry_update_msdu_drop(void *telemetry_ctx, u8 tid,
+				       u8 queue, u64 success,
+				       u64 failure_drop,
+				       u64 failure_ttl);
+bool ath12k_telemetry_get_rate(void *telemetry_ctx, u8 tid, u8 queue,
+			       u32 *egress_rate, u32 *ingress_rate);
+bool ath12k_telemetry_get_mov_avg(void *telemetry_ctx, u8 tid, u8 queue,
+				  u32 *nwdelay_avg, u32 *swdelay_avg,
+				  u32 *hwdelay_avg);
+int ath12k_telemetry_reset_peer_stats(u8 *peer_mac);
+#endif /* ATH12K_TELEMETRY_AGENT_IF_H */
--- a/drivers/net/wireless/ath/ath12k/Makefile
+++ b/drivers/net/wireless/ath/ath12k/Makefile
@@ -31,7 +31,7 @@ ath12k-$(CPTCFG_ATH12K_PKTLOG) += pktlog
 ath12k-$(CPTCFG_ATH12K_AHB) += ahb.o
 ath12k-$(CPTCFG_ATH12K_PPE_DS_SUPPORT) += ppe.o
 ath12k-$(CPTCFG_ATH12K_BONDED_DS_SUPPORT) += bondif.o
-ath12k-$(CPTCFG_ATH12K_SAWF) += sawf.o telemetry.o
+ath12k-$(CPTCFG_ATH12K_SAWF) += sawf.o telemetry.o telemetry_agent_if.o
 
 # for tracing framework to find trace.h
 CFLAGS_trace.o := -I$(src)
--- a/drivers/net/wireless/ath/ath12k/core.c
+++ b/drivers/net/wireless/ath/ath12k/core.c
@@ -21,6 +21,7 @@
 #include "ppe.h"
 #include "ahb.h"
 #include "telemetry.h"
+#include "peer.h"
 
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 #include <linux/rtnetlink.h>
@@ -2617,6 +2618,43 @@ int ath12k_core_sawf_ul_config(struct ne
 	return ret;
 }
 
+void *ath12k_get_ab_nd_peer_from_peer_mac(u8 *peer_mac, struct ath12k_base **ab_ref)
+{
+	struct ath12k_hw_group *ag = NULL;
+	struct ath12k_base *ab = NULL;
+	void *peer = NULL;
+	int soc;
+
+	mutex_lock(&ath12k_hw_lock);
+	list_for_each_entry(ag, &ath12k_hw_groups, list) {
+		if (!ag) {
+			ath12k_warn(NULL, "unable to fetch hw group\n");
+			mutex_unlock(&ath12k_hw_lock);
+			return -ENODEV;
+		}
+		for (soc = ag->num_probed; soc > 0; soc--) {
+
+			ab = ag->ab[soc - 1];
+			if (!ab) {
+				/* Control should not reach here */
+				ath12k_info(NULL, "SOC not initialized\n");
+				continue;
+			}
+			spin_lock_bh(&ab->base_lock);
+			peer = ath12k_peer_find_by_addr(ab, peer_mac);
+			spin_unlock_bh(&ab->base_lock);
+			if (peer) {
+				mutex_unlock(&ath12k_hw_lock);
+				*ab_ref = ab;
+				return peer;
+			}
+			ab = NULL;
+		}
+	}
+	mutex_unlock(&ath12k_hw_lock);
+	return peer;
+}
+
 #endif /* CPTCFG_ATH12K_SAWF */
 
 static int ath12k_init(void)
--- a/drivers/net/wireless/ath/ath12k/core.h
+++ b/drivers/net/wireless/ath/ath12k/core.h
@@ -29,6 +29,7 @@
 #include "pktlog.h"
 #include "sawf.h"
 #include "vendor.h"
+#include "telemetry_agent_if.h"
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 #include <ppe_ds_wlan.h>
 #include <ppe_vp_public.h>
@@ -1568,6 +1569,7 @@ void ath12k_fw_stats_free(struct ath12k_
 int ath12k_send_sawf_configs_soc(struct ath12k_sawf_svc_params *new_param);
 int ath12k_sawf_send_disable_soc(u8 svc_id);
 int ath12k_core_sawf_ul_config(struct net_device *dev, struct ath12k_sawf_wmi_peer_latency_param *latency_info);
+void *ath12k_get_ab_nd_peer_from_peer_mac(u8 *peer_mac, struct ath12k_base **ab_ref);
 #endif /* CPTCFG_ATH12K_SAWF */
 
 static inline const char *ath12k_scan_state_str(enum ath12k_scan_state state)
--- a/drivers/net/wireless/ath/ath12k/dp_rx.c
+++ b/drivers/net/wireless/ath/ath12k/dp_rx.c
@@ -2068,8 +2068,10 @@ static void ath12k_htt_sawf_info_ind_han
 					     struct sk_buff *skb)
 {
 	struct htt_t2h_sawf_info_ind *resp = (struct htt_t2h_sawf_info_ind *)skb->data;
-	u32 htt_qtype, remapped_tid, peer_id;
-	u32 hlos_tid, flow_or, ast_idx, who_cl, tgt_opaque_id;
+	struct ath12k_peer *peer = NULL;
+	u32 htt_qtype, remapped_tid, peer_id, default_msduq_per_tid, default_msduq_max, sawf_msduq_per_tid;
+	u32 hlos_tid, flow_or, ast_idx, who_cl, tgt_opaque_id, sawf_msduq_max;
+	u8 msduq_index;
 
 	htt_qtype = u32_get_bits(__le32_to_cpu(resp->info0),
 				 HTT_T2H_SAWF_MSDUQ_INFO_0_IND_HTT_QTYPE_ID);
@@ -2103,6 +2105,24 @@ static void ath12k_htt_sawf_info_ind_han
 		   flow_or,
 		   ast_idx,
 		   tgt_opaque_id);
+	spin_lock_bh(&ab->base_lock);
+
+	default_msduq_per_tid = ab->default_msduq_per_tid;
+	sawf_msduq_per_tid = ab->max_msduq_per_tid - ab->default_msduq_per_tid;
+	default_msduq_max = default_msduq_per_tid * ATH12K_SAWF_MAX_TID_SUPPORT;
+	sawf_msduq_max = sawf_msduq_per_tid * ATH12K_SAWF_MAX_TID_SUPPORT;
+	msduq_index = ((who_cl * default_msduq_max) +
+		      (flow_or * ATH12K_SAWF_MAX_TID_SUPPORT) + hlos_tid) -
+		      default_msduq_max;
+
+	peer = ath12k_peer_find_by_id(ab, peer_id);
+	if ((msduq_index < sawf_msduq_max) && peer) {
+		if (peer->sawf_ctx_peer.telemetry_peer_ctx)
+			ath12k_telemetry_update_tid_msduq(peer->sawf_ctx_peer.telemetry_peer_ctx,
+							  msduq_index ,remapped_tid,
+							  (htt_qtype - default_msduq_per_tid));
+	}
+	spin_unlock_bh(&ab->base_lock);
 }
 #endif /* CPTCFG_ATH12K_SAWF */
 void ath12k_dp_htt_htc_t2h_msg_handler(struct ath12k_base *ab,
--- a/drivers/net/wireless/ath/ath12k/mac.c
+++ b/drivers/net/wireless/ath/ath12k/mac.c
@@ -1175,6 +1175,10 @@ void ath12k_mac_peer_cleanup_all(struct
 		ath12k_dp_rx_peer_tid_cleanup(ar, peer);
 		ath12k_peer_rhash_delete(ab, peer);
 		list_del(&peer->list);
+#ifdef CPTCFG_ATH12K_SAWF
+	if (peer->sawf_ctx_peer.telemetry_peer_ctx)
+		ath12k_telemetry_peer_ctx_free(peer->sawf_ctx_peer.telemetry_peer_ctx);
+#endif
 		kfree(peer);
 	}
 	spin_unlock_bh(&ab->base_lock);
@@ -6843,6 +6847,10 @@ static void ath12k_mac_station_post_remo
 		ath12k_peer_rhash_delete(ar->ab, peer);
 		peer->sta = NULL;
 		list_del(&peer->list);
+#ifdef CPTCFG_ATH12K_SAWF
+		if (peer->sawf_ctx_peer.telemetry_peer_ctx)
+			ath12k_telemetry_peer_ctx_free(peer->sawf_ctx_peer.telemetry_peer_ctx);
+#endif
 		kfree(peer);
 		ar->num_peers--;
 	}
--- a/drivers/net/wireless/ath/ath12k/peer.c
+++ b/drivers/net/wireless/ath/ath12k/peer.c
@@ -159,6 +159,10 @@ void ath12k_peer_unmap_event(struct ath1
 		   peer->vdev_id, peer->addr, peer_id);
 
 	list_del(&peer->list);
+#ifdef CPTCFG_ATH12K_SAWF
+	if (peer->sawf_ctx_peer.telemetry_peer_ctx)
+		ath12k_telemetry_peer_ctx_free(peer->sawf_ctx_peer.telemetry_peer_ctx);
+#endif
 	kfree(peer);
 	wake_up(&ab->peer_mapping_wq);
 
@@ -361,6 +365,10 @@ void ath12k_peer_cleanup(struct ath12k *
 			    peer->addr, vdev_id);
 		ath12k_peer_rhash_delete(ab, peer);
 		list_del(&peer->list);
+#ifdef CPTCFG_ATH12K_SAWF
+		if (peer->sawf_ctx_peer.telemetry_peer_ctx)
+			ath12k_telemetry_peer_ctx_free(peer->sawf_ctx_peer.telemetry_peer_ctx);
+#endif
 		kfree(peer);
 		ar->num_peers--;
 	}
--- a/drivers/net/wireless/ath/ath12k/sawf.h
+++ b/drivers/net/wireless/ath/ath12k/sawf.h
@@ -231,10 +231,13 @@ struct ath12k_sawf_def_queue_report {
  * The allocation is mapped with the service class ID.
  * @msduq_table: map table of msduq and svc id per peer
  * @def_q_map: default q map report
+ * @telemetry_peer_ctx: pointer to hold the structure reference
+ * maintained in telemetry agent module.
  */
 struct ath12k_sawf_peer_ctx {
 	struct ath12k_msduq_map msduq_table[ATH12K_SAWF_MAX_TID_SUPPORT][MAX_Q_PER_TID];
 	struct ath12k_sawf_def_queue_report def_q_map[ATH12K_SAWF_MAX_TID_SUPPORT];
+	void *telemetry_peer_ctx;
 };
 
 /* MSG_TYPE => HTT_H2T_SAWF_DEF_QUEUES_MAP_REQ
@@ -811,6 +814,15 @@ struct htt_stats_strm_gen_mpdus_details_
 	__le16 burst_size_margin_bytes;
 } __packed;
 
+struct ath12k_tele_breach_params {
+	struct list_head list;
+	u8 mac_addr[ETH_ALEN];
+	u8 svc_id;
+	u8 param;
+	bool set_clear;
+	u8 tid;
+};
+
 extern bool ath12k_sawf_enable;
 struct ath12k_sawf_ctx *ath12k_get_sawf_context(void);
 void ath12k_sawf_init(struct ath12k_base *ab);
@@ -865,6 +877,22 @@ int telemetry_extract_data(struct stats_
 			   struct telemetry_sawftx_stats *tx_stats,
 			   struct telemetry_sawfdelay_stats *delay_stats,
 			   struct ath12k_base *ab);
+int ath12k_telemetry_sla_reset_stats(u8 svc_id, u8 *peer_mac, u8 *mld_mac_addr,
+				     u8 set_clear);
+int ath12k_telemetry_get_sawf_tx_stats_tput(void *ptr, void *stats, u64 *in_bytes,
+					    u64 *in_cnt, u64 *tx_bytes,
+					    u64 *tx_cnt, u8 tid_v, u8 msduq_id);
+int ath12k_telemetry_get_sawf_tx_stats_mpdu(void *ptr, void *stats, u64 *svc_int_pass,
+					    u64 *svc_int_fail, u64 *burst_pass,
+					    u64 *burst_fail, u8 tid_v, u8 msduq_id);
+int ath12k_telemetry_get_sawf_tx_stats_drop(void *ptr, void *stats, u64 *pass,
+					    u64 *drop, u64 *drop_ttl,
+					    u8 tid, u8 msduq_id);
+void ath12k_telemetry_notify_breach(u8 *mac_addr, u8 svc_id, u8 param,
+				    bool set_clear, u8 tid);
+void ath12k_telemetry_breach_indication(u8 *mac_addr, u8 svc_id,
+					u8 param, bool set_clear,
+					u8 tid);
 #else /* CPTCFG_ATH12K_SAWF */
 
 static inline void ath12k_sawf_init(struct ath12k_base *ab) {
--- a/drivers/net/wireless/ath/ath12k/telemetry.h
+++ b/drivers/net/wireless/ath/ath12k/telemetry.h
@@ -93,6 +93,10 @@ struct ath12k_telemetry_ctx {
 	struct ath12k_sla_samples_cfg sla_samples_params;
 	struct ath12k_sla_thershold_cfg sla_thershold_params;
 	struct ath12k_sla_detect_cfg sla_detect_params;
+	spinlock_t breach_ind_lock;
+	struct workqueue_struct *workqueue;
+	struct work_struct indicate_breach;
+	struct list_head list;
 };
 
 void ath12k_telemetry_init(struct ath12k_base *ab);
@@ -101,7 +105,9 @@ struct ath12k_telemetry_ctx *get_telemet
 int ath12k_telemetry_sawf_sla_samples_config(struct ath12k_sla_samples_cfg param);
 int ath12k_telemetry_sawf_sla_thershold_config(struct ath12k_sla_thershold_cfg param);
 int ath12k_telemetry_sawf_sla_detection_config(struct ath12k_sla_detect_cfg param);
-
+bool ath12k_telemetry_get_sla_num_pkts(u32 *pkt_num);
+bool ath12k_telemetry_get_sla_mov_avg_num_pkt(u32 *mov_avg);
+void ath12k_send_breach_indication(struct work_struct *work);
 #else /* CPTCFG_ATH12K_SAWF */
 
 static inline void ath12k_telemetry_init(struct ath12k_base *ab) {
--- a/drivers/net/wireless/ath/ath12k/vendor.c
+++ b/drivers/net/wireless/ath/ath12k/vendor.c
@@ -95,6 +95,18 @@ ath12k_telemetric_req_policy[QCA_WLAN_VE
 	[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_SERVICEID] = {.type = NLA_U8},
 };
 
+static const struct nla_policy
+ath12k_telemetric_sla_policy[QCA_WLAN_VENDOR_ATTR_SLA_MAX + 1] = {
+	[QCA_WLAN_VENDOR_ATTR_SLA_PEER_MAC] = {.type = NLA_BINARY,
+					       .len = ETH_ALEN},
+	[QCA_WLAN_VENDOR_ATTR_SLA_SVC_ID] = {.type = NLA_U8},
+	[QCA_WLAN_VENDOR_ATTR_SLA_PARAM] = {.type = NLA_U8},
+	[QCA_WLAN_VENDOR_ATTR_SLA_SET_CLEAR] = {.type = NLA_U8},
+	[QCA_WLAN_VENDOR_ATTR_SLA_PEER_MLD_MAC] = {.type = NLA_BINARY,
+						   .len = ETH_ALEN},
+	[QCA_WLAN_VENDOR_ATTR_SLA_AC] = {.type = NLA_U8},
+};
+
 static void ath12k_set_default_values(struct ath12k_sawf_svc_params *param)
 {
 	param->min_throughput_rate = SAWF_SVC_PARAM_DEFAULT_MIN_THRUPUT;
@@ -896,6 +908,110 @@ end_stats:
 	return ret;
 }
 
+static int ath12k_vendor_telemetry_sla_reset_stats(struct wiphy *wihpy,
+						   struct wireless_dev *wdev,
+						   const void *data,
+						   int data_len)
+{
+	struct nlattr *tb[QCA_WLAN_VENDOR_ATTR_TELEMETRIC_MAX + 1];
+	int ret = 0;
+	u8 svc_id, mac_addr[ETH_ALEN] = { 0 }, mld_mac_addr[ETH_ALEN] = { 0 }, set_clear;
+
+	if (!ath12k_sawf_enable)
+		return -EOPNOTSUPP;
+
+	ret = nla_parse(tb, QCA_WLAN_VENDOR_ATTR_SLA_MAX, data, data_len,
+			ath12k_telemetric_sla_policy, NULL);
+
+	if (ret) {
+		ath12k_err(NULL, "Invalid attribute with telemetry sla reset stats command\n");
+		return ret;
+	}
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SLA_SVC_ID])
+		svc_id = nla_get_u8(tb[QCA_WLAN_VENDOR_ATTR_SLA_SVC_ID]);
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SLA_PEER_MAC] &&
+	    (nla_len(tb[QCA_WLAN_VENDOR_ATTR_SLA_PEER_MAC]) == ETH_ALEN))
+		memcpy(mac_addr, nla_data(tb[QCA_WLAN_VENDOR_ATTR_SLA_PEER_MAC]),
+		       ETH_ALEN);
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SLA_PEER_MLD_MAC] &&
+	    (nla_len(tb[QCA_WLAN_VENDOR_ATTR_SLA_PEER_MLD_MAC]) == ETH_ALEN))
+		memcpy(mld_mac_addr, nla_data(tb[QCA_WLAN_VENDOR_ATTR_SLA_PEER_MLD_MAC]),
+		       ETH_ALEN);
+
+	if (tb[QCA_WLAN_VENDOR_ATTR_SLA_SET_CLEAR])
+		set_clear = nla_get_u8(tb[QCA_WLAN_VENDOR_ATTR_SLA_SET_CLEAR]);
+
+	return ath12k_telemetry_sla_reset_stats(svc_id, mac_addr, mld_mac_addr,
+						set_clear);
+}
+
+void ath12k_vendor_telemetry_notify_breach(struct ieee80211_vif *vif, u8 *mac_addr,
+					   u8 svc_id, u8 param, bool set_clear,
+					   u8 tid, u8 *mld_addr)
+{
+	struct wireless_dev *wdev;
+	struct sk_buff *skb;
+	u8 access_category;
+
+	wdev = ieee80211_vif_to_wdev(vif);
+
+	if (!wdev)
+		return;
+
+	if (!wdev->wiphy)
+		return;
+
+	skb = cfg80211_vendor_event_alloc(wdev->wiphy, wdev, NLMSG_DEFAULT_SIZE,
+					  QCA_NL80211_VENDOR_SUBCMD_SAWF_SLA_BREACH_INDEX,
+					  GFP_KERNEL);
+	if (!skb) {
+		ath12k_err(NULL, "No memory available to send notify breach event\n");
+		return;
+	}
+
+	switch (tid) {
+	case 0:
+	case 3:
+		access_category = 0; //AC_BE
+		break;
+	case 1:
+	case 2:
+		access_category = 1; //AC_BK
+		break;
+	case 4:
+	case 5:
+		access_category = 2; //AC_VI
+		break;
+	case 6:
+	case 7:
+		access_category = 3; //AC_VO
+		break;
+	default:
+		ath12k_err(NULL, "Invalid TID = %u for notifying breach event\n", tid);
+		goto err;
+	}
+
+	if (nla_put(skb, QCA_WLAN_VENDOR_ATTR_SLA_PEER_MAC, ETH_ALEN, mac_addr) ||
+	    (mld_addr && nla_put(skb, QCA_WLAN_VENDOR_ATTR_SLA_PEER_MLD_MAC,
+	    ETH_ALEN, mld_addr)) ||
+	    nla_put_u8(skb, QCA_WLAN_VENDOR_ATTR_SLA_SVC_ID, svc_id) ||
+	    nla_put_u8(skb, QCA_WLAN_VENDOR_ATTR_SLA_PARAM, param) ||
+	    nla_put_u8(skb, QCA_WLAN_VENDOR_ATTR_SLA_SET_CLEAR, set_clear) ||
+	    nla_put_u8(skb, QCA_WLAN_VENDOR_ATTR_SLA_AC, access_category)) {
+		ath12k_err(NULL, "No memory available at NL to send notify breach event\n");
+		goto err;
+	}
+
+	cfg80211_vendor_event(skb, GFP_KERNEL);
+	return;
+err:
+	kfree(skb);
+	return;
+}
+
 #endif /* CPTCFG_ATH12K_SAWF */
 static struct wiphy_vendor_command ath12k_vendor_commands[] = {
 #ifdef CPTCFG_ATH12K_SAWF
@@ -981,12 +1097,31 @@ static struct wiphy_vendor_command ath12
 		.maxattr = QCA_WLAN_VENDOR_ATTR_TELEMETRIC_MAX,
 		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV,
 	},
+	{
+		.info.vendor_id = QCA_NL80211_VENDOR_ID,
+		.info.subcmd = QCA_NL80211_VENDOR_SUBCMD_SAWF_SLA_BREACH,
+		.doit = ath12k_vendor_telemetry_sla_reset_stats,
+		.policy = ath12k_telemetric_sla_policy,
+		.maxattr = QCA_WLAN_VENDOR_ATTR_SLA_MAX,
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV,
+	},
 #endif /* CPTCFG_ATH12K_SAWF */
 };
 
+static const struct nl80211_vendor_cmd_info ath12k_vendor_events[] = {
+#ifdef CPTCFG_ATH12K_SAWF
+	[QCA_NL80211_VENDOR_SUBCMD_SAWF_SLA_BREACH_INDEX] = {
+		.vendor_id = QCA_NL80211_VENDOR_ID,
+		.subcmd = QCA_NL80211_VENDOR_SUBCMD_SAWF_SLA_BREACH,
+	},
+#endif
+};
+
 int ath12k_vendor_register(struct ath12k_hw *ah)
 {
 	ah->hw->wiphy->vendor_commands = ath12k_vendor_commands;
 	ah->hw->wiphy->n_vendor_commands = ARRAY_SIZE(ath12k_vendor_commands);
+	ah->hw->wiphy->vendor_events = ath12k_vendor_events;
+	ah->hw->wiphy->n_vendor_events = ARRAY_SIZE(ath12k_vendor_events);
 	return 0;
 }
--- a/drivers/net/wireless/ath/ath12k/vendor.h
+++ b/drivers/net/wireless/ath/ath12k/vendor.h
@@ -21,6 +21,8 @@ enum qca_nl80211_vendor_subcmds {
 	QCA_NL80211_VENDOR_SUBCMD_TELEMETRY_SLA_SAMPLES_CFG = 211,
 	QCA_NL80211_VENDOR_SUBCMD_TELEMETRY_SLA_BREACH_DETECTION_CFG = 212,
 	QCA_NL80211_VENDOR_SUBCMD_SAWF_STREAMING_STATS = 213,
+	QCA_NL80211_VENDOR_SUBCMD_SAWF_SLA_BREACH = 214,
+	QCA_NL80211_VENDOR_SUBCMD_SAWF_SLA_BREACH_INDEX = 215,
 	QCA_NL80211_VENDOR_SUBCMD_TELEMETRIC_DATA = 334,
 #endif /* CPTCFG_ATH12K_SAWF */
 };
@@ -451,6 +453,42 @@ struct unified_stats {
 	void *feat[STATS_FEAT_MAX];
 	u_int32_t size[STATS_FEAT_MAX];
 };
+
+/**
+ * enum qca_wlan_vendor_attr_sawf_sla_params - This enum defines
+ * attributes required for QCA_NL80211_VENDOR_SUBCMD_SAWF_SLA_BREACH
+ * Attributes are required to notify SLA breaches from driver to
+ * user application.
+ *
+ * @QCA_WLAN_VENDOR_ATTR_SLA_PEER_MAC: Unsigned 8-bit array
+ * of size 6, representing peer mac address.
+ * @QCA_WLAN_VENDOR_ATTR_SLA_SVC_ID: Unsigned 8-bit representing service ID
+ * @QCA_WLAN_VENDOR_ATTR_SLA_PARAM: Unsigned 8-bit indicaing service class
+ * from qca_vendor_attr_sla_param_type
+ * @QCA_WLAN_VENDOR_ATTR_SLA_PEER_MLD_MAC: Unsigned 8-bit array
+ * of size 6, representing peer mld mac address. Filled only for ML capable
+ * peers
+ * @QCA_WLAN_VENDOR_ATTR_SLA_AC: Unsigned 8-bit representing AC for breach
+ *
+ */
+enum qca_wlan_vendor_attr_sawf_sla_params {
+	QCA_WLAN_VENDOR_ATTR_SLA_INVALID = 0,
+	QCA_WLAN_VENDOR_ATTR_SLA_PEER_MAC = 1,
+	QCA_WLAN_VENDOR_ATTR_SLA_SVC_ID = 2,
+	QCA_WLAN_VENDOR_ATTR_SLA_PARAM = 3,
+	QCA_WLAN_VENDOR_ATTR_SLA_SET_CLEAR = 4,
+	QCA_WLAN_VENDOR_ATTR_SLA_PEER_MLD_MAC = 5,
+	QCA_WLAN_VENDOR_ATTR_SLA_AC = 6,
+
+	/* Keep last */
+	QCA_WLAN_VENDOR_ATTR_SLA_AFTER_LAST,
+	QCA_WLAN_VENDOR_ATTR_SLA_MAX =
+		QCA_WLAN_VENDOR_ATTR_SLA_AFTER_LAST - 1
+};
+
+void ath12k_vendor_telemetry_notify_breach(struct ieee80211_vif *vif, u8 *mac_addr,
+					   u8 svc_id, u8 param, bool set_clear,
+					   u8 tid, u8 *mld_addr);
 #endif /* CPTCFG_ATH12K_SAWF */
 
 int ath12k_vendor_register(struct ath12k_hw *ah);
