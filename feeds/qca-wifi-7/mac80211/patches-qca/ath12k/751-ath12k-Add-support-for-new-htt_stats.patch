From 141961f03032bd858e25353e6ee7eb19965148bf Mon Sep 17 00:00:00 2001
From: Sidhanta Sahu <quic_sidhanta@quicinc.com>
Date: Thu, 23 Mar 2023 20:21:38 -0700
Subject: [PATCH] ath12k: Add support for new htt_stats

Type:
  ATH12K_DGB_HTT_DBG_PDEV_MBSSID_CTRL_FRAME_STATS

Tags Added:
  HTT_STATS_TX_PDEV_PPDU_DUR_TAG
  HTT_STATS_RX_PDEV_PPDU_DUR_TAG
  HTT_STATS_PDEV_SCHED_ALGO_OFDMA_STATS_TAG
  HTT_STATS_LATENCY_PROF_CAL_STATS_TAG
  HTT_STATS_TX_PDEV_AP_EDCA_PARAMS_STATS_TAG
  HTT_STATS_TXBF_OFDMA_AX_STEER_MPDU_STATS_TAG
  HTT_STATS_TXBF_OFDMA_BE_STEER_MPDU_STATS_TAG
  HTT_STATS_PEER_AX_OFDMA_STATS_TAG
  HTT_STATS_TX_PDEV_MU_EDCA_PARAMS_STATS_TAG
  HTT_STATS_ODD_PDEV_MANDATORY_TAG
  HTT_STATS_PDEV_MBSSID_CTRL_FRAME_STATS_TAG
  HTT_STATS_TX_PDEV_MLO_ABORT_TAG
  HTT_STATS_TX_PDEV_MLO_TXOP_ABORT_TAG

Signed-off-by: Sidhanta Sahu <quic_sidhanta@quicinc.com>
---
 drivers/net/wireless/ath/ath12k/debugfs.h     |   2 +-
 .../wireless/ath/ath12k/debugfs_htt_stats.c   | 737 ++++++++++++++++++
 .../wireless/ath/ath12k/debugfs_htt_stats.h   | 329 +++++++-
 3 files changed, 1065 insertions(+), 3 deletions(-)

--- a/drivers/net/wireless/ath/ath12k/debugfs.h
+++ b/drivers/net/wireless/ath/ath12k/debugfs.h
@@ -73,7 +73,7 @@ enum ath12k_dbg_htt_ext_stats_type {
 	ATH12K_DBG_HTT_DBG_ODD_MANDATORY_MUOFDMA_STATS	    =  51,
 	ATH12K_DBG_HTT_DBG_EXT_PHY_PROF_CAL_STATS	    =  52,
 	ATH12K_DGB_HTT_DBG_EXT_STATS_PDEV_BW_MGR	    =  53,
-
+	ATH12K_DGB_HTT_DBG_PDEV_MBSSID_CTRL_FRAME_STATS	    =  54,
 	/* keep this last */
 	ATH12K_DBG_HTT_NUM_EXT_STATS,
 };
--- a/drivers/net/wireless/ath/ath12k/debugfs_htt_stats.c
+++ b/drivers/net/wireless/ath/ath12k/debugfs_htt_stats.c
@@ -6641,6 +6641,738 @@ htt_print_ml_link_info_stats_tlv(const v
 	stats_req->buf_len = len;
 }
 
+static inline void
+htt_print_tx_pdev_ppdu_dur_stats_tlv(const void *tag_buf,
+				     struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_tx_pdev_ppdu_dur_stats_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+	u8  i, j;
+	u16 index = 0;
+	char data[HTT_MAX_STRING_LEN] = {0};
+
+	len += scnprintf(buf + len, buf_len - len, "HTT_TX_PDEV_PPDU_DUR_STATS_TLV:\n");
+	len += scnprintf(buf + len, buf_len - len, "pdev_up_time_us_low = %u\n",
+			 htt_stats_buf->pdev_up_time_us_low);
+	len += scnprintf(buf + len, buf_len - len, "pdev_up_time_us_high = %u\n",
+			 htt_stats_buf->pdev_up_time_us_high);
+	len += scnprintf(buf + len, buf_len - len, "tx_success_time_us_low = %u\n",
+			 htt_stats_buf->tx_success_time_us_low);
+	len += scnprintf(buf + len, buf_len - len, "tx_success_time_us_high = %u\n",
+			 htt_stats_buf->tx_success_time_us_high);
+	len += scnprintf(buf + len, buf_len - len, "tx_fail_time_us_low = %u\n",
+			 htt_stats_buf->tx_fail_time_us_low);
+	len += scnprintf(buf + len, buf_len - len, "tx_fail_time_us_high = %u\n",
+			 htt_stats_buf->tx_fail_time_us_high);
+
+	/* Split the buffer store mechanism into two to avoid data buffer overflow
+	 */
+	for (i = 0; i < HTT_PDEV_STATS_PPDU_DUR_HIST_BINS >> 1; i++) {
+		index += snprintf(&data[index],
+				  HTT_MAX_STRING_LEN - index,
+				  " %u-%u : %u,",
+				  i * HTT_PDEV_STATS_PPDU_DUR_HIST_INTERVAL_US,
+				  (i + 1) * HTT_PDEV_STATS_PPDU_DUR_HIST_INTERVAL_US,
+				  htt_stats_buf->tx_ppdu_dur_hist[i]);
+	}
+
+	len += scnprintf(buf + len, buf_len - len, "tx_ppdu_dur_hist_us_0 = %s\n", data);
+	memset(data, '\0', sizeof(char) * HTT_MAX_STRING_LEN);
+	index = 0;
+
+	for (j = i; j < HTT_PDEV_STATS_PPDU_DUR_HIST_BINS; j++) {
+		index += snprintf(&data[index],
+				  HTT_MAX_STRING_LEN - index,
+				  " %u-%u : %u,",
+				  j * HTT_PDEV_STATS_PPDU_DUR_HIST_INTERVAL_US,
+				  (j + 1) * HTT_PDEV_STATS_PPDU_DUR_HIST_INTERVAL_US,
+				  htt_stats_buf->tx_ppdu_dur_hist[j]);
+	}
+
+	len += scnprintf(buf + len, buf_len - len, "tx_ppdu_dur_hist_us_1 = %s\n", data);
+	len += scnprintf(buf + len, buf_len - len,
+			 "=========================================== \n");
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_rx_pdev_ppdu_dur_stats_tlv(const void *tag_buf,
+				     struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_rx_pdev_ppdu_dur_stats_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+	u8  i, j;
+	u16 index = 0;
+	char data[HTT_MAX_STRING_LEN] = {0};
+
+	len += scnprintf(buf + len, buf_len - len, "HTT_RX_PDEV_PPDU_DUR_STATS_TLV:\n");
+
+	/* Split the buffer store mechanism into two to avoid data buffer overflow
+	 */
+	for (i = 0; i < HTT_PDEV_STATS_PPDU_DUR_HIST_BINS >> 1; i++) {
+		index += snprintf(&data[index],
+				  HTT_MAX_STRING_LEN - index,
+				  " %u-%u : %u,",
+				  i * HTT_PDEV_STATS_PPDU_DUR_HIST_INTERVAL_US,
+				  (i + 1) * HTT_PDEV_STATS_PPDU_DUR_HIST_INTERVAL_US,
+				  htt_stats_buf->rx_ppdu_dur_hist[i]);
+	}
+
+	len += scnprintf(buf + len, buf_len - len, "rx_ppdu_dur_hist_us_0 = %s\n", data);
+	memset(data, '\0', sizeof(char) * HTT_MAX_STRING_LEN);
+	index = 0;
+
+	for (j = i; j < HTT_PDEV_STATS_PPDU_DUR_HIST_BINS; j++) {
+		index += snprintf(&data[index],
+				  HTT_MAX_STRING_LEN - index,
+				  " %u-%u : %u,",
+				  j * HTT_PDEV_STATS_PPDU_DUR_HIST_INTERVAL_US,
+				  (j + 1) * HTT_PDEV_STATS_PPDU_DUR_HIST_INTERVAL_US,
+				  htt_stats_buf->rx_ppdu_dur_hist[j]);
+	}
+
+	len += scnprintf(buf + len, buf_len - len, "rx_ppdu_dur_hist_us_1 = %s\n", data);
+	len += scnprintf(buf + len, buf_len - len,
+			 "=========================================== \n");
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_pdev_sched_algo_ofdma_stats_tlv(const void *tag_buf,
+					  struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_pdev_sched_algo_ofdma_stats_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->rate_based_dlofdma_enabled_count,
+			   "rate_based_dlofdma_enabled_count",
+			   HTT_NUM_AC_WMM, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->rate_based_dlofdma_disabled_count,
+			   "rate_based_dlofdma_disabled_count",
+			   HTT_NUM_AC_WMM, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->rate_based_dlofdma_probing_count,
+			   "rate_based_dlofdma_probing_count",
+			   HTT_NUM_AC_WMM, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->rate_based_dlofdma_monitoring_count,
+			   "rate_based_dlofdma_monitoring_count",
+			   HTT_NUM_AC_WMM, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->chan_acc_lat_based_dlofdma_enabled_count,
+			   "chan_acc_lat_based_dlofdma_enabled_count",
+			   HTT_NUM_AC_WMM, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->chan_acc_lat_based_dlofdma_disabled_count,
+			   "chan_acc_lat_based_dlofdma_disabled_count",
+			   HTT_NUM_AC_WMM, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->chan_acc_lat_based_dlofdma_monitoring_count,
+			   "chan_acc_lat_based_dlofdma_monitoring_count",
+			   HTT_NUM_AC_WMM, "\n");
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "=========================================== \n");
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_latency_prof_cal_stats_tlv(const void *tag_buf,
+				     struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_latency_prof_cal_stats_tlv *htt_stats_buf = tag_buf;
+	char latency_prof_stat_name[HTT_STATS_MAX_PROF_STATS_NAME_LEN + 1] = {0};
+	u32 i, j;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += scnprintf(buf + len, buf_len - len, "HTT_STATS_LATENCY_PROF_CAL_TLV:\n");
+	for (i = 1; i < HTT_STATS_MAX_PROF_CAL; i++) {
+		memcpy(latency_prof_stat_name,
+		       (htt_stats_buf->latency_prof_name[i]),
+		       HTT_STATS_MAX_PROF_STATS_NAME_LEN);
+
+		len += scnprintf(buf + len, buf_len - len,
+				"%-32s",
+				htt_stats_buf->latency_prof_name[i]);
+		len += scnprintf(buf + len, buf_len - len,
+				 "|%9s|%8s|%8s|%8s|%8s|%8s|%10s|%14s|%8s|%8s|%8s|\n",
+				 "cal_index", "cnt", "min", "max", "last", "tot",
+				 "hist_intvl", "hist", "pf_last", "pf_tot",
+				 "pf_max");
+
+		for (j = 0; j < htt_stats_buf->CalCnt[i]; j++) {
+			len += scnprintf(buf + len, buf_len - len,
+					 "|%9u|%8u|%8u|%8u|%8u|%8u|%10u|%4u:%4u:%4u|%8u|%8u|%8u|\n",
+					 htt_stats_buf->enabledCalIdx[i][j],
+					 htt_stats_buf->cnt[i][j],
+					 htt_stats_buf->min[i][j],
+					 htt_stats_buf->max[i][j],
+					 htt_stats_buf->last[i][j],
+					 htt_stats_buf->tot[i][j],
+					 htt_stats_buf->hist_intvl[i][j],
+					 htt_stats_buf->hist[i][j][0],
+					 htt_stats_buf->hist[i][j][1],
+					 htt_stats_buf->hist[i][j][2],
+					 htt_stats_buf->pf_last[i][j],
+					 htt_stats_buf->pf_tot[i][j],
+					 htt_stats_buf->pf_max[i][j]);
+		}
+	}
+	len += scnprintf(buf + len, buf_len - len,
+			 "=========================================== \n");
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_tx_pdev_ap_edca_params_stats_tlv_v(const void *tag_buf,
+					     struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_tx_pdev_ap_edca_params_stats_tlv_v *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+	int i;
+
+	len += scnprintf(buf + len, buf_len - len, "\nAP EDCA PARAMETERS FOR UL MUMIMO:\n");
+	for (i = 0; i < HTT_NUM_AC_WMM; i++) {
+		len += scnprintf(buf + len, buf_len - len, "ul_mumimo_less_aggressive[%u] = %u\n",
+			i, htt_stats_buf->ul_mumimo_less_aggressive[i]);
+		len += scnprintf(buf + len, buf_len - len, "ul_mumimo_medium_aggressive[%u] = %u\n",
+			i, htt_stats_buf->ul_mumimo_medium_aggressive[i]);
+		len += scnprintf(buf + len, buf_len - len, "ul_mumimo_highly_aggressive[%u] = %u\n",
+			i, htt_stats_buf->ul_mumimo_highly_aggressive[i]);
+		len += scnprintf(buf + len, buf_len - len, "ul_mumimo_default_relaxed[%u] = %u\n",
+			i, htt_stats_buf->ul_mumimo_default_relaxed[i]);
+	}
+
+	len += scnprintf(buf + len, buf_len - len, "AP EDCA PARAMETERS FOR UL OFDMA:\n");
+	for (i = 0; i < HTT_NUM_AC_WMM; i++) {
+		len += scnprintf(buf + len, buf_len - len, "ul_muofdma_less_aggressive[%u] = %u\n",
+			i, htt_stats_buf->ul_muofdma_less_aggressive[i]);
+		len += scnprintf(buf + len, buf_len - len, "ul_muofdma_medium_aggressive[%u] = %u\n",
+			i, htt_stats_buf->ul_muofdma_medium_aggressive[i]);
+		len += scnprintf(buf + len, buf_len - len, "ul_muofdma_highly_aggressive[%u] = %u\n",
+			i, htt_stats_buf->ul_muofdma_highly_aggressive[i]);
+		len += scnprintf(buf + len, buf_len - len, "ul_muofdma_default_relaxed[%u] = %u\n",
+			i, htt_stats_buf->ul_muofdma_default_relaxed[i]);
+	}
+	len += scnprintf(buf + len, buf_len - len,
+			 "=========================================== \n");
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_txbf_ofdma_ax_steer_mpdu_stats_tlv(const void *tag_buf,
+					     struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_txbf_ofdma_ax_steer_mpdu_stats_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += scnprintf(buf + len, buf_len - len, "HTT_TXBF_OFDMA_AX_STEER_MPDU_STATS_TLV:\n");
+
+	len += scnprintf(buf + len, buf_len - len, "rbo_steer_mpdus_tried = %u\n",
+			 htt_stats_buf->ax_ofdma_rbo_steer_mpdus_tried);
+	len += scnprintf(buf + len, buf_len - len, "rbo_steer_mpdus_failed = %u\n",
+			 htt_stats_buf->ax_ofdma_rbo_steer_mpdus_failed);
+	len += scnprintf(buf + len, buf_len - len, "sifs_steer_mpdus_tried = %u\n",
+			 htt_stats_buf->ax_ofdma_sifs_steer_mpdus_tried);
+	len += scnprintf(buf + len, buf_len - len, "sifs_steer_mpdus_failed = %u\n",
+			 htt_stats_buf->ax_ofdma_sifs_steer_mpdus_failed);
+	len += scnprintf(buf + len, buf_len - len,
+			 "=========================================== \n");
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_txbf_ofdma_be_steer_mpdu_stats_tlv(const void *tag_buf,
+					     struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_txbf_ofdma_be_steer_mpdu_stats_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += scnprintf(buf + len, buf_len - len, "HTT_TXBF_OFDMA_BE_STEER_MPDU_STATS_TLV:\n");
+
+	len += scnprintf(buf + len, buf_len - len, "rbo_steer_mpdus_tried = %u\n",
+			 htt_stats_buf->be_ofdma_rbo_steer_mpdus_tried);
+	len += scnprintf(buf + len, buf_len - len, "rbo_steer_mpdus_failed = %u\n",
+			 htt_stats_buf->be_ofdma_rbo_steer_mpdus_failed);
+	len += scnprintf(buf + len, buf_len - len, "sifs_steer_mpdus_tried = %u\n",
+			 htt_stats_buf->be_ofdma_sifs_steer_mpdus_tried);
+	len += scnprintf(buf + len, buf_len - len, "sifs_steer_mpdus_failed = %u\n",
+			 htt_stats_buf->be_ofdma_sifs_steer_mpdus_failed);
+	len += scnprintf(buf + len, buf_len - len,
+			 "=========================================== \n");
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_peer_ax_ofdma_stats(const void *tag_buf,
+			      struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_peer_ax_ofdma_stats_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += scnprintf(buf + len, buf_len - len, "HTT_PEER_AX_OFDMA_STATS_TLV:\n");
+	len += scnprintf(buf + len, buf_len - len, "peer_id = %u\n",
+			 htt_stats_buf->peer_id);
+	len += scnprintf(buf + len, buf_len - len, "ax_basic_trig_count = %u\n",
+			 htt_stats_buf->ax_basic_trig_count);
+	len += scnprintf(buf + len, buf_len - len, "ax_basic_trig_err = %u\n",
+			 htt_stats_buf->ax_basic_trig_err);
+	len += scnprintf(buf + len, buf_len - len, "ax_bsr_trig_count = %u\n",
+			 htt_stats_buf->ax_bsr_trig_count);
+	len += scnprintf(buf + len, buf_len - len, "ax_bsr_trig_err = %u\n",
+			 htt_stats_buf->ax_bsr_trig_err);
+	len += scnprintf(buf + len, buf_len - len, "ax_mu_bar_trig_count = %u\n",
+			 htt_stats_buf->ax_mu_bar_trig_count);
+	len += scnprintf(buf + len, buf_len - len, "ax_mu_bar_trig_err = %u\n",
+			 htt_stats_buf->ax_mu_bar_trig_err);
+	len += scnprintf(buf + len, buf_len - len, "ax_basic_trig_with_per = %u\n",
+			 htt_stats_buf->ax_basic_trig_with_per);
+	len += scnprintf(buf + len, buf_len - len, "ax_bsr_trig_with_per = %u\n",
+			 htt_stats_buf->ax_bsr_trig_with_per);
+	len += scnprintf(buf + len, buf_len - len, "ax_mu_bar_trig_with_per = %u\n",
+			 htt_stats_buf->ax_mu_bar_trig_with_per);
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->is_airtime_large_for_dl_ofdma,
+			   "is_airtime_large_for_dl_ofdma", 2, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->is_airtime_large_for_ul_ofdma,
+			   "is_airtime_large_for_ul_ofdma", 2, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->last_updated_dl_qdepth,
+			   "last_updated_dl_qdepth", HTT_NUM_AC_WMM, "\n");
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->last_updated_ul_qdepth,
+			   "last_updated_ul_qdepth", HTT_NUM_AC_WMM, "\n");
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "=========================================== \n");
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_tx_pdev_mu_edca_params_stats_tlv_v(const void *tag_buf,
+					     struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_tx_pdev_mu_edca_params_stats_tlv_v *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+	char *edca_buf = NULL;
+
+	edca_buf = kmalloc(HTT_MAX_STRING_LEN, GFP_ATOMIC);
+	if (!edca_buf)
+		goto fail;
+
+	len += scnprintf(buf + len, buf_len - len, "HTT_TX_PDEV_MU_EDCA_PARAMS_STATS_TLV:\n");
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->relaxed_mu_edca,
+			   "irelaxed_mu_edca",
+			   HTT_NUM_AC_WMM, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->mumimo_aggressive_mu_edca,
+			   "mumimo_aggressive_mu_edca",
+			   HTT_NUM_AC_WMM, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->muofdma_relaxed_mu_edca,
+			   "muofdma_relaxed_mu_edca",
+			   HTT_NUM_AC_WMM, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->latency_mu_edca,
+			   "latency_mu_edca",
+			   HTT_NUM_AC_WMM, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->psd_boost_mu_edca,
+			   "psd_boost_mu_edca",
+			   HTT_NUM_AC_WMM, "\n");
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "=========================================== \n");
+	stats_req->buf_len = len;
+fail:
+	kfree(edca_buf);
+}
+
+static inline void
+htt_print_odd_pdev_mandatory_tlv(const void *tag_buf,
+				 struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_odd_mandatory_pdev_stats_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += scnprintf(buf + len, buf_len - len, "HTT_ODD_PDEV_MANDATORY_TLV:\n");
+	len += scnprintf(buf + len, buf_len - len, "hw_queued = %u\n",
+			 htt_stats_buf->hw_queued);
+	len += scnprintf(buf + len, buf_len - len, "hw_reaped = %u\n",
+			 htt_stats_buf->hw_reaped);
+	len += scnprintf(buf + len, buf_len - len, "hw_paused = %u\n",
+			 htt_stats_buf->hw_paused);
+	len += scnprintf(buf + len, buf_len - len, "hw_filt = %u\n",
+			 htt_stats_buf->hw_filt);
+	len += scnprintf(buf + len, buf_len - len, "seq_posted = %u\n",
+			 htt_stats_buf->seq_posted);
+	len += scnprintf(buf + len, buf_len - len, "seq_completed = %u\n",
+			 htt_stats_buf->seq_completed);
+	len += scnprintf(buf + len, buf_len - len, "underrun = %u\n",
+			 htt_stats_buf->underrun);
+	len += scnprintf(buf + len, buf_len - len, "hw_flush = %u\n",
+			 htt_stats_buf->hw_flush);
+	len += scnprintf(buf + len, buf_len - len, "next_seq_posted_dsr = %u\n",
+			 htt_stats_buf->next_seq_posted_dsr);
+	len += scnprintf(buf + len, buf_len - len, "seq_posted_isr = %u\n",
+			 htt_stats_buf->seq_posted_isr);
+	len += scnprintf(buf + len, buf_len - len, "mpdu_cnt_fcs_ok = %u\n",
+			 htt_stats_buf->mpdu_cnt_fcs_ok);
+	len += scnprintf(buf + len, buf_len - len, "mpdu_cnt_fcs_err = %u\n",
+			 htt_stats_buf->mpdu_cnt_fcs_err);
+	len += scnprintf(buf + len, buf_len - len, "msdu_count_tqm = %u\n",
+			 htt_stats_buf->msdu_count_tqm);
+	len += scnprintf(buf + len, buf_len - len, "mpdu_count_tqm = %u\n",
+			 htt_stats_buf->mpdu_count_tqm);
+	len += scnprintf(buf + len, buf_len - len, "mpdus_ack_failed = %u\n",
+			 htt_stats_buf->mpdus_ack_failed);
+	len += scnprintf(buf + len, buf_len - len, "num_data_ppdus_tried_ota = %u\n",
+			 htt_stats_buf->num_data_ppdus_tried_ota);
+	len += scnprintf(buf + len, buf_len - len, "ppdu_ok = %u\n",
+			 htt_stats_buf->ppdu_ok);
+	len += scnprintf(buf + len, buf_len - len, "num_total_ppdus_tried_ota = %u\n",
+			 htt_stats_buf->num_total_ppdus_tried_ota);
+	len += scnprintf(buf + len, buf_len - len, "thermal_suspend_cnt = %u\n",
+			 htt_stats_buf->thermal_suspend_cnt);
+	len += scnprintf(buf + len, buf_len - len, "dfs_suspend_cnt = %u\n",
+			 htt_stats_buf->dfs_suspend_cnt);
+	len += scnprintf(buf + len, buf_len - len, "tx_abort_suspend_cnt = %u\n",
+			 htt_stats_buf->tx_abort_suspend_cnt);
+	len += scnprintf(buf + len, buf_len - len, "suspended_txq_mask = %u\n",
+			 htt_stats_buf->suspended_txq_mask);
+	len += scnprintf(buf + len, buf_len - len, "last_suspend_reason = %u\n",
+			 htt_stats_buf->last_suspend_reason);
+	len += scnprintf(buf + len, buf_len - len, "seq_failed_queueing = %u\n",
+			 htt_stats_buf->seq_failed_queueing);
+	len += scnprintf(buf + len, buf_len - len, "seq_restarted = %u\n",
+			 htt_stats_buf->seq_restarted);
+	len += scnprintf(buf + len, buf_len - len, "seq_txop_repost_stop = %u\n",
+			 htt_stats_buf->seq_txop_repost_stop);
+	len += scnprintf(buf + len, buf_len - len, "next_seq_cancel = %u\n",
+			 htt_stats_buf->next_seq_cancel);
+	len += scnprintf(buf + len, buf_len - len, "seq_min_msdu_repost_stop = %u\n",
+			 htt_stats_buf->seq_min_msdu_repost_stop);
+	len += scnprintf(buf + len, buf_len - len, "total_phy_err_cnt = %u\n",
+			 htt_stats_buf->total_phy_err_cnt);
+	len += scnprintf(buf + len, buf_len - len, "ppdu_recvd = %u\n",
+			 htt_stats_buf->ppdu_recvd);
+	len += scnprintf(buf + len, buf_len - len, "tcp_msdu_cnt = %u\n",
+			 htt_stats_buf->tcp_msdu_cnt);
+	len += scnprintf(buf + len, buf_len - len, "tcp_ack_msdu_cnt = %u\n",
+			 htt_stats_buf->tcp_ack_msdu_cnt);
+	len += scnprintf(buf + len, buf_len - len, "udp_msdu_cnt = %u \n",
+			 htt_stats_buf->udp_msdu_cnt);
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->fw_tx_mgmt_subtype,
+			   "fw_tx_mgmt_subtype",
+			   HTT_STATS_SUBTYPE_MAX, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->fw_rx_mgmt_subtype,
+			   "fw_rx_mgmt_subtype",
+			   HTT_STATS_SUBTYPE_MAX, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->fw_ring_mpdu_err,
+			   "fw_ring_mpdu_err",
+			   HTT_STATS_SUBTYPE_MAX, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->fw_rx_mgmt_subtype,
+			   "fw_rx_mgmt_subtype",
+			   HTT_RX_STATS_RXDMA_MAX_ERR, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->urrn_stats,
+			   "urrn_stats",
+			   HTT_TX_PDEV_MAX_URRN_STATS, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->sifs_status,
+			   "sifs_status",
+			   HTT_TX_PDEV_MAX_SIFS_BURST_STATS, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->fw_rx_mgmt_subtype,
+			   "sifs_hist_status",
+			   HTT_TX_PDEV_SIFS_BURST_HIST_STATS, "\n");
+
+	len += scnprintf(buf + len, buf_len - len, "rx_suspend_cnt = %u\n",
+			 htt_stats_buf->rx_suspend_cnt);
+	len += scnprintf(buf + len, buf_len - len, "rx_suspend_fail_cnt = %u\n",
+			 htt_stats_buf->rx_suspend_fail_cnt);
+	len += scnprintf(buf + len, buf_len - len, "rx_resume_cnt = %u\n",
+			 htt_stats_buf->rx_resume_cnt);
+	len += scnprintf(buf + len, buf_len - len, "rx_resume_fail_cnt = %u \n",
+			 htt_stats_buf->rx_resume_fail_cnt);
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->hwq_beacon_cmd_result,
+			   "hwq_beacon_cmd_result",
+			   HTT_TX_HWQ_MAX_CMD_RESULT_STATS, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->hwq_voice_cmd_result,
+			   "hwq_voice_cmd_result",
+			   HTT_TX_HWQ_MAX_CMD_RESULT_STATS, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->hwq_video_cmd_result,
+			   "hwq_video_cmd_result",
+			   HTT_TX_HWQ_MAX_CMD_RESULT_STATS, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->hwq_best_effort_cmd_result,
+			   "hwq_best_effort_cmd_result",
+			   HTT_TX_HWQ_MAX_CMD_RESULT_STATS, "\n");
+
+	len += scnprintf(buf + len, buf_len - len, "hwq_beacon_mpdu_tried_cnt = %u\n",
+			 htt_stats_buf->hwq_beacon_mpdu_tried_cnt);
+	len += scnprintf(buf + len, buf_len - len, "hwq_voice_mpdu_tried_cnt = %u\n",
+			 htt_stats_buf->hwq_voice_mpdu_tried_cnt);
+	len += scnprintf(buf + len, buf_len - len, "hwq_video_mpdu_tried_cnt = %u\n",
+			 htt_stats_buf->hwq_video_mpdu_tried_cnt);
+	len += scnprintf(buf + len, buf_len - len, "hwq_best_effort_mpdu_tried_cnt = %u\n",
+			 htt_stats_buf->hwq_best_effort_mpdu_tried_cnt);
+	len += scnprintf(buf + len, buf_len - len, "hwq_beacon_mpdu_queued_cnt = %u\n",
+			 htt_stats_buf->hwq_beacon_mpdu_queued_cnt);
+	len += scnprintf(buf + len, buf_len - len, "hwq_voice_mpdu_queued_cnt = %u\n",
+			 htt_stats_buf->hwq_voice_mpdu_queued_cnt);
+	len += scnprintf(buf + len, buf_len - len, "hwq_video_mpdu_queued_cnt = %u\n",
+			 htt_stats_buf->hwq_video_mpdu_queued_cnt);
+	len += scnprintf(buf + len, buf_len - len, "hwq_best_effort_mpdu_queued_cnt = %u\n",
+			 htt_stats_buf->hwq_best_effort_mpdu_queued_cnt);
+	len += scnprintf(buf + len, buf_len - len, "hwq_beacon_mpdu_ack_fail_cnt = %u\n",
+			 htt_stats_buf->hwq_beacon_mpdu_ack_fail_cnt);
+	len += scnprintf(buf + len, buf_len - len, "hwq_voice_mpdu_ack_fail_cnt = %u\n",
+			 htt_stats_buf->hwq_voice_mpdu_ack_fail_cnt);
+	len += scnprintf(buf + len, buf_len - len, "hwq_video_mpdu_ack_fail_cnt = %u\n",
+			 htt_stats_buf->hwq_video_mpdu_ack_fail_cnt);
+	len += scnprintf(buf + len, buf_len - len, "hwq_best_effort_mpdu_ack_fail_cnt = %u\n",
+			 htt_stats_buf->hwq_best_effort_mpdu_ack_fail_cnt);
+	len += scnprintf(buf + len, buf_len - len, "pdev_resets = %u\n",
+			 htt_stats_buf->pdev_resets);
+	len += scnprintf(buf + len, buf_len - len, "phy_warm_reset = %u\n",
+			 htt_stats_buf->phy_warm_reset);
+	len += scnprintf(buf + len, buf_len - len, "hwsch_reset_count = %u\n",
+			 htt_stats_buf->hwsch_reset_count);
+	len += scnprintf(buf + len, buf_len - len, "phy_warm_reset_ucode_trig = %u\n",
+			 htt_stats_buf->phy_warm_reset_ucode_trig);
+	len += scnprintf(buf + len, buf_len - len, "mac_cold_reset = %u\n",
+			 htt_stats_buf->mac_cold_reset);
+	len += scnprintf(buf + len, buf_len - len, "mac_warm_reset = %u\n",
+			 htt_stats_buf->mac_warm_reset);
+	len += scnprintf(buf + len, buf_len - len, "mac_warm_reset_restore_cal = %u\n",
+			 htt_stats_buf->mac_warm_reset_restore_cal);
+	len += scnprintf(buf + len, buf_len - len, "phy_warm_reset_m3_ssr = %u\n",
+			 htt_stats_buf->phy_warm_reset_m3_ssr);
+	len += scnprintf(buf + len, buf_len - len, "fw_rx_rings_reset = %u\n",
+			 htt_stats_buf->fw_rx_rings_reset);
+	len += scnprintf(buf + len, buf_len - len, "tx_flush = %u\n",
+			 htt_stats_buf->tx_flush);
+	len += scnprintf(buf + len, buf_len - len, "hwsch_dev_reset_war = %u\n",
+			 htt_stats_buf->hwsch_dev_reset_war);
+	len += scnprintf(buf + len, buf_len - len, "mac_cold_reset_restore_cal = %u\n",
+			 htt_stats_buf->mac_cold_reset_restore_cal);
+	len += scnprintf(buf + len, buf_len - len, "mac_only_reset = %u\n",
+			 htt_stats_buf->mac_only_reset);
+	len += scnprintf(buf + len, buf_len - len, "mac_sfm_reset = %u\n",
+			 htt_stats_buf->mac_sfm_reset);
+	len += scnprintf(buf + len, buf_len - len, "rx_ldpc = %u\n",
+			 htt_stats_buf->rx_ldpc);
+	len += scnprintf(buf + len, buf_len - len, "tx_ldpc = %u \n",
+			 htt_stats_buf->tx_ldpc);
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->gen_mpdu_end_reason,
+			   "gen_mpdu_end_reason",
+			   HTT_TX_TQM_MAX_GEN_MPDU_END_REASON, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->list_mpdu_end_reason,
+			   "list_mpdu_end_reason",
+			   HTT_TX_TQM_MAX_GEN_MPDU_END_REASON, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->tx_mcs,
+			   "tx_mcs",
+			   (HTT_TX_PDEV_STATS_NUM_MCS_COUNTERS +
+			   HTT_TX_PDEV_STATS_NUM_EXTRA_MCS_COUNTERS +
+			   HTT_TX_PDEV_STATS_NUM_EXTRA2_MCS_COUNTERS), "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->tx_nss,
+			   "tx_nss",
+			   HTT_TX_PDEV_STATS_NUM_SPATIAL_STREAMS, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->tx_bw,
+			   "tx_bw",
+			   HTT_TX_PDEV_STATS_NUM_BW_COUNTERS, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->half_tx_bw,
+			   "half_tx_bw",
+			   HTT_TX_PDEV_STATS_NUM_BW_COUNTERS, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->quarter_tx_bw,
+			   "quarter_tx_bw",
+			   HTT_TX_PDEV_STATS_NUM_BW_COUNTERS, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->tx_su_punctured_mode,
+			   "tx_su_punctured_mode",
+			   HTT_TX_PDEV_STATS_NUM_PUNCTURED_MODE_COUNTERS, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->rx_mcs,
+			   "rx_mcs",
+			   (HTT_RX_PDEV_STATS_NUM_MCS_COUNTERS +
+			   HTT_RX_PDEV_STATS_NUM_EXTRA_MCS_COUNTERS +
+			   HTT_RX_PDEV_STATS_NUM_EXTRA2_MCS_COUNTERS), "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->rx_nss,
+			   "rx_nss",
+			   HTT_RX_PDEV_STATS_NUM_SPATIAL_STREAMS, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->rx_bw,
+			   "rx_bw",
+			   HTT_RX_PDEV_STATS_NUM_BW_COUNTERS, "\n");
+
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->rx_stbc,
+			   "rx_stbc",
+			   (HTT_RX_PDEV_STATS_NUM_MCS_COUNTERS +
+			    HTT_RX_PDEV_STATS_NUM_EXTRA_MCS_COUNTERS +
+			    HTT_RX_PDEV_STATS_NUM_EXTRA2_MCS_COUNTERS), "\n");
+
+	len += scnprintf(buf + len, buf_len - len, "rts_cnt = %u\n",
+			 htt_stats_buf->rts_cnt);
+	len += scnprintf(buf + len, buf_len - len, "rts_success = %u\n",
+			 htt_stats_buf->rts_success);
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "=================================================\n");
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_pdev_mbssid_ctrl_frame_stats_tlv(const void *tag_buf,
+					   struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_pdev_mbssid_ctrl_frame_stats_tlv *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+
+	len += scnprintf(buf + len, buf_len - len, "mac_id = %u\n",
+			 HTT_STATS_CMN_MAC_ID_GET(htt_stats_buf->mac_id__word));
+
+	len += scnprintf(buf + len, buf_len - len, "basic_trigger_across_bss_count = %u\n",
+			 htt_stats_buf->basic_trigger_across_bss);
+	len += scnprintf(buf + len, buf_len - len, "basic_trigger_within_bss_count = %u\n",
+			 htt_stats_buf->basic_trigger_within_bss);
+	len += scnprintf(buf + len, buf_len - len, "bsr_trigger_across_bss_count = %u\n",
+			 htt_stats_buf->bsr_trigger_across_bss);
+	len += scnprintf(buf + len, buf_len - len, "bsr_trigger_within_bss_count = %u\n",
+			 htt_stats_buf->bsr_trigger_within_bss);
+	len += scnprintf(buf + len, buf_len - len, "MU_RTS_across_bss_count = %u\n",
+			 htt_stats_buf->mu_rts_across_bss);
+	len += scnprintf(buf + len, buf_len - len, "MU_RTS_within_bss_count = %u\n",
+			 htt_stats_buf->mu_rts_within_bss);
+	len += scnprintf(buf + len, buf_len - len, "UL_MUMIMO_trigger_across_bss_count = %u\n",
+			 htt_stats_buf->ul_mumimo_trigger_across_bss);
+	len += scnprintf(buf + len, buf_len - len, "UL_MUMIMO_trigger_within_bss_count = %u\n",
+			 htt_stats_buf->ul_mumimo_trigger_within_bss);
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "=================================================\n");
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_tx_pdev_stats_mlo_abort_tlv_v(const void *tag_buf,
+					u16 tag_len,
+					struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_tx_pdev_stats_mlo_abort_tlv_v *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+	u32 num_elements = tag_len >> 2;
+
+	len += scnprintf(buf + len, buf_len - len, "HTT_TX_PDEV_STATS_MLO_ABORT_TLV_V:\n");
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->mlo_abort_cnt,
+			   "mlo_abort_cnt",
+			   num_elements, "\n");
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "=================================================\n");
+	stats_req->buf_len = len;
+}
+
+static inline void
+htt_print_tx_pdev_stats_mlo_txop_abort_tlv_v(const void *tag_buf,
+					     u16 tag_len,
+					     struct debug_htt_stats_req *stats_req)
+{
+	const struct htt_tx_pdev_stats_mlo_txop_abort_tlv_v *htt_stats_buf = tag_buf;
+	u8 *buf = stats_req->buf;
+	u32 len = stats_req->buf_len;
+	u32 buf_len = ATH12K_HTT_STATS_BUF_SIZE;
+	u32 num_elements = tag_len >> 2;
+
+	len += scnprintf(buf + len, buf_len - len, "HTT_TX_PDEV_STATS_MLO_TXOP_ABORT_TLV_V:\n");
+	PRINT_ARRAY_TO_BUF(buf, len,
+			   htt_stats_buf->mlo_txop_abort_cnt,
+			   "mlo_txop_abort_cnt",
+			   num_elements, "\n");
+
+	len += scnprintf(buf + len, buf_len - len,
+			 "=================================================\n");
+	stats_req->buf_len = len;
+}
+
 static inline void htt_print_phy_counters_tlv(const void *tag_buf,
 					      struct debug_htt_stats_req *stats_req)
 {
@@ -7921,6 +8653,45 @@ static int ath12k_dbg_htt_ext_stats_pars
 	case HTT_STATS_ML_LINK_INFO_DETAILS_TAG:
 		htt_print_ml_link_info_stats_tlv(tag_buf, stats_req);
 		break;
+	case HTT_STATS_TX_PDEV_PPDU_DUR_TAG:
+		htt_print_tx_pdev_ppdu_dur_stats_tlv(tag_buf, stats_req);
+		break;
+	case HTT_STATS_RX_PDEV_PPDU_DUR_TAG:
+		htt_print_rx_pdev_ppdu_dur_stats_tlv(tag_buf, stats_req);
+		break;
+	case HTT_STATS_PDEV_SCHED_ALGO_OFDMA_STATS_TAG:
+		htt_print_pdev_sched_algo_ofdma_stats_tlv(tag_buf, stats_req);
+		break;
+	case HTT_STATS_LATENCY_PROF_CAL_STATS_TAG:
+		htt_print_latency_prof_cal_stats_tlv(tag_buf, stats_req);
+		break;
+	case HTT_STATS_TX_PDEV_AP_EDCA_PARAMS_STATS_TAG:
+		htt_print_tx_pdev_ap_edca_params_stats_tlv_v(tag_buf, stats_req);
+		break;
+	case HTT_STATS_TXBF_OFDMA_AX_STEER_MPDU_STATS_TAG:
+		htt_print_txbf_ofdma_ax_steer_mpdu_stats_tlv(tag_buf, stats_req);
+		break;
+	case HTT_STATS_TXBF_OFDMA_BE_STEER_MPDU_STATS_TAG:
+		htt_print_txbf_ofdma_be_steer_mpdu_stats_tlv(tag_buf, stats_req);
+		break;
+	case HTT_STATS_PEER_AX_OFDMA_STATS_TAG:
+		htt_print_peer_ax_ofdma_stats(tag_buf, stats_req);
+		break;
+	case HTT_STATS_TX_PDEV_MU_EDCA_PARAMS_STATS_TAG:
+		htt_print_tx_pdev_mu_edca_params_stats_tlv_v(tag_buf, stats_req);
+		break;
+	case HTT_STATS_ODD_PDEV_MANDATORY_TAG:
+		htt_print_odd_pdev_mandatory_tlv(tag_buf, stats_req);
+		break;
+	case HTT_STATS_PDEV_MBSSID_CTRL_FRAME_STATS_TAG:
+		htt_print_pdev_mbssid_ctrl_frame_stats_tlv(tag_buf, stats_req);
+		break;
+	case HTT_STATS_TX_PDEV_MLO_ABORT_TAG:
+		htt_print_tx_pdev_stats_mlo_abort_tlv_v(tag_buf, len, stats_req);
+		break;
+	case HTT_STATS_TX_PDEV_MLO_TXOP_ABORT_TAG:
+		htt_print_tx_pdev_stats_mlo_txop_abort_tlv_v(tag_buf, len, stats_req);
+		break;
 	default:
 		break;
 	}
--- a/drivers/net/wireless/ath/ath12k/debugfs_htt_stats.h
+++ b/drivers/net/wireless/ath/ath12k/debugfs_htt_stats.h
@@ -158,6 +158,9 @@ enum htt_tlv_tag_t {
 	HTT_STATS_RX_PDEV_BE_UL_MIMO_USER_STATS_TAG	    = 141,
 	HTT_STATS_RX_RING_STATS_TAG			    = 142,
 	HTT_STATS_RX_PDEV_BE_UL_TRIG_STATS_TAG		    = 143,
+	HTT_STATS_TX_PDEV_SAWF_RATE_STATS_TAG		    = 144,
+	HTT_STATS_STRM_GEN_MPDUS_TAG			    = 145,
+	HTT_STATS_STRM_GEN_MPDUS_DETAILS_TAG		    = 146,
 	HTT_STATS_TXBF_OFDMA_AX_NDPA_STATS_TAG		    = 147,
 	HTT_STATS_TXBF_OFDMA_AX_NDP_STATS_TAG		    = 148,
 	HTT_STATS_TXBF_OFDMA_AX_BRP_STATS_TAG		    = 149,
@@ -187,6 +190,9 @@ enum htt_tlv_tag_t {
 	HTT_STATS_TXBF_OFDMA_BE_STEER_MPDU_STATS_TAG	    = 173,
 	HTT_STATS_PEER_AX_OFDMA_STATS_TAG		    = 174,
 	HTT_STATS_TX_PDEV_MU_EDCA_PARAMS_STATS_TAG	    = 175,
+	HTT_STATS_PDEV_MBSSID_CTRL_FRAME_STATS_TAG	    = 176,
+	HTT_STATS_TX_PDEV_MLO_ABORT_TAG			    = 177,
+	HTT_STATS_TX_PDEV_MLO_TXOP_ABORT_TAG		    = 178,
 	HTT_STATS_MAX_TAG,
 };
 
@@ -196,6 +202,8 @@ enum htt_tlv_tag_t {
 #define HTT_TX_HWQ_MAX_CMD_RESULT_STATS      13
 #define HTT_TX_HWQ_MAX_CMD_STALL_STATS       5
 #define HTT_TX_HWQ_MAX_FES_RESULT_STATS      10
+#define HTT_PDEV_STATS_PPDU_DUR_HIST_BINS 16
+#define HTT_PDEV_STATS_PPDU_DUR_HIST_INTERVAL_US 250
 
 enum htt_tx_pdev_underrun_enum {
 	HTT_STATS_TX_PDEV_NO_DATA_UNDERRUN           = 0,
@@ -328,6 +336,18 @@ struct htt_tx_pdev_stats_flush_tlv_v {
 	u32 flush_errs[0]; /* HTT_TX_PDEV_MAX_FLUSH_REASON_STATS */
 };
 
+#define HTT_TX_PDEV_STATS_MLO_ABORT_TLV_SZ(_num_elems) (sizeof(u32) * (_num_elems))
+/* NOTE: Variable length TLV, use length spec to infer array size */
+struct htt_tx_pdev_stats_mlo_abort_tlv_v {
+	u32 mlo_abort_cnt[0]; /* HTT_TX_PDEV_MAX_MLO_ABORT_REASON_STATS */
+};
+
+#define HTT_TX_PDEV_STATS_MLO_TXOP_ABORT_TLV_SZ(_num_elems) (sizeof(u32) * (_num_elems))
+/* NOTE: Variable length TLV, use length spec to infer array size */
+struct htt_tx_pdev_stats_mlo_txop_abort_tlv_v {
+	u32 mlo_txop_abort_cnt[0]; /* HTT_TX_PDEV_MAX_MLO_ABORT_REASON_STATS */
+};
+
 /* NOTE: Variable length TLV, use length spec to infer array size */
 struct htt_tx_pdev_stats_sifs_tlv_v {
 	u32 sifs_status[0]; /* HTT_TX_PDEV_MAX_SIFS_BURST_STATS */
@@ -1946,6 +1966,21 @@ struct htt_rx_pdev_rate_ext_stats_tlv {
 					 [HTT_RX_PDEV_STATS_NUM_BW_EXT_2_COUNTERS];
 };
 
+#define HTT_STATS_CMN_MAC_ID_M 0x000000ff
+#define HTT_STATS_CMN_MAC_ID_S 0
+
+#define HTT_STATS_CMN_MAC_ID_GET(_var)			\
+	(((_var) & HTT_STATS_CMN_MAC_ID_M) >>		\
+	 HTT_STATS_CMN_MAC_ID_S)
+
+#define HTT_STATS_CMN_MAC_ID_SET(_var, _val)			\
+	do {							\
+		HTT_CHECK_SET_VAL(HTT_STATS_CMN_MAC_ID, _val);	\
+		((_var) |= ((_val) << HTT_STATS_CMN_MAC_ID_S));	\
+	} while (0)
+
+#define HTT_RX_UL_MAX_UPLINK_RSSI_TRACK 5
+
 /* == RX PDEV/SOC STATS == */
 struct htt_rx_soc_fw_stats_tlv {
 	u32 fw_reo_ring_data_msdu;
@@ -2645,8 +2680,9 @@ struct htt_rx_pdev_ul_trigger_stats_tlv
 				  [HTT_RX_PDEV_STATS_NUM_BW_COUNTERS];
 };
 
-#define HTT_LATENCY_PROFILE_MAX_HIST		3
-#define HTT_STATS_MAX_PROF_STATS_NAME_LEN	32
+#define HTT_LATENCY_PROFILE_MAX_HIST        3
+#define HTT_STATS_MAX_PROF_STATS_NAME_LEN  32
+#define HTT_INTERRUPTS_LATENCY_PROFILE_MAX_HIST 3
 struct htt_latency_prof_stats_tlv {
 	u32 print_header;
 	u8 latency_prof_name[HTT_STATS_MAX_PROF_STATS_NAME_LEN];
@@ -2811,6 +2847,17 @@ struct htt_txbf_ofdma_ax_steer_stats_tlv
 	struct htt_txbf_ofdma_ax_steer_stats_elem_t ax_steer[1];
 };
 
+struct htt_txbf_ofdma_ax_steer_mpdu_stats_tlv {
+	/* 11AX HE OFDMA MPDUs tried in rbo steering */
+	u32 ax_ofdma_rbo_steer_mpdus_tried;
+	/* 11AX HE OFDMA MPDUs failed in rbo steering */
+	u32 ax_ofdma_rbo_steer_mpdus_failed;
+	/* 11AX HE OFDMA MPDUs tried in sifs steering */
+	u32 ax_ofdma_sifs_steer_mpdus_tried;
+	/* 11AX HE OFDMA MPDUs failed in sifs steering */
+	u32 ax_ofdma_sifs_steer_mpdus_failed;
+};
+
 struct htt_txbf_ofdma_be_ndpa_stats_elem_t {
 	u32 be_ofdma_ndpa_queued;
 	u32 be_ofdma_ndpa_tried;
@@ -2865,6 +2912,17 @@ struct htt_txbf_ofdma_be_steer_stats_tlv
 	struct htt_txbf_ofdma_be_steer_stats_elem_t be_steer[1];
 };
 
+struct htt_txbf_ofdma_be_steer_mpdu_stats_tlv {
+	/* 11BE EHT OFDMA MPDUs tried in rbo steering */
+	u32 be_ofdma_rbo_steer_mpdus_tried;
+	/* 11BE EHT OFDMA MPDUs failed in rbo steering */
+	u32 be_ofdma_rbo_steer_mpdus_failed;
+	/* 11BE EHT OFDMA MPDUs tried in sifs steering */
+	u32 be_ofdma_sifs_steer_mpdus_tried;
+	/* 11BE EHT OFDMA MPDUs failed in sifs steering */
+	u32 be_ofdma_sifs_steer_mpdus_failed;
+};
+
 struct htt_dmac_reset_stats_tlv {
 	u32 reset_count;
 	u32 reset_time_lo_ms;
@@ -2942,6 +3000,71 @@ struct htt_pdev_puncture_stats_tlv {
 	u32 num_subbands_used_cnt[HTT_PUNCTURE_STATS_MAX_SUBBAND_COUNT];
 };
 
+enum {
+	HTT_STATS_CAL_PROF_COLD_BOOT = 0,
+	HTT_STATS_CAL_PROF_FULL_CHAN_SWITCH = 1,
+	HTT_STATS_CAL_PROF_SCAN_CHAN_SWITCH = 2,
+	HTT_STATS_CAL_PROF_DPD_SPLIT_CAL = 3,
+
+	HTT_STATS_MAX_PROF_CAL = 4,
+};
+
+#define HTT_STATS_MAX_CAL_IDX_CNT 8
+struct htt_latency_prof_cal_stats_tlv {
+
+	u8 latency_prof_name[HTT_STATS_MAX_PROF_CAL][HTT_STATS_MAX_PROF_STATS_NAME_LEN];
+
+	/** To verify whether prof cal is enabled or not */
+	u32 enable;
+
+	/** current pdev_id */
+	u32 pdev_id;
+
+	/** The cnt is incremented when each time the calindex takes place */
+	u32 cnt[HTT_STATS_MAX_PROF_CAL][HTT_STATS_MAX_CAL_IDX_CNT];
+
+	/** Minimum time taken to complete the calibration - in us */
+	u32 min[HTT_STATS_MAX_PROF_CAL][HTT_STATS_MAX_CAL_IDX_CNT];
+
+	/** Maximum time taken to complete the calibration -in us */
+	u32 max[HTT_STATS_MAX_PROF_CAL][HTT_STATS_MAX_CAL_IDX_CNT];
+
+	/** Time taken by the cal for its final time execution - in us */
+	u32 last[HTT_STATS_MAX_PROF_CAL][HTT_STATS_MAX_CAL_IDX_CNT];
+
+	/** Total time taken - in us */
+	u32 tot[HTT_STATS_MAX_PROF_CAL][HTT_STATS_MAX_CAL_IDX_CNT];
+
+	/** hist_intvl - by default will be set to 2000 us */
+	u32 hist_intvl[HTT_STATS_MAX_PROF_CAL][HTT_STATS_MAX_CAL_IDX_CNT];
+
+	/**
+	* If last is less than hist_intvl, then hist[0]++,
+	* If last is less than hist_intvl << 1, then hist[1]++,
+	* otherwise hist[2]++.
+	*/
+	u32 hist[HTT_STATS_MAX_PROF_CAL][HTT_STATS_MAX_CAL_IDX_CNT][HTT_INTERRUPTS_LATENCY_PROFILE_MAX_HIST];
+
+	/** Pf_last will log the current no of page faults */
+	u32 pf_last[HTT_STATS_MAX_PROF_CAL][HTT_STATS_MAX_CAL_IDX_CNT];
+
+	/** Sum of all page faults happened */
+	u32 pf_tot[HTT_STATS_MAX_PROF_CAL][HTT_STATS_MAX_CAL_IDX_CNT];
+
+	/** If pf_last > pf_max then pf_max = pf_last */
+	u32 pf_max[HTT_STATS_MAX_PROF_CAL][HTT_STATS_MAX_CAL_IDX_CNT];
+
+	/**
+	* For each cal profile, only certain no of cal indices were invoked,
+	* this member will store what all the indices got invoked per each
+	* cal profile
+	*/
+	u32 enabledCalIdx[HTT_STATS_MAX_PROF_CAL][HTT_STATS_MAX_CAL_IDX_CNT];
+
+	/** No of indices invoked per each cal profile */
+	u32 CalCnt[HTT_STATS_MAX_PROF_CAL];
+};
+
 #define HTT_ML_PEER_DETAILS_NUM_LINKS_M			0x00000003
 #define HTT_ML_PEER_DETAILS_NUM_LINKS_S			0
 #define HTT_ML_PEER_DETAILS_ML_PEER_ID_M		0x00003FFC
@@ -3369,6 +3492,135 @@ struct htt_ml_link_info_tlv {
 	u32 primary_tid_mask;
 };
 
+struct htt_tx_pdev_ppdu_dur_stats_tlv {
+	/** Tx PPDU duration histogram **/
+	u32 tx_ppdu_dur_hist[HTT_PDEV_STATS_PPDU_DUR_HIST_BINS];
+	u32 tx_success_time_us_low;
+	u32 tx_success_time_us_high;
+	u32 tx_fail_time_us_low;
+	u32 tx_fail_time_us_high;
+	u32 pdev_up_time_us_low;
+	u32 pdev_up_time_us_high;
+};
+
+struct htt_rx_pdev_ppdu_dur_stats_tlv {
+	/** Tx PPDU duration histogram **/
+	u32 rx_ppdu_dur_hist[HTT_PDEV_STATS_PPDU_DUR_HIST_BINS];
+};
+
+#define HTT_TX_PDEV_SIFS_BURST_HIST_STATS 10
+#define HTT_TX_PDEV_STATS_SIFS_HIST_TLV_SZ(_num_elems) (sizeof(u32) * (_num_elems))
+
+struct htt_pdev_mbssid_ctrl_frame_stats_tlv {
+	/** mac_id__word:
+	* BIT [ 7 :  0]   :- mac_id
+	*                    Use the HTT_STATS_CMN_MAC_ID_GET,_SET macros to
+	*                    read/write this bitfield.
+	* BIT [31 :  8]   :- reserved
+	*/
+	u32 mac_id__word;
+	u32 basic_trigger_across_bss;
+	u32 basic_trigger_within_bss;
+	u32 bsr_trigger_across_bss;
+	u32 bsr_trigger_within_bss;
+	u32 mu_rts_across_bss;
+	u32 mu_rts_within_bss;
+	u32 ul_mumimo_trigger_across_bss;
+	u32 ul_mumimo_trigger_within_bss;
+};
+
+struct htt_odd_mandatory_pdev_stats_tlv {
+	u32 hw_queued;
+	u32 hw_reaped;
+	u32 hw_paused;
+	u32 hw_filt;
+	u32 seq_posted;
+	u32 seq_completed;
+	u32 underrun;
+	u32 hw_flush;
+	u32 next_seq_posted_dsr;
+	u32 seq_posted_isr;
+	u32 mpdu_cnt_fcs_ok;
+	u32 mpdu_cnt_fcs_err;
+	u32 msdu_count_tqm;
+	u32 mpdu_count_tqm;
+	u32 mpdus_ack_failed;
+	u32 num_data_ppdus_tried_ota;
+	u32 ppdu_ok;
+	u32 num_total_ppdus_tried_ota;
+	u32 thermal_suspend_cnt;
+	u32 dfs_suspend_cnt;
+	u32 tx_abort_suspend_cnt;
+	u32 suspended_txq_mask;
+	u32 last_suspend_reason;
+	u32 seq_failed_queueing;
+	u32 seq_restarted;
+	u32 seq_txop_repost_stop;
+	u32 next_seq_cancel;
+	u32 seq_min_msdu_repost_stop;
+	u32 total_phy_err_cnt;
+	u32 ppdu_recvd;
+	u32 tcp_msdu_cnt;
+	u32 tcp_ack_msdu_cnt;
+	u32 udp_msdu_cnt;
+	u32 fw_tx_mgmt_subtype[HTT_STATS_SUBTYPE_MAX];
+	u32 fw_rx_mgmt_subtype[HTT_STATS_SUBTYPE_MAX];
+	u32 fw_ring_mpdu_err[HTT_RX_STATS_RXDMA_MAX_ERR];
+	u32 urrn_stats[HTT_TX_PDEV_MAX_URRN_STATS];
+	u32 sifs_status[HTT_TX_PDEV_MAX_SIFS_BURST_STATS];
+	u32 sifs_hist_status[HTT_TX_PDEV_SIFS_BURST_HIST_STATS];
+	u32 rx_suspend_cnt;
+	u32 rx_suspend_fail_cnt;
+	u32 rx_resume_cnt;
+	u32 rx_resume_fail_cnt;
+	u32 hwq_beacon_cmd_result[HTT_TX_HWQ_MAX_CMD_RESULT_STATS];
+	u32 hwq_voice_cmd_result[HTT_TX_HWQ_MAX_CMD_RESULT_STATS];
+	u32 hwq_video_cmd_result[HTT_TX_HWQ_MAX_CMD_RESULT_STATS];
+	u32 hwq_best_effort_cmd_result[HTT_TX_HWQ_MAX_CMD_RESULT_STATS];
+	u32 hwq_beacon_mpdu_tried_cnt;
+	u32 hwq_voice_mpdu_tried_cnt;
+	u32 hwq_video_mpdu_tried_cnt;
+	u32 hwq_best_effort_mpdu_tried_cnt;
+	u32 hwq_beacon_mpdu_queued_cnt;
+	u32 hwq_voice_mpdu_queued_cnt;
+	u32 hwq_video_mpdu_queued_cnt;
+	u32 hwq_best_effort_mpdu_queued_cnt;
+	u32 hwq_beacon_mpdu_ack_fail_cnt;
+	u32 hwq_voice_mpdu_ack_fail_cnt;
+	u32 hwq_video_mpdu_ack_fail_cnt;
+	u32 hwq_best_effort_mpdu_ack_fail_cnt;
+	u32 pdev_resets;
+	u32 phy_warm_reset;
+	u32 hwsch_reset_count;
+	u32 phy_warm_reset_ucode_trig;
+	u32 mac_cold_reset;
+	u32 mac_warm_reset;
+	u32 mac_warm_reset_restore_cal;
+	u32 phy_warm_reset_m3_ssr;
+	u32 fw_rx_rings_reset;
+	u32 tx_flush;
+	u32 hwsch_dev_reset_war;
+	u32 mac_cold_reset_restore_cal;
+	u32 mac_only_reset;
+	u32 mac_sfm_reset;
+	u32 tx_ldpc; /* Number of tx PPDUs with LDPC coding */
+	u32 rx_ldpc; /* Number of rx PPDUs with LDPC coding */
+	u32 gen_mpdu_end_reason[HTT_TX_TQM_MAX_GEN_MPDU_END_REASON];
+	u32 list_mpdu_end_reason[HTT_TX_TQM_MAX_LIST_MPDU_END_REASON];
+	u32 tx_mcs[HTT_TX_PDEV_STATS_NUM_MCS_COUNTERS + HTT_TX_PDEV_STATS_NUM_EXTRA_MCS_COUNTERS + HTT_TX_PDEV_STATS_NUM_EXTRA2_MCS_COUNTERS];
+	u32 tx_nss[HTT_TX_PDEV_STATS_NUM_SPATIAL_STREAMS];
+	u32 tx_bw[HTT_TX_PDEV_STATS_NUM_BW_COUNTERS];
+	u32 half_tx_bw[HTT_TX_PDEV_STATS_NUM_BW_COUNTERS];
+	u32 quarter_tx_bw[HTT_TX_PDEV_STATS_NUM_BW_COUNTERS];
+	u32 tx_su_punctured_mode[HTT_TX_PDEV_STATS_NUM_PUNCTURED_MODE_COUNTERS];
+	u32 rx_mcs[HTT_RX_PDEV_STATS_NUM_MCS_COUNTERS + HTT_RX_PDEV_STATS_NUM_EXTRA_MCS_COUNTERS + HTT_RX_PDEV_STATS_NUM_EXTRA2_MCS_COUNTERS];
+	u32 rx_nss[HTT_RX_PDEV_STATS_NUM_SPATIAL_STREAMS];
+	u32 rx_bw[HTT_RX_PDEV_STATS_NUM_BW_COUNTERS];
+	u32 rx_stbc[HTT_RX_PDEV_STATS_NUM_MCS_COUNTERS + HTT_RX_PDEV_STATS_NUM_EXTRA_MCS_COUNTERS + HTT_RX_PDEV_STATS_NUM_EXTRA2_MCS_COUNTERS];
+	u32 rts_cnt;
+	u32 rts_success;
+};
+
 struct htt_phy_counters_tlv {
 	u32 rx_ofdma_timing_err_cnt;
 	u32 rx_cck_fail_cnt;
@@ -3904,4 +4156,77 @@ struct htt_print_sta_ul_ofdma_stats_tlv
				  [HTT_STA_UL_OFDMA_NUM_BW_COUNTERS];
 };

+struct htt_tx_pdev_mu_edca_params_stats_tlv_v {
+	u32 relaxed_mu_edca[HTT_NUM_AC_WMM];
+	u32 mumimo_aggressive_mu_edca[HTT_NUM_AC_WMM];
+	u32 mumimo_relaxed_mu_edca[HTT_NUM_AC_WMM];
+	u32 muofdma_aggressive_mu_edca[HTT_NUM_AC_WMM];
+	u32 muofdma_relaxed_mu_edca[HTT_NUM_AC_WMM];
+	u32 latency_mu_edca[HTT_NUM_AC_WMM];
+	u32 psd_boost_mu_edca[HTT_NUM_AC_WMM];
+};
+
+struct htt_tx_pdev_ap_edca_params_stats_tlv_v {
+	u32 ul_mumimo_less_aggressive[HTT_NUM_AC_WMM];
+	u32 ul_mumimo_medium_aggressive[HTT_NUM_AC_WMM];
+	u32 ul_mumimo_highly_aggressive[HTT_NUM_AC_WMM];
+	u32 ul_mumimo_default_relaxed[HTT_NUM_AC_WMM];
+	u32 ul_muofdma_less_aggressive[HTT_NUM_AC_WMM];
+	u32 ul_muofdma_medium_aggressive[HTT_NUM_AC_WMM];
+	u32 ul_muofdma_highly_aggressive[HTT_NUM_AC_WMM];
+	u32 ul_muofdma_default_relaxed[HTT_NUM_AC_WMM];
+};
+
+struct htt_peer_ax_ofdma_stats_tlv {
+	u32 peer_id;
+	u32 ax_basic_trig_count;
+	u32 ax_basic_trig_err;
+	u32 ax_bsr_trig_count;
+	u32 ax_bsr_trig_err;
+	u32 ax_mu_bar_trig_count;
+	u32 ax_mu_bar_trig_err;
+	u32 ax_basic_trig_with_per;
+	u32 ax_bsr_trig_with_per;
+	u32 ax_mu_bar_trig_with_per;
+		/* is_airtime_large_for_dl_ofdma, is_airtime_large_for_ul_ofdma
+	* These fields contain 2 counters each.  The first element in each
+	* array counts how many times the airtime is short enough to use
+	* OFDMA, and the second element in each array counts how many times the
+	* airtime is too large to select OFDMA for the PPDUs involving the peer.
+	*/
+	u32 is_airtime_large_for_dl_ofdma[2];
+	u32 is_airtime_large_for_ul_ofdma[2];
+	/* Last updated value of DL and UL queue depths for each peer per AC */
+	u32 last_updated_dl_qdepth[HTT_NUM_AC_WMM];
+	u32 last_updated_ul_qdepth[HTT_NUM_AC_WMM];
+};
+
+struct htt_pdev_sched_algo_ofdma_stats_tlv {
+	/**
+	 * BIT [ 7 :  0]   :- mac_id
+	 * BIT [31 :  8]   :- reserved
+	 */
+	union {
+		struct {
+			u32 mac_id:8,
+			reserved:24;
+		};
+		u32 mac_id__word;
+	};
+	u32 rate_based_dlofdma_enabled_count[HTT_NUM_AC_WMM];
+	u32 rate_based_dlofdma_disabled_count[HTT_NUM_AC_WMM];
+	u32 rate_based_dlofdma_probing_count[HTT_NUM_AC_WMM];
+	u32 rate_based_dlofdma_monitoring_count[HTT_NUM_AC_WMM];
+	u32 chan_acc_lat_based_dlofdma_enabled_count[HTT_NUM_AC_WMM];
+	u32 chan_acc_lat_based_dlofdma_disabled_count[HTT_NUM_AC_WMM];
+	u32 chan_acc_lat_based_dlofdma_monitoring_count[HTT_NUM_AC_WMM];
+	u32 downgrade_to_dl_su_ru_alloc_fail[HTT_NUM_AC_WMM];
+	u32 candidate_list_single_user_disable_ofdma[HTT_NUM_AC_WMM];
+	u32 dl_cand_list_dropped_high_ul_qos_weight[HTT_NUM_AC_WMM];
+	u32 ax_dlofdma_disabled_due_to_pipelining[HTT_NUM_AC_WMM];
+	u32 dlofdma_disabled_su_only_eligible[HTT_NUM_AC_WMM];
+	u32 dlofdma_disabled_consec_no_mpdus_tried[HTT_NUM_AC_WMM];
+	u32 dlofdma_disabled_consec_no_mpdus_success[HTT_NUM_AC_WMM];
+};
+
 #endif
