From 5f7bd379d845451a0c5257a6111a21cf572fb0e5 Mon Sep 17 00:00:00 2001
From: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
Date: Mon, 8 Apr 2024 09:39:05 -0700
Subject: [PATCH 1/2] ath12k: clean up bonded model for Direct Switching

Clean up Bonded model specific changes, which were added for
supporting Direct Switching (DS) in ath12k. This will be useful
for DS re-design using new PPE apis. Rename few functions as
necessary.

Currently DS specific functions are disabled using the module
param ppe_ds_enable which can be enabled during development. As
new DS design gets implemented, DS framework is not expected to
work functionally and developers need to enabled only on need
basis.

Some functions, although not directly related to bonded model
are deleted to enable compilation and will be added back with
new DS design in future.

Partially revert I5fb340ff346 ("ath12k: Add support for Bonded
	interface")

Signed-off-by: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
---
 drivers/net/wireless/ath/ath12k/Kconfig   |    9 -
 drivers/net/wireless/ath/ath12k/Makefile  |    1 -
 drivers/net/wireless/ath/ath12k/ahb.c     |    4 -
 drivers/net/wireless/ath/ath12k/bondif.c  | 1241 ---------------------
 drivers/net/wireless/ath/ath12k/bondif.h  |   55 -
 drivers/net/wireless/ath/ath12k/core.c    |  111 +-
 drivers/net/wireless/ath/ath12k/core.h    |   49 +-
 drivers/net/wireless/ath/ath12k/debugfs.c |   36 -
 drivers/net/wireless/ath/ath12k/dp.c      |   10 +-
 drivers/net/wireless/ath/ath12k/dp_mon.c  |   62 +-
 drivers/net/wireless/ath/ath12k/dp_rx.c   |   19 +-
 drivers/net/wireless/ath/ath12k/dp_tx.c   |    3 +-
 drivers/net/wireless/ath/ath12k/mac.c     |   99 +-
 drivers/net/wireless/ath/ath12k/pci.c     |    5 +-
 drivers/net/wireless/ath/ath12k/peer.c    |    5 +-
 drivers/net/wireless/ath/ath12k/peer.h    |    2 +-
 drivers/net/wireless/ath/ath12k/ppe.c     |  212 +---
 drivers/net/wireless/ath/ath12k/ppe.h     |   23 +-
 drivers/net/wireless/ath/ath12k/vendor.c  |    6 +-
 drivers/net/wireless/ath/ath12k/vendor.h  |    2 +
 drivers/net/wireless/ath/ath12k/wmi.h     |    7 +-
 21 files changed, 156 insertions(+), 1805 deletions(-)
 delete mode 100644 drivers/net/wireless/ath/ath12k/bondif.c
 delete mode 100644 drivers/net/wireless/ath/ath12k/bondif.h

--- a/drivers/net/wireless/ath/ath12k/Kconfig
+++ b/drivers/net/wireless/ath/ath12k/Kconfig
@@ -92,15 +92,6 @@ config ATH12K_PPE_DS_SUPPORT
 
 		Say Y to enable PPE DS Support. If unsure, say N.
 
-config ATH12K_BONDED_DS_SUPPORT
-	bool "QTI ath12k bonded-ds support"
-	depends on ATH12K_DEBUGFS
-	depends on RELAY
-	help
-		Enable ath12k Bonded-DS support
-
-		Say Y to enable Bonded DS Support. If unsure, say N.
-
 config ATH12K_SAWF
 	bool "ath12k Service Aware WiFi Framework and Telemetry support"
 	depends on ATH12K
--- a/drivers/net/wireless/ath/ath12k/Makefile
+++ b/drivers/net/wireless/ath/ath12k/Makefile
@@ -34,7 +34,6 @@ ath12k-$(CPTCFG_WANT_DEV_COREDUMP) += co
 ath12k-$(CPTCFG_ATH12K_PKTLOG) += pktlog.o
 ath12k-$(CPTCFG_ATH12K_AHB) += ahb.o
 ath12k-$(CPTCFG_ATH12K_PPE_DS_SUPPORT) += ppe.o
-ath12k-$(CPTCFG_ATH12K_BONDED_DS_SUPPORT) += bondif.o
 ath12k-$(CPTCFG_ATH12K_SAWF) += sawf.o telemetry.o telemetry_agent_if.o
 ath12k-$(CPTCFG_ATH12K_CFR) += cfr.o
 
--- a/drivers/net/wireless/ath/ath12k/ahb.c
+++ b/drivers/net/wireless/ath/ath12k/ahb.c
@@ -17,7 +17,6 @@
 #include <linux/remoteproc.h>
 #include <linux/soc/qcom/smem.h>
 #include <linux/soc/qcom/smem_state.h>
-#include "bondif.h"
 
 static const struct of_device_id ath12k_ahb_of_match[] = {
 	{ .compatible = "qcom,ipq5332-wifi",
@@ -1051,9 +1050,6 @@ static int ath12k_ahb_probe(struct platf
 		bus_type = ATH12K_BUS_AHB;
 		break;
 	case ATH12K_HW_QCN6432_HW10:
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
-		ath12k_bond_enable_ppe_ds();
-#endif
 		hif_ops = &ath12k_ahb_hif_ops_qcn6432;
 		bus_params = &ath12k_internal_pci_bus_params;
 		bus_type = ATH12K_BUS_HYBRID;
--- a/drivers/net/wireless/ath/ath12k/bondif.c
+++ /dev/null
@@ -1,1241 +0,0 @@
-// SPDX-License-Identifier: BSD-3-Clause-Clear
-/*
- * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
- */
-
-#include <net/mac80211.h>
-#include <linux/module.h>
-#include <net/bonding.h>
-#include <linux/ieee80211.h>
-#include <linux/if_vlan.h>
-#include "core.h"
-#include "ppe.h"
-#include "bondif.h"
-#include "debug.h"
-#include "dp_tx.h"
-#include "peer.h"
-
-static const struct net_device_ops ieee80211_link_dataif_8023_ops;
-extern struct ath12k_link_vif *ath12k_mac_assign_link_vif( struct ath12k_hw *ah,
-					struct ieee80211_vif *vif, u8 link_id);
-extern int g_bonded_interface_model;
-extern bool ath12k_mac_tx_check_max_limit(struct ath12k *ar, struct sk_buff *skb);
-
-void ath12k_bond_enable_ppe_ds(void)
-{
-	if (ath12k_frame_mode == ATH12K_HW_TXRX_RAW ||
-	   ath12k_frame_mode == ATH12K_HW_TXRX_NATIVE_WIFI) {
-			ath12k_mlo_capable = 1;
-	}
-
-	if (ath12k_mlo_capable == 2) {
-		ath12k_mlo_capable = 1;
-		g_bonded_interface_model = ath12k_mlo_capable;
-		ath12k_ppe_ds_enabled = 1;
-		driver_bond_dev_cb = ath12k_bond_dev_cb;
-	} else if (ath12k_mlo_capable == 1 && g_bonded_interface_model != 1) {
-		g_bonded_interface_model = 0;
-		driver_bond_dev_cb = NULL;
-	}
-
-	ath12k_info(NULL, "g_bonded_interface_model %d ath12k_mlo_capable %d\n",
-			g_bonded_interface_model, ath12k_mlo_capable);
-}
-
-void ath12k_bond_disable_ppe_ds(void)
-{
-	g_bonded_interface_model = 0;
-	driver_bond_dev_cb = NULL;
-}
-
-static void ath12k_ieee80211_if_free(struct net_device *dev)
-{
-	free_percpu(dev->tstats);
-}
-
-static void ath12k_ieee80211_if_setup(struct net_device *dev)
-{
-	ether_setup(dev);
-	dev->priv_flags &= ~IFF_TX_SKB_SHARING;
-	dev->netdev_ops = &ieee80211_link_dataif_8023_ops;
-	netdev_set_priv_destructor(dev, ath12k_ieee80211_if_free);
-}
-
-static bool ath12k_ppe_vp_set_mtu(struct net_device *dev, struct ath12k_link_vif *arvif,
-				  const int mtu)
-{
-	if (!arvif->ndev_pvt->vp_num)
-		return true;
-
-	if (ppe_vp_mtu_set(arvif->ndev_pvt->vp_num, mtu) != PPE_VP_STATUS_SUCCESS) {
-		ath12k_err(NULL, "Setting mtu to %d for link_ndev:%s (vp num:%d) failed\n",
-			   mtu, arvif->ndev_pvt->link_ndev->name,
-			   arvif->ndev_pvt->vp_num);
-		return false;
-	}
-
-	return true;
-}
-
-static bool ath12k_dst_ppe_vp(struct net_device *dev,
-                                         struct sk_buff *skb, void *cb_data)
-{
-	if (unlikely(dev == NULL)) {
-		dev_kfree_skb_any(skb);
-		return false;
-	}
-
-	skb->dev = dev;
-	dev_queue_xmit(skb);
-
-	return true;
-}
-
-int ath12k_bond_link_enslave(struct ath12k_link_vif *arvif, struct net_device *link_dev)
-{
-	struct ath12k_link_vif_pvt *link_ndev_pvt = NULL;
-	int ret;
-
-	if (!g_bonded_interface_model)
-		return 0;
-
-	link_ndev_pvt = netdev_priv(link_dev);
-
-	ath12k_info(NULL, "Enslave bond_dev %px link_ndev %px\n", link_ndev_pvt->bond_dev, link_dev);
-	ret = bond_enslave(link_ndev_pvt->bond_dev, link_dev, NULL);
-	if (ret) {
-		arvif->ndev_pvt->is_bond_enslaved = false;
-		ath12k_err(NULL, "Error bond enslave error\n");
-		return -EINVAL;
-	}
-	else {
-		arvif->ndev_pvt->is_bond_enslaved = true;
-		ath12k_info(NULL, "Successfully enslaved link_ndev %s %px\n",
-			    link_dev->name, link_dev);
-	}
-
-	return 0;
-}
-
-void ath12k_bond_link_release(struct ath12k_link_vif *arvif)
-{
-	struct ath12k_link_vif_pvt *link_ndev_pvt = NULL;
-	int err;
-
-	if (!g_bonded_interface_model)
-		return;
-
-	if (!arvif->ndev_pvt || !arvif->ndev_pvt->link_ndev) {
-		ath12k_err(NULL, "ERR no link dev for this vif to release from bond\n");
-		return;
-	}
-
-	link_ndev_pvt = netdev_priv(arvif->ndev_pvt->link_ndev);
-	if (link_ndev_pvt && link_ndev_pvt->bond_dev) {
-		ath12k_info(NULL, "Bond_release link netdevice %s link ndev %px \n",
-			    arvif->ndev_pvt->link_ndev->name, arvif->ndev_pvt->link_ndev);
-
-		/* bond_release expects slave netdevices to be in down state */
-		link_ndev_pvt->link_ndev->flags &= ~IFF_UP;
-		err = bond_release(link_ndev_pvt->bond_dev, link_ndev_pvt->link_ndev);
-		if (err) {
-			ath12k_err(NULL, "Error bond release link ndev:%s from bond ndev:%s: due to err: %d\n",
-				   link_ndev_pvt->link_ndev->name,
-				   link_ndev_pvt->bond_dev->name, err);
-			return;
-		}
-		arvif->ndev_pvt->is_bond_enslaved = false;
-	} else {
-		ath12k_err(NULL, "ERR unable to release Bond %s link ndev %px \n",
-			   arvif->ndev_pvt->link_ndev->name, arvif->ndev_pvt->link_ndev);
-	}
-}
-
-static bool ath12k_stats_update_ppe_vp(struct net_device *dev, ppe_vp_hw_stats_t *vp_stats)
-{
-	struct pcpu_sw_netstats *tstats = this_cpu_ptr(netdev_tstats(dev));
-	u64_stats_update_begin(&tstats->syncp);
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0))
-	tstats->tx_packets += vp_stats->tx_pkt_cnt;
-	tstats->tx_bytes += vp_stats->tx_byte_cnt;
-	tstats->rx_packets += vp_stats->rx_pkt_cnt;
-	tstats->rx_bytes += vp_stats->rx_byte_cnt;
-#else
-	u64_stats_add(&tstats->tx_packets, vp_stats->tx_pkt_cnt);
-	u64_stats_add(&tstats->tx_bytes, vp_stats->tx_byte_cnt);
-	u64_stats_add(&tstats->rx_packets, vp_stats->rx_pkt_cnt);
-	u64_stats_add(&tstats->rx_bytes, vp_stats->rx_byte_cnt);
-#endif
-	u64_stats_update_end(&tstats->syncp);
-	return true;
-}
-
-void ath12k_enable_ppe_for_link_netdev(struct ath12k_base *ab,
-				      struct ath12k_link_vif *arvif,
-				      struct net_device *link_dev)
-{
-	struct ppe_vp_ai vpai;
-	struct ieee80211_ppe_vp_ds_params vp_params = {0};
-	struct ath12k_link_vif_pvt *link_ndev_pvt = NULL;
-	int ret;
-	int ppe_vp_num = -1;
-
-	arvif->ppe_vp_num = -1;
-	arvif->ppe_vp_type = -1;
-	if (!g_bonded_interface_model)
-		return;
-
-	if (!arvif->ar) {
-		ath12k_warn(ab, "failed to enable ds for link id %d \n",
-				arvif->link_id);
-		return;
-	}
-
-	memset(&vpai, 0, sizeof(struct ppe_vp_ai));
-
-	vpai.type = PPE_VP_TYPE_SW_L2;
-	vpai.dst_cb = ath12k_dst_ppe_vp;
-	vpai.dst_cb_data = arvif;
-	vpai.src_cb = NULL;
-	vpai.src_cb_data = NULL;
-	vpai.stats_cb = ath12k_stats_update_ppe_vp;
-	vpai.queue_num = 0;
-	vpai.net_dev_type = PPE_VP_NET_DEV_TYPE_WIFI;
-	link_ndev_pvt = netdev_priv(link_dev);
-
-	vpai.core_mask = ATH12K_PPE_DS_DEFAULT_CORE_MASK;
-	vp_params.dev = link_dev;
-
-	if (test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &arvif->ar->ab->dev_flags)) {
-		vpai.usr_type = PPE_VP_USER_TYPE_DS;
-
-		ret = ath12k_mac_op_ppeds_attach_vdev(arvif, &vpai,
-						      &ppe_vp_num, &vp_params);
-		if (ret) {
-			ath12k_err(NULL, "Error in enabling DS for arvif %pM\n", arvif->addr);
-			return;
-		}
-		arvif->ppe_vp_type = PPE_VP_USER_TYPE_DS;
-		link_ndev_pvt->ppe_vp_profile_idx = vp_params.ppe_vp_profile_idx;
-		link_ndev_pvt->vp_num = ppe_vp_num;
-		arvif->ppe_vp_num = ppe_vp_num;
-		ath12k_dbg(ab, ATH12K_DBG_PPE,
-			   "Enabling DS index %d vp %d link_id %d %pM core_mask 0x%x\n",
-			   vp_params.ppe_vp_profile_idx, ppe_vp_num,
-			   arvif->link_id, arvif->addr, vpai.core_mask);
-	} else {
-		vpai.usr_type = PPE_VP_USER_TYPE_ACTIVE;
-
-		ppe_vp_num = ppe_vp_alloc(vp_params.dev, &vpai);
-		if (ppe_vp_num <= 0) {
-			ath12k_err(NULL, "Error in enabling Active VP for arvif %pM\n", arvif->addr);
-			return;
-		}
-		link_ndev_pvt->vp_num = ppe_vp_num;
-		arvif->ppe_vp_num = ppe_vp_num;
-		arvif->ppe_vp_type = vpai.usr_type;
-		ath12k_dbg(ab, ATH12K_DBG_PPE,
-			   "Enabling Active VP for arvif %pM dev %s vp_num %d core_mask 0x%x\n",
-			   arvif->addr, vp_params.dev->name,
-			   arvif->ppe_vp_num, vpai.core_mask);
-	}
-
-	return;
-}
-
-void ath12k_disable_ppe_for_link_netdev(struct ath12k_base *ab,
-				       struct ath12k_link_vif *arvif,
-				       struct net_device *link_dev)
-{
-	struct ieee80211_ppe_vp_ds_params vp_params = {0};
-	struct ath12k_link_vif_pvt *link_ndev_pvt = NULL;
-
-	if (!g_bonded_interface_model)
-		return;
-
-	if (!arvif->ar) {
-		ath12k_warn(ab, "failed to disable ds for link id %d \n",
-				arvif->link_id);
-		return;
-	}
-
-	if (!arvif->ndev_pvt || !arvif->ndev_pvt->link_ndev) {
-		ath12k_err(NULL, "ERR no link dev for this vif to disable DS.\n");
-		return;
-	}
-
-	link_ndev_pvt = netdev_priv(link_dev);
-	vp_params.ppe_vp_profile_idx = link_ndev_pvt->ppe_vp_profile_idx;
-	if (arvif->ppe_vp_num == -1)
-		return;
-
-	if (test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags)) {
-		ath12k_mac_op_ppeds_detach_vdev(arvif, &vp_params);
-		if (arvif->ppe_vp_type != PPE_VP_USER_TYPE_DS)
-			ppe_vp_free(arvif->ppe_vp_num);
-
-	} else {
-		ppe_vp_free(arvif->ppe_vp_num);
-	}
-
-	ath12k_dbg(ab, ATH12K_DBG_PPE,
-		   "Destroyed PPE VP port type %d no:%d for dev:%s\n",
-		   arvif->ppe_vp_type, arvif->ppe_vp_num, link_dev->name);
-	arvif->ppe_vp_num = -1;
-	arvif->ppe_vp_type = -1;
-}
-
-static const struct ath12k_base *
-ath12k_get_core_ab_from_link_ndev_pvt(struct ieee80211_vif *vif,
-				      const int link_num)
-{
-	struct net_device *link_ndev;
-	struct ath12k_link_vif_pvt *arvif_pvt = NULL;
-
-	if (!vif)
-		return false;
-
-	mutex_lock(&vif->bond_mutex);
-
-	link_ndev = vif->link_ndev[link_num];
-	if (link_ndev) {
-		arvif_pvt = netdev_priv(link_ndev);
-		if (arvif_pvt && arvif_pvt->ab)
-			ath12k_info(NULL, "Get core AB:%pV of Link ndev:%s\n",
-				    arvif_pvt->ab->dev, link_ndev->name);
-	}
-
-	mutex_unlock(&vif->bond_mutex);
-
-	return arvif_pvt ? arvif_pvt->ab : NULL;
-}
-
-static bool ath12k_is_core_recovery_in_progress(const struct ath12k_base *ab)
-{
-	if (ab && test_bit(ATH12K_FLAG_RECOVERY, &ab->dev_flags)) {
-		ath12k_warn(ab, "Skip: link netdev allocation during recovery\n");
-		return true;
-	}
-
-	return false;
-}
-
-int ath12k_mac_op_change_vif_links(struct ieee80211_hw *hw,
-					  struct ieee80211_vif *vif,
-					  u16 old_links, u16 new_links,
-					  struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS])
-{
-	u16  new_link_id;
-	struct wireless_dev *wdev = ieee80211_vif_to_wdev(vif);
-	struct net_device *cp_netdev = wdev->netdev;
-	struct ath12k_link_vif_pvt *link_ndev_pvt = NULL;
-	struct net_device *link_ndev;
-	struct ath12k_mld_dev *mldev = NULL;
-	u16 link_num;
-	struct net_device *bond_dev = NULL;
-	char name[20] = {0};
-	int ret = 0, chip_id = 0, pdev_id = 0;
-	struct ath12k_link_vif *arvif = NULL;
-	struct ath12k_base *tmp_ab = NULL;
-
-	if (!g_bonded_interface_model)
-		return 0;
-
-	bond_dev = wdev->bond_netdev;
-	if (!bond_dev)
-		return 0;
-	mldev = bond_get_mlo_ctx(bond_dev);
-
-	new_link_id = new_links ^ old_links;
-	link_num =  ffs(new_link_id) - 1;
-	/* TODO: Do this assignment only for the Add link case */
-	tmp_ab = ath12k_get_core_ab_from_link_ndev_pvt(vif, link_num);
-
-	if (new_links > old_links)  {
-		if (ath12k_is_core_recovery_in_progress(tmp_ab))
-			return 0;
-
-		/* Add Link operation */
-		snprintf(name, sizeof(name), "%s_l%d", cp_netdev->name, link_num);
-		link_ndev = alloc_netdev_mqs(sizeof (struct ath12k_link_vif_pvt), name, NET_NAME_ENUM, ath12k_ieee80211_if_setup, 1, 1);
-		if (!link_ndev) {
-			ath12k_err(NULL, "ERR: link netdev allocation failed\n");
-			//TODO: Graceful cleanup
-			return -EINVAL;
-		}
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0))
-		memcpy(&link_ndev->perm_addr, wdev->links[link_num].addr, ETH_ALEN);
-		link_ndev->dev_addr = &link_ndev->perm_addr;
-#else
-		dev_addr_set(link_ndev, wdev->links[link_num].addr);
-#endif
-		link_ndev_pvt = netdev_priv(link_ndev);
-		memset(link_ndev_pvt, 0, sizeof(*link_ndev_pvt));
-		link_ndev->netdev_ops = &ieee80211_link_dataif_8023_ops;
-		link_ndev_pvt->hw = hw;
-		link_ndev_pvt->link_ndev = link_ndev;
-		link_ndev_pvt->bond_dev = bond_dev;
-		link_ndev_pvt->is_started = false;
-		link_ndev_pvt->is_bond_enslaved = false;
-		mldev->vif = vif;
- 		mldev->ahvif = ath12k_vif_to_ahvif(vif);
-		mutex_lock(&vif->bond_mutex);
-		vif->link_ndev[link_num] = link_ndev;
-		mutex_unlock(&vif->bond_mutex);
-		link_ndev->max_mtu = IEEE80211_MAX_DATA_LEN;
-		link_ndev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);
-		ret = register_netdevice(link_ndev);
-		if (ret) {
-			ath12k_err(NULL, "Error register link netdevice\n");
-			//TODO: Graceful cleanup
-			return -EINVAL;
-		}
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0))
-		memcpy(&bond_dev->perm_addr, vif->addr, ETH_ALEN);
-		bond_dev->dev_addr = &bond_dev->perm_addr;
-#else
-		dev_addr_set(bond_dev, vif->addr);
-#endif
-		if (mldev && !mldev->mcast_dev_set) {
-			mldev->mcast_dev_set = true;
-			mldev->primary_chipid = chip_id;
-			mldev->primary_pdevid = pdev_id;
-		}
-		if (mldev)
-			mldev->link_dev[chip_id][pdev_id] =  link_ndev;
-
-	} else {
-		/* Delete Link operation */
-		mutex_lock(&vif->bond_mutex);
-		link_ndev = vif->link_ndev[link_num];
-		if (link_ndev) {
-			link_ndev_pvt = netdev_priv(link_ndev);
-			if (link_ndev_pvt->is_bond_enslaved) {
-				arvif = link_ndev_pvt->arvif;
-				tmp_ab = arvif->ab;
-				ath12k_bond_link_release(link_ndev_pvt->arvif);
-				if (link_ndev_pvt->vp_num)
-					ath12k_disable_ppe_for_link_netdev(tmp_ab, arvif,
-									   arvif->ndev_pvt->link_ndev);
-			}
-			ath12k_info(NULL, "Unregister link netdevice %s link ndev %p link_num %d\n",
-				    link_ndev->name, link_ndev, link_num);
-			unregister_netdevice(link_ndev);
-			link_ndev_pvt->link_ndev = NULL;
-			vif->link_ndev[link_num] = NULL;
-		} else {
-			ath12k_err(NULL, "ERR Unregister link netdevice %s link ndev %p link_num %d\n",
-				   link_ndev->name, link_ndev, link_num);
-		}
-		mutex_unlock(&vif->bond_mutex);
-	}
-	ath12k_info(NULL, "%s:%d link changed for MLD %pM old 0x%x new 0x%x\n", __func__, __LINE__,
-		    vif->addr, old_links, new_links);
-	return 0;
-}
-
-
-static struct net_device *ath12k_mac_get_tx_link_netdev(struct ath12k_mld_dev *mldev, u8 *dst_mac_addr)
-{
-	struct net_device *ndev = NULL, *dvlan_ndev;
-	struct ieee80211_sta *sta;
-	struct ath12k_sta *ahsta;
-	struct ath12k_vif *ahvif = ath12k_vif_to_ahvif(mldev->vif);
-
-	rcu_read_lock();
-	sta = ieee80211_find_sta(mldev->vif, dst_mac_addr);
-
-	if (!sta) {
-		rcu_read_unlock();
-		ndev = mldev->vif->link_ndev[ahvif->deflink.link_id];
-		ath12k_dbg(NULL, ATH12K_DBG_DP_TX, "(%s,%d) PPE %s:%d ahvif->deflink.link_id %d dev %s\n",
-				current->comm, current->pid, __func__, __LINE__,
-				ahvif->deflink.link_id, ndev->name);
-		return ndev;
-	}
-
-	ahsta = ath12k_sta_to_ahsta(sta);
-
-	if (!sta->mlo) {
-		ndev = mldev->vif->link_ndev[ahsta->deflink.link_id];
-		//todo: check changing addr3 needed as in ath12k_mac_get_tx_link
-
-		ath12k_dbg(NULL, ATH12K_DBG_DP_TX, "(%s,%d) PPE %s:%d pkt delivered to sta.deflink.link_id %d dev %s\n",
-				current->comm, current->pid, __func__, __LINE__,
-				ahsta->deflink.link_id, ndev->name);
-		goto dvlan_check;
-	}
-
-	if (sta) {
-		ndev = mldev->vif->link_ndev[ahsta->primary_link_id];
-		ath12k_dbg(NULL, ATH12K_DBG_DP_TX, "[%s] %s:%d deliver packets for sta %pM ahsta->primary_link_id %d ndev %s\n",
-			   current->comm, __func__, __LINE__,
-			   sta, ahsta->primary_link_id, ndev->name);
-	}
-
-dvlan_check:
-	dvlan_ndev = ieee80211_sta_get_dvlan_iface(sta);
-	if (dvlan_ndev)
-		ndev = dvlan_ndev;
-
-	rcu_read_unlock();
-
-	/* TODO: Verify what happens with NULL. Understand what is the fall back*/
-	return ndev;
-}
-
-static void ath12k_dp_tx_release_txbuf(struct ath12k_dp *dp,
-				       struct ath12k_tx_desc_info *tx_desc,
-				       u8 ring_id)
-{
-	tx_desc->skb = NULL;
-	tx_desc->skb_ext_desc = NULL;
-	spin_lock_bh(&dp->tx_desc_lock[ring_id]);
-	tx_desc->in_use = false;
-	list_add_tail(&tx_desc->list, &dp->tx_desc_free_list[ring_id]);
-	spin_unlock_bh(&dp->tx_desc_lock[ring_id]);
-}
-
-static inline
-struct ath12k_tx_desc_info *ath12k_dp_tx_assign_buffer(struct ath12k_dp *dp,
-							      u8 pool_id)
-{
-	struct ath12k_tx_desc_info *desc = NULL;
-
-	spin_lock_bh(&dp->tx_desc_lock[pool_id]);
-	desc = list_first_entry_or_null(&dp->tx_desc_free_list[pool_id],
-					struct ath12k_tx_desc_info,
-					list);
-	if (!desc) {
-		ath12k_dbg(dp->ab, ATH12K_DBG_DP_TX, "failed to allocate data Tx desc\n");
-		spin_unlock_bh(&dp->tx_desc_lock[pool_id]);
-		return NULL;
-	}
-
-	prefetch(desc);
-	list_del(&desc->list);
-	desc->in_use = true;
-	spin_unlock_bh(&dp->tx_desc_lock[pool_id]);
-
-	return desc;
-}
-
-int ath12k_mcast_dp_tx(struct ath12k *ar, struct ath12k_link_vif *arvif,
-		       struct sk_buff *skb, bool gsn_valid, int mcbc_gsn)
-{
-	struct ath12k_vif *ahvif = arvif->ahvif;
-	struct ath12k_base *ab = ar->ab;
-	struct ath12k_dp *dp = &ab->dp;
-	struct hal_tx_info ti = {0};
-	struct ath12k_tx_desc_info *tx_desc = NULL;
-	struct ath12k_skb_cb *skb_cb = ATH12K_SKB_CB(skb);
-	struct hal_srng *tcl_ring;
-	struct dp_tx_ring *tx_ring;
-	void *hal_tcl_desc;
-	struct hal_tcl_data_cmd *tcl_cmd;
-	u8 hal_ring_id;
-	int ret;
-
-	if (unlikely(test_bit(ATH12K_FLAG_CRASH_FLUSH, &ar->ab->dev_flags))) {
-		return -ESHUTDOWN;
-	}
-
-	ti.ring_id =
-		ab->hw_params->hw_ops->get_ring_selector(skb);
-
-	tx_ring = &dp->tx_ring[ti.ring_id];
-
-	tx_desc = ath12k_dp_tx_assign_buffer(dp, ti.ring_id);
-	if (unlikely(!tx_desc)) {
-		ab->soc_stats.tx_err.txbuf_na[ti.ring_id]++;
-		return -ENOMEM;
-	}
-
-	ATH12K_SKB_CB(skb)->link_id = arvif->link_id;
-	ti.bank_id = arvif->bank_id;
-	ti.meta_data_flags = arvif->tcl_metadata;
-
-	if (gsn_valid) {
-		ti.meta_data_flags = u32_encode_bits(HTT_TCL_META_DATA_TYPE_GLOBAL_SEQ_NUM,
-						     HTT_TCL_META_DATA_TYPE_MISSION) |
-				     u32_encode_bits(mcbc_gsn, HTT_TCL_META_DATA_GLOBAL_SEQ_NUM);
-		ti.vdev_id = arvif->vdev_id +
-			     HTT_TX_MLO_MCAST_HOST_REINJECT_BASE_VDEV_ID;
-	} else {
-		ti.vdev_id = arvif->vdev_id;
-	}
-
-	ti.encap_type = HAL_TCL_ENCAP_TYPE_ETHERNET;
-	ti.addr_search_flags = arvif->hal_addr_search_flags;
-	ti.search_type = arvif->search_type;
-	ti.type = HAL_TCL_DESC_TYPE_BUFFER;
-
-	if (likely(skb->ip_summed == CHECKSUM_PARTIAL &&
-		   ti.encap_type != HAL_TCL_ENCAP_TYPE_RAW)) {
-		ti.flags0 |= TX_IP_CHECKSUM;
-	}
-
-	ti.paddr = dma_map_single(ab->dev, skb->data, skb->len, DMA_TO_DEVICE);
-	if (unlikely(dma_mapping_error(ab->dev, ti.paddr))) {
-		atomic_inc(&ab->soc_stats.tx_err.misc_fail);
-		ath12k_warn(ab, "failed to DMA map data Tx buffer\n");
-		ret = -ENOMEM;
-		goto fail_remove_tx_buf;
-	}
-
-
-	/* Add metadata for sw encrypted vlan group traffic */
-
-	tx_desc->skb = skb;
-	tx_desc->mac_id = ar->pdev_idx;
-	tx_desc->recycler_fast_xmit = 0;
-	ti.desc_id = tx_desc->desc_id;
-	ti.data_len = skb->len - ti.pkt_offset;
-	skb_cb->paddr = ti.paddr;
-	skb_cb->vif = ahvif->vif;
-
-	hal_ring_id = tx_ring->tcl_data_ring.ring_id;
-	tcl_ring = &ab->hal.srng_list[hal_ring_id];
-
-	spin_lock_bh(&tcl_ring->lock);
-	ath12k_hal_srng_access_src_ring_begin_nolock(tcl_ring);
-	hal_tcl_desc = ath12k_hal_srng_src_get_next_entry(ab, tcl_ring);
-	if (unlikely(!hal_tcl_desc)) {
-		/* NOTE: It is highly unlikely we'll be running out of tcl_ring
-		 * desc because the desc is directly enqueued onto hw queue.
-		 */
-		ath12k_hal_srng_access_umac_src_ring_end_nolock(tcl_ring);
-		spin_unlock_bh(&tcl_ring->lock);
-		ab->soc_stats.tx_err.desc_na[ti.ring_id]++;
-		ret = -ENOMEM;
-
-		goto fail_unmap_dma;
-	}
-
-	ab->soc_stats.tx_enqueued[ti.ring_id]++;
-	arvif->link_stats.tx_encap_type[ti.encap_type]++;
-	arvif->link_stats.tx_encrypt_type[ti.encrypt_type]++;
-	arvif->link_stats.tx_desc_type[ti.type]++;
-	tcl_cmd = (struct hal_tcl_data_cmd *)hal_tcl_desc;
-
-	tcl_cmd->buf_addr_info.info0 = (u32)ti.paddr;
-	/* TODO: Copy the upper 8 bits here */
-	tcl_cmd->buf_addr_info.info1 = (ti.desc_id << 12);
-	tcl_cmd->info0 = (ti.type << 1) | arvif->desc.info0;
-	tcl_cmd->info1 = ti.meta_data_flags << 16;
-	tcl_cmd->info2 = ti.flags0 | ti.data_len;
-
-	/* In tcl_cmd->info3, Bit 24 to 31 represents vdev_id
-	 * LSH 24 times to add updated vdev_id to info3
-	 */
-	tcl_cmd->info3 = (ti.vdev_id << 24) | arvif->desc.info3;
-	tcl_cmd->info4 = arvif->desc.info4;
-	tcl_cmd->info5 = 0;
-
-	dsb(st);
-	ath12k_hal_srng_access_umac_src_ring_end_nolock(tcl_ring);
-	spin_unlock_bh(&tcl_ring->lock);
-
-	ath12k_dbg_dump(ab, ATH12K_DBG_DP_TX, NULL, "dp tx msdu: ", skb->data, skb->len);
-	arvif->link_stats.tx_enqueued++;
-	atomic_inc(&ar->dp.num_tx_pending);
-	atomic_inc(&ab->ag->num_dp_tx_pending);
-
-	return 0;
-
-fail_unmap_dma:
-	dma_unmap_single(ab->dev, skb_cb->paddr, skb->len, DMA_TO_DEVICE);
-
-fail_remove_tx_buf:
-	ath12k_dp_tx_release_txbuf(dp, tx_desc, ti.ring_id);
-	if (ti.pkt_offset)
-		skb_pull(skb, ti.pkt_offset);
-
-	arvif->link_stats.tx_dropped++;
-
-	return ret;
-}
-
-static int ath12k_update_da(struct sk_buff *skb, u8 *ucastaddr)
-{
-        int ret;
-        struct ethhdr *ethhdr;
-
-        ret  = skb_ensure_writable(skb, ETH_HLEN);
-        if (unlikely(ret))
-                return ret;
-
-        ethhdr = (void *)skb->data;
-        ether_addr_copy(ethhdr->h_dest, ucastaddr);
-
-        return 0;
-}
-
-static int ath12k_convert_to_unicast(struct ath12k_base *ab,
-				     struct sk_buff *skb,
-				     struct ath12k_vif *orig_ahvif,
-				     struct sk_buff_head *queue)
-{
-	const struct ethhdr *ethhdr;
-	struct ath12k_vif *ahvif;
-	struct ath12k_peer *peer;
-	struct ieee80211_vif *vif;
-	struct sk_buff *skb_new;
-	int ring_id;
-	int ret = 0;
-	int len = 0;
-
-	if (!skb)
-		return -EINVAL;
-
-	ethhdr = (struct ethhdr *)skb->data;
-
-	ring_id = ab->hw_params->hw_ops->get_ring_selector(skb);
-	ab->soc_stats.bond_mcast2ucast_tried[ring_id]++;
-
-	spin_lock_bh(&ab->base_lock);
-	list_for_each_entry(peer, &ab->peers, list) {
-		vif = peer->vif;
-		ahvif = ath12k_vif_to_ahvif(vif);
-		if (ahvif != orig_ahvif)
-			continue;
-
-		if(!peer->sta)
-			continue;
-
-		if (unlikely(ether_addr_equal(ethhdr->h_source, peer->sta->addr))) {
-			/* do not send back to source */
-			continue;
-		}
-
-		skb_new = skb_clone(skb, GFP_ATOMIC);
-		if (!skb_new) {
-			ab->soc_stats.bond_mcast2ucast_drop[ring_id]++;
-			ret = -ENOMEM;
-			goto purge;
-		}
-		if (unlikely(ath12k_update_da(skb_new, peer->sta->addr))) {
-			ab->soc_stats.bond_mcast2ucast_drop[ring_id]++;
-			dev_kfree_skb(skb_new);
-			ret = -ENOMEM;
-			goto purge;
-		}
-		__skb_queue_tail(queue, skb_new);
-		len++;
-	}
-	ab->soc_stats.bond_mcast2ucast_converted[ring_id] += len;
-	goto out;
-purge:
-	__skb_queue_purge(queue);
-out:
-	spin_unlock_bh(&ab->base_lock);
-	return ret;
-}
-
-static bool ath12k_dp_mlo_multicast_to_unicast(struct sk_buff *skb,
-					   struct net_device *bond_dev)
-{
-	const struct ethhdr *eth = (void *)skb->data;
-	const struct vlan_ethhdr *ethvlan = (void *)skb->data;
-	__be16 ethertype;
-
-	ethertype = eth->h_proto;
-	if (ethertype == htons(ETH_P_8021Q) && skb->len >= VLAN_ETH_HLEN)
-		ethertype = ethvlan->h_vlan_encapsulated_proto;
-	switch (ethertype) {
-	case htons(ETH_P_ARP):
-	case htons(ETH_P_IP):
-	case htons(ETH_P_IPV6):
-		break;
-	default:
-		return false;
-	}
-
-	return true;
-}
-
-int ath12k_dp_mlo_xmit_netdev(struct sk_buff *skb, struct net_device *bond_dev)
-{
-	struct net_device *link_dev = NULL;
-	struct ethhdr *eh = NULL;
-	struct ath12k_mld_dev *mldev = bond_get_mlo_ctx(bond_dev);
-	struct ath12k_link_vif_pvt *arvif_pvt = NULL;
-	struct ath12k_link_vif *arvif, *tmp_arvif;
-	struct ath12k_vif *ahvif = NULL;
-	struct sk_buff *msdu_copied;
-	struct ath12k *tmp_ar;
-	int is_mcast;
-	u16 mcbc_gsn;
-	struct sk_buff *skb1;
-	int ret, i;
-	bool is_convert;
-	int link_id, ring_id = 0;
-	struct ath12k_skb_cb *skb_cb;
-	struct ieee80211_tx_info *info;
-	struct sk_buff_head queue;
-
-	if (!(bond_dev->flags & IFF_UP)) {
-		dev_kfree_skb(skb);
-		return NETDEV_TX_OK;
-	}
-
-	eh = (struct ethhdr *)skb->data;
-	is_mcast = is_multicast_ether_addr(eh->h_dest);
-	skb_cb = ATH12K_SKB_CB(skb);
-	skb_cb->flags |= ATH12K_SKB_HW_80211_ENCAP;
-	info = IEEE80211_SKB_CB(skb);
-	info->flags |= IEEE80211_TX_CTL_HW_80211_ENCAP;
-
-	if (is_mcast) {
-		uint8_t chip_id = mldev->primary_chipid;
-		uint8_t pdev_id = mldev->primary_pdevid;
-
-		link_dev = mldev->link_dev[chip_id][pdev_id];
-		arvif_pvt = netdev_priv(link_dev);
-		arvif = arvif_pvt->arvif;
-		if (!arvif) {
-			dev_kfree_skb_any(skb);
-			return NETDEV_TX_OK;
-		}
-
-		ahvif = arvif->ahvif;
-		if (!ahvif) {
-			dev_kfree_skb_any(skb);
-			return NETDEV_TX_OK;
-		}
-
-		if (ahvif->mcast_to_ucast_en) {
-			is_convert = ath12k_dp_mlo_multicast_to_unicast(skb, bond_dev);
-
-			if (is_convert) {
-				for (i = 0; i < IEEE80211_MLD_MAX_NUM_LINKS; i++) {
-					arvif = ahvif->link[i];
-					if (!arvif)
-						continue;
-
-					__skb_queue_head_init(&queue);
-					ath12k_convert_to_unicast(arvif->ab, skb, ahvif,  &queue);
-					while ((skb1 = __skb_dequeue(&queue))) {
-						eh = (struct ethhdr *)skb1->data;
-						link_dev = ath12k_mac_get_tx_link_netdev( mldev, eh->h_dest);
-#ifdef CPTCFG_MAC80211_SFE_SUPPORT
-						skb1->fast_xmit = 0;
-#endif
-						if (link_dev)
-							link_dev->netdev_ops->ndo_start_xmit(skb1, link_dev);
-						else
-							dev_kfree_skb_any(skb1);
-					}
-				}
-				dev_kfree_skb_any(skb);
-				return NETDEV_TX_OK;
-			}
-		}
-
-		spin_lock(&ahvif->mcbc_gsn_lock);
-		mcbc_gsn = ahvif->mcbc_gsn++;
-		if (ahvif->mcbc_gsn > 0xFFF)
-			ahvif->mcbc_gsn = 0;
-		spin_unlock(&ahvif->mcbc_gsn_lock);
-
-		for_each_set_bit(link_id, &ahvif->links_map,
-				IEEE80211_MLD_MAX_NUM_LINKS) {
-			tmp_arvif = ahvif->link[link_id];
-			if (tmp_arvif && tmp_arvif->ar)
-				tmp_ar = tmp_arvif->ar;
-			else
-				break;
-
-			ret = ath12k_mac_tx_check_max_limit(tmp_ar, skb);
-			if (ret) {
-				ath12k_dbg(tmp_ar->ab, ATH12K_DBG_MAC,
-						"failed fast tx due to limit check pdev idx %d\n",
-						tmp_ar->pdev_idx);
-				continue;
-			}
-
-			ring_id = tmp_arvif->ar->ab->hw_params->hw_ops->get_ring_selector(skb);
-
-			if (test_bit(ATH12K_FLAG_RECOVERY, &tmp_ar->ab->dev_flags)) {
-				tmp_ar->ab->soc_stats.bond_tx_mcast_dropped[ring_id]++;
-				break;
-			}
-
-			tmp_ar->ab->soc_stats.bond_tx_mcast_enqueued[ring_id]++;
-			msdu_copied = skb_copy(skb, GFP_ATOMIC);
-			if (!msdu_copied) {
-				tmp_ar->ab->soc_stats.bond_tx_mcast_dropped[ring_id]++;
-				continue;
-			}
-
-			ret = ath12k_mcast_dp_tx(tmp_ar, tmp_arvif, msdu_copied, true, mcbc_gsn);
-			if (ret) {
-				tmp_ar->ab->soc_stats.bond_tx_mcast_dropped[ring_id]++;
-				dev_kfree_skb_any(msdu_copied);
-				continue;
-			}
-		}
-		dev_kfree_skb_any(skb);
-		return NETDEV_TX_OK;
-	} else {
-		link_dev = ath12k_mac_get_tx_link_netdev( mldev, eh->h_dest);
-	}
-
-	if (!link_dev) {
-		dev_kfree_skb_any(skb);
-		return NETDEV_TX_OK;
-	}
-
-#ifdef CPTCFG_MAC80211_SFE_SUPPORT
-	skb->fast_xmit = 0;
-#endif
-	return link_dev->netdev_ops->ndo_start_xmit(skb, link_dev);
-}
-
-struct net_device *ath12k_dp_get_mlo_tx_netdev(void *bondctx, u8 *dst_mac_addr)
-{
-	struct ath12k_mld_dev *mldev = (struct ath12k_mld_dev *)bondctx;
-
-	return ath12k_mac_get_tx_link_netdev(mldev, dst_mac_addr);
-}
-
-int ieee80211_link_open(struct net_device *dev)
-{
-	struct ath12k_link_vif_pvt *arvif_pvt = netdev_priv(dev);
-	arvif_pvt->is_started = true;
-	return 0;
-}
-
-int ieee80211_link_stop(struct net_device *dev)
-{
-	struct ath12k_link_vif_pvt *arvif_pvt = netdev_priv(dev);
-	arvif_pvt->is_started = false;
-	return 0;
-}
-
-void ieee80211_link_uninit(struct net_device *dev)
-{
-	return;
-}
-
-static inline void ieee80211_tx_stats_bonded_if(struct net_device *dev, u32 len)
-{
-	struct pcpu_sw_netstats *tstats = this_cpu_ptr(netdev_tstats(dev));
-
-	u64_stats_update_begin(&tstats->syncp);
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0))
-	tstats->tx_packets++;
-	tstats->tx_bytes += len;
-#else
-	u64_stats_inc(&tstats->tx_packets);
-	u64_stats_add(&tstats->tx_bytes, len);
-#endif
-	u64_stats_update_end(&tstats->syncp);
-}
-
-netdev_tx_t ieee80211_link_subif_start_xmit_8023(struct sk_buff *skb,
-					    struct net_device *dev)
-{
-	struct ath12k_link_vif_pvt *arvif_pvt = netdev_priv(dev);
-	struct ath12k_link_vif *arvif = arvif_pvt->arvif;
-	struct ath12k_base *ab;
-	int ret;
-	int is_mcast, ring_id = 0;
-	struct ethhdr *eh = NULL;
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-	struct ath12k_skb_cb *skb_cb = ATH12K_SKB_CB(skb);
-
-	ieee80211_tx_stats_bonded_if(dev, skb->len);
-
-	if (!(dev->flags & IFF_UP)) {
-		dev_kfree_skb(skb);
-		return NETDEV_TX_OK;
-	}
-
-	eh = (struct ethhdr *)skb->data;
-	is_mcast = is_multicast_ether_addr(eh->h_dest);
-	skb_cb->link_id = arvif->link_id;
-	skb_cb->flags |= ATH12K_SKB_HW_80211_ENCAP;
-	info->flags |= IEEE80211_TX_CTL_HW_80211_ENCAP;
-	ATH12K_SKB_CB(skb)->link_id = arvif->link_id;
-
-	if (!arvif_pvt->is_started) {
-		ath12k_dbg(NULL, ATH12K_DBG_PPE, "Dropping frames as arvif is not started\n");
-		dev_kfree_skb_any(skb);
-		return NETDEV_TX_OK;
-	}
-	if (!arvif || !arvif->is_started) {
-		ath12k_dbg(NULL, ATH12K_DBG_PPE, "Dropping frames as arvif is not started\n");
-		dev_kfree_skb_any(skb);
-		return NETDEV_TX_OK;
-	}
-
-	ab = arvif->ar->ab;
-	ring_id = ab->hw_params->hw_ops->get_ring_selector(skb);
-
-	if (test_bit(ATH12K_FLAG_RECOVERY, &ab->dev_flags)) {
-		ath12k_dbg(NULL, ATH12K_DBG_PPE, "Dropping frames as radio is in recovery\n");
-		ab->soc_stats.bond_tx_ucast_dropped[ring_id]++;
-		dev_kfree_skb_any(skb);
-		return NETDEV_TX_OK;
-	}
-
-
-	ab->soc_stats.bond_tx_ucast_enqueued[ring_id]++;
-	/* TODO: debug why queue is always 15 */
-	info->hw_queue = 0;
-	info->flags = IEEE80211_TX_CTL_HW_80211_ENCAP;
-	ATH12K_SKB_CB(skb)->flags = ATH12K_SKB_HW_80211_ENCAP;
-
-	ret = ath12k_mac_tx_check_max_limit(arvif->ar, skb);
-	if (ret) {
-		ath12k_dbg(arvif->ar->ab, ATH12K_DBG_MAC,
-				"failed fast tx due to limit check pdev idx %d\n",
-				arvif->ar->pdev_idx);
-		dev_kfree_skb_any(skb);
-		return NETDEV_TX_OK;
-	}
-
-	ret = ath12k_dp_tx_direct(arvif, skb);
-	if (unlikely(ret)) {
-		ath12k_dbg(ab, ATH12K_DBG_PPE,
-			   "failed to transmit frame %d\n", ret);
-		dev_kfree_skb_any(skb);
-		ab->soc_stats.bond_tx_ucast_dropped[ring_id]++;
-		return NETDEV_TX_OK;
-	}
-	return NETDEV_TX_OK;
-}
-
-void ieee80211_link_set_multicast_list(struct net_device *dev)
-{
-	return;
-}
-
-static int ieee80211_link_set_mtu(struct net_device *dev, int mtu)
-{
-	struct ath12k_link_vif_pvt *arvif_pvt = netdev_priv(dev);
-	struct ath12k_link_vif *arvif = arvif_pvt->arvif;
-
-	if (!arvif)
-		return -EINVAL;
-
-	if (!(IEEE80211_MTU_MIN < mtu && mtu < IEEE80211_MTU_MAX))
-		return -EINVAL;
-
-	if (!ath12k_ppe_vp_set_mtu(dev, arvif, mtu))
-		return -EINVAL;
-
-	dev->mtu = mtu;
-
-	return 0;
-}
-
-int ieee80211_link_change_mac(struct net_device *dev, void *addr)
-{
-	return 0;
-}
-
-#if LINUX_VERSION_IS_GEQ(5,2,0)
-u16 ieee80211_link_netdev_select_queue(struct net_device *dev,
-					 struct sk_buff *skb,
-					 struct net_device *sb_dev)
-#elif LINUX_VERSION_IS_GEQ(4,19,0)
-u16 ieee80211_link_netdev_select_queue(struct net_device *dev,
-					 struct sk_buff *skb,
-					 struct net_device *sb_dev,
-					 select_queue_fallback_t fallback)
-#else
-u16 ieee80211_link_netdev_select_queue(struct net_device *dev,
-					 struct sk_buff *skb,
-					 void *accel_priv,
-					 select_queue_fallback_t fallback)
-#endif
-{
-	return smp_processor_id();
-}
-
-void
-ieee80211_link_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)
-{
-	dev_fetch_sw_netstats(stats, dev->tstats);
-}
-static const struct net_device_ops ieee80211_link_dataif_8023_ops = {
-	.ndo_open		= ieee80211_link_open,
-	.ndo_stop		= ieee80211_link_stop,
-	.ndo_uninit		= ieee80211_link_uninit,
-	.ndo_start_xmit		= ieee80211_link_subif_start_xmit_8023,
-	.ndo_set_rx_mode	= ieee80211_link_set_multicast_list,
-	.ndo_change_mtu		= ieee80211_link_set_mtu,
-	.ndo_set_mac_address	= ieee80211_link_change_mac,
-	.ndo_select_queue	= ieee80211_link_netdev_select_queue,
-	.ndo_get_stats64	= ieee80211_link_get_stats64,
-};
-
-int ath12k_free_bonddev_for_sfe(struct wireless_dev *wdev, struct ieee80211_vif *vif, int link_num)
-{
-	struct ath12k_mld_dev *mldev = NULL;
-	struct wireless_dev *dummywdev = NULL;
-	struct wiphy *dummywiphy = NULL;
-	struct net_device *link_ndev = NULL;
-	int ret;
-
-	mutex_lock(&vif->bond_mutex);
-	link_ndev = vif->link_ndev[link_num];
-	if (link_ndev) {
-		ath12k_info(NULL, "Bond_release and Unregister link netdevice %s link ndev %px link_num %d\n", link_ndev->name, link_ndev, link_num);
-		bond_release(wdev->bond_netdev, link_ndev);
-		unregister_netdevice(link_ndev);
-		vif->link_ndev[link_num] = NULL;
-	} else {
-		ath12k_err(NULL, "ERR Free Bond dev for SFE. Unregister link netdevice %s link ndev %px link_num %d\n", link_ndev->name, link_ndev, link_num);
-	}
-	mutex_unlock(&vif->bond_mutex);
-	if (!wdev->bond_netdev) {
-		ath12k_info(NULL, "No bond device exists in the ath12k driver for device. SFE\n");
-		return 0;
-	}
-	mldev = bond_get_mlo_ctx(wdev->bond_netdev);
-	if (!test_bit(ATH12K_BOND_REGISTERED, &mldev->bond_state)) {
-		ath12k_err(NULL, "Bond interface destroyed already. Called for the second time.\n");
-		return 0;
-	}
-
-	dummywiphy = mldev->wdev->wiphy;
-	dummywdev = mldev->wdev;
-
-	/* Returns true on success */
-	ret  = bond_destroy_mlo(wdev->bond_netdev);
-	if (ret) {
-		wdev->bond_netdev = NULL;
-		ath12k_info(NULL,"Successfully destroyed bond device\n");
-	} else {
-		ath12k_err(NULL, "Not able destroy bond device %s ret %d\n", wdev->bond_netdev->name, ret);
-		return -EINVAL;
-	}
-	kfree(dummywdev);
-	wiphy_free(dummywiphy);
-	clear_bit(ATH12K_BOND_REGISTERED, &mldev->bond_state);
-	kfree(mldev);
-	return 0;
-}
-
-extern const struct cfg80211_ops mac80211_dummy_config_ops;
-int ath12k_bond_dev_cb(struct wireless_dev *wdev, struct net_device *dev, bool is_register)
-{
-	struct mlo_bond_info *mlo_info = NULL;
-	struct ath12k_mld_dev *mldev = NULL;
-	struct wireless_dev *dummywdev = NULL;
-	int priv_size = 100;
-	char name[20] = {0};
-	struct wiphy *dummywiphy = NULL;
-	bool ret;
-
-	if (!g_bonded_interface_model)
-		return 0;
-
-	if (is_register) {
-		if (wdev->bond_netdev && test_bit(ATH12K_BOND_REGISTERED, &mldev->bond_state)) {
-			ath12k_info(NULL, "Bond device already registered\n");
-			return 0;
-		}
-		mlo_info = kmalloc(sizeof(struct mlo_bond_info), GFP_KERNEL); //TODO: Free
-		if (!mlo_info) {
-			ath12k_err(NULL, "ERR: Couldn't allocate mlo_info\n");
-			return -ENOMEM;
-		}
-		memset(mlo_info, 0, sizeof(struct mlo_bond_info));
-		mldev = kmalloc(sizeof(struct ath12k_mld_dev), GFP_KERNEL);
-		if (!mldev) {
-			ath12k_err(NULL, "ERR: Couldn't allocate mld_dev\n");
-			kfree(mlo_info);
-			return -ENOMEM;
-		}
-		memset(mldev, 0, sizeof(struct ath12k_mld_dev));
-		dummywdev = kmalloc(sizeof(struct wireless_dev), GFP_KERNEL);
-		if (!mldev) {
-			ath12k_err(NULL, "ERR: Couldn't allocate mld_dev\n");
-			kfree(mlo_info);
-			kfree(mldev);
-			return -ENOMEM;
-		}
-		memset(dummywdev, 0, sizeof(struct wireless_dev));
-		dummywiphy = wiphy_new_nm(&mac80211_dummy_config_ops, priv_size, NULL);
-		if (!dummywiphy) {
-			kfree(mlo_info);
-			kfree(mldev);
-			kfree(dummywdev);
-			return -EINVAL;
-		}
-		dummywiphy->interface_modes = BIT(NL80211_IFTYPE_AP) | BIT(NL80211_IFTYPE_DUMMY);
-		mlo_info->wdev = dummywdev;
-		mldev->wdev = dummywdev;
-		mlo_info->wdev->wiphy = dummywiphy;
-		mlo_info->wdev->iftype = NL80211_IFTYPE_DUMMY;
-		mlo_info->bond_mlo_ctx = (void *)mldev;
-		mlo_info->bond_mlo_xmit_netdev = ath12k_dp_mlo_xmit_netdev;
-		mlo_info->bond_get_mlo_tx_netdev = ath12k_dp_get_mlo_tx_netdev ;
-		snprintf(name, sizeof(name), "%s_b", dev->name);
-		wdev->bond_netdev = bond_create_mlo(&init_net, name, mlo_info);
-
-		if (wdev->bond_netdev) {
-			wdev->bond_netdev->max_mtu = IEEE80211_MAX_DATA_LEN;
-			set_bit(ATH12K_BOND_REGISTERED, &mldev->bond_state);
-			ath12k_info(NULL, "Successfully registered bond_netdev %s for netdevice %s\n", wdev->bond_netdev->name, dev->name);
-		} else {
-			ath12k_err(NULL, "ERR: Unnable to register Bonded interface\n");
-		}
-		kfree(mlo_info);
-	} else {
-		//TODO: Cleanup all objects in the allocation path. dummy wdev, wiphy, mldev
-		if (!wdev->bond_netdev) {
-			ath12k_info(NULL, "No bond device exists in the ath12k driver for device %s\n", dev->name);
-			return 0;
-		}
-		mldev = bond_get_mlo_ctx(wdev->bond_netdev);
-		if (!test_bit(ATH12K_BOND_REGISTERED, &mldev->bond_state)) {
-			ath12k_err(NULL, "bond interface destroyed already. Called for the second time.\n");
-			return 0;
-		}
-
-		dummywiphy = mldev->wdev->wiphy;
-		dummywdev = mldev->wdev;
-
-		/* Returns true on success */
-		ret  = bond_destroy_mlo(wdev->bond_netdev);
-		if (ret) {
-			wdev->bond_netdev = NULL;
-			ath12k_info(NULL,"Successfully destroyed bond device\n");
-		} else {
-			ath12k_err(NULL, "Not able destroy bond device %s ret %d\n", wdev->bond_netdev->name, ret);
-			return -EINVAL;
-		}
-		//TODO: Free mlo_info
-		kfree(dummywdev);
-		wiphy_free(dummywiphy);
-		clear_bit(ATH12K_BOND_REGISTERED, &mldev->bond_state);
-		kfree(mldev);
-	}
-	return 0;
-}
-
-int ath12k_mac_op_set_multicast_to_unicast(struct ieee80211_hw *hw,
-					    struct ieee80211_vif *vif,
-					    const bool enabled)
-{
-	struct ath12k_vif *ahvif = ath12k_vif_to_ahvif(vif);
-	struct wireless_dev *wdev = ieee80211_vif_to_wdev(vif);
-
-	if (!g_bonded_interface_model)
-		return -ENOTSUPP;
-
-	if (!wdev->bond_netdev)
-		return -ENOTSUPP;
-
-	ahvif->mcast_to_ucast_en = enabled;
-
-	return 0;
-}
--- a/drivers/net/wireless/ath/ath12k/bondif.h
+++ /dev/null
@@ -1,55 +0,0 @@
-// SPDX-License-Identifier: BSD-3-Clause-Clear
-/*
- * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
- */
-
-#ifndef __BONDIF_H
-#define __BONDIF_H
-
-#define MAX_MLO_CHIPS 3
-#define MAX_PDEV_PER_SOC 3
-
-#define ATH12K_PPE_DS_DEFAULT_CORE_MASK		0x7
-
-void ath12k_disable_ppe_for_link_netdev(struct ath12k_base *ab,
-				       struct ath12k_link_vif *arvif,
-				       struct net_device *link_dev);
-void ath12k_enable_ppe_for_link_netdev(struct ath12k_base *ab,
-				      struct ath12k_link_vif *arvif,
-				      struct net_device *link_dev);
-int ath12k_free_bonddev_for_sfe(struct wireless_dev *wdev,
-				struct ieee80211_vif *vif,
-				int link_num);
-int ath12k_mac_op_set_multicast_to_unicast(struct ieee80211_hw *hw,
-					   struct ieee80211_vif *vif,
-					   const bool enabled);
-int ath12k_bond_link_enslave(struct ath12k_link_vif *arvif, struct net_device *link_dev);
-void ath12k_bond_link_release(struct ath12k_link_vif *arvif);
-void ath12k_bond_enable_ppe_ds(void);
-void ath12k_bond_disable_ppe_ds(void);
-extern int g_bonded_interface_model;
-extern unsigned int ath12k_ppe_ds_enabled;
-extern unsigned int ath12k_mlo_capable;
-int ath12k_bond_dev_cb(struct wireless_dev *wdev, struct net_device *dev, bool is_register);
-extern int (*driver_bond_dev_cb)(struct wireless_dev *wdev, struct net_device *dev, bool is_register);
-enum ath12k_bond_state {
-	ATH12K_BOND_SETUP_INPROGRESS,
-	ATH12K_BOND_REGISTERED,
-	ATH12K_BOND_LINK0_REGISTERED,
-	ATH12K_BOND_LINK1_REGISTERED,
-	ATH12K_BOND_LINK2_REGISTERED,
-
-};
-struct ath12k_mld_dev {
-	struct net_device *netdev;
-	struct ieee80211_vif *vif;
-	struct ath12k_vif *ahvif;
-	struct wireless_dev *wdev; //dummy one for bond registration. Optimize Bond MLO API.
-	struct net_device *link_dev[MAX_MLO_CHIPS][MAX_PDEV_PER_SOC];
-	u8 primary_chipid, primary_pdevid;
-	bool mcast_dev_set;
-	bool mcast_to_ucast_en;
-	unsigned long bond_state;
-};
-
-#endif //__BONDIF_H
--- a/drivers/net/wireless/ath/ath12k/core.c
+++ b/drivers/net/wireless/ath/ath12k/core.c
@@ -26,11 +26,6 @@
 #include "telemetry.h"
 #include "peer.h"
 
-#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
-#include <linux/rtnetlink.h>
-#include "bondif.h"
-#endif
-
 #ifdef CPTCFG_ATH12K_POWER_OPTIMIZATION
 extern struct ath12k_ps_context ath12k_global_ps_ctx;
 #endif
@@ -1768,6 +1763,7 @@ int ath12k_core_qmi_firmware_ready(struc
 	}
 
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+	/* TODO: DS: revisit this for new DS design */
 	if (ath12k_ppe_ds_enabled) {
 		if (ath12k_frame_mode != ATH12K_HW_TXRX_ETHERNET) {
 			ath12k_warn(ab,
@@ -2612,11 +2608,6 @@ static int ath12k_mlo_recovery_link_vif_
 		changed |= BSS_CHANGED_MU_GROUPS;
 
 	switch (vif->type) {
-#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
-	case NL80211_IFTYPE_DUMMY:
-		mutex_unlock(&ah->conf_mutex);
-		return 0;
-#endif
 	case NL80211_IFTYPE_STATION:
 		if (!vif->valid_links) {
 			/* Set this only for legacy stations */
@@ -3426,61 +3417,13 @@ static int ath12k_core_trigger_umac_rese
 	return ret;
 }
 
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
-static void ath12k_core_disable_ppe_rtnl_bond_release(struct ath12k_base *ab)
-{
-	struct ath12k *ar;
-	struct ath12k_pdev *pdev;
-	struct ath12k_link_vif *arvif;
-	struct net_device *link_ndev;
-	int i;
-
-	rtnl_lock();
-
-	for (i = 0; i < ab->num_radios; i++) {
-		pdev = &ab->pdevs[i];
-		ar = pdev->ar;
-
-		if (!ar || ar->state == ATH12K_STATE_OFF)
-			continue;
-
-		mutex_lock(&ar->conf_mutex);
-		list_for_each_entry(arvif, &ar->arvifs, list) {
-			if (arvif->ndev_pvt) {
-				link_ndev = arvif->ndev_pvt->link_ndev;
-				if (arvif->ndev_pvt->bond_dev &&
-				    arvif->ndev_pvt->bond_dev->flags & IFF_UP) {
-					netif_tx_stop_all_queues(arvif->ndev_pvt->bond_dev);
-					arvif->ndev_pvt->bond_dev->flags &= ~IFF_UP;
-				}
-
-				if (link_ndev) {
-					netif_tx_stop_all_queues(link_ndev);
-					if (ab->ag->recovery_mode == ATH12K_MLO_RECOVERY_MODE0) {
-						ath12k_bond_link_release(arvif);
-						ath12k_disable_ppe_for_link_netdev(ab,
-										   arvif,
-										   link_ndev);
-					}
-				}
-			}
-		}
-		mutex_unlock(&ar->conf_mutex);
-	}
-
-	rtnl_unlock();
-}
-#endif
-
 static void ath12k_core_reset(struct work_struct *work)
 {
 	struct ath12k_base *ab = container_of(work, struct ath12k_base, reset_work);
 	struct ath12k_hw_group *ag = ab->ag;
 	struct ath12k_hw *ah;
 	struct ath12k_base *partner_ab;
-	struct ath12k_pdev *pdev;
-	struct ath12k *ar;
-	int reset_count, fail_cont_count, i, j;
+	int reset_count, fail_cont_count, i;
 	long time_left;
 	bool teardown = false;
 
@@ -3509,12 +3452,14 @@ static void ath12k_core_reset(struct wor
 		ath12k_info(ab, "Recovery is initiated with Mode%s\n",
 			   (ag->recovery_mode == ATH12K_MLO_RECOVERY_MODE0 ? "0" : "1"));
 
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 	if (!ab->is_reset) {
+		/* TODO: DS: revisit for DS SSR
+		 * As net device still exists and part of the bridge,
+		 * do not free vp allocated upon SSR */
 		ath12k_hif_ppeds_irq_disable(ab, PPEDS_IRQ_PPE2TCL);
 		ath12k_hif_ppeds_irq_disable(ab, PPEDS_IRQ_REO2PPE);
 		ath12k_hif_ppeds_irq_disable(ab, PPEDS_IRQ_PPE_WBM2SW_REL);
-		ath12k_core_disable_ppe_rtnl_bond_release(ab);
 	}
 #endif
 
@@ -3579,26 +3524,10 @@ static void ath12k_core_reset(struct wor
 	if (ag->num_started && ab->fw_recovery_support)
 		ag->num_started--;
 
-	if (!ag->hw_queues_stopped) {
+	/* TODO: DS: How to stop ppeds queues during SSR??
+	 * PPE hardware might still be enqueuing packets on PPE2TCL */
+	if (!ag->hw_queues_stopped)
 		ath12k_core_mlo_hw_queues_stop(ag, ab);
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
-		if (ag->recovery_mode == ATH12K_MLO_RECOVERY_MODE1) {
-			for (i = 0; i < ag->num_chip; i++) {
-				partner_ab = ag->ab[i];
-				if (ab == partner_ab)
-					continue;
-				for (j = 0; j < partner_ab->num_radios; j++) {
-					pdev = &partner_ab->pdevs[j];
-					ar = pdev->ar;
-					if (!ar)
-						continue;
-					ath12k_ppeds_partner_link_stop_queues(ar);
-				}
-			}
-		}
-#endif
-	}
-
 
 	for (i = 0; i < ag->num_chip; i++) {
 		partner_ab = ag->ab[i];
@@ -3646,7 +3575,7 @@ static void ath12k_core_reset(struct wor
 			 * failed
 			 */
 			ag->recovery_mode = ATH12K_MLO_RECOVERY_MODE0;
-			ath12k_core_disable_ppe_rtnl_bond_release(ab);
+			/* TODO: DS: Handle any clean up necessary for Mode1 SSR */
 			ath12k_info(ab, "Recovery is falling back to Mode0\n");
 		} else {
 			/* wake queues here as ping should continue for
@@ -3659,21 +3588,6 @@ static void ath12k_core_reset(struct wor
 
 				ieee80211_wake_queues(ah->hw);
 			}
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
-			for (i = 0; i < ag->num_chip; i++) {
-				partner_ab = ag->ab[i];
-				if (ab == partner_ab)
-					continue;
-				for (j = 0; j < partner_ab->num_radios; j++) {
-					pdev = &partner_ab->pdevs[j];
-					ar = pdev->ar;
-
-					if (!ar)
-						continue;
-					ath12k_ppeds_partner_link_start_queues(ar);
-				}
-			}
-#endif
 			ath12k_dbg(ab, ATH12K_DBG_MODE1_RECOVERY,
 				   "Queues are started as umac reset is completed for partner chipset\n");
 		}
@@ -4074,6 +3988,8 @@ struct ath12k_base *ath12k_core_alloc(st
 	ab->qmi.num_radios = ATH12K_QMI_INVALID_RADIO;
 
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+	/* Used for tracking the order of per ab's DS node in bringup sequence
+	 * for the purposes of affinity settings */
 	ab->ppeds_node_idx = -1;
 #endif
 	return ab;
@@ -4395,9 +4311,6 @@ static void ath12k_exit(void)
 	ath12k_pci_exit();
 	ath12k_ahb_exit();
 	ath12k_debugfs_destroy();
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
-	ath12k_bond_disable_ppe_ds();
-#endif
 }
 
 module_init(ath12k_init)
--- a/drivers/net/wireless/ath/ath12k/core.h
+++ b/drivers/net/wireless/ath/ath12k/core.h
@@ -31,6 +31,7 @@
 #include "vendor.h"
 #include "telemetry_agent_if.h"
 #include "cfr.h"
+#include "hal_rx.h"
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 #include <ppe_ds_wlan.h>
 #include <ppe_vp_public.h>
@@ -378,20 +379,6 @@ struct ath12k_vif_tcl_desc_template {
 	u32 info4;
 };
 
-#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
-struct ath12k_link_vif_pvt {
-	struct ath12k_base *ab;
-	struct ath12k_link_vif *arvif;
-	struct net_device *link_ndev;
-	struct net_device *bond_dev;
-	struct ieee80211_hw *hw;
-	bool is_started;
-	bool is_bond_enslaved;
-	int ppe_vp_profile_idx;
-	int vp_num;
-};
-#endif
-
 struct ath12k_peer_ch_width_switch_data {
 	int count;
 	struct wmi_chan_width_peer_arg peer_arg[];
@@ -459,14 +446,8 @@ struct ath12k_link_vif {
 	u64 obss_color_bitmap;
 	struct work_struct update_obss_color_notify_work;
 	u32 tx_vdev_id;
-    u8 link_id;
-    struct ath12k_vif *ahvif;
-#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
-	struct ath12k_link_vif_pvt *ndev_pvt;
-	struct net_device *link_ndev;
-	int ppe_vp_type;
-	int ppe_vp_num;
-#endif
+	u8 link_id;
+	struct ath12k_vif *ahvif;
 
 	bool mvr_processing;
 	bool pending_csa_up;
@@ -477,6 +458,12 @@ struct ath12k_link_vif {
 	struct ath12k_peer_ch_width_switch_data *peer_ch_width_switch_data;
 	struct ieee80211_key_conf *keys[WMI_MAX_KEY_INDEX + 1];
 	struct ath12k_prb_resp_tmpl_ml_info ml_info;
+
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+	/* TODO: DS: Placeholder for new DS implementation */
+	int ppe_vp_profile_idx;
+#endif
+
 };
 
 struct ath12k_vif {
@@ -522,11 +509,17 @@ struct ath12k_vif {
 	struct dentry *debugfs_primary_link;
 	struct dentry *debugfs_rfs_core_mask;
 #endif /* CPTCFG_ATH12K_DEBUGFS */
-	bool mcast_to_ucast_en;
 	bool chanctx_peer_del_done;
 
 	int ppe_rfs_vp_num;
 	int ppe_rfs_core_mask;
+
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+	/* TODO: DS: Placeholder for new DS implementation */
+	int ppe_vp_num;
+	int ppe_core_mask;
+	int ppe_vp_type;
+#endif
 };
 
 struct ath12k_vif_iter {
@@ -1303,16 +1296,6 @@ struct ath12k_soc_dp_stats {
 	u32 tx_enqueued[MAX_TCL_RING];
 	u32 tx_completed[MAX_TCL_RING];
 	u32 null_tx_complete[MAX_TCL_RING];
-	u32 bond_tx_ucast_enqueued[MAX_TCL_RING];
-	u32 bond_tx_mcast_enqueued[MAX_TCL_RING];
-	u32 bond_tx_ucast_dropped[MAX_TCL_RING];
-	u32 bond_tx_mcast_dropped[MAX_TCL_RING];
-	/* Number of frames successfully converted to ucast from mcast */
-	u32 bond_mcast2ucast_converted[MAX_TCL_RING];
-	/* Number of mcast frames tried for ucast conversion*/
-	u32 bond_mcast2ucast_tried[MAX_TCL_RING];
-	/* Number of times mcast to ucast conversion failed*/
-	u32 bond_mcast2ucast_drop[MAX_TCL_RING];
 	u32 reo_rx[DP_REO_DST_RING_MAX] [ATH12K_MAX_SOCS];
 	u32 fast_rx[DP_REO_DST_RING_MAX] [ATH12K_MAX_SOCS];
 	u32 non_fast_rx[DP_REO_DST_RING_MAX] [ATH12K_MAX_SOCS];
--- a/drivers/net/wireless/ath/ath12k/debugfs.c
+++ b/drivers/net/wireless/ath/ath12k/debugfs.c
@@ -1817,42 +1817,6 @@ static ssize_t ath12k_debugfs_dump_soc_d
 			soc_stats->tx_completed[2],
 			soc_stats->tx_completed[3]);
 
-
-	len += scnprintf(buf + len, size - len, "\nbond_tx_ucast_enqueued: ");
-	for (i = 0; i < MAX_TCL_RING; i++)
-		len += scnprintf(buf + len, size - len,"%u:%u ",
-				 i, soc_stats->bond_tx_ucast_enqueued[i]);
-
-	len += scnprintf(buf + len, size - len,	"\nbond_tx_mcast_enqueued: ");
-	for (i = 0; i < MAX_TCL_RING; i++)
-		len += scnprintf(buf + len, size - len,	"%u:%u ",
-				i, soc_stats->bond_tx_mcast_enqueued[i]);
-
-	len += scnprintf(buf + len, size - len, "\nbond_tx_ucast_dropped: ");
-	for (i = 0; i < MAX_TCL_RING; i++)
-		len += scnprintf(buf + len, size - len,	"%u:%u ",
-				i, soc_stats->bond_tx_ucast_dropped[i]);
-
-	len += scnprintf(buf + len, size - len, "\nbond_tx_mcast_dropped: ");
-	for (i = 0; i < MAX_TCL_RING; i++)
-		len += scnprintf(buf + len, size - len,	"%u:%u ",
-				i, soc_stats->bond_tx_mcast_dropped[i]);
-
-	len += scnprintf(buf + len, size - len, "\nbond_mcast2ucast_tried: ");
-	for (i = 0; i < MAX_TCL_RING; i++)
-		len += scnprintf(buf + len, size - len,	"%u:%u ",
-				i, soc_stats->bond_mcast2ucast_tried[i]);
-
-	len += scnprintf(buf + len, size - len, "\nbond_mcast2ucast_converted: ");
-	for (i = 0; i < MAX_TCL_RING; i++)
-		len += scnprintf(buf + len, size - len,	"%u:%u ",
-				i, soc_stats->bond_mcast2ucast_converted[i]);
-
-	len += scnprintf(buf + len, size - len,	"\nbond_mcast2ucast_drop: ");
-	for (i = 0; i < MAX_TCL_RING; i++)
-		len += scnprintf(buf + len, size - len,
-				"%u:%u ", i, soc_stats->bond_mcast2ucast_drop[i]);
-
 	len += scnprintf(buf + len, size - len,
 			 "\nag tx_pending: %u\n",
 			 atomic_read(&ab->ag->num_dp_tx_pending));
--- a/drivers/net/wireless/ath/ath12k/dp.c
+++ b/drivers/net/wireless/ath/ath12k/dp.c
@@ -21,10 +21,6 @@
 #define ATH12K_DP_LMAC_PEER_ID_MLO	3
 #define ATH12K_DP_PEER_ROUTING_LMAC_ID_MASK	GENMASK(7,6)
 
-#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
-extern int g_bonded_interface_model;
-#endif
-
 static void ath12k_dp_htt_htc_tx_complete(struct ath12k_base *ab,
 					  struct sk_buff *skb)
 {
@@ -1465,13 +1461,13 @@ static void ath12k_dp_mon_reap_timer_ini
 	timer_setup(&ab->mon_reap_timer, ath12k_dp_service_mon_ring, 0);
 }
 
-#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 static int ath12k_dp_ppe_rxole_rxdma_cfg(struct ath12k_base *ab)
 {
 	struct ath12k_dp_htt_rxdma_ppe_cfg_param param = {0};
 	int ret;
 
-	if (!g_bonded_interface_model)
+	if (!test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags))
 		return 0;
 
 	param.override = 1;
@@ -1498,7 +1494,7 @@ int ath12k_dp_pdev_alloc(struct ath12k_b
 	int ret;
 	int i;
 
-#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 	ret = ath12k_dp_ppe_rxole_rxdma_cfg(ab);
 	if (ret) {
 		ath12k_err(ab, "Failed to send htt RxOLE and RxDMA messages to target :%d\n",
--- a/drivers/net/wireless/ath/ath12k/dp_mon.c
+++ b/drivers/net/wireless/ath/ath12k/dp_mon.c
@@ -16,10 +16,6 @@
 #define ATH12K_LE64_DEC_ENC(value, decode_bits, encode_bits) \
 	le64_encode_bits(le64_get_bits(value, decode_bits), encode_bits)
 
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
-extern int g_bonded_interface_model;
-#endif
-
 static void ath12k_dp_mon_rx_handle_ofdma_info(void *rx_tlv,
 					       struct hal_rx_user_status *rx_user_status)
 {
@@ -3344,25 +3340,28 @@ ath12k_dp_mon_rx_update_peer_rate_table_
 		rx_stats->byte_stats.rx_rate[bw_idx][gi_idx][nss_idx][mcs_idx] += ppdu_info->mpdu_len;
 }
 
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
-static void ath12k_dp_mon_rx_update_peer_stats_bonded(struct ath12k *ar,
-						      struct ath12k_link_sta *arsta,
-						      struct hal_rx_mon_ppdu_info *ppdu_info,
-						      struct ieee80211_rx_status *rx_status)
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+static void ath12k_dp_mon_rx_update_peer_stats_ds(struct ath12k *ar,
+						  struct ath12k_link_sta *arsta,
+						  struct hal_rx_mon_ppdu_info *ppdu_info,
+						  struct ieee80211_rx_status *rx_status)
 {
 	struct ieee80211_rx_status status;
+	struct ath12k_base *ab = ar->ab;
 	struct ieee80211_sta *sta;
 	u32 uid;
 
-	if (ar->ab->stats_disable || !g_bonded_interface_model ||
-	    !test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ar->ab->dev_flags))
+	/* TODO: DS: how to disable/enable stats per vap support ?? */
+	if (ar->ab->stats_disable ||
+	    !test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags))
 		return;
 
-	memset(&status, 0 , sizeof(status));
+	memset(&status, 0, sizeof(status));
 
 	lockdep_assert_held(&ar->ab->base_lock);
 	if (arsta) { // SU stats
-		if (arsta->arvif && (arsta->arvif->ppe_vp_num == -1 ||
+		/* TODO: DS: is this still needed. assuming ahvif holds ppe_vp_num*/
+		if (arsta->arvif && (arsta->arvif->ahvif->ppe_vp_num == -1 ||
 		    (arsta->arvif->ahvif &&
 		     hweight16(arsta->arvif->ahvif->links_map) <= 1)))
 			return;
@@ -3373,8 +3372,10 @@ static void ath12k_dp_mon_rx_update_peer
 		}
 
 		sta = container_of((void *)arsta->ahsta, struct ieee80211_sta, drv_priv);
+#ifdef CPTCFG_MAC80211_DS_SUPPORT
 		ieee80211_rx_update_stats(ar->ah->hw, sta, arsta->link_id,
 					  ppdu_info->mpdu_len, rx_status);
+#endif
 		return;
 	}
 
@@ -3398,9 +3399,10 @@ static void ath12k_dp_mon_rx_update_peer
 			continue;
 		}
 
-		if (arsta->arvif && (arsta->arvif->ppe_vp_num == -1 ||
-		    (arsta->arvif->ahvif &&
-		     hweight16(arsta->arvif->ahvif->links_map) <= 1)))
+		/*TODO: DS: revisit this for new DS design */
+		if (arsta->arvif && arsta->arvif->ahvif &&
+		    (arsta->arvif->ahvif->ppe_vp_num == -1 ||
+		    hweight16(arsta->arvif->ahvif->links_map) <= 1))
 			continue;
 
 		if (!rx_status) {
@@ -3409,11 +3411,13 @@ static void ath12k_dp_mon_rx_update_peer
 		}
 
 		sta = container_of((void *)arsta->ahsta, struct ieee80211_sta, drv_priv);
+#ifdef CPTCFG_MAC80211_DS_SUPPORT
 		ieee80211_rx_update_stats(ar->ah->hw, sta, arsta->link_id,
 					  ppdu_info->mpdu_len, rx_status);
+#endif
 	}
 }
-#endif /* CPTCFG_ATH12K_BONDED_DS_SUPPORT */
+#endif /* CPTCFG_ATH12K_PPE_DS_SUPPORT */
 
 static void ath12k_dp_mon_rx_update_peer_su_stats(struct ath12k *ar,
 						  struct ath12k_link_sta *arsta,
@@ -3881,18 +3885,18 @@ move_next:
 
 			ath12k_dp_mon_rx_update_peer_su_stats(ar, arsta,
 							      ppdu_info);
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
-			ath12k_dp_mon_rx_update_peer_stats_bonded(ar, arsta, ppdu_info,
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+			ath12k_dp_mon_rx_update_peer_stats_ds(ar, arsta, ppdu_info,
 								  &ar->dp.rx_status);
-#endif /* CPTCFG_ATH12K_BONDED_DS_SUPPORT */
+#endif /* CPTCFG_ATH12K_PPE_DS_SUPPORT */
 		} else if ((ppdu_info->fc_valid) &&
 			   (ppdu_info->ast_index != HAL_AST_IDX_INVALID)) {
 			ath12k_dp_mon_rx_process_ulofdma(ppdu_info);
 			ath12k_dp_mon_rx_update_peer_mu_stats(ar, ppdu_info);
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
-			ath12k_dp_mon_rx_update_peer_stats_bonded(ar, NULL, ppdu_info,
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+			ath12k_dp_mon_rx_update_peer_stats_ds(ar, NULL, ppdu_info,
 								  &ar->dp.rx_status);
-#endif /* CPTCFG_ATH12K_BONDED_DS_SUPPORT */
+#endif /* CPTCFG_ATH12K_PPE_DS_SUPPORT */
 		}
 
 next_skb:
@@ -4071,18 +4075,18 @@ move_next:
 
 			ath12k_dp_mon_rx_update_peer_su_stats(ar, arsta,
 							      ppdu_info);
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
-			ath12k_dp_mon_rx_update_peer_stats_bonded(ar, arsta, ppdu_info,
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+			ath12k_dp_mon_rx_update_peer_stats_ds(ar, arsta, ppdu_info,
 								  NULL);
-#endif /* CPTCFG_ATH12K_BONDED_DS_SUPPORT */
+#endif /* CPTCFG_ATH12K_PPE_DS_SUPPORT */
 		} else if ((ppdu_info->fc_valid) &&
 			   (ppdu_info->ast_index != HAL_AST_IDX_INVALID)) {
 			ath12k_dp_mon_rx_process_ulofdma(ppdu_info);
 			ath12k_dp_mon_rx_update_peer_mu_stats(ar, ppdu_info);
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
-			ath12k_dp_mon_rx_update_peer_stats_bonded(ar, NULL, ppdu_info,
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+			ath12k_dp_mon_rx_update_peer_stats_ds(ar, NULL, ppdu_info,
 								  NULL);
-#endif /* CPTCFG_ATH12K_BONDED_DS_SUPPORT */
+#endif /* CPTCFG_ATH12K_PPE_DS_SUPPORT */
  		}
 
 		if (ath12k_debugfs_is_pktlog_peer_valid(ar, peer->addr)) {
--- a/drivers/net/wireless/ath/ath12k/dp_rx.c
+++ b/drivers/net/wireless/ath/ath12k/dp_rx.c
@@ -2904,7 +2904,7 @@ static void ath12k_dp_rx_h_mpdu(struct a
 	u32 err_bitmap;
 	struct ath12k_dp_rx_tid *rx_tid;
 	u8 tid;
-#if defined(CPTCFG_MAC80211_PPE_SUPPORT) || defined(CPTCFG_ATH12K_BONDED_DS_SUPPORT)
+#if defined(CPTCFG_MAC80211_PPE_SUPPORT) || defined(CPTCFG_ATH12K_PPE_DS_SUPPORT)
 	int vp;
 #endif
 	struct wireless_dev *wdev = NULL;
@@ -2929,17 +2929,14 @@ static void ath12k_dp_rx_h_mpdu(struct a
 		    ath12k_dp_rx_check_fast_rx(ar, msdu, rx_desc, peer, rx_info)) {
 			wdev = ieee80211_vif_to_wdev(peer->vif);
 		        if (wdev) {
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+#if defined(CPTCFG_MAC80211_PPE_SUPPORT) || defined(CPTCFG_ATH12K_PPE_DS_SUPPORT)
 				vp = peer->ppe_vp_num;
-				if (unlikely(wdev->bond_netdev))
-					msdu->dev = wdev->bond_netdev;
-				else
 #endif
-					msdu->dev = wdev->netdev;
+				msdu->dev = wdev->netdev;
 
 				spin_unlock_bh(&ar->ab->base_lock);
 				ath12k_dp_rx_h_csum_offload(ar, msdu, rx_info);
-#if defined(CPTCFG_MAC80211_PPE_SUPPORT) || defined(CPTCFG_ATH12K_BONDED_DS_SUPPORT)
+#if defined(CPTCFG_MAC80211_PPE_SUPPORT) || defined(CPTCFG_ATH12K_PPE_DS_SUPPORT)
 				if (vp > 0) {
 					if (likely(ppe_vp_tx_to_ppe(vp, msdu)))
 						return;
@@ -2966,14 +2963,6 @@ static void ath12k_dp_rx_h_mpdu(struct a
 	}
 	spin_unlock_bh(&ar->ab->base_lock);
 
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
-	if (peer) {
-		wdev = ieee80211_vif_to_wdev(peer->vif);
-		if (wdev && wdev->bond_netdev)
-			msdu->dev = wdev->bond_netdev;
-	}
-#endif
-
 	*fast_rx = false;
 
 	err_bitmap = ath12k_dp_rx_h_mpdu_err(ab, rx_desc);
--- a/drivers/net/wireless/ath/ath12k/dp_tx.c
+++ b/drivers/net/wireless/ath/ath12k/dp_tx.c
@@ -1446,9 +1446,10 @@ static void ath12k_ppeds_tx_update_stats
 		return;
 	}
 
+#ifdef CPTCFG_MAC80211_DS_SUPPORT
 	ieee80211_ppeds_tx_update_stats(ar->ah->hw, peer->sta, info, arsta->txrate,
 					peer->link_id, msdu->len);
-
+#endif
 	spin_unlock_bh(&ab->base_lock);
 }
 
--- a/drivers/net/wireless/ath/ath12k/mac.c
+++ b/drivers/net/wireless/ath/ath12k/mac.c
@@ -25,9 +25,6 @@
 #include "peer.h"
 #include "debugfs_sta.h"
 #include "ppe.h"
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
-#include "bondif.h"
-#endif
 
 #define IEEE80211_EHT_PPE_THRES_NSS_POS                        0
 #define IEEE80211_EHT_PPE_THRES_NSS_MASK               0xf
@@ -66,13 +63,6 @@
 static void ath12k_mac_remove_link_interface(struct ieee80211_hw *hw,
 					     struct ath12k_link_vif *arvif);
 
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
-int ath12k_mac_op_change_vif_links(struct ieee80211_hw *hw,
-					  struct ieee80211_vif *vif,
-					  u16 old_links, u16 new_links,
-					  struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS]);
-extern int g_bonded_interface_model;
-#endif
 static const struct ieee80211_channel ath12k_2ghz_channels[] = {
 	CHAN2G(1, 2412, 0),
 	CHAN2G(2, 2417, 0),
@@ -5221,14 +5211,6 @@ static int ath12k_mac_vdev_delete(struct
 	ar->ab->free_vdev_map |= 1LL << arvif->vdev_id;
 	spin_unlock_bh(&ar->ab->base_lock);
 
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
-	if (arvif->link_id != ATH12K_DEFAULT_SCAN_LINK && arvif->ndev_pvt) {
-		if (arvif->ndev_pvt->is_bond_enslaved)
-			ath12k_bond_link_release(arvif);
-		ath12k_disable_ppe_for_link_netdev(ar->ab, arvif,
-						   arvif->ndev_pvt->link_ndev);
-	}
-#endif
 	ar->allocated_vdev_map &= ~(1LL << arvif->vdev_id);
 	ar->ab->free_vdev_stats_id_map &= ~(1LL << arvif->vdev_stats_id);
 	ar->num_created_vdevs--;
@@ -6709,7 +6691,7 @@ static int ath12k_station_assoc(struct a
 		return ret;
 	}
 
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 	ret = ath12k_wmi_set_peer_intra_bss_cmd(ar, arvif->vdev_id, arsta->addr, 1);
 	if (ret) {
 		ath12k_warn(ar->ab, "failed to set vdev %i intra bss enable: %d\n",
@@ -10117,14 +10099,13 @@ static int ath12k_mac_config_mon_status_
 		if (ath12k_debugfs_rx_filter(ar))
 			tlv_filter.rx_filter = ath12k_debugfs_rx_filter(ar);
 
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
-			if (g_bonded_interface_model &&
-			    test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ar->ab->dev_flags))
-				tlv_filter.rx_filter |= (HTT_RX_FILTER_TLV_FLAGS_PPDU_START |
-							 HTT_RX_FILTER_TLV_FLAGS_PPDU_END_USER_STATS |
-							 HTT_RX_FILTER_TLV_FLAGS_PPDU_END_USER_STATS_EXT |
-							 HTT_RX_FILTER_TLV_FLAGS_PPDU_START_USER_INFO);
-#endif /* CPTCFG_ATH12K_BONDED_DS_SUPPORT */
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+		if (test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ar->ab->dev_flags))
+			tlv_filter.rx_filter |= (HTT_RX_FILTER_TLV_FLAGS_PPDU_START |
+						 HTT_RX_FILTER_TLV_FLAGS_PPDU_END_USER_STATS |
+						 HTT_RX_FILTER_TLV_FLAGS_PPDU_END_USER_STATS_EXT |
+						 HTT_RX_FILTER_TLV_FLAGS_PPDU_START_USER_INFO);
+#endif /* CPTCFG_ATH12K_PPE_DS_SUPPORT */
 
 	}
 
@@ -10864,8 +10845,9 @@ static void ath12k_mac_update_vif_offloa
 					IEEE80211_OFFLOAD_DECAP_ENABLED);
 
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
-	if (vif->type == NL80211_IFTYPE_AP && arvif->ndev_pvt
-			&& (hweight16(vif->valid_links) > 1))
+	/* TODO: DS: revisit this */
+	if (test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags) &&
+	    vif->type == NL80211_IFTYPE_AP)
 		vif->offload_flags |= (IEEE80211_OFFLOAD_ENCAP_ENABLED |
 					IEEE80211_OFFLOAD_DECAP_ENABLED);
 #endif
@@ -10989,11 +10971,6 @@ static void ath12k_update_obss_color_not
 	struct ath12k_wmi_peer_create_arg peer_param = {0};
 	struct ieee80211_bss_conf *link_conf;
 	u32 param_id, param_value;
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
-	struct wireless_dev *wdev = ieee80211_vif_to_wdev(vif);
-	struct net_device *link_ndev = NULL;
-	struct ath12k_link_vif_pvt *link_ndev_pvt = NULL;
-#endif
 	u16 nss;
 	int i;
 	int ret, fbret, vdev_id;
@@ -11066,17 +11043,6 @@ static void ath12k_update_obss_color_not
 	arvif->dp = &ab->dp;
 	arvif->dev = ab->dev;
 	arvif->pdev_idx = ar->pdev_idx;
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
-	if (arvif->link_id != ATH12K_DEFAULT_SCAN_LINK) {
-		link_ndev = vif->link_ndev[link_id];
-		if (link_ndev) {
-			link_ndev_pvt = netdev_priv(link_ndev);
-			link_ndev_pvt->ab = ab;
-			link_ndev_pvt->arvif = arvif;
-			arvif->ndev_pvt = link_ndev_pvt;
-		}
-	}
-#endif
 
 	switch (vif->type) {
 	case NL80211_IFTYPE_UNSPECIFIED:
@@ -11175,22 +11141,6 @@ static void ath12k_update_obss_color_not
 				    arvif->vdev_id, ret);
 			goto err_peer_del;
 		}
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
-		if (arvif->link_id != ATH12K_DEFAULT_SCAN_LINK) {
-			if (hweight16(vif->valid_links) <= 1 && link_ndev && !wdev->ml_netdev) {
-				ath12k_free_bonddev_for_sfe(wdev, vif, link_id);
-				arvif->ndev_pvt = NULL;
-				arvif->ppe_vp_num = -1;
-			} else if (link_ndev && !arvif->ndev_pvt->is_bond_enslaved) {
-				ath12k_enable_ppe_for_link_netdev(ab, arvif,
-								 arvif->ndev_pvt->link_ndev);
-				netif_tx_start_all_queues(arvif->ndev_pvt->bond_dev);
-				netif_tx_start_all_queues(arvif->ndev_pvt->link_ndev);
-				arvif->ndev_pvt->bond_dev->flags |= IFF_UP;
-				ath12k_bond_link_enslave(arvif, arvif->ndev_pvt->link_ndev);
-			}
-		}
-#endif
 		break;
 	case WMI_VDEV_TYPE_STA:
 		param_id = WMI_STA_PS_PARAM_RX_WAKE_POLICY;
@@ -11259,7 +11209,7 @@ static void ath12k_update_obss_color_not
 	    test_bit(MONITOR_CONF_ENABLED, &ar->monitor_flags))
 		ath12k_mac_monitor_vdev_create(ar);
 
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 	ret = ath12k_wmi_send_vdev_set_intra_bss_cmd(ar, arvif->vdev_id,
 						     1);
 	if (ret) {
@@ -11478,6 +11428,12 @@ static int ath12k_mac_op_add_interface(s
 		ahvif->ppe_rfs_core_mask = ppe_rfs_core_mask;
 	}
 
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+	/* TODO: DS: revisit for new DS design*/
+	ahvif->ppe_vp_num = -1;
+	ahvif->ppe_vp_type = -1;
+#endif
+
 	INIT_LIST_HEAD(&ahvif->deflink.list);
 	INIT_DELAYED_WORK(&ahvif->deflink.connection_loss_work,
 			ath12k_mac_vif_sta_connection_loss_work);
@@ -11852,7 +11808,6 @@ static int ath12k_mac_op_ampdu_action(st
 	return ret;
 }
 
-#ifndef CPTCFG_ATH12K_BONDED_DS_SUPPORT
 int ath12k_mac_op_change_vif_links(struct ieee80211_hw *hw,
 				   struct ieee80211_vif *vif,
 				   u16 old_links, u16 new_links,
@@ -11862,7 +11817,6 @@ int ath12k_mac_op_change_vif_links(struc
 		    "link changed for MLD %pM old %d new %d\n", vif->addr, old_links, new_links);
 	return 0;
 }
-#endif
 
 static int ath12k_mac_op_add_chanctx(struct ieee80211_hw *hw,
 				     struct ieee80211_chanctx_conf *ctx)
@@ -16333,9 +16287,6 @@ static const struct ieee80211_ops ath12k
 	.cancel_remain_on_channel       = ath12k_mac_op_cancel_remain_on_channel,
 	.get_txpower			= ath12k_mac_op_get_txpower,
 	.set_radar_background		= ath12k_mac_op_set_radar_background,
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
-	.set_multicast_to_unicast	= ath12k_mac_op_set_multicast_to_unicast,
-#endif
 };
 
 static void ath12k_mac_update_ch_list(struct ath12k *ar,
@@ -17617,9 +17568,6 @@ int ath12k_mac_allocate(struct ath12k_hw
 			goto err_mac_destroy;
 		}
 
-#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
-		ieee80211_enable_bond_dev(hw);
-#endif
 		ah = hw->priv;
 		ah->hw = hw;
 		ah->ops = ops;
--- a/drivers/net/wireless/ath/ath12k/pci.c
+++ b/drivers/net/wireless/ath/ath12k/pci.c
@@ -11,7 +11,6 @@
 #include "mhi.h"
 #include "debug.h"
 #include "ppe.h"
-#include "bondif.h"
 #include "pcic.h"
 
 #define ATH12K_PCI_BAR_NUM		0
@@ -924,9 +923,7 @@ static int ath12k_pci_probe(struct pci_d
 	u32 addr;
 	u32 msi = 0;
 	int ret;
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
-       ath12k_bond_enable_ppe_ds();
-#endif
+
 	ab = ath12k_core_alloc(&pdev->dev, sizeof(*ab_pci), ATH12K_BUS_PCI,
 			       &ath12k_pci_bus_params);
 	if (!ab) {
--- a/drivers/net/wireless/ath/ath12k/peer.c
+++ b/drivers/net/wireless/ath/ath12k/peer.c
@@ -817,8 +817,9 @@ int ath12k_peer_create(struct ath12k *ar
 	if (peer->vif->ppe_vp_type == PPE_VP_USER_TYPE_ACTIVE)
 		peer->ppe_vp_num = peer->vif->ppe_vp_num;
 #endif
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
-	peer->ppe_vp_num = arvif->ppe_vp_num;
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+	/* TODO: DS: assuming ahvif holds ppe_vp_num. revisit after new design*/
+	peer->ppe_vp_num = arvif->ahvif->ppe_vp_num;
 #endif
 
 	if (sta) {
--- a/drivers/net/wireless/ath/ath12k/peer.h
+++ b/drivers/net/wireless/ath/ath12k/peer.h
@@ -81,7 +81,7 @@ struct ath12k_peer {
 	 * here and would be same for all partner peers
 	 */
 	u8 ml_addr[ETH_ALEN];
-#if defined(CPTCFG_MAC80211_PPE_SUPPORT) || defined(CPTCFG_ATH12K_BONDED_DS_SUPPORT)
+#if defined(CPTCFG_MAC80211_PPE_SUPPORT) || defined(CPTCFG_ATH12K_PPE_DS_SUPPORT)
 	/* Duplicate PPE port number to avoid link vif lookup in rx data path */
 	int ppe_vp_num;
 #endif
--- a/drivers/net/wireless/ath/ath12k/ppe.c
+++ b/drivers/net/wireless/ath/ath12k/ppe.c
@@ -15,14 +15,10 @@
 #include <ppe_drv.h>
 #include <linux/dma-mapping.h>
 #include <asm/cacheflush.h>
-#include <net/bonding.h>
 #include "hif.h"
 #include "ppe.h"
 #include "fse.h"
 
-#ifdef CPTCFG_MAC80211_BONDED_SUPPORT
-extern int g_bonded_interface_model;
-#endif
 extern bool ath12k_fse_enable;
 
 static atomic_t num_ppeds_nodes;
@@ -515,13 +511,22 @@ void ath12k_dp_peer_ppeds_route_setup(st
 	u32 service_code = PPE_DRV_SC_SPF_BYPASS;
 	bool ppe_routing_enable = true;
 	bool use_ppe = true;
-	u32 priority_valid = 0, src_info = arvif->ppe_vp_num;
+	u32 priority_valid = 0, src_info = ahvif->ppe_vp_num;
 	struct ath12k_sta *ahsta = arsta->ahsta;
 	struct ieee80211_sta *sta;
 
-	if (!g_bonded_interface_model)
+	/* TODO: DS: revisit this function for miami 2G case.
+ 	 * introduce ast based DS checks and skip this function
+ 	 */
+	if (!test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags))
 		return;
 
+	if (ahvif->ppe_vp_num == -1 ||
+	    ahvif->ppe_vp_type != PPE_VP_USER_TYPE_DS) {
+		ath12k_info(ab, "DS is disabled for peer %pM\n", arsta->addr);
+		return;
+	}
+
 	/* If FSE is enabled, then let flow rule take decision of routing the
 	 * packet to DS or host.
 	 */
@@ -530,10 +535,6 @@ void ath12k_dp_peer_ppeds_route_setup(st
 
 	sta = container_of((void *)ahsta, struct ieee80211_sta, drv_priv);
 
-	/* In SLO AP, DS is not supported */
-	if (hweight16(ahvif->vif->valid_links) <= 1)
-		return;
-
 	/* When SLO STA is associated to AP link vif which does not have DS rings,
  	 * do not enable DS.
 	 */
@@ -544,20 +545,16 @@ void ath12k_dp_peer_ppeds_route_setup(st
 	 * disable DS routing on RX.
 	 */
 	if (sta->mlo) {
-		primary_link_arvif = arvif->ahvif->link[ahsta->assoc_link_id];
+		primary_link_arvif = arvif->ahvif->link[ahsta->primary_link_id];
 
-		if (primary_link_arvif->ppe_vp_num == -1 ||
-		    primary_link_arvif->ppe_vp_type != PPE_VP_USER_TYPE_DS) {
+		if (!test_bit(ATH12K_FLAG_PPE_DS_ENABLED,
+		    primary_link_arvif->ab->dev_flags)) {
 			ath12k_info(ab,
 				    "Primary link %d does not support DS "
 				    "Disabling DS routing on RX for peer %pM\n",
-				    ahsta->assoc_link_id, arsta->addr);
+				    ahsta->primary_link_id, arsta->addr);
 			return;
 		}
-
-		if (arvif->ppe_vp_num == -1 ||
-		    arvif->ppe_vp_type != PPE_VP_USER_TYPE_DS)
-			src_info = primary_link_arvif->ppe_vp_num;
 	}
 
 	ath12k_wmi_config_peer_ppeds_routing(ar, arsta->addr, arvif->vdev_id,
@@ -598,7 +595,7 @@ static int ath12k_dp_ppeds_alloc_ppe_vp_
 
 static void
 ath12k_dp_ppeds_dealloc_ppe_vp_profile(struct ath12k_base *ab,
-					 int ppe_vp_profile_idx)
+				       int ppe_vp_profile_idx)
 {
 	if (ppe_vp_profile_idx < 0 || ppe_vp_profile_idx >= PPE_VP_ENTRIES_MAX) {
 		ath12k_err(ab, "Invalid PPE VP profile free index");
@@ -764,10 +761,10 @@ void ath12k_dp_ppeds_update_vp_entry(str
 				     struct ath12k_link_vif *arvif)
 {
 	struct ath12k_base *ab = ar->ab;
-	struct ath12k_link_vif_pvt *link_ndev_pvt = arvif->ndev_pvt;
 	struct ath12k_dp_ppe_vp_profile *vp_profile;
 	int ppe_vp_profile_idx;
 
+	/*TODO: DS: revisit this function */
 	if (!test_bit(ATH12K_FLAG_PPE_DS_ENABLED, &ab->dev_flags))
 		return;
 
@@ -776,12 +773,7 @@ void ath12k_dp_ppeds_update_vp_entry(str
 		return;
 	}
 
-	if (!link_ndev_pvt) {
-		ath12k_dbg(ab, ATH12K_DBG_PPE, "link netdevice not present for arvif\n");
-		return;
-	}
-
-	ppe_vp_profile_idx = link_ndev_pvt->ppe_vp_profile_idx;
+	ppe_vp_profile_idx = arvif->ppe_vp_profile_idx;
 	vp_profile = &ab->dp.ppe_vp_profile[ppe_vp_profile_idx];
 	if (!vp_profile) {
 		ath12k_dbg(ab, ATH12K_DBG_PPE, "vp profile not present for arvif\n");
@@ -791,16 +783,15 @@ void ath12k_dp_ppeds_update_vp_entry(str
 	ath12k_dp_ppeds_setup_vp_entry(ab, arvif->ar, arvif, vp_profile);
 }
 
-int ath12k_mac_op_ppeds_attach_vdev(struct ath12k_link_vif *arvif,
+/* TODO: DS: revisit ath12k_ppeds_attach_vdev and ath12k_ppeds_detach_vdev */
+int ath12k_ppeds_attach_vdev(struct ath12k_link_vif *arvif,
 				void *vp_arg, int *ppe_vp_num,
 				struct ieee80211_ppe_vp_ds_params *vp_params)
 {
-	//TODO: handle MLO
 	struct ath12k *ar = arvif->ar;
-	//TODO: Handle split phy
 	struct ath12k_base *ab = ar->ab;
+	struct ath12k_vif *ahvif = arvif->ahvif;
 	struct ath12k_dp_ppe_vp_profile *vp_profile = NULL;
-	struct ath12k_link_vif_pvt *link_ndev_pvt = NULL;
 	int ppe_vp_profile_idx, ppe_vp_tbl_idx, vp_num;
 	int ppe_vp_search_tbl_idx = -1;
 	int vdev_id = arvif->vdev_id;
@@ -818,12 +809,8 @@ int ath12k_mac_op_ppeds_attach_vdev(stru
 		return -EINVAL;
 	}
 
-	link_ndev_pvt = netdev_priv(vp_params->dev);
-	vp_num = ppe_ds_wlan_vp_alloc(ab->ppeds_handle, vp_params->dev, vp_arg);
-	if (vp_num < 0) {
-		ath12k_err(ab," vp alloc failed\n");
-		return -EFAULT;
-	}
+	/* No Need to allocate another vp here */
+	vp_num = ahvif->ppe_vp_num;
 
 	/*Allocate a ppe vp profile for a vap */
 	ppe_vp_profile_idx = ath12k_dp_ppeds_alloc_ppe_vp_profile(ab, &vp_profile);
@@ -882,7 +869,7 @@ vp_free:
 	return ret;
 }
 
-void ath12k_mac_op_ppeds_detach_vdev(struct ath12k_link_vif *arvif,
+void ath12k_ppeds_detach_vdev(struct ath12k_link_vif *arvif,
 				     struct ieee80211_ppe_vp_ds_params *vp_params)
 {
 	struct ath12k *ar = arvif->ar;
@@ -1108,46 +1095,6 @@ void ath12k_dp_ppeds_stop(struct ath12k_
 	ath12k_dbg(ab, ATH12K_DBG_PPE, "PPEDS stop success\n");
 }
 
-void ath12k_ppeds_partner_link_stop_queues(struct ath12k *ar)
-{
-	struct ath12k_link_vif *arvif;
-
-	rtnl_lock();
-	mutex_lock(&ar->conf_mutex);
-	list_for_each_entry(arvif, &ar->arvifs, list) {
-		if (!arvif)
-			continue;
-		if (arvif->ndev_pvt &&
-		    arvif->ndev_pvt->link_ndev)
-			netif_tx_stop_all_queues(arvif->ndev_pvt->link_ndev);
-	}
-	mutex_unlock(&ar->conf_mutex);
-	rtnl_unlock();
-}
-
-void ath12k_ppeds_partner_link_start_queues(struct ath12k *ar)
-{
-	struct ath12k_link_vif *arvif;
-
-	rtnl_lock();
-	mutex_lock(&ar->conf_mutex);
-	list_for_each_entry(arvif, &ar->arvifs, list) {
-		if (!arvif)
-			continue;
-		if (arvif->ndev_pvt) {
-			if (arvif->ndev_pvt->bond_dev &&
-			    !(arvif->ndev_pvt->bond_dev->flags & IFF_UP)) {
-				arvif->ndev_pvt->bond_dev->flags |= IFF_UP;
-				netif_tx_start_all_queues(arvif->ndev_pvt->bond_dev);
-			}
-			if (arvif->ndev_pvt->link_ndev)
-				netif_tx_start_all_queues(arvif->ndev_pvt->link_ndev);
-		}
-	}
-	mutex_unlock(&ar->conf_mutex);
-	rtnl_unlock();
-}
-
 int ath12k_dp_ppeds_register_soc(struct ath12k_dp *dp,
 				 struct dp_ppe_ds_idxs *idx)
 {
@@ -1279,7 +1226,7 @@ void ath12k_dp_srng_ppeds_cleanup(struct
 	ath12k_dp_srng_cleanup(ab, &dp->ppeds_comp_ring.ppe_wbm2sw_ring);
 }
 
-int ath12k_ppeds_get_core_mask(struct ath12k_vif *ahvif)
+int ath12k_ppe_rfs_get_core_mask(struct ath12k_vif *ahvif)
 {
 	struct ath12k_pdev *pdev;
 	struct ath12k *ar = ahvif->ah->radio;
@@ -1314,7 +1261,7 @@ int ath12k_change_core_mask_for_ppe_rfs(
 	struct wireless_dev *wdev = ieee80211_vif_to_wdev(ahvif->vif);
 	int ret;
 
-	if (!ath12k_ppe_rfs_support || wdev->bond_netdev)
+	if (!ath12k_ppe_rfs_support)
 		return 0;
 
 	if (!ahvif->ppe_rfs_vp_num) {
@@ -1347,7 +1294,7 @@ void ath12k_disable_ppe_rfs(struct ath12
 {
 	struct wireless_dev *wdev = ieee80211_vif_to_wdev(ahvif->vif);
 
-	if (!ath12k_ppe_rfs_support || wdev->bond_netdev)
+	if (!ath12k_ppe_rfs_support)
 		return;
 
 	if (!ahvif->ppe_rfs_vp_num) {
@@ -1371,7 +1318,7 @@ int ath12k_enable_ppe_rfs(struct ath12k_
 	struct wireless_dev *wdev = ieee80211_vif_to_wdev(ahvif->vif);
 
 	ahvif->ppe_rfs_vp_num = ATH12K_INVALID_PPE_RFS_VP_NUM;
-	if (!ath12k_ppe_rfs_support || wdev->bond_netdev ||
+	if (!ath12k_ppe_rfs_support ||
 	    ahvif->vdev_type == WMI_VDEV_TYPE_MONITOR ||
 	    !wdev->netdev)
 		return 0;
@@ -1386,7 +1333,7 @@ int ath12k_enable_ppe_rfs(struct ath12k_
 	if (core_mask)
 		vpai.core_mask = *core_mask;
 	else
-		vpai.core_mask = ath12k_ppeds_get_core_mask(ahvif);
+		vpai.core_mask = ath12k_ppe_rfs_get_core_mask(ahvif);
 
 	ppe_vp_num = ppe_vp_alloc(wdev->netdev, &vpai);
 	if (ppe_vp_num <= 0) {
@@ -1406,111 +1353,20 @@ int ath12k_enable_ppe_rfs(struct ath12k_
 	return 0;
 }
 
-void *ath12k_fse_get_ab_from_link_netdev(struct net_device *link_ndev)
-{
-	struct ath12k_link_vif_pvt *arvif_pvt = NULL;
-
-	if (link_ndev) {
-		arvif_pvt = netdev_priv(link_ndev);
-		if (arvif_pvt && arvif_pvt->ab)
-			ath12k_dbg(arvif_pvt->ab, ATH12K_DBG_DP_FST,
-				   "Get core AB:%pV of Link ndev:%s\n",
-				   arvif_pvt->ab->dev, link_ndev->name);
-	}
-
-	return arvif_pvt ? arvif_pvt->ab : NULL;
-}
-
-static void ath12k_dp_rx_ppe_update_flow_info(struct ath12k_base *ab,
-					      struct rx_flow_info *flow_info,
-					      struct ppe_drv_fse_rule_info *ppe_flow_info,
-					      int operation)
-{
-	struct hal_flow_tuple_info *tuple_info = &flow_info->flow_tuple_info;
-	struct ppe_drv_fse_tuple *ppe_tuple = &ppe_flow_info->tuple;
-
-	ath12k_dbg(ab, ATH12K_DBG_DP_FST, "%s S_IP:%x:%x:%x:%x,sPort:%u,D_IP:%x:%x:%x:%x,dPort:%u,Proto:%d,flags:%d",
-		   fse_state_to_string(operation),
-		   ppe_tuple->src_ip[0], ppe_tuple->src_ip[1],
-		   ppe_tuple->src_ip[2], ppe_tuple->src_ip[3],
-		   ppe_tuple->src_port,
-		   ppe_tuple->dest_ip[0], ppe_tuple->dest_ip[1],
-		   ppe_tuple->dest_ip[2], ppe_tuple->dest_ip[3],
-		   ppe_tuple->dest_port,
-		   ppe_tuple->protocol,
-		   ppe_flow_info->flags);
-
-	tuple_info->src_port = ppe_tuple->src_port;
-	tuple_info->dest_port = ppe_tuple->dest_port;
-	tuple_info->l4_protocol = ppe_tuple->protocol;
-	flow_info->fse_metadata = ATH12K_RX_FSE_FLOW_MATCH_PPE;
-
-	if (ppe_flow_info->flags & PPE_DRV_FSE_IPV4) {
-		flow_info->is_addr_ipv4 = 1;
-		tuple_info->src_ip_31_0 = ntohl(ppe_tuple->src_ip[0]);
-		tuple_info->dest_ip_31_0 = ntohl(ppe_tuple->dest_ip[0]);
-	} else if (ppe_flow_info->flags & PPE_DRV_FSE_IPV6) {
-		tuple_info->src_ip_31_0 = ntohl(ppe_tuple->src_ip[3]);
-		tuple_info->src_ip_63_32 = ntohl(ppe_tuple->src_ip[2]);
-		tuple_info->src_ip_95_64 = ntohl(ppe_tuple->src_ip[1]);
-		tuple_info->src_ip_127_96 = ntohl(ppe_tuple->src_ip[0]);
-
-		tuple_info->dest_ip_31_0 = ntohl(ppe_tuple->dest_ip[3]);
-		tuple_info->dest_ip_63_32 = ntohl(ppe_tuple->dest_ip[2]);
-		tuple_info->dest_ip_95_64 = ntohl(ppe_tuple->dest_ip[1]);
-		tuple_info->dest_ip_127_96 = ntohl(ppe_tuple->dest_ip[0]);
-	}
-
-	if (ppe_flow_info->flags & PPE_DRV_FSE_DS)
-		flow_info->use_ppe = 1;
-}
-
+/* TODO: DS: FSE needs to be reworked for DS with single netdevice model */
 bool
 ath12k_dp_rx_ppe_add_flow_entry(struct ppe_drv_fse_rule_info *ppe_flow_info)
 {
-	struct ath12k_base *ab;
-	struct rx_flow_info flow_info = { 0 };
-
-	if (!ath12k_fse_enable)
-		return false;
-
-	if (!ppe_flow_info->dev)
-		return false;
-
-	ab = ath12k_fse_get_ab_from_link_netdev(ppe_flow_info->dev);
-	if (!ab)
-		return false;
-
-	ath12k_dp_rx_ppe_update_flow_info(ab, &flow_info, ppe_flow_info, FSE_RULE_ADD);
-
-	return ath12k_dp_rx_flow_add_entry(ab, &flow_info);
+	/* TODO: DS: Revisit for  in single netdev model */
+	return false;
 }
 
 bool
 ath12k_dp_rx_ppe_del_flow_entry(struct ppe_drv_fse_rule_info *ppe_flow_info)
 {
-	struct ath12k_base *ab;
-	struct rx_flow_info flow_info = { 0 };
-
-	if (!ath12k_fse_enable)
-		return false;
-
-	if (!ppe_flow_info->dev)
-		return false;
-
-	ab = ath12k_fse_get_ab_from_link_netdev(ppe_flow_info->dev);
-	if (!ab)
-		return false;
-
-	/* Skip deleting entries during rmmod and SSR */
-	if (ppe_flow_info->dev->reg_state >= NETREG_UNREGISTERING ||
-	    netif_queue_stopped(ppe_flow_info->dev))
-		return false;
-
-	ath12k_dp_rx_ppe_update_flow_info(ab, &flow_info, ppe_flow_info,
-					  FSE_RULE_DELETE);
+	/* TODO: DS: Revisit for  in single netdev model */
+	return false;
 
-	return ath12k_dp_rx_flow_delete_entry(ab, &flow_info);
 }
 
 void ath12k_dp_rx_ppe_fse_register(void)
--- a/drivers/net/wireless/ath/ath12k/ppe.h
+++ b/drivers/net/wireless/ath/ath12k/ppe.h
@@ -20,6 +20,14 @@
 extern bool ath12k_ppe_rfs_support;
 extern unsigned int ath12k_mlo_capable;
 
+int ath12k_ppe_rfs_get_core_mask(struct ath12k_vif *ahvif);
+int ath12k_change_core_mask_for_ppe_rfs(struct ath12k_base *ab,
+					struct ath12k_vif *ahvif,
+					int core_mask);
+int ath12k_enable_ppe_rfs(struct ath12k_vif *ahvif,
+			  int *core_mask);
+void ath12k_disable_ppe_rfs(struct ath12k_vif *ahvif);
+
 #ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 
 #define ATH12K_DP_PPEDS_NAPI_DONE_BIT	1
@@ -39,10 +47,10 @@ void ath12k_dp_ppeds_stop(struct ath12k_
 int ath12k_dp_ppeds_start(struct ath12k_base *ab);
 int ath12k_ppeds_detach( struct ath12k_base *ab);
 int ath12k_ppeds_attach( struct ath12k_base *ab);
-int ath12k_mac_op_ppeds_attach_vdev(struct ath12k_link_vif *arvif,
+int ath12k_ppeds_attach_vdev(struct ath12k_link_vif *arvif,
                                 void *vp_arg, int *ppe_vp_num,
                                 struct ieee80211_ppe_vp_ds_params *vp_params);
-void ath12k_mac_op_ppeds_detach_vdev(struct ath12k_link_vif *arvif,
+void ath12k_ppeds_detach_vdev(struct ath12k_link_vif *arvif,
                                      struct ieee80211_ppe_vp_ds_params *vp_params);
 void ath12k_dp_peer_ppeds_route_setup(struct ath12k *ar, struct ath12k_link_vif *arvif,
 				      struct ath12k_link_sta *arsta);
@@ -62,14 +70,7 @@ void ath12k_ppeds_partner_link_start_que
 void ath12k_ppeds_partner_link_stop_queues(struct ath12k *ar);
 void ath12k_dp_rx_ppe_fse_register(void);
 void ath12k_dp_rx_ppe_fse_unregister(void);
-#endif
 
-int ath12k_ppeds_get_core_mask(struct ath12k_vif *ahvif);
-int ath12k_change_core_mask_for_ppe_rfs(struct ath12k_base *ab,
-					struct ath12k_vif *ahvif,
-					int core_mask);
-int ath12k_enable_ppe_rfs(struct ath12k_vif *ahvif,
-			  int *core_mask);
-void ath12k_disable_ppe_rfs(struct ath12k_vif *ahvif);
+#endif /* CPTCFG_ATH12K_PPE_DS_SUPPORT */
 
 #endif
--- a/drivers/net/wireless/ath/ath12k/vendor.c
+++ b/drivers/net/wireless/ath/ath12k/vendor.c
@@ -12,7 +12,6 @@
 #include "mac.h"
 #include "telemetry.h"
 #include "sawf.h"
-#include "bondif.h"
 #include "dp_rx.h"
 #include "pci.h"
 
@@ -1016,7 +1015,9 @@ static int ath12k_vendor_ds_handler(stru
 	int ret = 0;
 	int ml_netdev = 0;
 
-	if (!g_bonded_interface_model)
+	/* TODO: DS: This function to be reused for per VAP PPE VP
+	 * config support */
+	if (!ath12k_ppe_ds_enabled)
 		return 0;
 
 	ret = nla_parse(tb, QCA_WLAN_VENDOR_ATTR_DS_MAX, data, data_len,
@@ -1032,7 +1033,6 @@ static int ath12k_vendor_ds_handler(stru
 
 	ath12k_dbg(NULL, ATH12K_DBG_PPE,
 		   "Marking dev [%s] as mlo netdev. %d\n", wdev->netdev->name, ml_netdev);
-	wdev->ml_netdev = ml_netdev;
 
 	return 0;
 }
--- a/drivers/net/wireless/ath/ath12k/vendor.h
+++ b/drivers/net/wireless/ath/ath12k/vendor.h
@@ -7,6 +7,8 @@
 
 #define QCA_NL80211_VENDOR_ID 0x001374
 
+extern unsigned int ath12k_ppe_ds_enabled;
+
 enum qca_nl80211_vendor_subcmds {
 	/* Wi-Fi configuration subcommand */
 	QCA_NL80211_VENDOR_SUBCMD_SET_WIFI_CONFIGURATION = 74,
--- a/drivers/net/wireless/ath/ath12k/wmi.h
+++ b/drivers/net/wireless/ath/ath12k/wmi.h
@@ -3892,7 +3892,8 @@ struct wmi_peer_set_param_cmd {
 	__le32 param_value;
 } __packed;
 
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
+/* TODO: DS: HW still need to mark the frames as intra bss to make SW job easier. */
 struct wmi_peer_set_intra_bss_cmd {
 	__le32 tlv_header;
 	struct wmi_mac_addr peer_macaddr;
@@ -8751,14 +8752,12 @@ int
 ath12k_mgmt_rx_reo_init_context(struct ath12k_base *ab);
 int
 ath12k_mgmt_rx_reo_deinit_context(struct ath12k_base *ab);
-#ifdef CPTCFG_ATH12K_BONDED_DS_SUPPORT
+#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 int
 ath12k_wmi_send_vdev_set_intra_bss_cmd(struct ath12k *ar,
 				       u32 vdev_id, u32 enable);
 int ath12k_wmi_set_peer_intra_bss_cmd(struct ath12k *ar,  u32 vdev_id, const u8 *peer_addr,
 				      u32 enable);
-#endif
-#ifdef CPTCFG_ATH12K_PPE_DS_SUPPORT
 int ath12k_wmi_config_peer_ppeds_routing(struct ath12k *ar,
 					 const u8 *peer_addr, u8 vdev_id,
 					 u32 service_code, u32 priority_valid,
