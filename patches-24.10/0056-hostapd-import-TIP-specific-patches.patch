From 5d526cceade9b4082a01641928577db924a36c5c Mon Sep 17 00:00:00 2001
From: John Crispin <john@phrozen.org>
Date: Wed, 20 Aug 2025 09:36:17 +0200
Subject: [PATCH] hostapd: import TIP specific patches

Signed-off-by: John Crispin <john@phrozen.org>
---
 .../hostapd/files/hostapd-full.config         |   4 +-
 .../hostapd/patches/600-ubus_support.patch    |   4 +-
 .../services/hostapd/patches/900-wispr.patch  | 113 +++++++++
 .../hostapd/patches/901-acs_exclude_dfs.patch |  15 ++
 .../hostapd/patches/902-maxassoc.patch        |  13 +
 .../903-fix-ap-sta-channel-setup-failed.patch |  29 +++
 .../hostapd/patches/904-cfg-section.patch     |  51 ++++
 .../hostapd/patches/905-probe-request.patch   |  49 ++++
 .../services/hostapd/patches/906-s8-u8.patch  |  22 ++
 .../patches/907-wired-dynamic-vlan.patch      |  33 +++
 .../services/hostapd/patches/908-coa.patch    |  22 ++
 .../hostapd/patches/909-coa-ubus.patch        |  28 +++
 .../hostapd/patches/910-das-proxy-state.patch |  95 +++++++
 .../hostapd/patches/911-ssi_signal.patch      |  75 ++++++
 .../patches/912-ignore-probe-event.patch      |  14 ++
 .../patches/913-radius-extended-avp.patch     |  11 +
 .../hostapd/patches/914-roaming-key.patch     |  67 +++++
 .../hostapd/patches/915-ft_refresh.patch      |  86 +++++++
 .../916-proxy-arp-fail-gracefully.patch       |  27 ++
 .../917-hostapd-Fix-DVLAN-802.1x-issue.patch  |  53 ++++
 .../hostapd/patches/918-ft-anonce.patch       |  46 ++++
 .../services/hostapd/src/src/ap/ubus.c        | 235 +++++++++++++++++-
 .../services/hostapd/src/src/ap/ubus.h        |   2 +
 23 files changed, 1081 insertions(+), 13 deletions(-)
 create mode 100644 package/network/services/hostapd/patches/900-wispr.patch
 create mode 100644 package/network/services/hostapd/patches/901-acs_exclude_dfs.patch
 create mode 100644 package/network/services/hostapd/patches/902-maxassoc.patch
 create mode 100644 package/network/services/hostapd/patches/903-fix-ap-sta-channel-setup-failed.patch
 create mode 100644 package/network/services/hostapd/patches/904-cfg-section.patch
 create mode 100644 package/network/services/hostapd/patches/905-probe-request.patch
 create mode 100644 package/network/services/hostapd/patches/906-s8-u8.patch
 create mode 100644 package/network/services/hostapd/patches/907-wired-dynamic-vlan.patch
 create mode 100644 package/network/services/hostapd/patches/908-coa.patch
 create mode 100644 package/network/services/hostapd/patches/909-coa-ubus.patch
 create mode 100644 package/network/services/hostapd/patches/910-das-proxy-state.patch
 create mode 100644 package/network/services/hostapd/patches/911-ssi_signal.patch
 create mode 100644 package/network/services/hostapd/patches/912-ignore-probe-event.patch
 create mode 100644 package/network/services/hostapd/patches/913-radius-extended-avp.patch
 create mode 100644 package/network/services/hostapd/patches/914-roaming-key.patch
 create mode 100644 package/network/services/hostapd/patches/915-ft_refresh.patch
 create mode 100644 package/network/services/hostapd/patches/916-proxy-arp-fail-gracefully.patch
 create mode 100644 package/network/services/hostapd/patches/917-hostapd-Fix-DVLAN-802.1x-issue.patch
 create mode 100644 package/network/services/hostapd/patches/918-ft-anonce.patch

diff --git a/package/network/services/hostapd/files/hostapd-full.config b/package/network/services/hostapd/files/hostapd-full.config
index 9076ebc44f..2ac2a312d1 100644
--- a/package/network/services/hostapd/files/hostapd-full.config
+++ b/package/network/services/hostapd/files/hostapd-full.config
@@ -94,10 +94,10 @@ CONFIG_EAP_TTLS=y
 #CONFIG_EAP_PAX=y
 
 # EAP-PSK for the integrated EAP server (this is _not_ needed for WPA-PSK)
-#CONFIG_EAP_PSK=y
+CONFIG_EAP_PSK=y
 
 # EAP-pwd for the integrated EAP server (secure authentication with a password)
-#CONFIG_EAP_PWD=y
+CONFIG_EAP_PWD=y
 
 # EAP-SAKE for the integrated EAP server
 #CONFIG_EAP_SAKE=y
diff --git a/package/network/services/hostapd/patches/600-ubus_support.patch b/package/network/services/hostapd/patches/600-ubus_support.patch
index 256d1cfcc4..9d8a9f24ec 100644
--- a/package/network/services/hostapd/patches/600-ubus_support.patch
+++ b/package/network/services/hostapd/patches/600-ubus_support.patch
@@ -221,7 +221,7 @@ probe/assoc/auth requests via object subscribe.
  		goto fail;
  	}
 +	ubus_resp = hostapd_ubus_handle_event(hapd, &req);
-+	if (ubus_resp) {
++	if (0 && ubus_resp) {
 +		wpa_printf(MSG_DEBUG, "Station " MACSTR " rejected by ubus handler.\n",
 +			MAC2STR(mgmt->sa));
 +		resp = ubus_resp > 0 ? (u16) ubus_resp : WLAN_STATUS_UNSPECIFIED_FAILURE;
@@ -256,7 +256,7 @@ probe/assoc/auth requests via object subscribe.
  		ieee802_11_update_beacons(hapd->iface);
  
 +	ubus_resp = hostapd_ubus_handle_event(hapd, &req);
-+	if (ubus_resp) {
++	if (0 && ubus_resp) {
 +		wpa_printf(MSG_DEBUG, "Station " MACSTR " assoc rejected by ubus handler.\n",
 +		       MAC2STR(mgmt->sa));
 +		resp = ubus_resp > 0 ? (u16) ubus_resp : WLAN_STATUS_UNSPECIFIED_FAILURE;
diff --git a/package/network/services/hostapd/patches/900-wispr.patch b/package/network/services/hostapd/patches/900-wispr.patch
new file mode 100644
index 0000000000..59537cedeb
--- /dev/null
+++ b/package/network/services/hostapd/patches/900-wispr.patch
@@ -0,0 +1,113 @@
+Index: hostapd-2021-02-20-59e9794c/src/ap/ieee802_1x.c
+===================================================================
+--- hostapd-2021-02-20-59e9794c.orig/src/ap/ieee802_1x.c
++++ hostapd-2021-02-20-59e9794c/src/ap/ieee802_1x.c
+@@ -1904,6 +1904,25 @@ static int ieee802_1x_update_vlan(struct
+ }
+ #endif /* CONFIG_NO_VLAN */
+ 
++static int ieee802_1x_update_wispr(struct hostapd_data *hapd,
++				   struct sta_info *sta,
++				   struct radius_msg *msg)
++{
++	memset(sta->bandwidth, 0, sizeof(sta->bandwidth));
++
++	if (radius_msg_get_wispr(msg, &sta->bandwidth))
++		return 0;
++
++	if (!sta->bandwidth[0] && !sta->bandwidth[1])
++		return 0;
++
++	hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE8021X,
++		       HOSTAPD_LEVEL_INFO,
++		       "received wispr bandwidth from RADIUS server %d/%d",
++		       sta->bandwidth[0], sta->bandwidth[1]);
++
++	return 0;
++}
+ 
+ /**
+  * ieee802_1x_receive_auth - Process RADIUS frames from Authentication Server
+@@ -2029,6 +2048,7 @@ ieee802_1x_receive_auth(struct radius_ms
+ 		ieee802_1x_check_hs20(hapd, sta, msg,
+ 				      session_timeout_set ?
+ 				      (int) session_timeout : -1);
++		ieee802_1x_update_wispr(hapd, sta, msg);
+ 		break;
+ 	case RADIUS_CODE_ACCESS_REJECT:
+ 		sm->eap_if->aaaFail = true;
+Index: hostapd-2021-02-20-59e9794c/src/ap/sta_info.h
+===================================================================
+--- hostapd-2021-02-20-59e9794c.orig/src/ap/sta_info.h
++++ hostapd-2021-02-20-59e9794c/src/ap/sta_info.h
+@@ -117,6 +117,7 @@ struct sta_info {
+ 	u8 supported_rates[WLAN_SUPP_RATES_MAX];
+ 	int supported_rates_len;
+ 	u8 qosinfo; /* Valid when WLAN_STA_WMM is set */
++	u32 bandwidth[2];
+ 
+ #ifdef CONFIG_MESH
+ 	enum mesh_plink_state plink_state;
+Index: hostapd-2021-02-20-59e9794c/src/radius/radius.c
+===================================================================
+--- hostapd-2021-02-20-59e9794c.orig/src/radius/radius.c
++++ hostapd-2021-02-20-59e9794c/src/radius/radius.c
+@@ -1182,6 +1182,35 @@ radius_msg_get_cisco_keys(struct radius_
+ 	return keys;
+ }
+ 
++#define RADIUS_VENDOR_ID_WISPR	14122
++#define RADIUS_WISPR_AV_BW_UP	7
++#define RADIUS_WISPR_AV_BW_DOWN	8
++
++int
++radius_msg_get_wispr(struct radius_msg *msg, u32 *bandwidth)
++{
++	int i;
++
++	if (msg == NULL || bandwidth == NULL)
++		return 1;
++
++	for (i = 0; i < 2; i++) {
++		size_t keylen;
++		u8 *key;
++
++		key = radius_msg_get_vendor_attr(msg, RADIUS_VENDOR_ID_WISPR,
++						 RADIUS_WISPR_AV_BW_UP + i, &keylen);
++		if (!key)
++			continue;
++
++		if (keylen == 4)
++			bandwidth[i] = ntohl(*((u32 *)key));
++		os_free(key);
++	}
++
++	return 0;
++}
++
+ 
+ int radius_msg_add_mppe_keys(struct radius_msg *msg,
+ 			     const u8 *req_authenticator,
+Index: hostapd-2021-02-20-59e9794c/src/radius/radius.h
+===================================================================
+--- hostapd-2021-02-20-59e9794c.orig/src/radius/radius.h
++++ hostapd-2021-02-20-59e9794c/src/radius/radius.h
+@@ -205,6 +205,10 @@ enum {
+ 	RADIUS_VENDOR_ATTR_WFA_HS20_T_C_URL = 10,
+ };
+ 
++#define RADIUS_VENDOR_ID_WISPR	14122
++#define RADIUS_WISPR_AV_BW_UP	7
++#define RADIUS_WISPR_AV_BW_DOWN	8
++
+ #ifdef _MSC_VER
+ #pragma pack(pop)
+ #endif /* _MSC_VER */
+@@ -277,6 +281,7 @@ radius_msg_get_ms_keys(struct radius_msg
+ struct radius_ms_mppe_keys *
+ radius_msg_get_cisco_keys(struct radius_msg *msg, struct radius_msg *sent_msg,
+ 			  const u8 *secret, size_t secret_len);
++int radius_msg_get_wispr(struct radius_msg *msg, u32 *bandwidth);
+ int radius_msg_add_mppe_keys(struct radius_msg *msg,
+ 			     const u8 *req_authenticator,
+ 			     const u8 *secret, size_t secret_len,
diff --git a/package/network/services/hostapd/patches/901-acs_exclude_dfs.patch b/package/network/services/hostapd/patches/901-acs_exclude_dfs.patch
new file mode 100644
index 0000000000..52d63c5ff9
--- /dev/null
+++ b/package/network/services/hostapd/patches/901-acs_exclude_dfs.patch
@@ -0,0 +1,15 @@
+Index: hostapd-2021-02-20-59e9794c/src/ap/acs.c
+===================================================================
+--- hostapd-2021-02-20-59e9794c.orig/src/ap/acs.c
++++ hostapd-2021-02-20-59e9794c/src/ap/acs.c
+@@ -672,6 +672,10 @@ acs_find_ideal_chan_mode(struct hostapd_
+ 			continue;
+ 		}
+ 
++		if (iface->conf->acs_exclude_dfs &&
++                      (chan->flag & HOSTAPD_CHAN_RADAR))
++			continue;
++
+ 		/* HT40 on 5 GHz has a limited set of primary channels as per
+ 		 * 11n Annex J */
+ 		if (mode->mode == HOSTAPD_MODE_IEEE80211A &&
diff --git a/package/network/services/hostapd/patches/902-maxassoc.patch b/package/network/services/hostapd/patches/902-maxassoc.patch
new file mode 100644
index 0000000000..98840f382a
--- /dev/null
+++ b/package/network/services/hostapd/patches/902-maxassoc.patch
@@ -0,0 +1,13 @@
+Index: hostapd-2021-02-20-59e9794c/src/ap/sta_info.c
+===================================================================
+--- hostapd-2021-02-20-59e9794c.orig/src/ap/sta_info.c
++++ hostapd-2021-02-20-59e9794c/src/ap/sta_info.c
+@@ -717,7 +717,7 @@ struct sta_info * ap_sta_add(struct host
+ 		return sta;
+ 
+ 	wpa_printf(MSG_DEBUG, "  New STA");
+-	if (hapd->num_sta >= hapd->conf->max_num_sta) {
++	if (hostapd_check_max_sta(hapd)) {
+ 		/* FIX: might try to remove some old STAs first? */
+ 		wpa_printf(MSG_DEBUG, "no more room for new STAs (%d/%d)",
+ 			   hapd->num_sta, hapd->conf->max_num_sta);
diff --git a/package/network/services/hostapd/patches/903-fix-ap-sta-channel-setup-failed.patch b/package/network/services/hostapd/patches/903-fix-ap-sta-channel-setup-failed.patch
new file mode 100644
index 0000000000..de7a611587
--- /dev/null
+++ b/package/network/services/hostapd/patches/903-fix-ap-sta-channel-setup-failed.patch
@@ -0,0 +1,29 @@
+diff --git a/src/common/hw_features_common.c b/src/common/hw_features_common.c
+index ad2aebf..355b4a8 100644
+--- a/src/common/hw_features_common.c
++++ b/src/common/hw_features_common.c
+@@ -615,9 +615,21 @@ int hostapd_set_freq_params(struct hostapd_freq_params *data,
+ 			    center_segment0 == channel - 6)
+ 				data->center_freq1 = 5000 + center_segment0 * 5;
+ 			else {
+-				wpa_printf(MSG_ERROR,
+-					   "Wrong coupling between HT and VHT/HE channel setting");
+-				return -1;
++				if (channel <= 48)
++					center_segment0 = 42;
++				else if (channel <= 64)
++					center_segment0 = 58;
++				else if (channel <= 112)
++					center_segment0 = 106;
++				else if (channel <= 128)
++					center_segment0 = 122;
++				else if (channel <= 144)
++					center_segment0 = 138;
++				else if (channel <= 161)
++					center_segment0 = 155;
++				else if (channel <= 177)
++					center_segment0 = 171;
++				data->center_freq1 = 5000 + center_segment0 * 5;
+ 			}
+ 		}
+ 		break;
diff --git a/package/network/services/hostapd/patches/904-cfg-section.patch b/package/network/services/hostapd/patches/904-cfg-section.patch
new file mode 100644
index 0000000000..657c5054f6
--- /dev/null
+++ b/package/network/services/hostapd/patches/904-cfg-section.patch
@@ -0,0 +1,51 @@
+Index: hostapd-2023-06-22-599d00be/hostapd/config_file.c
+===================================================================
+--- hostapd-2023-06-22-599d00be.orig/hostapd/config_file.c
++++ hostapd-2023-06-22-599d00be/hostapd/config_file.c
+@@ -2345,6 +2345,8 @@ static int hostapd_config_fill(struct ho
+ 			return 1;
+ 		}
+ 		conf->driver = driver;
++	} else if (os_strcmp(buf, "uci_section") == 0) {
++		bss->uci_section = os_strdup(pos);
+ 	} else if (os_strcmp(buf, "driver_params") == 0) {
+ 		os_free(conf->driver_params);
+ 		conf->driver_params = os_strdup(pos);
+Index: hostapd-2023-06-22-599d00be/src/ap/ap_config.h
+===================================================================
+--- hostapd-2023-06-22-599d00be.orig/src/ap/ap_config.h
++++ hostapd-2023-06-22-599d00be/src/ap/ap_config.h
+@@ -288,6 +288,7 @@ struct hostapd_bss_config {
+ 	char vlan_bridge[IFNAMSIZ + 1];
+ 	char wds_bridge[IFNAMSIZ + 1];
+ 	int bridge_hairpin; /* hairpin_mode on bridge members */
++	char *uci_section;
+ 
+ 	enum hostapd_logger_level logger_syslog_level, logger_stdout_level;
+ 
+Index: hostapd-2023-06-22-599d00be/src/ap/ubus.c
+===================================================================
+--- hostapd-2023-06-22-599d00be.orig/src/ap/ubus.c
++++ hostapd-2023-06-22-599d00be/src/ap/ubus.c
+@@ -418,6 +418,9 @@ hostapd_bss_get_status(struct ubus_conte
+ 			hapd->iface->cac_started ? hapd->iface->dfs_cac_ms / 1000 - now.sec : 0);
+ 	blobmsg_close_table(&b, dfs_table);
+ 
++	if (hapd->conf->uci_section)
++		blobmsg_add_string(&b, "uci_section", hapd->conf->uci_section);
++
+ 	ubus_send_reply(ctx, req, b.head);
+ 
+ 	return 0;
+Index: hostapd-2023-06-22-599d00be/src/ap/ap_config.c
+===================================================================
+--- hostapd-2023-06-22-599d00be.orig/src/ap/ap_config.c
++++ hostapd-2023-06-22-599d00be/src/ap/ap_config.c
+@@ -798,6 +798,7 @@ void hostapd_config_free_bss(struct host
+ 	os_free(conf->radius_req_attr_sqlite);
+ 	os_free(conf->rsn_preauth_interfaces);
+ 	os_free(conf->ctrl_interface);
++	os_free(conf->uci_section);
+ 	os_free(conf->config_id);
+ 	os_free(conf->ca_cert);
+ 	os_free(conf->server_cert);
diff --git a/package/network/services/hostapd/patches/905-probe-request.patch b/package/network/services/hostapd/patches/905-probe-request.patch
new file mode 100644
index 0000000000..3b79338c2f
--- /dev/null
+++ b/package/network/services/hostapd/patches/905-probe-request.patch
@@ -0,0 +1,49 @@
+Index: hostapd-2021-02-20-59e9794c/hostapd/config_file.c
+===================================================================
+--- hostapd-2021-02-20-59e9794c.orig/hostapd/config_file.c
++++ hostapd-2021-02-20-59e9794c/hostapd/config_file.c
+@@ -3339,6 +3339,8 @@ static int hostapd_config_fill(struct ho
+ 		bss->ignore_broadcast_ssid = atoi(pos);
+ 	} else if (os_strcmp(buf, "no_probe_resp_if_max_sta") == 0) {
+ 		bss->no_probe_resp_if_max_sta = atoi(pos);
++	} else if (os_strcmp(buf, "dynamic_probe_resp") == 0) {
++		bss->dynamic_probe_resp = atoi(pos);
+ #ifdef CONFIG_WEP
+ 	} else if (os_strcmp(buf, "wep_default_key") == 0) {
+ 		bss->ssid.wep.idx = atoi(pos);
+Index: hostapd-2021-02-20-59e9794c/src/ap/ap_config.h
+===================================================================
+--- hostapd-2021-02-20-59e9794c.orig/src/ap/ap_config.h
++++ hostapd-2021-02-20-59e9794c/src/ap/ap_config.h
+@@ -460,6 +460,7 @@ struct hostapd_bss_config {
+ 	int ap_max_inactivity;
+ 	int ignore_broadcast_ssid;
+ 	int no_probe_resp_if_max_sta;
++	int dynamic_probe_resp;
+ 
+ 	int wmm_enabled;
+ 	int wmm_uapsd;
+Index: hostapd-2021-02-20-59e9794c/src/ap/beacon.c
+===================================================================
+--- hostapd-2021-02-20-59e9794c.orig/src/ap/beacon.c
++++ hostapd-2021-02-20-59e9794c/src/ap/beacon.c
+@@ -920,7 +920,8 @@ void handle_probe_req(struct hostapd_dat
+ 	}
+ #endif /* CONFIG_P2P */
+ 
+-	if (hapd->conf->ignore_broadcast_ssid && elems.ssid_len == 0 &&
++	if (!hapd->conf->dynamic_probe_resp &&
++	    hapd->conf->ignore_broadcast_ssid && elems.ssid_len == 0 &&
+ 	    elems.ssid_list_len == 0 && elems.short_ssid_list_len == 0) {
+ 		wpa_printf(MSG_MSGDUMP, "Probe Request from " MACSTR " for "
+ 			   "broadcast SSID ignored", MAC2STR(mgmt->sa));
+@@ -967,7 +968,8 @@ void handle_probe_req(struct hostapd_dat
+ 		return;
+ 	}
+ 
+-	if (hapd->conf->ignore_broadcast_ssid && res == WILDCARD_SSID_MATCH) {
++	if (!hapd->conf->dynamic_probe_resp &&
++	    hapd->conf->ignore_broadcast_ssid && res == WILDCARD_SSID_MATCH) {
+ 		wpa_printf(MSG_MSGDUMP, "Probe Request from " MACSTR " for "
+ 			   "broadcast SSID ignored", MAC2STR(mgmt->sa));
+ 		return;
diff --git a/package/network/services/hostapd/patches/906-s8-u8.patch b/package/network/services/hostapd/patches/906-s8-u8.patch
new file mode 100644
index 0000000000..f43aa91861
--- /dev/null
+++ b/package/network/services/hostapd/patches/906-s8-u8.patch
@@ -0,0 +1,22 @@
+Index: hostapd-2023-06-22-599d00be/src/drivers/driver_nl80211.c
+===================================================================
+--- hostapd-2023-06-22-599d00be.orig/src/drivers/driver_nl80211.c
++++ hostapd-2023-06-22-599d00be/src/drivers/driver_nl80211.c
+@@ -7686,7 +7686,7 @@ static int get_sta_handler(struct nl_msg
+ 		[NL80211_STA_INFO_BEACON_SIGNAL_AVG] = { .type = NLA_U8},
+ 		[NL80211_STA_INFO_RX_DURATION] = { .type = NLA_U64 },
+ 		[NL80211_STA_INFO_ACK_SIGNAL] = { .type = NLA_U8 },
+-		[NL80211_STA_INFO_ACK_SIGNAL_AVG] = { .type = NLA_S8 },
++		[NL80211_STA_INFO_ACK_SIGNAL_AVG] = { .type = NLA_U8 },
+ 		[NL80211_STA_INFO_RX_MPDUS] = { .type = NLA_U32 },
+ 		[NL80211_STA_INFO_FCS_ERROR_COUNT] = { .type = NLA_U32 },
+ 		[NL80211_STA_INFO_TX_DURATION] = { .type = NLA_U64 },
+@@ -7792,7 +7792,7 @@ static int get_sta_handler(struct nl_msg
+ 	}
+ 	if (stats[NL80211_STA_INFO_ACK_SIGNAL_AVG])
+ 		data->avg_ack_signal =
+-			nla_get_s8(stats[NL80211_STA_INFO_ACK_SIGNAL_AVG]);
++			nla_get_u8(stats[NL80211_STA_INFO_ACK_SIGNAL_AVG]);
+ 	if (stats[NL80211_STA_INFO_RX_MPDUS])
+ 		data->rx_mpdus = nla_get_u32(stats[NL80211_STA_INFO_RX_MPDUS]);
+ 	if (stats[NL80211_STA_INFO_FCS_ERROR_COUNT])
diff --git a/package/network/services/hostapd/patches/907-wired-dynamic-vlan.patch b/package/network/services/hostapd/patches/907-wired-dynamic-vlan.patch
new file mode 100644
index 0000000000..f673c3e34f
--- /dev/null
+++ b/package/network/services/hostapd/patches/907-wired-dynamic-vlan.patch
@@ -0,0 +1,33 @@
+Index: hostapd-2021-02-20-59e9794c/src/ap/vlan_init.c
+===================================================================
+--- hostapd-2021-02-20-59e9794c.orig/src/ap/vlan_init.c
++++ hostapd-2021-02-20-59e9794c/src/ap/vlan_init.c
+@@ -37,7 +37,14 @@ static int vlan_if_add(struct hostapd_da
+ 	}
+ #endif /* CONFIG_WEP */
+ 
+-	if (!vlan_exists)
++	if (!hapd->driver || !hapd->driver->if_add) {
++		char *dot = strstr(vlan->ifname, ".");
++		if (dot)
++			*dot = '\0';
++		ret = 0;
++	}
++	
++	else if (!vlan_exists)
+ 		ret = hostapd_vlan_if_add(hapd, vlan->ifname);
+ 	else if (!existsok)
+ 		return -1;
+Index: hostapd-2021-02-20-59e9794c/src/ap/vlan_init.c
+===================================================================
+--- hostapd-2021-02-20-59e9794c.orig/src/ap/vlan_init.c
++++ hostapd-2021-02-20-59e9794c/src/ap/vlan_init.c
+@@ -59,7 +59,7 @@ static int vlan_if_add(struct hostapd_da
+ 	if (hapd->wpa_auth)
+ 		ret = wpa_auth_ensure_group(hapd->wpa_auth, vlan->vlan_id);
+ 
+-	if (!ret && !vlan_exists)
++	if (!ret && !vlan_exists && hapd->driver->if_add)
+ 		hostapd_ubus_add_vlan(hapd, vlan);
+ 
+ 	if (ret == 0)
diff --git a/package/network/services/hostapd/patches/908-coa.patch b/package/network/services/hostapd/patches/908-coa.patch
new file mode 100644
index 0000000000..3e1213a4dd
--- /dev/null
+++ b/package/network/services/hostapd/patches/908-coa.patch
@@ -0,0 +1,22 @@
+--- a/src/radius/radius_das.c
++++ b/src/radius/radius_das.c
+@@ -48,6 +48,8 @@ static struct radius_msg * radius_das_di
+ 		RADIUS_ATTR_EVENT_TIMESTAMP,
+ 		RADIUS_ATTR_MESSAGE_AUTHENTICATOR,
+ 		RADIUS_ATTR_CHARGEABLE_USER_IDENTITY,
++		RADIUS_ATTR_VENDOR_SPECIFIC,
++		RADIUS_ATTR_CALLED_STATION_ID,
+ #ifdef CONFIG_IPV6
+ 		RADIUS_ATTR_NAS_IPV6_ADDRESS,
+ #endif /* CONFIG_IPV6 */
+@@ -205,9 +207,8 @@ static struct radius_msg * radius_das_co
+ 		RADIUS_ATTR_EVENT_TIMESTAMP,
+ 		RADIUS_ATTR_MESSAGE_AUTHENTICATOR,
+ 		RADIUS_ATTR_CHARGEABLE_USER_IDENTITY,
+-#ifdef CONFIG_HS20
+ 		RADIUS_ATTR_VENDOR_SPECIFIC,
+-#endif /* CONFIG_HS20 */
++		RADIUS_ATTR_CALLED_STATION_ID,
+ #ifdef CONFIG_IPV6
+ 		RADIUS_ATTR_NAS_IPV6_ADDRESS,
+ #endif /* CONFIG_IPV6 */
diff --git a/package/network/services/hostapd/patches/909-coa-ubus.patch b/package/network/services/hostapd/patches/909-coa-ubus.patch
new file mode 100644
index 0000000000..d525c79460
--- /dev/null
+++ b/package/network/services/hostapd/patches/909-coa-ubus.patch
@@ -0,0 +1,28 @@
+Index: hostapd-2021-02-20-59e9794c/src/ap/hostapd.c
+===================================================================
+--- hostapd-2021-02-20-59e9794c.orig/src/ap/hostapd.c
++++ hostapd-2021-02-20-59e9794c/src/ap/hostapd.c
+@@ -1034,6 +1034,23 @@ hostapd_das_disconnect(void *ctx, struct
+ 	struct hostapd_data *hapd = ctx;
+ 	struct sta_info *sta;
+ 	int multi;
++	int ubus_resp;
++	struct hostapd_ubus_request req = {
++		.type = HOSTAPD_UBUS_COA,
++		.mgmt_frame = 0,
++		.ssi_signal = 0,
++		.addr = attr->sta_addr,
++	};
++
++	if (hostapd_ubus_handle_event(hapd, &req)) {
++		wpa_printf(MSG_INFO, "DAS: disconnect due approved via ubus");
++		sta = ap_get_sta(hapd, attr->sta_addr);
++		if (sta) {
++			hostapd_drv_sta_deauth(hapd, attr->sta_addr, 2);
++			ap_sta_deauthenticate(hapd, sta, 2);
++		}
++		return RADIUS_DAS_SUCCESS;
++	}
+ 
+ 	if (hostapd_das_nas_mismatch(hapd, attr))
+ 		return RADIUS_DAS_NAS_MISMATCH;
diff --git a/package/network/services/hostapd/patches/910-das-proxy-state.patch b/package/network/services/hostapd/patches/910-das-proxy-state.patch
new file mode 100644
index 0000000000..64b7aa4c07
--- /dev/null
+++ b/package/network/services/hostapd/patches/910-das-proxy-state.patch
@@ -0,0 +1,95 @@
+Index: hostapd-2021-02-20-59e9794c/src/radius/radius_das.c
+===================================================================
+--- hostapd-2021-02-20-59e9794c.orig/src/radius/radius_das.c
++++ hostapd-2021-02-20-59e9794c/src/radius/radius_das.c
+@@ -63,6 +63,7 @@ static struct radius_msg * radius_das_di
+ 		RADIUS_ATTR_CHARGEABLE_USER_IDENTITY,
+ 		RADIUS_ATTR_VENDOR_SPECIFIC,
+ 		RADIUS_ATTR_CALLED_STATION_ID,
++		RADIUS_ATTR_PROXY_STATE,
+ #ifdef CONFIG_IPV6
+ 		RADIUS_ATTR_NAS_IPV6_ADDRESS,
+ #endif /* CONFIG_IPV6 */
+@@ -159,6 +160,12 @@ static struct radius_msg * radius_das_di
+ 		attrs.cui_len = len;
+ 	}
+ 
++	if (radius_msg_get_attr_ptr(msg, RADIUS_ATTR_PROXY_STATE,
++				    &buf, &len, NULL) == 0) {
++		attrs.proxy = buf;
++		attrs.proxy_len = len;
++	}
++
+ 	res = das->disconnect(das->ctx, &attrs);
+ 	switch (res) {
+ 	case RADIUS_DAS_NAS_MISMATCH:
+@@ -167,10 +174,11 @@ static struct radius_msg * radius_das_di
+ 		error = 403;
+ 		break;
+ 	case RADIUS_DAS_SESSION_NOT_FOUND:
+-		wpa_printf(MSG_INFO, "DAS: Session not found for request from "
+-			   "%s:%d", abuf, from_port);
+-		error = 503;
+-		break;
++		return NULL;
++//		wpa_printf(MSG_INFO, "DAS: Session not found for request from "
++//			   "%s:%d", abuf, from_port);
++//		error = 503;
++//		break;
+ 	case RADIUS_DAS_MULTI_SESSION_MATCH:
+ 		wpa_printf(MSG_INFO,
+ 			   "DAS: Multiple sessions match for request from %s:%d",
+@@ -192,6 +200,9 @@ fail:
+ 	if (reply == NULL)
+ 		return NULL;
+ 
++	if (attrs.proxy)
++		radius_msg_add_attr(reply, RADIUS_ATTR_PROXY_STATE, attrs.proxy, attrs.proxy_len);
++
+ 	if (error) {
+ 		if (!radius_msg_add_attr_int32(reply, RADIUS_ATTR_ERROR_CAUSE,
+ 					       error)) {
+@@ -222,6 +233,7 @@ static struct radius_msg * radius_das_co
+ 		RADIUS_ATTR_CHARGEABLE_USER_IDENTITY,
+ 		RADIUS_ATTR_VENDOR_SPECIFIC,
+ 		RADIUS_ATTR_CALLED_STATION_ID,
++		RADIUS_ATTR_PROXY_STATE,
+ #ifdef CONFIG_IPV6
+ 		RADIUS_ATTR_NAS_IPV6_ADDRESS,
+ #endif /* CONFIG_IPV6 */
+@@ -347,6 +359,12 @@ static struct radius_msg * radius_das_co
+ 	}
+ #endif /* CONFIG_HS20 */
+ 
++	if (radius_msg_get_attr_ptr(msg, RADIUS_ATTR_PROXY_STATE,
++				    &buf, &len, NULL) == 0) {
++		attrs.proxy = buf;
++		attrs.proxy_len = len;
++	}
++
+ 	res = das->coa(das->ctx, &attrs);
+ 	switch (res) {
+ 	case RADIUS_DAS_NAS_MISMATCH:
+@@ -382,6 +400,9 @@ fail:
+ 	if (!reply)
+ 		return NULL;
+ 
++	if (attrs.proxy)
++		radius_msg_add_attr(reply, RADIUS_ATTR_PROXY_STATE, attrs.proxy, attrs.proxy_len);
++
+ 	if (error &&
+ 	    !radius_msg_add_attr_int32(reply, RADIUS_ATTR_ERROR_CAUSE, error)) {
+ 		radius_msg_free(reply);
+Index: hostapd-2021-02-20-59e9794c/src/radius/radius_das.h
+===================================================================
+--- hostapd-2021-02-20-59e9794c.orig/src/radius/radius_das.h
++++ hostapd-2021-02-20-59e9794c/src/radius/radius_das.h
+@@ -36,6 +36,8 @@ struct radius_das_attrs {
+ 	size_t acct_multi_session_id_len;
+ 	const u8 *cui;
+ 	size_t cui_len;
++	const u8 *proxy;
++	size_t proxy_len;
+ 
+ 	/* Authorization changes */
+ 	const u8 *hs20_t_c_filtering;
diff --git a/package/network/services/hostapd/patches/911-ssi_signal.patch b/package/network/services/hostapd/patches/911-ssi_signal.patch
new file mode 100644
index 0000000000..4bc6ffd61a
--- /dev/null
+++ b/package/network/services/hostapd/patches/911-ssi_signal.patch
@@ -0,0 +1,75 @@
+--- a/src/ap/ieee802_11.c
++++ b/src/ap/ieee802_11.c
+@@ -64,6 +64,17 @@
+ #	include "apup.h"
+ #endif // def CONFIG_APUP
+ 
++static int
++ewma(int new, int old)
++{
++	#define ALPHA	10
++	if (!old)
++		return new;
++	if (new >= 0)
++		return old;
++	return ((ALPHA * new) + ((100 - ALPHA) * old)) / 100;
++}
++
+ #ifdef CONFIG_FILS
+ static struct wpabuf *
+ prepare_auth_resp_fils(struct hostapd_data *hapd,
+@@ -6080,7 +6091,7 @@ static int robust_action_frame(u8 catego
+ 
+ static int handle_action(struct hostapd_data *hapd,
+ 			 const struct ieee80211_mgmt *mgmt, size_t len,
+-			 unsigned int freq)
++			 unsigned int freq, int ssi_signal)
+ {
+ 	struct sta_info *sta;
+ 	u8 *action __maybe_unused;
+@@ -6137,6 +6148,7 @@ static int handle_action(struct hostapd_
+ 
+ 		sta->last_seq_ctrl = seq_ctrl;
+ 		sta->last_subtype = WLAN_FC_STYPE_ACTION;
++		sta->signal_mgmt = ewma(ssi_signal, sta->signal_mgmt);;
+ 	}
+ 
+ 	switch (mgmt->u.action.category) {
+@@ -6338,6 +6350,8 @@ int ieee802_11_mgmt(struct hostapd_data
+ 		{ 0x51, 0x6f, 0x9a, 0x01, 0x00, 0x00 };
+ #endif /* CONFIG_NAN_USD */
+ 
++	hapd->signal_mgmt = ewma(ssi_signal, hapd->signal_mgmt);;
++
+ 	if (len < 24)
+ 		return 0;
+ 
+@@ -6451,7 +6465,7 @@ int ieee802_11_mgmt(struct hostapd_data
+ 		break;
+ 	case WLAN_FC_STYPE_ACTION:
+ 		wpa_printf(MSG_DEBUG, "mgmt::action");
+-		ret = handle_action(hapd, mgmt, len, freq);
++		ret = handle_action(hapd, mgmt, len, freq, ssi_signal);
+ 		break;
+ 	default:
+ 		hostapd_logger(hapd, mgmt->sa, HOSTAPD_MODULE_IEEE80211,
+--- a/src/ap/sta_info.h
++++ b/src/ap/sta_info.h
+@@ -315,6 +315,7 @@ struct sta_info {
+ #ifdef CONFIG_PASN
+ 	struct pasn_data *pasn;
+ #endif /* CONFIG_PASN */
++	int signal_mgmt;
+ 
+ #ifdef CONFIG_IEEE80211BE
+ 	struct mld_info mld_info;
+--- a/src/ap/hostapd.h
++++ b/src/ap/hostapd.h
+@@ -538,6 +538,7 @@ struct hostapd_data {
+ 
+ 	u64 scan_cookie; /* Scan instance identifier for the ongoing HT40 scan
+ 			  */
++	int signal_mgmt;
+ };
+ 
+ 
diff --git a/package/network/services/hostapd/patches/912-ignore-probe-event.patch b/package/network/services/hostapd/patches/912-ignore-probe-event.patch
new file mode 100644
index 0000000000..93d31dfbbd
--- /dev/null
+++ b/package/network/services/hostapd/patches/912-ignore-probe-event.patch
@@ -0,0 +1,14 @@
+--- a/src/ap/beacon.c
++++ b/src/ap/beacon.c
+@@ -934,8 +934,10 @@ void handle_probe_req(struct hostapd_dat
+ 	int ubus_response;
+ 
+ 	if (hapd->iconf->rssi_ignore_probe_request && ssi_signal &&
+-	    ssi_signal < hapd->iconf->rssi_ignore_probe_request)
++	    ssi_signal < hapd->iconf->rssi_ignore_probe_request) {
++		hostapd_ubus_notify_rssi(hapd, "rssi-ignore-probe", mgmt->sa, ssi_signal);
+ 		return;
++	}
+ 
+ 	if (len < IEEE80211_HDRLEN)
+ 		return;
diff --git a/package/network/services/hostapd/patches/913-radius-extended-avp.patch b/package/network/services/hostapd/patches/913-radius-extended-avp.patch
new file mode 100644
index 0000000000..b70545f4bb
--- /dev/null
+++ b/package/network/services/hostapd/patches/913-radius-extended-avp.patch
@@ -0,0 +1,11 @@
+--- a/src/radius/radius.c
++++ b/src/radius/radius.c
+@@ -755,7 +755,7 @@ struct radius_attr_hdr * radius_msg_add_
+ 			ext->length = sizeof(*ext) + 1 + alen;
+ 			ext->ext_type = ext_type;
+ 			wpabuf_put_u8(msg->buf, data_len > alen ? 0x80 : 0);
+-			wpabuf_put_data(msg->buf, data, data_len);
++			wpabuf_put_data(msg->buf, data, alen);
+ 			data += alen;
+ 			data_len -= alen;
+ 			if (radius_msg_add_attr_to_array(
diff --git a/package/network/services/hostapd/patches/914-roaming-key.patch b/package/network/services/hostapd/patches/914-roaming-key.patch
new file mode 100644
index 0000000000..a7614aa284
--- /dev/null
+++ b/package/network/services/hostapd/patches/914-roaming-key.patch
@@ -0,0 +1,67 @@
+--- a/hostapd/config_file.c
++++ b/hostapd/config_file.c
+@@ -3362,6 +3362,8 @@ static int hostapd_config_fill(struct ho
+ 		bss->ft_over_ds = atoi(pos);
+ 	} else if (os_strcmp(buf, "ft_psk_generate_local") == 0) {
+ 		bss->ft_psk_generate_local = atoi(pos);
++	} else if (os_strcmp(buf, "ft_key") == 0) {
++		strncpy(bss->ft_key, pos, sizeof(bss->ft_key));
+ #endif /* CONFIG_IEEE80211R_AP */
+ #ifndef CONFIG_NO_CTRL_IFACE
+ 	} else if (os_strcmp(buf, "ctrl_interface") == 0) {
+@@ -5302,8 +5304,22 @@ struct hostapd_config * hostapd_config_r
+ 
+ 	fclose(f);
+ 
+-	for (i = 0; i < conf->num_bss; i++)
++	for (i = 0; i < conf->num_bss; i++) {
++		if (*conf->bss[i]->ft_key) {
++			u8 buffer[128];
++			sprintf(buffer, "%02X:%02X:%02X:%02X:%02X:%02X %02X%02X%02X%02X%02X%02X %s", MAC2STR(conf->bss[i]->bssid), MAC2STR(conf->bss[i]->bssid), conf->bss[i]->ft_key);
++			add_r0kh(conf->bss[i], buffer);
++			sprintf(buffer, "%02X:%02X:%02X:%02X:%02X:%02X %02X:%02X:%02X:%02X:%02X:%02X %s", MAC2STR(conf->bss[i]->bssid), MAC2STR(conf->bss[i]->bssid), conf->bss[i]->ft_key);
++			add_r1kh(conf->bss[i], buffer);
++			sprintf(buffer, "ff:ff:ff:ff:ff:ff * %s", conf->bss[i]->ft_key);
++			add_r0kh(conf->bss[i], buffer);
++			sprintf(buffer, "00:00:00:00:00:00 00:00:00:00:00:00 %s", conf->bss[i]->ft_key);
++			add_r1kh(conf->bss[i], buffer);
++			hexstr2bin(conf->bss[i]->bssid, conf->bss[i]->r1_key_holder, FT_R1KH_ID_LEN); 
++			conf->bss[i]->r0_key_holder_bssid = 1;
++		}
+ 		hostapd_set_security_params(conf->bss[i], 1);
++	}
+ 
+ 	if (hostapd_config_check(conf, 1))
+ 		errors++;
+--- a/src/ap/ap_config.h
++++ b/src/ap/ap_config.h
+@@ -407,6 +407,7 @@ struct hostapd_bss_config {
+ 	/* IEEE 802.11r - Fast BSS Transition */
+ 	u8 mobility_domain[MOBILITY_DOMAIN_ID_LEN];
+ 	u8 r1_key_holder[FT_R1KH_ID_LEN];
++	int r0_key_holder_bssid;
+ 	u32 r0_key_lifetime; /* PMK-R0 lifetime seconds */
+ 	int rkh_pos_timeout;
+ 	int rkh_neg_timeout;
+@@ -420,6 +421,7 @@ struct hostapd_bss_config {
+ 	int ft_psk_generate_local;
+ 	int r1_max_key_lifetime;
+ 	char *rxkh_file;
++	u8 ft_key[65];
+ #endif /* CONFIG_IEEE80211R_AP */
+ 
+ 	char *ctrl_interface; /* directory for UNIX domain sockets */
+--- a/src/ap/wpa_auth_glue.c
++++ b/src/ap/wpa_auth_glue.c
+@@ -87,7 +87,10 @@ static void hostapd_wpa_auth_conf(struct
+ #ifdef CONFIG_IEEE80211R_AP
+ 	os_memcpy(wconf->mobility_domain, conf->mobility_domain,
+ 		  MOBILITY_DOMAIN_ID_LEN);
+-	if (conf->nas_identifier &&
++	if (1 || conf->r0_key_holder_bssid) {
++		sprintf(wconf->r0_key_holder, "%02X%02X%02X%02X%02X%02X", MAC2STR(conf->bssid));
++		wconf->r0_key_holder_len = 12;
++	} else if (conf->nas_identifier &&
+ 	    os_strlen(conf->nas_identifier) <= FT_R0KH_ID_MAX_LEN) {
+ 		wconf->r0_key_holder_len = os_strlen(conf->nas_identifier);
+ 		os_memcpy(wconf->r0_key_holder, conf->nas_identifier,
diff --git a/package/network/services/hostapd/patches/915-ft_refresh.patch b/package/network/services/hostapd/patches/915-ft_refresh.patch
new file mode 100644
index 0000000000..064f5650ec
--- /dev/null
+++ b/package/network/services/hostapd/patches/915-ft_refresh.patch
@@ -0,0 +1,86 @@
+--- a/hostapd/config_file.c
++++ b/hostapd/config_file.c
+@@ -3364,6 +3364,8 @@ static int hostapd_config_fill(struct ho
+ 		bss->ft_psk_generate_local = atoi(pos);
+ 	} else if (os_strcmp(buf, "ft_key") == 0) {
+ 		strncpy(bss->ft_key, pos, sizeof(bss->ft_key));
++	} else if (os_strcmp(buf, "ft_l2_refresh") == 0) {
++		bss->ft_l2_refresh = atoi(pos);
+ #endif /* CONFIG_IEEE80211R_AP */
+ #ifndef CONFIG_NO_CTRL_IFACE
+ 	} else if (os_strcmp(buf, "ctrl_interface") == 0) {
+--- a/src/ap/ap_config.h
++++ b/src/ap/ap_config.h
+@@ -419,6 +419,7 @@ struct hostapd_bss_config {
+ 	int pmk_r1_push;
+ 	int ft_over_ds;
+ 	int ft_psk_generate_local;
++	int ft_l2_refresh;
+ 	int r1_max_key_lifetime;
+ 	char *rxkh_file;
+ 	u8 ft_key[65];
+--- a/src/ap/wpa_auth_glue.c
++++ b/src/ap/wpa_auth_glue.c
+@@ -1669,6 +1669,28 @@ static int hostapd_wpa_auth_get_drv_flag
+ }
+ 
+ 
++static void wpa_ft_refresh(void *eloop_data, void *user_data)
++{
++	struct hostapd_data *hapd = eloop_data;
++	struct ft_rrb_frame *frame;
++	struct l2_ethhdr *buf;
++	size_t len;
++
++	len = sizeof(*buf) + sizeof(*frame);
++	buf = os_zalloc(len);
++	frame = (struct ft_rrb_frame *)(buf + 1);
++	frame->frame_type = RSN_REMOTE_FRAME_TYPE_FT_RRB;
++	frame->packet_type = FT_PACKET_REQUEST;
++	memset(buf->h_dest, 0xff, ETH_ALEN);
++	os_memcpy(buf->h_source, hapd->own_addr, ETH_ALEN);
++	buf->h_proto = host_to_be16(ETH_P_RRB);
++	l2_packet_send(hapd->l2, buf->h_dest, ETH_P_RRB, (u8 *) buf, len);
++	os_free(buf);
++
++	eloop_register_timeout(hapd->conf->ft_l2_refresh, 0, wpa_ft_refresh,
++			       hapd, NULL);
++}
++
+ int hostapd_setup_wpa(struct hostapd_data *hapd)
+ {
+ 	struct wpa_auth_config _conf;
+@@ -1847,6 +1869,9 @@ int hostapd_setup_wpa(struct hostapd_dat
+ 				   "Failed to open ETH_P_OUI interface");
+ 			return -1;
+ 		}
++
++		if (hapd->conf->ft_l2_refresh)
++			wpa_ft_refresh(hapd, NULL);
+ 	}
+ #endif /* CONFIG_IEEE80211R_AP */
+ 
+@@ -1862,7 +1887,6 @@ void hostapd_reconfig_wpa(struct hostapd
+ 	wpa_reconfig(hapd->wpa_auth, &wpa_auth_conf);
+ }
+ 
+-
+ void hostapd_deinit_wpa(struct hostapd_data *hapd)
+ {
+ 	ieee80211_tkip_countermeasures_deinit(hapd);
+@@ -1886,6 +1910,7 @@ void hostapd_deinit_wpa(struct hostapd_d
+ 				   "information element from interface %s",
+ 				   hapd->conf->iface);
+ 		}
++
+ 	}
+ 	ieee802_1x_deinit(hapd);
+ 
+@@ -1894,6 +1919,7 @@ void hostapd_deinit_wpa(struct hostapd_d
+ 	hostapd_wpa_ft_rrb_rx_later(hapd, NULL); /* flush without delivering */
+ 	eloop_cancel_timeout(hostapd_oui_deliver_later, hapd, ELOOP_ALL_CTX);
+ 	hostapd_oui_deliver_later(hapd, NULL); /* flush without delivering */
++	eloop_cancel_timeout(wpa_ft_refresh, hapd, ELOOP_ALL_CTX);
+ 	l2_packet_deinit(hapd->l2);
+ 	hapd->l2 = NULL;
+ 	hostapd_wpa_unregister_ft_oui(hapd);
diff --git a/package/network/services/hostapd/patches/916-proxy-arp-fail-gracefully.patch b/package/network/services/hostapd/patches/916-proxy-arp-fail-gracefully.patch
new file mode 100644
index 0000000000..a9518623b4
--- /dev/null
+++ b/package/network/services/hostapd/patches/916-proxy-arp-fail-gracefully.patch
@@ -0,0 +1,27 @@
+--- a/src/ap/hostapd.c
++++ b/src/ap/hostapd.c
+@@ -1527,19 +1527,15 @@ int hostapd_setup_bss(struct hostapd_dat
+ 		if (x_snoop_init(hapd)) {
+ 			wpa_printf(MSG_ERROR,
+ 				   "Generic snooping infrastructure initialization failed");
+-			return -1;
+-		}
+-
+-		if (dhcp_snoop_init(hapd)) {
++			conf->proxy_arp = 0;
++		} else if (dhcp_snoop_init(hapd)) {
+ 			wpa_printf(MSG_ERROR,
+ 				   "DHCP snooping initialization failed");
+-			return -1;
+-		}
+-
+-		if (ndisc_snoop_init(hapd)) {
++			conf->proxy_arp = 0;
++		} else if (ndisc_snoop_init(hapd)) {
+ 			wpa_printf(MSG_ERROR,
+ 				   "Neighbor Discovery snooping initialization failed");
+-			return -1;
++			conf->proxy_arp = 0;
+ 		}
+ 	}
+ 
diff --git a/package/network/services/hostapd/patches/917-hostapd-Fix-DVLAN-802.1x-issue.patch b/package/network/services/hostapd/patches/917-hostapd-Fix-DVLAN-802.1x-issue.patch
new file mode 100644
index 0000000000..080d416592
--- /dev/null
+++ b/package/network/services/hostapd/patches/917-hostapd-Fix-DVLAN-802.1x-issue.patch
@@ -0,0 +1,53 @@
+From 98b6503b87bb36bf2f5ae16e52e230e8870c867f Mon Sep 17 00:00:00 2001
+From: Venkat Chimata <venkata@shasta.cloud>
+Date: Fri, 28 Jun 2024 14:39:31 +0530
+Subject: [PATCH] hostapd: Fix DVLAN + 802.1x issue
+
+In case of swconfig switches, the basename of the interface should be based on the last dot.
+Earlier it was done based on the first dot, which would result in incorrect basename.
+For example if the interface name is eth0.4087 then the vlan->ifname would be eth0.4087.  (A dot at the end) .
+Before this patch, the basename was returned as eth0. It should be eth0.4087
+
+Also fixed the return code by adding a default value of 0 and removed an unncessary check
+for if_add before ubus add call.
+
+Signed-off-by: Venkat Chimata <venkata@shasta.cloud>
+---
+ src/ap/vlan_init.c | 7 ++++---
+ 1 file changed, 4 insertions(+), 3 deletions(-)
+
+diff --git a/src/ap/vlan_init.c b/src/ap/vlan_init.c
+index 3e27671..cfeb1e5 100644
+--- a/src/ap/vlan_init.c
++++ b/src/ap/vlan_init.c
+@@ -23,7 +23,8 @@ static int vlan_if_add(struct hostapd_data *hapd, struct hostapd_vlan *vlan,
+ 		       int existsok)
+ {
+ 	bool vlan_exists = iface_exists(vlan->ifname);
+-	int ret;
++	int ret = 0;
++
+ #ifdef CONFIG_WEP
+ 	int i;
+ 
+@@ -38,7 +39,7 @@ static int vlan_if_add(struct hostapd_data *hapd, struct hostapd_vlan *vlan,
+ #endif /* CONFIG_WEP */
+ 
+ 	if (!hapd->driver || !hapd->driver->if_add) {
+-		char *dot = strstr(vlan->ifname, ".");
++		char *dot = strrchr(vlan->ifname, '.');
+ 		if (dot)
+ 			*dot = '\0';
+ 		ret = 0;
+@@ -59,7 +60,7 @@ static int vlan_if_add(struct hostapd_data *hapd, struct hostapd_vlan *vlan,
+ 	if (hapd->wpa_auth)
+ 		ret = wpa_auth_ensure_group(hapd->wpa_auth, vlan->vlan_id);
+ 
+-	if (!ret && !vlan_exists && hapd->driver->if_add)
++	if (!ret && !vlan_exists)
+ 		hostapd_ubus_add_vlan(hapd, vlan);
+ 
+ 	if (ret == 0)
+-- 
+2.34.1
+
diff --git a/package/network/services/hostapd/patches/918-ft-anonce.patch b/package/network/services/hostapd/patches/918-ft-anonce.patch
new file mode 100644
index 0000000000..10003e296d
--- /dev/null
+++ b/package/network/services/hostapd/patches/918-ft-anonce.patch
@@ -0,0 +1,46 @@
+--- a/src/ap/wpa_auth_ft.c
++++ b/src/ap/wpa_auth_ft.c
+@@ -3183,6 +3183,7 @@ static int wpa_ft_process_auth_req(struc
+ 	size_t identity_len = 0, radius_cui_len = 0;
+ 	size_t pmk_r1_len, kdk_len, len;
+ 	int retval = WLAN_STATUS_UNSPECIFIED_FAILURE;
++	struct os_reltime now;
+ 
+ 	*resp_ies = NULL;
+ 	*resp_ies_len = 0;
+@@ -3314,11 +3315,20 @@ pmk_r1_derived:
+ 	os_memcpy(sm->pmk_r1, pmk_r1, pmk_r1_len);
+ 	sm->pmk_r1_len = pmk_r1_len;
+ 
+-	if (random_get_bytes(sm->ANonce, WPA_NONCE_LEN)) {
+-		wpa_printf(MSG_DEBUG, "FT: Failed to get random data for "
+-			   "ANonce");
+-		goto out;
+-	}
++	if (os_get_reltime(&now) < 0 ||
++	    os_reltime_expired(&now, &sm->ANonce_time, 1)) {
++		if (random_get_bytes(sm->ANonce, WPA_NONCE_LEN)) {
++			wpa_printf(MSG_DEBUG, "FT: Failed to get random data for "
++				   "ANonce");
++			return WLAN_STATUS_UNSPECIFIED_FAILURE;
++		}
++		sm->ANonce_time.sec = now.sec;
++		sm->ANonce_time.usec = now.usec;
++		wpa_printf(MSG_INFO, "FT: ANonce was randomized");
++	} else {
++		wpa_printf(MSG_INFO, "FT: ANonce has not expired");
++		
++ 	}
+ 
+ 	/* Now that we know the correct PMK-R1 length and as such, the length
+ 	 * of the MIC field, fetch the SNonce. */
+--- a/src/ap/wpa_auth_i.h
++++ b/src/ap/wpa_auth_i.h
+@@ -54,6 +54,7 @@ struct wpa_state_machine {
+ 	bool MICVerified;
+ 	bool GUpdateStationKeys;
+ 	u8 ANonce[WPA_NONCE_LEN];
++	struct os_reltime ANonce_time;
+ 	u8 SNonce[WPA_NONCE_LEN];
+ 	u8 alt_SNonce[WPA_NONCE_LEN];
+ 	u8 alt_replay_counter[WPA_REPLAY_COUNTER_LEN];
diff --git a/package/network/services/hostapd/src/src/ap/ubus.c b/package/network/services/hostapd/src/src/ap/ubus.c
index 2256720755..6707d84891 100644
--- a/package/network/services/hostapd/src/src/ap/ubus.c
+++ b/package/network/services/hostapd/src/src/ap/ubus.c
@@ -24,6 +24,7 @@
 #include "taxonomy.h"
 #include "airtime_policy.h"
 #include "hw_features.h"
+#include "ieee802_11_auth.h"
 
 static struct ubus_context *ctx;
 static struct blob_buf b;
@@ -153,7 +154,7 @@ hostapd_bss_ban_client(struct hostapd_data *hapd, u8 *addr, int time)
 		}
 	}
 
-	eloop_register_timeout(0, time * 1000, hostapd_bss_del_ban, ban, hapd);
+	eloop_register_timeout(time, 0, hostapd_bss_del_ban, ban, hapd);
 }
 
 static int
@@ -319,7 +320,42 @@ hostapd_bss_get_clients(struct ubus_context *ctx, struct ubus_object *obj,
 			blobmsg_add_u32(&b, "rx", sta_driver_data.current_rx_rate * 100);
 			blobmsg_add_u32(&b, "tx", sta_driver_data.current_tx_rate * 100);
 			blobmsg_close_table(&b, r);
+			blobmsg_add_u32(&b, "retries", sta_driver_data.tx_retry_count);
+			blobmsg_add_u32(&b, "failed", sta_driver_data.tx_retry_failed);
 			blobmsg_add_u32(&b, "signal", sta_driver_data.signal);
+
+			r = blobmsg_open_table(&b, "mcs");
+			if (sta_driver_data.rx_hemcs) {
+				blobmsg_add_u32(&b, "he", 1);
+				blobmsg_add_u32(&b, "rx", sta_driver_data.rx_hemcs);
+				blobmsg_add_u32(&b, "tx", sta_driver_data.tx_hemcs);
+			} else if (sta_driver_data.rx_vhtmcs) {
+				blobmsg_add_u32(&b, "vht", 1);
+				blobmsg_add_u32(&b, "rx", sta_driver_data.rx_vhtmcs);
+				blobmsg_add_u32(&b, "tx", sta_driver_data.tx_vhtmcs);
+			} else {
+				blobmsg_add_u32(&b, "rx", sta_driver_data.rx_mcs);
+				blobmsg_add_u32(&b, "tx", sta_driver_data.tx_mcs);
+			}
+			blobmsg_close_table(&b, r);
+
+			r = blobmsg_open_table(&b, "nss");
+			if (sta_driver_data.rx_he_nss) {
+				blobmsg_add_u32(&b, "he", 1);
+				blobmsg_add_u32(&b, "rx", sta_driver_data.rx_he_nss);
+				blobmsg_add_u32(&b, "tx", sta_driver_data.tx_he_nss);
+			} else if (sta_driver_data.rx_vht_nss) {
+				blobmsg_add_u32(&b, "vht", 1);
+				blobmsg_add_u32(&b, "rx", sta_driver_data.rx_vht_nss);
+				blobmsg_add_u32(&b, "tx", sta_driver_data.tx_vht_nss);
+			} else {
+				blobmsg_add_u32(&b, "rx", sta_driver_data.rx_mcs);
+				blobmsg_add_u32(&b, "tx", sta_driver_data.tx_mcs);
+			}
+			blobmsg_close_table(&b, r);
+
+			if (sta->signal_mgmt)
+				blobmsg_add_u32(&b, "signal_mgmt", sta->signal_mgmt);
 		}
 
 		hostapd_parse_capab_blobmsg(sta);
@@ -369,6 +405,7 @@ hostapd_bss_get_status(struct ubus_context *ctx, struct ubus_object *obj,
 				      &op_class, &channel);
 
 	blob_buf_init(&b, 0);
+	blobmsg_add_string(&b, "driver", hapd->driver->name);
 	blobmsg_add_string(&b, "status", hostapd_state_text(hapd->iface->state));
 	blobmsg_printf(&b, "bssid", MACSTR, MAC2STR(hapd->conf->bssid));
 
@@ -418,6 +455,12 @@ hostapd_bss_get_status(struct ubus_context *ctx, struct ubus_object *obj,
 			hapd->iface->cac_started ? hapd->iface->dfs_cac_ms / 1000 - now.sec : 0);
 	blobmsg_close_table(&b, dfs_table);
 
+	if (hapd->conf->uci_section)
+		blobmsg_add_string(&b, "uci_section", hapd->conf->uci_section);
+
+	if (hapd->signal_mgmt)
+		blobmsg_add_u32(&b, "signal_mgmt", hapd->signal_mgmt);
+
 	ubus_send_reply(ctx, req, b.head);
 
 	return 0;
@@ -459,6 +502,7 @@ enum {
 	DEL_CLIENT_REASON,
 	DEL_CLIENT_DEAUTH,
 	DEL_CLIENT_BAN_TIME,
+	DEL_CLIENT_GLOBAL_BAN,
 	__DEL_CLIENT_MAX
 };
 
@@ -467,8 +511,26 @@ static const struct blobmsg_policy del_policy[__DEL_CLIENT_MAX] = {
 	[DEL_CLIENT_REASON] = { "reason", BLOBMSG_TYPE_INT32 },
 	[DEL_CLIENT_DEAUTH] = { "deauth", BLOBMSG_TYPE_INT8 },
 	[DEL_CLIENT_BAN_TIME] = { "ban_time", BLOBMSG_TYPE_INT32 },
+	[DEL_CLIENT_GLOBAL_BAN] = { "global_ban", BLOBMSG_TYPE_INT8 },
 };
 
+static int
+hostapd_bss_del_client_cb(struct hostapd_iface *iface, void *ctx)
+{
+	struct blob_attr **tb = ctx;
+	u8 addr[ETH_ALEN];
+	int i;
+
+	hwaddr_aton(blobmsg_data(tb[DEL_CLIENT_ADDR]), addr);
+
+	for (i = 0; i < iface->num_bss; i++) {
+		struct hostapd_data *bss = iface->bss[i];
+
+		hostapd_bss_ban_client(bss, addr, blobmsg_get_u32(tb[DEL_CLIENT_BAN_TIME]));
+	}
+	return 0;
+}
+
 static int
 hostapd_bss_del_client(struct ubus_context *ctx, struct ubus_object *obj,
 			struct ubus_request_data *req, const char *method,
@@ -477,8 +539,8 @@ hostapd_bss_del_client(struct ubus_context *ctx, struct ubus_object *obj,
 	struct blob_attr *tb[__DEL_CLIENT_MAX];
 	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
 	struct sta_info *sta;
-	bool deauth = false;
-	int reason;
+	bool deauth = false, global = false;
+	int reason, ban_time = 0;
 	u8 addr[ETH_ALEN];
 
 	blobmsg_parse(del_policy, __DEL_CLIENT_MAX, tb, blob_data(msg), blob_len(msg));
@@ -495,6 +557,12 @@ hostapd_bss_del_client(struct ubus_context *ctx, struct ubus_object *obj,
 	if (tb[DEL_CLIENT_DEAUTH])
 		deauth = blobmsg_get_bool(tb[DEL_CLIENT_DEAUTH]);
 
+	if (tb[DEL_CLIENT_GLOBAL_BAN])
+		global = blobmsg_get_bool(tb[DEL_CLIENT_GLOBAL_BAN]);
+
+	if (tb[DEL_CLIENT_GLOBAL_BAN])
+		global = blobmsg_get_bool(tb[DEL_CLIENT_GLOBAL_BAN]);
+
 	sta = ap_get_sta(hapd, addr);
 	if (sta) {
 		if (deauth) {
@@ -506,8 +574,13 @@ hostapd_bss_del_client(struct ubus_context *ctx, struct ubus_object *obj,
 		}
 	}
 
-	if (tb[DEL_CLIENT_BAN_TIME])
-		hostapd_bss_ban_client(hapd, addr, blobmsg_get_u32(tb[DEL_CLIENT_BAN_TIME]));
+	if (tb[DEL_CLIENT_BAN_TIME]) {
+		ban_time = blobmsg_get_u32(tb[DEL_CLIENT_BAN_TIME]);
+		if (global)
+			hapd->iface->interfaces->for_each_interface(hapd->iface->interfaces, hostapd_bss_del_client_cb, tb);
+		else
+			hostapd_bss_ban_client(hapd, addr, ban_time);
+	}
 
 	return 0;
 }
@@ -1657,6 +1730,121 @@ static int avl_compare_macaddr(const void *k1, const void *k2, void *ptr)
 	return memcmp(k1, k2, ETH_ALEN);
 }
 
+static int
+hostapd_wired_get_clients(struct ubus_context *ctx, struct ubus_object *obj,
+			  struct ubus_request_data *req, const char *method,
+			  struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+	struct hostap_sta_driver_data sta_driver_data;
+	struct sta_info *sta;
+	void *list, *c;
+	char mac_buf[20];
+	static const struct {
+		const char *name;
+		uint32_t flag;
+	} sta_flags[] = {
+		{ "authorized", WLAN_STA_AUTHORIZED },
+	};
+
+	blob_buf_init(&b, 0);
+	list = blobmsg_open_table(&b, "clients");
+	for (sta = hapd->sta_list; sta; sta = sta->next) {
+		void *r;
+		int i;
+
+		sprintf(mac_buf, MACSTR, MAC2STR(sta->addr));
+		c = blobmsg_open_table(&b, mac_buf);
+		for (i = 0; i < ARRAY_SIZE(sta_flags); i++)
+			blobmsg_add_u8(&b, sta_flags[i].name,
+				       !!(sta->flags & sta_flags[i].flag));
+
+			blobmsg_close_table(&b, c);
+	}
+	blobmsg_close_array(&b, list);
+	ubus_send_reply(ctx, req, b.head);
+
+	return 0;
+}
+
+static int
+hostapd_wired_get_status(struct ubus_context *ctx, struct ubus_object *obj,
+			 struct ubus_request_data *req, const char *method,
+			 struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+	char iface_name[17];
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_string(&b, "driver", hapd->driver->name);
+	blobmsg_add_string(&b, "status", hostapd_state_text(hapd->iface->state));
+
+	snprintf(iface_name, 17, "%s", hapd->iface->phy);
+	blobmsg_add_string(&b, "iface", iface_name);
+
+	ubus_send_reply(ctx, req, b.head);
+
+	return 0;
+}
+
+static int
+hostapd_wired_del_clients(struct ubus_context *ctx, struct ubus_object *obj,
+			  struct ubus_request_data *req, const char *method,
+			  struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+
+	hostapd_free_stas(hapd);
+
+	return 0;
+}
+
+enum {
+	MAC_AUTH_ADDR,
+	__MAC_AUTH_MAX
+};
+
+static const struct blobmsg_policy mac_auth_policy[__MAC_AUTH_MAX] = {
+	[MAC_AUTH_ADDR] = { "addr", BLOBMSG_TYPE_STRING },
+};
+
+static int
+hostapd_wired_mac_auth(struct ubus_context *ctx, struct ubus_object *obj,
+		       struct ubus_request_data *req, const char *method,
+		       struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+	struct blob_attr *tb[__MAC_AUTH_MAX];
+	struct radius_sta rad_info;
+	struct sta_info *sta;
+	u8 addr[ETH_ALEN];
+	int acl_res;
+
+	blobmsg_parse(mac_auth_policy, __MAC_AUTH_MAX, tb, blob_data(msg), blob_len(msg));
+
+	if (hwaddr_aton(blobmsg_data(tb[MAC_AUTH_ADDR]), addr))
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	acl_res = hostapd_allowed_address(hapd, addr, NULL, 0, &rad_info, 0);
+	if (acl_res == HOSTAPD_ACL_REJECT) {
+		wpa_printf(MSG_ERROR, "Ignore new peer notification\n");
+		return UBUS_STATUS_INVALID_ARGUMENT;
+	}
+
+	return 0;
+}
+
+static const struct ubus_method wired_methods[] = {
+	UBUS_METHOD_NOARG("reload", hostapd_bss_reload),
+	UBUS_METHOD_NOARG("get_clients", hostapd_wired_get_clients),
+	UBUS_METHOD_NOARG("del_clients", hostapd_wired_del_clients),
+	UBUS_METHOD_NOARG("get_status", hostapd_wired_get_status),
+	UBUS_METHOD("mac_auth", hostapd_wired_mac_auth, mac_auth_policy),
+};
+
+static struct ubus_object_type wired_object_type =
+	UBUS_OBJECT_TYPE("hostapd_wired", wired_methods);
+
 void hostapd_ubus_add_bss(struct hostapd_data *hapd)
 {
 	struct ubus_object *obj = &hapd->ubus.obj;
@@ -1676,9 +1864,15 @@ void hostapd_ubus_add_bss(struct hostapd_data *hapd)
 
 	avl_init(&hapd->ubus.banned, avl_compare_macaddr, false, NULL);
 	obj->name = name;
-	obj->type = &bss_object_type;
-	obj->methods = bss_object_type.methods;
-	obj->n_methods = bss_object_type.n_methods;
+	if (!strcmp(hapd->driver->name, "wired")) {
+		obj->type = &wired_object_type;
+		obj->methods = wired_object_type.methods;
+		obj->n_methods = wired_object_type.n_methods;
+	} else {
+		obj->type = &bss_object_type;
+		obj->methods = bss_object_type.methods;
+		obj->n_methods = bss_object_type.n_methods;
+	}
 	ret = ubus_add_object(ctx, obj);
 	hostapd_ubus_ref_inc();
 }
@@ -1761,6 +1955,7 @@ int hostapd_ubus_handle_event(struct hostapd_data *hapd, struct hostapd_ubus_req
 		[HOSTAPD_UBUS_PROBE_REQ] = "probe",
 		[HOSTAPD_UBUS_AUTH_REQ] = "auth",
 		[HOSTAPD_UBUS_ASSOC_REQ] = "assoc",
+		[HOSTAPD_UBUS_COA] = "coa",
 	};
 	const char *type = "mgmt";
 	struct ubus_event_req ureq = {};
@@ -1831,7 +2026,7 @@ int hostapd_ubus_handle_event(struct hostapd_data *hapd, struct hostapd_ubus_req
 		}
 	}
 
-	if (!hapd->ubus.notify_response) {
+	if (!hapd->ubus.notify_response && req->type != HOSTAPD_UBUS_COA) {
 		ubus_notify(ctx, &hapd->ubus.obj, type, b.head, -1);
 		return WLAN_STATUS_SUCCESS;
 	}
@@ -1876,6 +2071,13 @@ void hostapd_ubus_notify_authorized(struct hostapd_data *hapd, struct sta_info *
 	blobmsg_add_string(&b, "ifname", hapd->conf->iface);
 	if (auth_alg)
 		blobmsg_add_string(&b, "auth-alg", auth_alg);
+	if (sta->bandwidth[0] || sta->bandwidth[1]) {
+		void *r = blobmsg_open_array(&b, "rate-limit");
+ 
+		blobmsg_add_u32(&b, "", sta->bandwidth[0]);
+		blobmsg_add_u32(&b, "", sta->bandwidth[1]);
+		blobmsg_close_array(&b, r);
+	}
 
 	ubus_notify(ctx, &hapd->ubus.obj, "sta-authorized", b.head, -1);
 }
@@ -2025,6 +2227,21 @@ void hostapd_ubus_notify_apup_newpeer(
 }
 #endif // def CONFIG_APUP
 
+void hostapd_ubus_notify_rssi(struct hostapd_data *hapd, const char *type, const u8 *addr, int rssi)
+{
+	if (!hapd->ubus.obj.has_subscribers)
+		return;
+
+	if (!addr)
+		return;
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_macaddr(&b, "address", addr);
+	blobmsg_add_u32(&b, "rssi", rssi);
+
+	ubus_notify(ctx, &hapd->ubus.obj, type, b.head, -1);
+}
+
 void hostapd_ubus_notify_csa(struct hostapd_data *hapd, int freq)
 {
 	if (!hapd->ubus.obj.has_subscribers)
diff --git a/package/network/services/hostapd/src/src/ap/ubus.h b/package/network/services/hostapd/src/src/ap/ubus.h
index 055a18c092..1ca6352f1a 100644
--- a/package/network/services/hostapd/src/src/ap/ubus.h
+++ b/package/network/services/hostapd/src/src/ap/ubus.h
@@ -12,6 +12,7 @@ enum hostapd_ubus_event_type {
 	HOSTAPD_UBUS_PROBE_REQ,
 	HOSTAPD_UBUS_AUTH_REQ,
 	HOSTAPD_UBUS_ASSOC_REQ,
+	HOSTAPD_UBUS_COA,
 	HOSTAPD_UBUS_TYPE_MAX
 };
 
@@ -56,6 +57,7 @@ void hostapd_ubus_notify_beacon_report(struct hostapd_data *hapd,
 				       size_t len);
 void hostapd_ubus_notify_radar_detected(struct hostapd_iface *iface, int frequency,
 					int chan_width, int cf1, int cf2);
+void hostapd_ubus_notify_rssi(struct hostapd_data *hapd, const char *type, const u8 *addr, int rssi);
 
 void hostapd_ubus_notify_bss_transition_response(
 	struct hostapd_data *hapd, const u8 *addr, u8 dialog_token, u8 status_code,
-- 
2.34.1

